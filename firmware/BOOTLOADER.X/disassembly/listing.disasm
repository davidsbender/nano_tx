Disassembly Listing for BOOTLOADER
Generated From:
C:/Users/DB/Desktop/nano_tx/firmware/BOOTLOADER.X/dist/default/debug/BOOTLOADER.X.debug.elf
10.11.2023 14:31:12
C:/Users/DB/Desktop/nano_tx/firmware/NANO_TX.X/dist/default/debug/NANO_TX.X.debug.elf
10.11.2023 14:39:49

---  c:/users/db/desktop/nano_tx/firmware/src/user_hal/strconv.c  ---------------------------------------
1:                   int strToInt(char* str, int* valid, char** end)
2:                   {
3:                       int value = 0;
4:                       int sign = 0;
5:                       int i = 0;
6:                       while (str[i] != '\0') {
7:                           if ((sign == 0) && (str[i] == '+')) {
8:                               sign = +1;
9:                           } else if ((sign == 0) && (str[i] == '-')) {
10:                              sign = -1;
11:                          } else if ((str[i] >= '0') && (str[i] <= '9')) {
12:                              value = value * 10 + (int)(str[i] - '0');
13:                              if (value & 0x80000000) {
14:                                  *valid = 0;
15:                              }
16:                          } else {
17:                              break;
18:                          }
19:                          i++;
20:                      }
21:                      *end = &str[i];
22:                      if (sign == -1) {
23:                          value = -value;
24:                      }
25:                      return value;
26:                  }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D006F30  80850000   LB A1, 0(A0)
9D006F34  10A0001F   BEQ A1, ZERO, 0x9D006FB4
9D006F38  00004825   OR T1, ZERO, ZERO
9D006F3C  00001025   OR V0, ZERO, ZERO
9D006F40  240A002B   ADDIU T2, ZERO, 43
9D006F44  10000005   BEQ ZERO, ZERO, 0x9D006F5C
9D006F48  240B002D   ADDIU T3, ZERO, 45
9D006F4C  24840001   ADDIU A0, A0, 1
9D006F50  80850000   LB A1, 0(A0)
9D006F54  50A0000F   BEQL A1, ZERO, 0x9D006F94
9D006F58  2403FFFF   ADDIU V1, ZERO, -1
9D006F5C  24A8FFD0   ADDIU T0, A1, -48
9D006F60  00021880   SLL V1, V0, 2
9D006F64  310700FF   ANDI A3, T0, 255
9D006F68  00621821   ADDU V1, V1, V0
9D006F6C  2CE7000A   SLTIU A3, A3, 10
9D006F70  15200005   BNE T1, ZERO, 0x9D006F88
9D006F74  00031840   SLL V1, V1, 1
9D006F78  50AAFFF4   BEQL A1, T2, 0x9D006F4C
9D006F7C  24090001   ADDIU T1, ZERO, 1
9D006F80  50ABFFF2   BEQL A1, T3, 0x9D006F4C
9D006F84  2409FFFF   ADDIU T1, ZERO, -1
9D006F88  54E0FFF0   BNEL A3, ZERO, 0x9D006F4C
9D006F8C  01031021   ADDU V0, T0, V1
9D006F90  2403FFFF   ADDIU V1, ZERO, -1
9D006F94  11230005   BEQ T1, V1, 0x9D006FAC
9D006F98  ACC40000   SW A0, 0(A2)
9D006F9C  03E00008   JR RA
9D006FA0  00000000   NOP
9D006FA4  1000FFE9   BEQ ZERO, ZERO, 0x9D006F4C
9D006FA8  2409FFFF   ADDIU T1, ZERO, -1
9D006FAC  03E00008   JR RA
9D006FB0  00021023   SUBU V0, ZERO, V0
9D006FB4  ACC40000   SW A0, 0(A2)
9D006FB8  03E00008   JR RA
9D006FBC  00001025   OR V0, ZERO, ZERO
---  c:/users/db/desktop/nano_tx/firmware/src/user_hal/printf.c  ----------------------------------------
1:                   ///////////////////////////////////////////////////////////////////////////////
2:                   // \author (c) Marco Paland (info@paland.com)
3:                   //             2014-2019, PALANDesign Hannover, Germany
4:                   //
5:                   // \license The MIT License (MIT)
6:                   //
7:                   // Permission is hereby granted, free of charge, to any person obtaining a copy
8:                   // of this software and associated documentation files (the "Software"), to deal
9:                   // in the Software without restriction, including without limitation the rights
10:                  // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
11:                  // copies of the Software, and to permit persons to whom the Software is
12:                  // furnished to do so, subject to the following conditions:
13:                  //
14:                  // The above copyright notice and this permission notice shall be included in
15:                  // all copies or substantial portions of the Software.
16:                  //
17:                  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
18:                  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
19:                  // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
20:                  // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
21:                  // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
22:                  // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
23:                  // THE SOFTWARE.
24:                  //
25:                  // \brief Tiny printf, sprintf and (v)snprintf implementation, optimized for speed on
26:                  //        embedded systems with a very limited resources. These routines are thread
27:                  //        safe and reentrant!
28:                  //        Use this instead of the bloated standard/newlib printf cause these use
29:                  //        malloc for printf (and may not be thread safe).
30:                  //
31:                  ///////////////////////////////////////////////////////////////////////////////
32:                  
33:                  #include <stdbool.h>
34:                  #include <stdint.h>
35:                  
36:                  #include "printf.h"
37:                  
38:                  
39:                  // define this globally (e.g. gcc -DPRINTF_INCLUDE_CONFIG_H ...) to include the
40:                  // printf_config.h header file
41:                  // default: undefined
42:                  #ifdef PRINTF_INCLUDE_CONFIG_H
43:                  #include "printf_config.h"
44:                  #endif
45:                  
46:                  
47:                  // 'ntoa' conversion buffer size, this must be big enough to hold one converted
48:                  // numeric number including padded zeros (dynamically created on stack)
49:                  // default: 32 byte
50:                  #ifndef PRINTF_NTOA_BUFFER_SIZE
51:                  #define PRINTF_NTOA_BUFFER_SIZE    32U
52:                  #endif
53:                  
54:                  // 'ftoa' conversion buffer size, this must be big enough to hold one converted
55:                  // float number including padded zeros (dynamically created on stack)
56:                  // default: 32 byte
57:                  #ifndef PRINTF_FTOA_BUFFER_SIZE
58:                  #define PRINTF_FTOA_BUFFER_SIZE    32U
59:                  #endif
60:                  
61:                  // support for the floating point type (%f)
62:                  // default: activated
63:                  #ifndef PRINTF_DISABLE_SUPPORT_FLOAT
64:                  #define PRINTF_SUPPORT_FLOAT
65:                  #endif
66:                  
67:                  // support for exponential floating point notation (%e/%g)
68:                  // default: activated
69:                  #ifndef PRINTF_DISABLE_SUPPORT_EXPONENTIAL
70:                  #define PRINTF_SUPPORT_EXPONENTIAL
71:                  #endif
72:                  
73:                  // define the default floating point precision
74:                  // default: 6 digits
75:                  #ifndef PRINTF_DEFAULT_FLOAT_PRECISION
76:                  #define PRINTF_DEFAULT_FLOAT_PRECISION  6U
77:                  #endif
78:                  
79:                  // define the largest float suitable to print with %f
80:                  // default: 1e9
81:                  #ifndef PRINTF_MAX_FLOAT
82:                  #define PRINTF_MAX_FLOAT  1e9
83:                  #endif
84:                  
85:                  // support for the long long types (%llu or %p)
86:                  // default: activated
87:                  #ifndef PRINTF_DISABLE_SUPPORT_LONG_LONG
88:                  #define PRINTF_SUPPORT_LONG_LONG
89:                  #endif
90:                  
91:                  // support for the ptrdiff_t type (%t)
92:                  // ptrdiff_t is normally defined in <stddef.h> as long or long long type
93:                  // default: activated
94:                  #ifndef PRINTF_DISABLE_SUPPORT_PTRDIFF_T
95:                  #define PRINTF_SUPPORT_PTRDIFF_T
96:                  #endif
97:                  
98:                  ///////////////////////////////////////////////////////////////////////////////
99:                  
100:                 // internal flag definitions
101:                 #define FLAGS_ZEROPAD   (1U <<  0U)
102:                 #define FLAGS_LEFT      (1U <<  1U)
103:                 #define FLAGS_PLUS      (1U <<  2U)
104:                 #define FLAGS_SPACE     (1U <<  3U)
105:                 #define FLAGS_HASH      (1U <<  4U)
106:                 #define FLAGS_UPPERCASE (1U <<  5U)
107:                 #define FLAGS_CHAR      (1U <<  6U)
108:                 #define FLAGS_SHORT     (1U <<  7U)
109:                 #define FLAGS_LONG      (1U <<  8U)
110:                 #define FLAGS_LONG_LONG (1U <<  9U)
111:                 #define FLAGS_PRECISION (1U << 10U)
112:                 #define FLAGS_ADAPT_EXP (1U << 11U)
113:                 
114:                 
115:                 // import float.h for DBL_MAX
116:                 #if defined(PRINTF_SUPPORT_FLOAT)
117:                 #include <float.h>
118:                 #endif
119:                 
120:                 
121:                 // output function type
122:                 typedef void (*out_fct_type)(char character, void* buffer, size_t idx, size_t maxlen);
123:                 
124:                 
125:                 // wrapper (used as buffer) for output function type
126:                 typedef struct {
127:                   void  (*fct)(char character, void* arg);
128:                   void* arg;
129:                 } out_fct_wrap_type;
130:                 
131:                 
132:                 // internal buffer output
133:                 static inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)
134:                 {
135:                   if (idx < maxlen) {
136:                     ((char*)buffer)[idx] = character;
137:                   }
138:                 }
139:                 
140:                 
141:                 // internal null output
142:                 static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
143:                 {
144:                   (void)character; (void)buffer; (void)idx; (void)maxlen;
145:                 }
146:                 
147:                 
148:                 // internal _putchar wrapper
149:                 static inline void _out_char(char character, void* buffer, size_t idx, size_t maxlen)
150:                 {
151:                   (void)buffer; (void)idx; (void)maxlen;
152:                   if (character) {
153:                     _putchar(character);
154:                   }
155:                 }
156:                 
157:                 
158:                 // internal output function wrapper
159:                 static inline void _out_fct(char character, void* buffer, size_t idx, size_t maxlen)
160:                 {
161:                   (void)idx; (void)maxlen;
162:                   if (character) {
163:                     // buffer is the output fct pointer
164:                     ((out_fct_wrap_type*)buffer)->fct(character, ((out_fct_wrap_type*)buffer)->arg);
165:                   }
166:                 }
167:                 
168:                 
169:                 // internal secure strlen
170:                 // \return The length of the string (excluding the terminating 0) limited by 'maxsize'
171:                 static inline unsigned int _strnlen_s(const char* str, size_t maxsize)
172:                 {
173:                   const char* s;
174:                   for (s = str; *s && maxsize--; ++s);
175:                   return (unsigned int)(s - str);
176:                 }
177:                 
178:                 
179:                 // internal test if char is a digit (0-9)
180:                 // \return true if char is a digit
181:                 static inline bool _is_digit(char ch)
182:                 {
183:                   return (ch >= '0') && (ch <= '9');
184:                 }
185:                 
186:                 
187:                 // internal ASCII string to unsigned int conversion
188:                 static unsigned int _atoi(const char** str)
189:                 {
190:                   unsigned int i = 0U;
191:                   while (_is_digit(**str)) {
192:                     i = i * 10U + (unsigned int)(*((*str)++) - '0');
193:                   }
194:                   return i;
195:                 }
196:                 
197:                 
198:                 // output the specified string in reverse, taking care of any zero-padding
199:                 static size_t _out_rev(out_fct_type out, char* buffer, size_t idx, size_t maxlen, const char* buf, size_t len, unsigned int width, unsigned int flags)
200:                 {
201:                   const size_t start_idx = idx;
202:                 
203:                   // pad spaces up to given width
204:                   if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
205:                     for (size_t i = len; i < width; i++) {
206:                       out(' ', buffer, idx++, maxlen);
207:                     }
208:                   }
209:                 
210:                   // reverse string
211:                   while (len) {
212:                     out(buf[--len], buffer, idx++, maxlen);
213:                   }
214:                 
215:                   // append pad spaces up to given width
216:                   if (flags & FLAGS_LEFT) {
217:                     while (idx - start_idx < width) {
218:                       out(' ', buffer, idx++, maxlen);
219:                     }
220:                   }
221:                 
222:                   return idx;
223:                 }
224:                 
225:                 
226:                 // internal itoa format
227:                 static size_t _ntoa_format(out_fct_type out, char* buffer, size_t idx, size_t maxlen, char* buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)
228:                 {
229:                   // pad leading zeros
230:                   if (!(flags & FLAGS_LEFT)) {
231:                     if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
232:                       width--;
233:                     }
234:                     while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
235:                       buf[len++] = '0';
236:                     }
237:                     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
238:                       buf[len++] = '0';
239:                     }
240:                   }
241:                 
242:                   // handle hash
243:                   if (flags & FLAGS_HASH) {
244:                     if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
245:                       len--;
246:                       if (len && (base == 16U)) {
247:                         len--;
248:                       }
249:                     }
250:                     if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
251:                       buf[len++] = 'x';
252:                     }
253:                     else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
254:                       buf[len++] = 'X';
255:                     }
256:                     else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
257:                       buf[len++] = 'b';
258:                     }
259:                     if (len < PRINTF_NTOA_BUFFER_SIZE) {
260:                       buf[len++] = '0';
261:                     }
262:                   }
263:                 
264:                   if (len < PRINTF_NTOA_BUFFER_SIZE) {
265:                     if (negative) {
266:                       buf[len++] = '-';
267:                     }
268:                     else if (flags & FLAGS_PLUS) {
269:                       buf[len++] = '+';  // ignore the space if the '+' exists
270:                     }
271:                     else if (flags & FLAGS_SPACE) {
272:                       buf[len++] = ' ';
273:                     }
274:                   }
275:                 
276:                   return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
277:                 }
278:                 
279:                 
280:                 // internal itoa for 'long' type
281:                 static size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
282:                 {
283:                   char buf[PRINTF_NTOA_BUFFER_SIZE];
284:                   size_t len = 0U;
285:                 
286:                   // no hash for 0 values
287:                   if (!value) {
288:                     flags &= ~FLAGS_HASH;
289:                   }
290:                 
291:                   // write if precision != 0 and value is != 0
292:                   if (!(flags & FLAGS_PRECISION) || value) {
293:                     do {
294:                       const char digit = (char)(value % base);
295:                       buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
296:                       value /= base;
297:                     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
298:                   }
299:                 
300:                   return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
301:                 }
302:                 
303:                 
304:                 // internal itoa for 'long long' type
305:                 #if defined(PRINTF_SUPPORT_LONG_LONG)
306:                 static size_t _ntoa_long_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long long value, bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)
307:                 {
308:                   char buf[PRINTF_NTOA_BUFFER_SIZE];
309:                   size_t len = 0U;
310:                 
311:                   // no hash for 0 values
312:                   if (!value) {
313:                     flags &= ~FLAGS_HASH;
314:                   }
315:                 
316:                   // write if precision != 0 and value is != 0
317:                   if (!(flags & FLAGS_PRECISION) || value) {
318:                     do {
319:                       const char digit = (char)(value % base);
320:                       buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
321:                       value /= base;
322:                     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
323:                   }
324:                 
325:                   return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
326:                 }
327:                 #endif  // PRINTF_SUPPORT_LONG_LONG
328:                 
329:                 
330:                 #if defined(PRINTF_SUPPORT_FLOAT)
331:                 
332:                 #if defined(PRINTF_SUPPORT_EXPONENTIAL)
333:                 // forward declaration so that _ftoa can switch to exp notation for values > PRINTF_MAX_FLOAT
334:                 static size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags);
335:                 #endif
336:                 
337:                 
338:                 // internal ftoa for fixed decimal floating point
339:                 static size_t _ftoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)
340:                 {
341:                   char buf[PRINTF_FTOA_BUFFER_SIZE];
342:                   size_t len  = 0U;
343:                   double diff = 0.0;
344:                 
345:                   // powers of 10
346:                   static const double pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };
347:                 
348:                   // test for special values
349:                   if (value != value)
350:                     return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
351:                   if (value < -DBL_MAX)
352:                     return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
353:                   if (value > DBL_MAX)
354:                     return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
355:                 
356:                   // test for very large values
357:                   // standard printf behavior is to print EVERY whole number digit -- which could be 100s of characters overflowing your buffers == bad
358:                   if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
359:                 #if defined(PRINTF_SUPPORT_EXPONENTIAL)
360:                     return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
361:                 #else
362:                     return 0U;
363:                 #endif
364:                   }
365:                 
366:                   // test for negative
367:                   bool negative = false;
368:                   if (value < 0) {
369:                     negative = true;
370:                     value = 0 - value;
371:                   }
372:                 
373:                   // set default precision, if not set explicitly
374:                   if (!(flags & FLAGS_PRECISION)) {
375:                     prec = PRINTF_DEFAULT_FLOAT_PRECISION;
376:                   }
377:                   // limit precision to 9, cause a prec >= 10 can lead to overflow errors
378:                   while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
379:                     buf[len++] = '0';
380:                     prec--;
381:                   }
382:                 
383:                   int whole = (int)value;
384:                   double tmp = (value - whole) * pow10[prec];
385:                   unsigned long frac = (unsigned long)tmp;
386:                   diff = tmp - frac;
387:                 
388:                   if (diff > 0.5) {
389:                     ++frac;
390:                     // handle rollover, e.g. case 0.99 with prec 1 is 1.0
391:                     if (frac >= pow10[prec]) {
392:                       frac = 0;
393:                       ++whole;
394:                     }
395:                   }
396:                   else if (diff < 0.5) {
397:                   }
398:                   else if ((frac == 0U) || (frac & 1U)) {
399:                     // if halfway, round up if odd OR if last digit is 0
400:                     ++frac;
401:                   }
402:                 
403:                   if (prec == 0U) {
404:                     diff = value - (double)whole;
405:                     if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
406:                       // exactly 0.5 and ODD, then round up
407:                       // 1.5 -> 2, but 2.5 -> 2
408:                       ++whole;
409:                     }
410:                   }
411:                   else {
412:                     unsigned int count = prec;
413:                     // now do fractional part, as an unsigned number
414:                     while (len < PRINTF_FTOA_BUFFER_SIZE) {
415:                       --count;
416:                       buf[len++] = (char)(48U + (frac % 10U));
417:                       if (!(frac /= 10U)) {
418:                         break;
419:                       }
420:                     }
421:                     // add extra 0s
422:                     while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
423:                       buf[len++] = '0';
424:                     }
425:                     if (len < PRINTF_FTOA_BUFFER_SIZE) {
426:                       // add decimal
427:                       buf[len++] = '.';
428:                     }
429:                   }
430:                 
431:                   // do whole part, number is reversed
432:                   while (len < PRINTF_FTOA_BUFFER_SIZE) {
433:                     buf[len++] = (char)(48 + (whole % 10));
434:                     if (!(whole /= 10)) {
435:                       break;
436:                     }
437:                   }
438:                 
439:                   // pad leading zeros
440:                   if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
441:                     if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
442:                       width--;
443:                     }
444:                     while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
445:                       buf[len++] = '0';
446:                     }
447:                   }
448:                 
449:                   if (len < PRINTF_FTOA_BUFFER_SIZE) {
450:                     if (negative) {
451:                       buf[len++] = '-';
452:                     }
453:                     else if (flags & FLAGS_PLUS) {
454:                       buf[len++] = '+';  // ignore the space if the '+' exists
455:                     }
456:                     else if (flags & FLAGS_SPACE) {
457:                       buf[len++] = ' ';
458:                     }
459:                   }
460:                 
461:                   return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
462:                 }
463:                 
464:                 
465:                 #if defined(PRINTF_SUPPORT_EXPONENTIAL)
466:                 // internal ftoa variant for exponential floating-point type, contributed by Martijn Jasperse <m.jasperse@gmail.com>
467:                 static size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)
468:                 {
469:                   // check for NaN and special values
470:                   if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
471:                     return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
472:                   }
473:                 
474:                   // determine the sign
475:                   const bool negative = value < 0;
476:                   if (negative) {
477:                     value = -value;
478:                   }
479:                 
480:                   // default precision
481:                   if (!(flags & FLAGS_PRECISION)) {
482:                     prec = PRINTF_DEFAULT_FLOAT_PRECISION;
483:                   }
484:                 
485:                   // determine the decimal exponent
486:                   // based on the algorithm by David Gay (https://www.ampl.com/netlib/fp/dtoa.c)
487:                   union {
488:                     uint64_t U;
489:                     double   F;
490:                   } conv;
491:                 
492:                   conv.F = value;
493:                   int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
494:                   conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
495:                   // now approximate log10 from the log2 integer part and an expansion of ln around 1.5
496:                   int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
497:                   // now we want to compute 10^expval but we want to be sure it won't overflow
498:                   exp2 = (int)(expval * 3.321928094887362 + 0.5);
499:                   const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
500:                   const double z2 = z * z;
501:                   conv.U = (uint64_t)(exp2 + 1023) << 52U;
502:                   // compute exp(z) using continued fractions, see https://en.wikipedia.org/wiki/Exponential_function#Continued_fractions_for_ex
503:                   conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
504:                   // correct for rounding errors
505:                   if (value < conv.F) {
506:                     expval--;
507:                     conv.F /= 10;
508:                   }
509:                 
510:                   // the exponent format is "%+03d" and largest value is "307", so set aside 4-5 characters
511:                   unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
512:                 
513:                   // in "%g" mode, "prec" is the number of *significant figures* not decimals
514:                   if (flags & FLAGS_ADAPT_EXP) {
515:                     // do we want to fall-back to "%f" mode?
516:                     if ((value >= 1e-4) && (value < 1e6)) {
517:                       if ((int)prec > expval) {
518:                         prec = (unsigned)((int)prec - expval - 1);
519:                       }
520:                       else {
521:                         prec = 0;
522:                       }
523:                       flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
524:                       // no characters in exponent
525:                       minwidth = 0U;
526:                       expval   = 0;
527:                     }
528:                     else {
529:                       // we use one sigfig for the whole part
530:                       if ((prec > 0) && (flags & FLAGS_PRECISION)) {
531:                         --prec;
532:                       }
533:                     }
534:                   }
535:                 
536:                   // will everything fit?
537:                   unsigned int fwidth = width;
538:                   if (width > minwidth) {
539:                     // we didn't fall-back so subtract the characters required for the exponent
540:                     fwidth -= minwidth;
541:                   } else {
542:                     // not enough characters, so go back to default sizing
543:                     fwidth = 0U;
544:                   }
545:                   if ((flags & FLAGS_LEFT) && minwidth) {
546:                     // if we're padding on the right, DON'T pad the floating part
547:                     fwidth = 0U;
548:                   }
549:                 
550:                   // rescale the float value
551:                   if (expval) {
552:                     value /= conv.F;
553:                   }
554:                 
555:                   // output the floating part
556:                   const size_t start_idx = idx;
557:                   idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
558:                 
559:                   // output the exponent part
560:                   if (minwidth) {
561:                     // output the exponential symbol
562:                     out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
563:                     // output the exponent value
564:                     idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);
565:                     // might need to right-pad spaces
566:                     if (flags & FLAGS_LEFT) {
567:                       while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);
568:                     }
569:                   }
570:                   return idx;
571:                 }
572:                 #endif  // PRINTF_SUPPORT_EXPONENTIAL
573:                 #endif  // PRINTF_SUPPORT_FLOAT
574:                 
575:                 
576:                 // internal vsnprintf
577:                 static int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)
578:                 {
579:                   unsigned int flags, width, precision, n;
580:                   size_t idx = 0U;
581:                 
582:                   if (!buffer) {
583:                     // use null output function
584:                     out = _out_null;
585:                   }
586:                 
587:                   while (*format)
588:                   {
589:                     // format specifier?  %[flags][width][.precision][length]
590:                     if (*format != '%') {
591:                       // no
592:                       out(*format, buffer, idx++, maxlen);
593:                       format++;
594:                       continue;
595:                     }
596:                     else {
597:                       // yes, evaluate it
598:                       format++;
599:                     }
600:                 
601:                     // evaluate flags
602:                     flags = 0U;
603:                     do {
604:                       switch (*format) {
605:                         case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
606:                         case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
607:                         case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
608:                         case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
609:                         case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
610:                         default :                                   n = 0U; break;
611:                       }
612:                     } while (n);
613:                 
614:                     // evaluate width field
615:                     width = 0U;
616:                     if (_is_digit(*format)) {
617:                       width = _atoi(&format);
618:                     }
619:                     else if (*format == '*') {
620:                       const int w = va_arg(va, int);
621:                       if (w < 0) {
622:                         flags |= FLAGS_LEFT;    // reverse padding
623:                         width = (unsigned int)-w;
624:                       }
625:                       else {
626:                         width = (unsigned int)w;
627:                       }
628:                       format++;
629:                     }
630:                 
631:                     // evaluate precision field
632:                     precision = 0U;
633:                     if (*format == '.') {
634:                       flags |= FLAGS_PRECISION;
635:                       format++;
636:                       if (_is_digit(*format)) {
637:                         precision = _atoi(&format);
638:                       }
639:                       else if (*format == '*') {
640:                         const int prec = (int)va_arg(va, int);
641:                         precision = prec > 0 ? (unsigned int)prec : 0U;
642:                         format++;
643:                       }
644:                     }
645:                 
646:                     // evaluate length field
647:                     switch (*format) {
648:                       case 'l' :
649:                         flags |= FLAGS_LONG;
650:                         format++;
651:                         if (*format == 'l') {
652:                           flags |= FLAGS_LONG_LONG;
653:                           format++;
654:                         }
655:                         break;
656:                       case 'h' :
657:                         flags |= FLAGS_SHORT;
658:                         format++;
659:                         if (*format == 'h') {
660:                           flags |= FLAGS_CHAR;
661:                           format++;
662:                         }
663:                         break;
664:                 #if defined(PRINTF_SUPPORT_PTRDIFF_T)
665:                       case 't' :
666:                         flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
667:                         format++;
668:                         break;
669:                 #endif
670:                       case 'j' :
671:                         flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
672:                         format++;
673:                         break;
674:                       case 'z' :
675:                         flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
676:                         format++;
677:                         break;
678:                       default :
679:                         break;
680:                     }
681:                 
682:                     // evaluate specifier
683:                     switch (*format) {
684:                       case 'd' :
685:                       case 'i' :
686:                       case 'u' :
687:                       case 'x' :
688:                       case 'X' :
689:                       case 'o' :
690:                       case 'b' : {
691:                         // set the base
692:                         unsigned int base;
693:                         if (*format == 'x' || *format == 'X') {
694:                           base = 16U;
695:                         }
696:                         else if (*format == 'o') {
697:                           base =  8U;
698:                         }
699:                         else if (*format == 'b') {
700:                           base =  2U;
701:                         }
702:                         else {
703:                           base = 10U;
704:                           flags &= ~FLAGS_HASH;   // no hash for dec format
705:                         }
706:                         // uppercase
707:                         if (*format == 'X') {
708:                           flags |= FLAGS_UPPERCASE;
709:                         }
710:                 
711:                         // no plus or space flag for u, x, X, o, b
712:                         if ((*format != 'i') && (*format != 'd')) {
713:                           flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
714:                         }
715:                 
716:                         // ignore '0' flag when precision is given
717:                         if (flags & FLAGS_PRECISION) {
718:                           flags &= ~FLAGS_ZEROPAD;
719:                         }
720:                 
721:                         // convert the integer
722:                         if ((*format == 'i') || (*format == 'd')) {
723:                           // signed
724:                           if (flags & FLAGS_LONG_LONG) {
725:                 #if defined(PRINTF_SUPPORT_LONG_LONG)
726:                             const long long value = va_arg(va, long long);
727:                             idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
728:                 #endif
729:                           }
730:                           else if (flags & FLAGS_LONG) {
731:                             const long value = va_arg(va, long);
732:                             idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
733:                           }
734:                           else {
735:                             const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
736:                             idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
737:                           }
738:                         }
739:                         else {
740:                           // unsigned
741:                           if (flags & FLAGS_LONG_LONG) {
742:                 #if defined(PRINTF_SUPPORT_LONG_LONG)
743:                             idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
744:                 #endif
745:                           }
746:                           else if (flags & FLAGS_LONG) {
747:                             idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
748:                           }
749:                           else {
750:                             const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
751:                             idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
752:                           }
753:                         }
754:                         format++;
755:                         break;
756:                       }
757:                 #if defined(PRINTF_SUPPORT_FLOAT)
758:                       case 'f' :
759:                       case 'F' :
760:                         if (*format == 'F') flags |= FLAGS_UPPERCASE;
761:                         idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
762:                         format++;
763:                         break;
764:                 #if defined(PRINTF_SUPPORT_EXPONENTIAL)
765:                       case 'e':
766:                       case 'E':
767:                       case 'g':
768:                       case 'G':
769:                         if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;
770:                         if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
771:                         idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
772:                         format++;
773:                         break;
774:                 #endif  // PRINTF_SUPPORT_EXPONENTIAL
775:                 #endif  // PRINTF_SUPPORT_FLOAT
776:                       case 'c' : {
777:                         unsigned int l = 1U;
778:                         // pre padding
779:                         if (!(flags & FLAGS_LEFT)) {
780:                           while (l++ < width) {
781:                             out(' ', buffer, idx++, maxlen);
782:                           }
783:                         }
784:                         // char output
785:                         out((char)va_arg(va, int), buffer, idx++, maxlen);
786:                         // post padding
787:                         if (flags & FLAGS_LEFT) {
788:                           while (l++ < width) {
789:                             out(' ', buffer, idx++, maxlen);
790:                           }
791:                         }
792:                         format++;
793:                         break;
794:                       }
795:                 
796:                       case 's' : {
797:                         const char* p = va_arg(va, char*);
798:                         unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
799:                         // pre padding
800:                         if (flags & FLAGS_PRECISION) {
801:                           l = (l < precision ? l : precision);
802:                         }
803:                         if (!(flags & FLAGS_LEFT)) {
804:                           while (l++ < width) {
805:                             out(' ', buffer, idx++, maxlen);
806:                           }
807:                         }
808:                         // string output
809:                         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
810:                           out(*(p++), buffer, idx++, maxlen);
811:                         }
812:                         // post padding
813:                         if (flags & FLAGS_LEFT) {
814:                           while (l++ < width) {
815:                             out(' ', buffer, idx++, maxlen);
816:                           }
817:                         }
818:                         format++;
819:                         break;
820:                       }
821:                 
822:                       case 'p' : {
823:                         width = sizeof(void*) * 2U;
824:                         flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
825:                 #if defined(PRINTF_SUPPORT_LONG_LONG)
826:                         const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
827:                         if (is_ll) {
828:                           idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
829:                         }
830:                         else {
831:                 #endif
832:                           idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
833:                 #if defined(PRINTF_SUPPORT_LONG_LONG)
834:                         }
835:                 #endif
836:                         format++;
837:                         break;
838:                       }
839:                 
840:                       case '%' :
841:                         out('%', buffer, idx++, maxlen);
842:                         format++;
843:                         break;
844:                 
845:                       default :
846:                         out(*format, buffer, idx++, maxlen);
847:                         format++;
848:                         break;
849:                     }
850:                   }
851:                 
852:                   // termination
853:                   out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
854:                 
855:                   // return written chars without terminating \0
856:                   return (int)idx;
857:                 }
858:                 
859:                 
860:                 ///////////////////////////////////////////////////////////////////////////////
861:                 
862:                 int printf_(const char* format, ...)
863:                 {
864:                   va_list va;
865:                   va_start(va, format);
866:                   char buffer[1];
867:                   const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
868:                   va_end(va);
869:                   return ret;
870:                 }
871:                 
872:                 
873:                 int sprintf_(char* buffer, const char* format, ...)
874:                 {
875:                   va_list va;
876:                   va_start(va, format);
877:                   const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
878:                   va_end(va);
879:                   return ret;
880:                 }
881:                 
882:                 
883:                 int snprintf_(char* buffer, size_t count, const char* format, ...)
884:                 {
885:                   va_list va;
886:                   va_start(va, format);
887:                   const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
888:                   va_end(va);
889:                   return ret;
890:                 }
891:                 
892:                 
893:                 int vprintf_(const char* format, va_list va)
894:                 {
895:                   char buffer[1];
896:                   return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
897:                 }
898:                 
899:                 
900:                 int vsnprintf_(char* buffer, size_t count, const char* format, va_list va)
901:                 {
902:                   return _vsnprintf(_out_buffer, buffer, count, format, va);
903:                 }
904:                 
905:                 
906:                 int fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...)
907:                 {
908:                   va_list va;
909:                   va_start(va, format);
910:                   const out_fct_wrap_type out_fct_wrap = { out, arg };
911:                   const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
912:                   va_end(va);
913:                   return ret;
914:                 }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000024  00000000   NOP
00000028  00000000   NOP
0000002C  00000000   NOP
00000030  00000000   NOP
00000038  00000000   NOP
9D000248  00C7382B   SLTU A3, A2, A3
9D00024C  10E00002   BEQ A3, ZERO, _out_buffer
9D000250  00A62821   ADDU A1, A1, A2
9D000254  A0A40000   SB A0, 0(A1)
9D000258  03E00008   JR RA
9D00025C  00000000   NOP
9D0003D0  03E00008   JR RA
9D0003D4  00000000   NOP
9D000768  27BDFF98   ADDIU SP, SP, -104
9D00076C  AFB60058   SW S6, 88(SP)
9D000770  AFB50054   SW S5, 84(SP)
9D000774  AFB40050   SW S4, 80(SP)
9D000778  AFB3004C   SW S3, 76(SP)
9D00077C  AFB20048   SW S2, 72(SP)
9D000780  AFBF0064   SW RA, 100(SP)
9D000784  AFBE0060   SW FP, 96(SP)
9D000788  AFB7005C   SW S7, 92(SP)
9D00078C  AFB10044   SW S1, 68(SP)
9D000790  AFB00040   SW S0, 64(SP)
9D000794  00A09825   OR S3, A1, ZERO
9D000798  00C09025   OR S2, A2, ZERO
9D00079C  00E0A825   OR S5, A3, ZERO
9D0007A0  8FB60078   LW S6, 120(SP)
9D0007A4  10A001C0   BEQ A1, ZERO, _vsnprintf
9D0007A8  0080A025   OR S4, A0, ZERO
9D0007AC  3C029D00   LUI V0, -25344
9D0007B0  3C119D00   LUI S1, -25344
9D0007B4  24420978   ADDIU V0, V0, 2424
9D0007B8  0000B825   OR S7, ZERO, ZERO
9D0007BC  26310880   ADDIU S1, S1, 2176
9D0007C0  AFA20030   SW V0, 48(SP)
9D0007C4  82A40000   LB A0, 0(S5)
9D0007C8  1080000C   BEQ A0, ZERO, _vsnprintf
9D0007CC  02F2302B   SLTU A2, S7, S2
9D0007D0  24030025   ADDIU V1, ZERO, 37
9D0007D4  1083001D   BEQ A0, V1, _vsnprintf
9D0007D8  26B50001   ADDIU S5, S5, 1
9D0007DC  02E03025   OR A2, S7, ZERO
9D0007E0  02403825   OR A3, S2, ZERO
9D0007E4  0280F809   JALR S4
9D0007E8  02602825   OR A1, S3, ZERO
9D0007EC  82A40000   LB A0, 0(S5)
9D0007F0  1480FFF7   BNE A0, ZERO, _vsnprintf
9D0007F4  26F70001   ADDIU S7, S7, 1
9D0007F8  02F2302B   SLTU A2, S7, S2
9D0007FC  2643FFFF   ADDIU V1, S2, -1
9D000800  02E6180B   MOVN V1, S7, A2
9D000804  02403825   OR A3, S2, ZERO
9D000808  02602825   OR A1, S3, ZERO
9D00080C  00603025   OR A2, V1, ZERO
9D000810  0280F809   JALR S4
9D000814  00002025   OR A0, ZERO, ZERO
9D000818  8FBF0064   LW RA, 100(SP)
9D00081C  02E01025   OR V0, S7, ZERO
9D000820  8FBE0060   LW FP, 96(SP)
9D000824  8FB7005C   LW S7, 92(SP)
9D000828  8FB60058   LW S6, 88(SP)
9D00082C  8FB50054   LW S5, 84(SP)
9D000830  8FB40050   LW S4, 80(SP)
9D000834  8FB3004C   LW S3, 76(SP)
9D000838  8FB20048   LW S2, 72(SP)
9D00083C  8FB10044   LW S1, 68(SP)
9D000840  8FB00040   LW S0, 64(SP)
9D000844  03E00008   JR RA
9D000848  27BD0068   ADDIU SP, SP, 104
9D00084C  82A40000   LB A0, 0(S5)
9D000850  26A50001   ADDIU A1, S5, 1
9D000854  00003025   OR A2, ZERO, ZERO
9D000858  2483FFE0   ADDIU V1, A0, -32
9D00085C  306300FF   ANDI V1, V1, 255
9D000860  2C670011   SLTIU A3, V1, 17
9D000864  10E00020   BEQ A3, ZERO, _vsnprintf::_is_digit
9D000868  00A04825   OR T1, A1, ZERO
9D00086C  00031880   SLL V1, V1, 2
9D000870  02231821   ADDU V1, S1, V1
9D000874  8C630000   LW V1, 0(V1)
9D000878  00600008   JR V1
9D00087C  00000000   NOP
9D0008C4  34C60001   ORI A2, A2, 1
9D0008C8  00A0A825   OR S5, A1, ZERO
9D0008CC  82A40000   LB A0, 0(S5)
9D0008D0  26A50001   ADDIU A1, S5, 1
9D0008D4  2483FFE0   ADDIU V1, A0, -32
9D0008D8  306300FF   ANDI V1, V1, 255
9D0008DC  2C670011   SLTIU A3, V1, 17
9D0008E0  14E0FFE2   BNE A3, ZERO, _vsnprintf
9D0008E4  00A04825   OR T1, A1, ZERO
9D0008E8  2483FFD0   ADDIU V1, A0, -48
9D0008EC  306300FF   ANDI V1, V1, 255
9D0008F0  2C63000A   SLTIU V1, V1, 10
9D0008F4  14600089   BNE V1, ZERO, _vsnprintf
9D0008F8  2403002A   ADDIU V1, ZERO, 42
9D0008FC  108300B8   BEQ A0, V1, _vsnprintf
9D000900  2403002E   ADDIU V1, ZERO, 46
9D000904  02A04825   OR T1, S5, ZERO
9D000908  0000F025   OR FP, ZERO, ZERO
9D00090C  00A0A825   OR S5, A1, ZERO
9D000910  10830095   BEQ A0, V1, _vsnprintf
9D000914  00008025   OR S0, ZERO, ZERO
9D000918  2403006A   ADDIU V1, ZERO, 106
9D00091C  5083009F   BEQL A0, V1, _vsnprintf
9D000920  34C60200   ORI A2, A2, 512
9D000924  2883006B   SLTI V1, A0, 107
9D000928  14600073   BNE V1, ZERO, _vsnprintf
9D00092C  2403006C   ADDIU V1, ZERO, 108
9D000930  50830157   BEQL A0, V1, _vsnprintf
9D000934  81240001   LB A0, 1(T1)
9D000938  2403007A   ADDIU V1, ZERO, 122
9D00093C  14830005   BNE A0, V1, _vsnprintf
9D000940  2483FFDB   ADDIU V1, A0, -37
9D000944  81240001   LB A0, 1(T1)
9D000948  34C60100   ORI A2, A2, 256
9D00094C  26B50001   ADDIU S5, S5, 1
9D000950  2483FFDB   ADDIU V1, A0, -37
9D000954  306300FF   ANDI V1, V1, 255
9D000958  2C650054   SLTIU A1, V1, 84
9D00095C  10A0FF9F   BEQ A1, ZERO, _vsnprintf
9D000960  8FA20030   LW V0, 48(SP)
9D000964  00031880   SLL V1, V1, 2
9D000968  00431821   ADDU V1, V0, V1
9D00096C  8C630000   LW V1, 0(V1)
9D000970  00600008   JR V1
9D000974  00000000   NOP
9D000AC8  34C60002   ORI A2, A2, 2
9D000ACC  1000FF7F   BEQ ZERO, ZERO, _vsnprintf
9D000AD0  00A0A825   OR S5, A1, ZERO
9D000AD4  34C60004   ORI A2, A2, 4
9D000AD8  1000FF7C   BEQ ZERO, ZERO, _vsnprintf
9D000ADC  00A0A825   OR S5, A1, ZERO
9D000AE0  34C60010   ORI A2, A2, 16
9D000AE4  1000FF79   BEQ ZERO, ZERO, _vsnprintf
9D000AE8  00A0A825   OR S5, A1, ZERO
9D000AEC  34C60008   ORI A2, A2, 8
9D000AF0  1000FF76   BEQ ZERO, ZERO, _vsnprintf
9D000AF4  00A0A825   OR S5, A1, ZERO
9D000AF8  24030068   ADDIU V1, ZERO, 104
9D000AFC  5483FF95   BNEL A0, V1, _vsnprintf
9D000B00  2483FFDB   ADDIU V1, A0, -37
9D000B04  81240001   LB A0, 1(T1)
9D000B08  508300F7   BEQL A0, V1, _vsnprintf
9D000B0C  34C600C0   ORI A2, A2, 192
9D000B10  34C60080   ORI A2, A2, 128
9D000B14  1000FF8E   BEQ ZERO, ZERO, _vsnprintf
9D000B18  26B50001   ADDIU S5, S5, 1
9D000B1C  10000003   BEQ ZERO, ZERO, _vsnprintf
9D000B20  0000F025   OR FP, ZERO, ZERO
9D000B24  00A0A825   OR S5, A1, ZERO
9D000B2C  001E8080   SLL S0, FP, 2
9D000B38  02048021   ADDU S0, S0, A0
9D000B3C  80A40000   LB A0, 0(A1)
9D000B40  00A04825   OR T1, A1, ZERO
9D000B44  2483FFD0   ADDIU V1, A0, -48
9D000B48  306300FF   ANDI V1, V1, 255
9D000B5C  2403002E   ADDIU V1, ZERO, 46
9D000B60  1483FF6D   BNE A0, V1, _vsnprintf
9D000B64  00008025   OR S0, ZERO, ZERO
9D000B68  81240001   LB A0, 1(T1)
9D000B6C  2483FFD0   ADDIU V1, A0, -48
9D000B70  306300FF   ANDI V1, V1, 255
9D000B74  2C63000A   SLTIU V1, V1, 10
9D000B78  1460000C   BNE V1, ZERO, _vsnprintf
9D000B7C  34C60400   ORI A2, A2, 1024
9D000B80  2403002A   ADDIU V1, ZERO, 42
9D000B84  108300CB   BEQ A0, V1, _vsnprintf
9D000B88  2403006A   ADDIU V1, ZERO, 106
9D000B8C  02A04825   OR T1, S5, ZERO
9D000B90  1483FF64   BNE A0, V1, _vsnprintf
9D000B94  26B50001   ADDIU S5, S5, 1
9D000B98  34C60200   ORI A2, A2, 512
9D000B9C  81240001   LB A0, 1(T1)
9D000BA0  1000FF6B   BEQ ZERO, ZERO, _vsnprintf
9D000BA4  26B50001   ADDIU S5, S5, 1
9D000BA8  0120A825   OR S5, T1, ZERO
9D000BAC  00101880   SLL V1, S0, 2
9D000BB8  01645821   ADDU T3, T3, A0
9D000BBC  82A40001   LB A0, 1(S5)
9D000BC0  26A90001   ADDIU T1, S5, 1
9D000BC4  2483FFD0   ADDIU V1, A0, -48
9D000BC8  306300FF   ANDI V1, V1, 255
9D000BE0  8EDE0000   LW FP, 0(S6)
9D000BE4  07C000A6   BLTZ FP, _vsnprintf
9D000BE8  26D60004   ADDIU S6, S6, 4
9D000BEC  82A40001   LB A0, 1(S5)
9D000BF0  1000FFDA   BEQ ZERO, ZERO, _vsnprintf
9D000BF4  26B50002   ADDIU S5, S5, 2
9D000BF8  8EC20000   LW V0, 0(S6)
9D000BFC  26C30004   ADDIU V1, S6, 4
9D000C00  AFA30038   SW V1, 56(SP)
9D000C04  AFA2002C   SW V0, 44(SP)
9D000C08  160000B3   BNE S0, ZERO, _strnlen_s
9D000C0C  80440000   LB A0, 0(V0)
9D000C10  1080014F   BEQ A0, ZERO, _vsnprintf
9D000C14  2402FFFE   ADDIU V0, ZERO, -2
9D000C18  8FA3002C   LW V1, 44(SP)
9D000C1C  24420001   ADDIU V0, V0, 1
9D000C20  AFA20034   SW V0, 52(SP)
9D000C24  10000003   BEQ ZERO, ZERO, _vsnprintf
9D000C28  00623821   ADDU A3, V1, V0
9D000C2C  10E30008   BEQ A3, V1, _vsnprintf
9D000C30  30D60400   ANDI S6, A2, 1024
9D000C34  24630001   ADDIU V1, V1, 1
9D000C38  80650000   LB A1, 0(V1)
9D000C3C  14A0FFFB   BNE A1, ZERO, _vsnprintf
9D000C40  8FA2002C   LW V0, 44(SP)
9D000C44  00621023   SUBU V0, V1, V0
9D000C48  AFA20034   SW V0, 52(SP)
9D000C4C  30D60400   ANDI S6, A2, 1024
9D000C50  12C00006   BEQ S6, ZERO, _vsnprintf
9D000C54  30C20002   ANDI V0, A2, 2
9D000C58  8FA20034   LW V0, 52(SP)
9D000C5C  0202182B   SLTU V1, S0, V0
9D000C60  0203100B   MOVN V0, S0, V1
9D000C64  AFA20034   SW V0, 52(SP)
9D000C68  30C20002   ANDI V0, A2, 2
9D000C6C  104000F7   BEQ V0, ZERO, _vsnprintf
9D000C70  AFA2003C   SW V0, 60(SP)
9D000C74  108000A0   BEQ A0, ZERO, _vsnprintf
9D000C78  8FA20034   LW V0, 52(SP)
9D000C7C  02E03025   OR A2, S7, ZERO
9D000C80  12C00005   BEQ S6, ZERO, _vsnprintf
9D000C84  24C90001   ADDIU T1, A2, 1
9D000C88  120000D3   BEQ S0, ZERO, _vsnprintf
9D000C8C  2603FFFF   ADDIU V1, S0, -1
9D000C90  00608025   OR S0, V1, ZERO
9D000C94  24C90001   ADDIU T1, A2, 1
9D000C98  AFA90028   SW T1, 40(SP)
9D000C9C  02403825   OR A3, S2, ZERO
9D000CA0  0280F809   JALR S4
9D000CA4  02602825   OR A1, S3, ZERO
9D000CA8  8FA90028   LW T1, 40(SP)
9D000CAC  8FA2002C   LW V0, 44(SP)
9D000CB0  01371823   SUBU V1, T1, S7
9D000CB4  00431821   ADDU V1, V0, V1
9D000CB8  80640000   LB A0, 0(V1)
9D000CBC  1480FFF0   BNE A0, ZERO, _vsnprintf
9D000CC0  01203025   OR A2, T1, ZERO
9D000CC4  8FA2003C   LW V0, 60(SP)
9D000CC8  5440008A   BNEL V0, ZERO, _vsnprintf
9D000CCC  0120B825   OR S7, T1, ZERO
9D000CD0  8FB60038   LW S6, 56(SP)
9D000CD4  1000FEBB   BEQ ZERO, ZERO, _vsnprintf
9D000CD8  0120B825   OR S7, T1, ZERO
9D000CDC  24030008   ADDIU V1, ZERO, 8
9D000CE0  34C20021   ORI V0, A2, 33
9D000CE4  AFA30020   SW V1, 32(SP)
9D000CE8  24030010   ADDIU V1, ZERO, 16
9D000CEC  AFA20024   SW V0, 36(SP)
9D000CF0  AFB0001C   SW S0, 28(SP)
9D000CF4  AFA30018   SW V1, 24(SP)
9D000CF8  AFA00014   SW ZERO, 20(SP)
9D000CFC  8EC30000   LW V1, 0(S6)
9D000D00  02E03025   OR A2, S7, ZERO
9D000D04  02403825   OR A3, S2, ZERO
9D000D08  AFA30010   SW V1, 16(SP)
9D000D0C  02602825   OR A1, S3, ZERO
9D000D10  0F400763   JAL _ntoa_long
9D000D14  02802025   OR A0, S4, ZERO
9D000D18  26D60004   ADDIU S6, S6, 4
9D000D1C  1000FEA9   BEQ ZERO, ZERO, _vsnprintf
9D000D20  0040B825   OR S7, V0, ZERO
9D000D24  26C20004   ADDIU V0, S6, 4
9D000D28  30D00002   ANDI S0, A2, 2
9D000D2C  26E30001   ADDIU V1, S7, 1
9D000D30  120000AE   BEQ S0, ZERO, _vsnprintf
9D000D34  AFA2002C   SW V0, 44(SP)
9D000D38  82C40000   LB A0, 0(S6)
9D000D3C  AFA30034   SW V1, 52(SP)
9D000D40  AFA30028   SW V1, 40(SP)
9D000D44  02E03025   OR A2, S7, ZERO
9D000D48  02403825   OR A3, S2, ZERO
9D000D4C  0280F809   JALR S4
9D000D50  02602825   OR A1, S3, ZERO
9D000D54  2FC40002   SLTIU A0, FP, 2
9D000D58  03D7B821   ADDU S7, FP, S7
9D000D5C  8FA20028   LW V0, 40(SP)
9D000D60  148000D9   BNE A0, ZERO, _vsnprintf
9D000D64  8FA30034   LW V1, 52(SP)
9D000D68  00403025   OR A2, V0, ZERO
9D000D6C  245E0001   ADDIU FP, V0, 1
9D000D70  02403825   OR A3, S2, ZERO
9D000D74  02602825   OR A1, S3, ZERO
9D000D78  0280F809   JALR S4
9D000D7C  24040020   ADDIU A0, ZERO, 32
9D000D80  16FEFFF9   BNE S7, FP, _vsnprintf
9D000D84  03C01025   OR V0, FP, ZERO
9D000D88  1000FE8E   BEQ ZERO, ZERO, _vsnprintf
9D000D8C  8FB6002C   LW S6, 44(SP)
9D000D90  24030078   ADDIU V1, ZERO, 120
9D000D94  108300CF   BEQ A0, V1, _vsnprintf
9D000D98  30C70400   ANDI A3, A2, 1024
9D000D9C  24030058   ADDIU V1, ZERO, 88
9D000DA0  10830067   BEQ A0, V1, _vsnprintf
9D000DA4  00C01825   OR V1, A2, ZERO
9D000DA8  2403006F   ADDIU V1, ZERO, 111
9D000DAC  108300C4   BEQ A0, V1, _vsnprintf
9D000DB0  24030062   ADDIU V1, ZERO, 98
9D000DB4  10830068   BEQ A0, V1, _vsnprintf
9D000DB8  00C01825   OR V1, A2, ZERO
9D000DBC  24050069   ADDIU A1, ZERO, 105
9D000DC0  148500EB   BNE A0, A1, _vsnprintf
9D000DC4  7C032104   INS V1, ZERO, 4, 1
9D000DC8  2405000A   ADDIU A1, ZERO, 10
9D000DCC  10E00069   BEQ A3, ZERO, _vsnprintf
9D000DD0  30C20200   ANDI V0, A2, 512
9D000DD4  7C030004   INS V1, ZERO, 0, 1
9D000DD8  24060069   ADDIU A2, ZERO, 105
9D000DDC  10860065   BEQ A0, A2, _vsnprintf
9D000DE0  30620200   ANDI V0, V1, 512
9D000DE4  24060064   ADDIU A2, ZERO, 100
9D000DE8  10860062   BEQ A0, A2, _vsnprintf
9D000DEC  00000000   NOP
9D000DF0  5440FE75   BNEL V0, ZERO, _vsnprintf
9D000DF4  82A40000   LB A0, 0(S5)
9D000DF8  30640100   ANDI A0, V1, 256
9D000DFC  148000C9   BNE A0, ZERO, _vsnprintf
9D000E00  26C80004   ADDIU T0, S6, 4
9D000E04  30640040   ANDI A0, V1, 64
9D000E08  54800005   BNEL A0, ZERO, _vsnprintf
9D000E0C  92C40000   LBU A0, 0(S6)
9D000E10  30640080   ANDI A0, V1, 128
9D000E14  50800002   BEQL A0, ZERO, _vsnprintf
9D000E18  8EC40000   LW A0, 0(S6)
9D000E1C  96C40000   LHU A0, 0(S6)
9D000E20  AFA80028   SW T0, 40(SP)
9D000E24  AFA30024   SW V1, 36(SP)
9D000E28  AFBE0020   SW FP, 32(SP)
9D000E2C  AFB0001C   SW S0, 28(SP)
9D000E30  AFA50018   SW A1, 24(SP)
9D000E34  AFA00014   SW ZERO, 20(SP)
9D000E38  AFA40010   SW A0, 16(SP)
9D000E3C  02403825   OR A3, S2, ZERO
9D000E40  02E03025   OR A2, S7, ZERO
9D000E44  02602825   OR A1, S3, ZERO
9D000E48  0F400763   JAL _ntoa_long
9D000E4C  02802025   OR A0, S4, ZERO
9D000E50  8FA80028   LW T0, 40(SP)
9D000E54  0040B825   OR S7, V0, ZERO
9D000E58  1000FE5A   BEQ ZERO, ZERO, _vsnprintf
9D000E5C  0100B025   OR S6, T0, ZERO
9D000E60  02E03025   OR A2, S7, ZERO
9D000E64  02403825   OR A3, S2, ZERO
9D000E68  02602825   OR A1, S3, ZERO
9D000E6C  24040025   ADDIU A0, ZERO, 37
9D000E70  0280F809   JALR S4
9D000E74  26F70001   ADDIU S7, S7, 1
9D000E78  1000FE53   BEQ ZERO, ZERO, _vsnprintf
9D000E7C  82A40000   LB A0, 0(S5)
9D000E80  34C60002   ORI A2, A2, 2
9D000E84  001EF023   SUBU FP, ZERO, FP
9D000E88  1000FF59   BEQ ZERO, ZERO, _vsnprintf
9D000E8C  82A40001   LB A0, 1(S5)
9D000E90  5483FEAE   BNEL A0, V1, _vsnprintf
9D000E94  34C60100   ORI A2, A2, 256
9D000E98  34C60300   ORI A2, A2, 768
9D000E9C  81240002   LB A0, 2(T1)
9D000EA0  1000FEAB   BEQ ZERO, ZERO, _vsnprintf
9D000EA4  25350003   ADDIU S5, T1, 3
9D000EA8  3C149D00   LUI S4, -25344
9D000EAC  1000FE3F   BEQ ZERO, ZERO, _vsnprintf
9D000EB0  269403D0   ADDIU S4, S4, 976
9D000EB4  8EC30000   LW V1, 0(S6)
9D000EB8  81240002   LB A0, 2(T1)
9D000EBC  25350003   ADDIU S5, T1, 3
9D000EC0  286B0000   SLTI T3, V1, 0
9D000EC4  000B180B   MOVN V1, ZERO, T3
9D000EC8  00608025   OR S0, V1, ZERO
9D000ECC  26D60004   ADDIU S6, S6, 4
9D000ED0  1000FE91   BEQ ZERO, ZERO, _vsnprintf
9D000ED4  25290002   ADDIU T1, T1, 2
9D000ED8  1080009D   BEQ A0, ZERO, _vsnprintf
9D000EDC  2602FFFF   ADDIU V0, S0, -1
9D000EE0  1000FF4E   BEQ ZERO, ZERO, _vsnprintf
9D000EE4  8FA3002C   LW V1, 44(SP)
9D000EE8  81240002   LB A0, 2(T1)
9D000EEC  1000FE98   BEQ ZERO, ZERO, _vsnprintf
9D000EF0  25350003   ADDIU S5, T1, 3
9D000EF4  8FA20034   LW V0, 52(SP)
9D000EF8  005E182B   SLTU V1, V0, FP
9D000EFC  1060006A   BEQ V1, ZERO, _vsnprintf
9D000F00  02E04825   OR T1, S7, ZERO
9D000F04  03D78021   ADDU S0, FP, S7
9D000F08  02024823   SUBU T1, S0, V0
9D000F0C  AFA90028   SW T1, 40(SP)
9D000F10  02E03025   OR A2, S7, ZERO
9D000F14  02403825   OR A3, S2, ZERO
9D000F18  02602825   OR A1, S3, ZERO
9D000F1C  0280F809   JALR S4
9D000F20  24040020   ADDIU A0, ZERO, 32
9D000F24  8FA90028   LW T1, 40(SP)
9D000F28  26F70001   ADDIU S7, S7, 1
9D000F2C  5537FFF8   BNEL T1, S7, _vsnprintf
9D000F30  AFA90028   SW T1, 40(SP)
9D000F34  8FB60038   LW S6, 56(SP)
9D000F38  1000FE22   BEQ ZERO, ZERO, _vsnprintf
9D000F3C  0120B825   OR S7, T1, ZERO
9D000F40  7C031884   INS V1, ZERO, 2, 2
9D000F44  30C50400   ANDI A1, A2, 1024
9D000F48  10A0005A   BEQ A1, ZERO, _vsnprintf
9D000F4C  34630020   ORI V1, V1, 32
9D000F50  1000FFA0   BEQ ZERO, ZERO, _vsnprintf
9D000F54  24050010   ADDIU A1, ZERO, 16
9D000F58  24050002   ADDIU A1, ZERO, 2
9D000F5C  00C01825   OR V1, A2, ZERO
9D000F60  24060064   ADDIU A2, ZERO, 100
9D000F64  14860080   BNE A0, A2, _vsnprintf
9D000F68  30670400   ANDI A3, V1, 1024
9D000F6C  14E0FF99   BNE A3, ZERO, _vsnprintf
9D000F70  30620200   ANDI V0, V1, 512
9D000F74  5440FE14   BNEL V0, ZERO, _vsnprintf
9D000F78  82A40000   LB A0, 0(S5)
9D000F7C  30640100   ANDI A0, V1, 256
9D000F80  1480005A   BNE A0, ZERO, _vsnprintf
9D000F84  26C80004   ADDIU T0, S6, 4
9D000F88  30640040   ANDI A0, V1, 64
9D000F8C  54800005   BNEL A0, ZERO, _vsnprintf
9D000F90  82C40000   LB A0, 0(S6)
9D000F94  30640080   ANDI A0, V1, 128
9D000F98  50800002   BEQL A0, ZERO, _vsnprintf
9D000F9C  8EC40000   LW A0, 0(S6)
9D000FA0  86C40000   LH A0, 0(S6)
9D000FA4  00043FC3   SRA A3, A0, 31
9D000FA8  00E43026   XOR A2, A3, A0
9D000FAC  00C73023   SUBU A2, A2, A3
9D000FB0  000427C2   SRL A0, A0, 31
9D000FB4  AFA80028   SW T0, 40(SP)
9D000FB8  AFA30024   SW V1, 36(SP)
9D000FBC  AFBE0020   SW FP, 32(SP)
9D000FC0  AFB0001C   SW S0, 28(SP)
9D000FC4  AFA50018   SW A1, 24(SP)
9D000FC8  AFA40014   SW A0, 20(SP)
9D000FCC  AFA60010   SW A2, 16(SP)
9D000FD0  1000FF9B   BEQ ZERO, ZERO, _vsnprintf
9D000FD4  02403825   OR A3, S2, ZERO
9D000FD8  8FA2003C   LW V0, 60(SP)
9D000FDC  1040FF3C   BEQ V0, ZERO, _vsnprintf
9D000FE0  00C04825   OR T1, A2, ZERO
9D000FE4  1000FFC3   BEQ ZERO, ZERO, _vsnprintf
9D000FE8  0120B825   OR S7, T1, ZERO
9D000FEC  2FC40002   SLTIU A0, FP, 2
9D000FF0  5480005B   BNEL A0, ZERO, _vsnprintf
9D000FF4  02E08025   OR S0, S7, ZERO
9D000FF8  26F0FFFF   ADDIU S0, S7, -1
9D000FFC  10000002   BEQ ZERO, ZERO, _vsnprintf
9D001000  021E8021   ADDU S0, S0, FP
9D001004  24630001   ADDIU V1, V1, 1
9D001008  AFA30028   SW V1, 40(SP)
9D00100C  02E03025   OR A2, S7, ZERO
9D001010  02403825   OR A3, S2, ZERO
9D001014  02602825   OR A1, S3, ZERO
9D001018  0280F809   JALR S4
9D00101C  24040020   ADDIU A0, ZERO, 32
9D001020  8FA30028   LW V1, 40(SP)
9D001024  1470FFF7   BNE V1, S0, _vsnprintf
9D001028  0060B825   OR S7, V1, ZERO
9D00102C  24770001   ADDIU S7, V1, 1
9D001030  82C40000   LB A0, 0(S6)
9D001034  02403825   OR A3, S2, ZERO
9D001038  02003025   OR A2, S0, ZERO
9D00103C  0280F809   JALR S4
9D001040  02602825   OR A1, S3, ZERO
9D001044  1000FDDF   BEQ ZERO, ZERO, _vsnprintf
9D001048  8FB6002C   LW S6, 44(SP)
9D00104C  8FA20034   LW V0, 52(SP)
9D001050  005E182B   SLTU V1, V0, FP
9D001054  10600040   BEQ V1, ZERO, _vsnprintf
9D001058  24450001   ADDIU A1, V0, 1
9D00105C  03D71821   ADDU V1, FP, S7
9D001060  00621023   SUBU V0, V1, V0
9D001064  AFA20028   SW V0, 40(SP)
9D001068  02E03025   OR A2, S7, ZERO
9D00106C  02403825   OR A3, S2, ZERO
9D001070  02602825   OR A1, S3, ZERO
9D001074  0280F809   JALR S4
9D001078  24040020   ADDIU A0, ZERO, 32
9D00107C  8FA20028   LW V0, 40(SP)
9D001080  26F70001   ADDIU S7, S7, 1
9D001084  1457FFF9   BNE V0, S7, _vsnprintf
9D001088  02E03025   OR A2, S7, ZERO
9D00108C  27C20001   ADDIU V0, FP, 1
9D001090  AFA20034   SW V0, 52(SP)
9D001094  8FA2002C   LW V0, 44(SP)
9D001098  80440000   LB A0, 0(V0)
9D00109C  1480FEF8   BNE A0, ZERO, _vsnprintf
9D0010A0  02E03025   OR A2, S7, ZERO
9D0010A4  02E04825   OR T1, S7, ZERO
9D0010A8  8FB60038   LW S6, 56(SP)
9D0010AC  1000FDC5   BEQ ZERO, ZERO, _vsnprintf
9D0010B0  0120B825   OR S7, T1, ZERO
9D0010B4  30C20200   ANDI V0, A2, 512
9D0010B8  1000FF4D   BEQ ZERO, ZERO, _vsnprintf
9D0010BC  24050010   ADDIU A1, ZERO, 16
9D0010C0  1000FFA6   BEQ ZERO, ZERO, _vsnprintf
9D0010C4  24050008   ADDIU A1, ZERO, 8
9D0010C8  0060B825   OR S7, V1, ZERO
9D0010CC  1000FDBD   BEQ ZERO, ZERO, _vsnprintf
9D0010D0  8FB6002C   LW S6, 44(SP)
9D0010D4  24050010   ADDIU A1, ZERO, 16
9D0010D8  00C01825   OR V1, A2, ZERO
9D0010DC  10E0FF3E   BEQ A3, ZERO, _vsnprintf
9D0010E0  7C031884   INS V1, ZERO, 2, 2
9D0010E4  1000FF3C   BEQ ZERO, ZERO, _vsnprintf
9D0010E8  7C030004   INS V1, ZERO, 0, 1
9D0010EC  8EC40000   LW A0, 0(S6)
9D0010F0  AFA30024   SW V1, 36(SP)
9D0010F4  AFA80028   SW T0, 40(SP)
9D0010F8  000437C3   SRA A2, A0, 31
9D0010FC  00C41826   XOR V1, A2, A0
9D001100  00661823   SUBU V1, V1, A2
9D001104  000427C2   SRL A0, A0, 31
9D001108  02403825   OR A3, S2, ZERO
9D00110C  AFBE0020   SW FP, 32(SP)
9D001110  AFB0001C   SW S0, 28(SP)
9D001114  AFA50018   SW A1, 24(SP)
9D001118  AFA40014   SW A0, 20(SP)
9D00111C  1000FF48   BEQ ZERO, ZERO, _vsnprintf
9D001120  AFA30010   SW V1, 16(SP)
9D001124  AFA30024   SW V1, 36(SP)
9D001128  AFBE0020   SW FP, 32(SP)
9D00112C  AFB0001C   SW S0, 28(SP)
9D001130  AFA50018   SW A1, 24(SP)
9D001134  AFA00014   SW ZERO, 20(SP)
9D001138  8EC30000   LW V1, 0(S6)
9D00113C  AFA80028   SW T0, 40(SP)
9D001140  02403825   OR A3, S2, ZERO
9D001144  02E03025   OR A2, S7, ZERO
9D001148  1000FF3E   BEQ ZERO, ZERO, _vsnprintf
9D00114C  AFA30010   SW V1, 16(SP)
9D001150  1000FEBE   BEQ ZERO, ZERO, _vsnprintf
9D001154  AFA00034   SW ZERO, 52(SP)
9D001158  1000FFD0   BEQ ZERO, ZERO, _vsnprintf
9D00115C  AFA50034   SW A1, 52(SP)
9D001160  1000FFB3   BEQ ZERO, ZERO, _vsnprintf
9D001164  0060B825   OR S7, V1, ZERO
9D001168  1000FFDB   BEQ ZERO, ZERO, _vsnprintf
9D00116C  00603025   OR A2, V1, ZERO
9D001170  1000FF7B   BEQ ZERO, ZERO, _vsnprintf
9D001174  2405000A   ADDIU A1, ZERO, 10
9D001D8C  27BDFFA0   ADDIU SP, SP, -96
9D001D90  8FAA0084   LW T2, 132(SP)
9D001D94  8FA80070   LW T0, 112(SP)
9D001D98  AFB40048   SW S4, 72(SP)
9D001D9C  AFB20040   SW S2, 64(SP)
9D001DA0  AFB1003C   SW S1, 60(SP)
9D001DA4  AFB00038   SW S0, 56(SP)
9D001DA8  00A08825   OR S1, A1, ZERO
9D001DAC  00E09025   OR S2, A3, ZERO
9D001DB0  AFBF005C   SW RA, 92(SP)
9D001DB4  AFBE0058   SW FP, 88(SP)
9D001DB8  AFB70054   SW S7, 84(SP)
9D001DBC  AFB60050   SW S6, 80(SP)
9D001DC0  AFB5004C   SW S5, 76(SP)
9D001DC4  AFB30044   SW S3, 68(SP)
9D001DC8  00808025   OR S0, A0, ZERO
9D001DCC  AFA60068   SW A2, 104(SP)
9D001DD0  93AD0074   LBU T5, 116(SP)
9D001DD4  8FA50078   LW A1, 120(SP)
9D001DD8  8FA7007C   LW A3, 124(SP)
9D001DDC  8FB40080   LW S4, 128(SP)
9D001DE0  15000007   BNE T0, ZERO, _ntoa_long
9D001DE4  314B0400   ANDI T3, T2, 1024
9D001DE8  01401025   OR V0, T2, ZERO
9D001DEC  15600092   BNE T3, ZERO, _ntoa_long::_ntoa_format
9D001DF0  7C022104   INS V0, ZERO, 4, 1
9D001DF4  00006025   OR T4, ZERO, ZERO
9D001DF8  10000002   BEQ ZERO, ZERO, _ntoa_long
9D001DFC  00405025   OR T2, V0, ZERO
9D001E00  314C0010   ANDI T4, T2, 16
9D001E04  31460020   ANDI A2, T2, 32
9D001E08  24030041   ADDIU V1, ZERO, 65
9D001E0C  24020061   ADDIU V0, ZERO, 97
9D001E10  0066100B   MOVN V0, V1, A2
9D001E14  27B30010   ADDIU S3, SP, 16
9D001E18  00001825   OR V1, ZERO, ZERO
9D001E1C  2446FFF6   ADDIU A2, V0, -10
9D001E20  10000003   BEQ ZERO, ZERO, _ntoa_long
9D001E24  240E0020   ADDIU T6, ZERO, 32
9D001E28  106E0011   BEQ V1, T6, _ntoa_long::_ntoa_format
9D001E2C  00004012   MFLO T0
9D001E30  0105001B   DIVU T0, A1
9D001E34  00A001F4   TEQ A1, ZERO
9D001E38  00001010   MFHI V0
9D001E3C  7C022420   SEB A0, V0
9D001E40  304200FF   ANDI V0, V0, 255
9D001E44  244F0030   ADDIU T7, V0, 48
9D001E48  2884000A   SLTI A0, A0, 10
9D001E4C  00461021   ADDU V0, V0, A2
9D001E50  10800002   BEQ A0, ZERO, _ntoa_long
9D001E54  7C021420   SEB V0, V0
9D001E58  7C0F1420   SEB V0, T7
9D001E5C  24630001   ADDIU V1, V1, 1
9D001E60  02632021   ADDU A0, S3, V1
9D001E64  0105402B   SLTU T0, T0, A1
9D001E68  1100FFEF   BEQ T0, ZERO, _ntoa_long
9D001E6C  A082FFFF   SB V0, -1(A0)
9D001E70  31420002   ANDI V0, T2, 2
9D001E74  10400076   BEQ V0, ZERO, _ntoa_long::_ntoa_format
9D001E78  AFA20030   SW V0, 48(SP)
9D001E7C  1180002F   BEQ T4, ZERO, _ntoa_long
9D001E80  24020020   ADDIU V0, ZERO, 32
9D001E84  1560008D   BNE T3, ZERO, _ntoa_long
9D001E88  24020010   ADDIU V0, ZERO, 16
9D001E8C  14600019   BNE V1, ZERO, _ntoa_long
9D001E90  00000000   NOP
9D001E94  10A200FD   BEQ A1, V0, _ntoa_long::_ntoa_format
9D001E98  24020002   ADDIU V0, ZERO, 2
9D001E9C  10A200ED   BEQ A1, V0, _ntoa_long::_ntoa_format
9D001EA0  24020030   ADDIU V0, ZERO, 48
9D001EA4  A3A20010   SB V0, 16(SP)
9D001EA8  24030001   ADDIU V1, ZERO, 1
9D001EAC  11A0008E   BEQ T5, ZERO, _ntoa_long::_ntoa_format
9D001EB0  31420004   ANDI V0, T2, 4
9D001EB4  27B30010   ADDIU S3, SP, 16
9D001EB8  02631021   ADDU V0, S3, V1
9D001EBC  247E0001   ADDIU FP, V1, 1
9D001EC0  2403002D   ADDIU V1, ZERO, 45
9D001EC4  A0430000   SB V1, 0(V0)
9D001EC8  314A0003   ANDI T2, T2, 3
9D001ECC  1540002F   BNE T2, ZERO, _ntoa_long
9D001ED0  8FB50068   LW S5, 104(SP)
9D001ED4  03D4102B   SLTU V0, FP, S4
9D001ED8  14400020   BNE V0, ZERO, _ntoa_long
9D001EDC  8FA20068   LW V0, 104(SP)
9D001EE0  1000002B   BEQ ZERO, ZERO, _ntoa_long
9D001EE4  03D5B021   ADDU S6, FP, S5
9D001EE8  15600072   BNE T3, ZERO, _ntoa_long
9D001EEC  24030020   ADDIU V1, ZERO, 32
9D001EF0  AFA00030   SW ZERO, 48(SP)
9D001EF4  10E30004   BEQ A3, V1, _ntoa_long
9D001EF8  2462FFFF   ADDIU V0, V1, -1
9D001EFC  1683006F   BNE S4, V1, _ntoa_long
9D001F00  24020010   ADDIU V0, ZERO, 16
9D001F04  2462FFFF   ADDIU V0, V1, -1
9D001F08  144000D6   BNE V0, ZERO, _ntoa_long::_ntoa_format
9D001F0C  24040010   ADDIU A0, ZERO, 16
9D001F10  24030010   ADDIU V1, ZERO, 16
9D001F14  10A300EB   BEQ A1, V1, _ntoa_long::_ntoa_format
9D001F18  24030002   ADDIU V1, ZERO, 2
9D001F1C  10A300D6   BEQ A1, V1, _ntoa_long
9D001F20  27B30010   ADDIU S3, SP, 16
9D001F24  00001825   OR V1, ZERO, ZERO
9D001F28  03A31021   ADDU V0, SP, V1
9D001F2C  24040030   ADDIU A0, ZERO, 48
9D001F30  A0440010   SB A0, 16(V0)
9D001F34  24630001   ADDIU V1, V1, 1
9D001F38  24020020   ADDIU V0, ZERO, 32
9D001F3C  1462FFDB   BNE V1, V0, _ntoa_long
9D001F40  00000000   NOP
9D001F44  314A0003   ANDI T2, T2, 3
9D001F48  15400057   BNE T2, ZERO, _ntoa_long::_ntoa_format
9D001F4C  241E0020   ADDIU FP, ZERO, 32
9D001F50  03D4102B   SLTU V0, FP, S4
9D001F54  1040006C   BEQ V0, ZERO, _ntoa_long
9D001F58  8FA20068   LW V0, 104(SP)
9D001F5C  0054A821   ADDU S5, V0, S4
9D001F60  02BEA823   SUBU S5, S5, FP
9D001F64  00403025   OR A2, V0, ZERO
9D001F68  24D60001   ADDIU S6, A2, 1
9D001F6C  02403825   OR A3, S2, ZERO
9D001F70  02202825   OR A1, S1, ZERO
9D001F74  0200F809   JALR S0
9D001F78  24040020   ADDIU A0, ZERO, 32
9D001F7C  16B6FFFA   BNE S5, S6, _ntoa_long
9D001F80  02C03025   OR A2, S6, ZERO
9D001F84  13C0000D   BEQ FP, ZERO, _ntoa_long
9D001F88  27B30010   ADDIU S3, SP, 16
9D001F8C  03D5B021   ADDU S6, FP, S5
9D001F90  027EB821   ADDU S7, S3, FP
9D001F94  0276F021   ADDU FP, S3, S6
9D001F98  82E4FFFF   LB A0, -1(S7)
9D001F9C  03D73023   SUBU A2, FP, S7
9D001FA0  02403825   OR A3, S2, ZERO
9D001FA4  26F7FFFF   ADDIU S7, S7, -1
9D001FA8  02202825   OR A1, S1, ZERO
9D001FAC  0200F809   JALR S0
9D001FB0  02C0A825   OR S5, S6, ZERO
9D001FB4  5677FFF9   BNEL S3, S7, _ntoa_long
9D001FB8  82E4FFFF   LB A0, -1(S7)
9D001FBC  8FA20030   LW V0, 48(SP)
9D001FC0  10400011   BEQ V0, ZERO, _ntoa_long
9D001FC4  8FBF005C   LW RA, 92(SP)
9D001FC8  8FA20068   LW V0, 104(SP)
9D001FCC  02A29823   SUBU S3, S5, V0
9D001FD0  0274102B   SLTU V0, S3, S4
9D001FD4  1040000D   BEQ V0, ZERO, _ntoa_long
9D001FD8  02A01025   OR V0, S5, ZERO
9D001FDC  02A03025   OR A2, S5, ZERO
9D001FE0  02403825   OR A3, S2, ZERO
9D001FE4  02202825   OR A1, S1, ZERO
9D001FE8  24040020   ADDIU A0, ZERO, 32
9D001FEC  0200F809   JALR S0
9D001FF0  26730001   ADDIU S3, S3, 1
9D001FF4  26B50001   ADDIU S5, S5, 1
9D001FF8  0274102B   SLTU V0, S3, S4
9D001FFC  1440FFF8   BNE V0, ZERO, _ntoa_long
9D002000  02A03025   OR A2, S5, ZERO
9D002004  8FBF005C   LW RA, 92(SP)
9D002008  02A01025   OR V0, S5, ZERO
9D00200C  8FBE0058   LW FP, 88(SP)
9D002010  8FB70054   LW S7, 84(SP)
9D002014  8FB60050   LW S6, 80(SP)
9D002018  8FB5004C   LW S5, 76(SP)
9D00201C  8FB40048   LW S4, 72(SP)
9D002020  8FB30044   LW S3, 68(SP)
9D002024  8FB20040   LW S2, 64(SP)
9D002028  8FB1003C   LW S1, 60(SP)
9D00202C  8FB00038   LW S0, 56(SP)
9D002030  03E00008   JR RA
9D002034  27BD0060   ADDIU SP, SP, 96
9D002038  31430002   ANDI V1, T2, 2
9D00203C  AFA30030   SW V1, 48(SP)
9D002040  1460005E   BNE V1, ZERO, _ntoa_long
9D002044  00405025   OR T2, V0, ZERO
9D002048  00006025   OR T4, ZERO, ZERO
9D00204C  00001825   OR V1, ZERO, ZERO
9D002050  31420001   ANDI V0, T2, 1
9D002054  1280002E   BEQ S4, ZERO, _ntoa_long::_ntoa_format
9D002058  AFA20030   SW V0, 48(SP)
9D00205C  10400059   BEQ V0, ZERO, _ntoa_long::_ntoa_format
9D002060  0067102B   SLTU V0, V1, A3
9D002064  55A00005   BNEL T5, ZERO, _ntoa_long
9D002068  2694FFFF   ADDIU S4, S4, -1
9D00206C  3142000C   ANDI V0, T2, 12
9D002070  54400001   BNEL V0, ZERO, _ntoa_long
9D002074  2694FFFF   ADDIU S4, S4, -1
9D002078  0067102B   SLTU V0, V1, A3
9D00207C  10400037   BEQ V0, ZERO, _ntoa_long
9D002080  24020020   ADDIU V0, ZERO, 32
9D002084  14620028   BNE V1, V0, _ntoa_long
9D002088  27B30010   ADDIU S3, SP, 16
9D00208C  2E820021   SLTIU V0, S4, 33
9D002090  14400041   BNE V0, ZERO, _ntoa_long
9D002094  00000000   NOP
9D002098  1580FF93   BNE T4, ZERO, _ntoa_long
9D00209C  00000000   NOP
9D0020A0  1000FFA8   BEQ ZERO, ZERO, _ntoa_long::_ntoa_format::_out_rev
9D0020A4  AFA00030   SW ZERO, 48(SP)
9D0020A8  8FB50068   LW S5, 104(SP)
9D0020AC  1000FFB7   BEQ ZERO, ZERO, _ntoa_long
9D0020B0  27B30010   ADDIU S3, SP, 16
9D0020B4  AFA00030   SW ZERO, 48(SP)
9D0020B8  24020010   ADDIU V0, ZERO, 16
9D0020BC  10A2004F   BEQ A1, V0, _ntoa_long::_ntoa_format
9D0020C0  24020002   ADDIU V0, ZERO, 2
9D0020C4  10A20045   BEQ A1, V0, _ntoa_long
9D0020C8  24020020   ADDIU V0, ZERO, 32
9D0020CC  24020020   ADDIU V0, ZERO, 32
9D0020D0  1062FF9C   BEQ V1, V0, _ntoa_long::_ntoa_format::_out_rev
9D0020D4  03A31021   ADDU V0, SP, V1
9D0020D8  24040030   ADDIU A0, ZERO, 48
9D0020DC  A0440010   SB A0, 16(V0)
9D0020E0  1000FF95   BEQ ZERO, ZERO, _ntoa_long
9D0020E4  24630001   ADDIU V1, V1, 1
9D0020E8  1440002F   BNE V0, ZERO, _ntoa_long::_ntoa_format
9D0020EC  27B30010   ADDIU S3, SP, 16
9D0020F0  31420008   ANDI V0, T2, 8
9D0020F4  5440004C   BNEL V0, ZERO, _ntoa_long::_ntoa_format
9D0020F8  02631021   ADDU V0, S3, V1
9D0020FC  314A0003   ANDI T2, T2, 3
9D002100  1140FF93   BEQ T2, ZERO, _ntoa_long
9D002104  0060F025   OR FP, V1, ZERO
9D002108  1000FF9E   BEQ ZERO, ZERO, _ntoa_long
9D00210C  8FB50068   LW S5, 104(SP)
9D002110  0067102B   SLTU V0, V1, A3
9D002114  1040000E   BEQ V0, ZERO, _ntoa_long
9D002118  24020020   ADDIU V0, ZERO, 32
9D00211C  1062000D   BEQ V1, V0, _ntoa_long
9D002120  8FA20030   LW V0, 48(SP)
9D002124  27B30010   ADDIU S3, SP, 16
9D002128  24060030   ADDIU A2, ZERO, 48
9D00212C  10000003   BEQ ZERO, ZERO, _ntoa_long
9D002130  24080020   ADDIU T0, ZERO, 32
9D002134  10680007   BEQ V1, T0, _ntoa_long
9D002138  8FA20030   LW V0, 48(SP)
9D00213C  24630001   ADDIU V1, V1, 1
9D002140  02632021   ADDU A0, S3, V1
9D002144  0067102B   SLTU V0, V1, A3
9D002148  1440FFFA   BNE V0, ZERO, _ntoa_long::_ntoa_format
9D00214C  A086FFFF   SB A2, -1(A0)
9D002150  8FA20030   LW V0, 48(SP)
9D002154  1040FF49   BEQ V0, ZERO, _ntoa_long
9D002158  00000000   NOP
9D00215C  0074102B   SLTU V0, V1, S4
9D002160  1040000D   BEQ V0, ZERO, _ntoa_long
9D002164  00000000   NOP
9D002168  2C620020   SLTIU V0, V1, 32
9D00216C  1040FFCA   BEQ V0, ZERO, _ntoa_long
9D002170  27B30010   ADDIU S3, SP, 16
9D002174  24040030   ADDIU A0, ZERO, 48
9D002178  10000003   BEQ ZERO, ZERO, _ntoa_long
9D00217C  24060020   ADDIU A2, ZERO, 32
9D002180  1066FFC5   BEQ V1, A2, _ntoa_long
9D002184  00000000   NOP
9D002188  24630001   ADDIU V1, V1, 1
9D00218C  02631021   ADDU V0, S3, V1
9D002190  1474FFFB   BNE V1, S4, _ntoa_long::_ntoa_format
9D002194  A044FFFF   SB A0, -1(V0)
9D002198  1580FF3A   BNE T4, ZERO, _ntoa_long
9D00219C  AFA00030   SW ZERO, 48(SP)
9D0021A0  1000FF66   BEQ ZERO, ZERO, _ntoa_long
9D0021A4  24020020   ADDIU V0, ZERO, 32
9D0021A8  02631021   ADDU V0, S3, V1
9D0021AC  247E0001   ADDIU FP, V1, 1
9D0021B0  2403002B   ADDIU V1, ZERO, 43
9D0021B4  1000FF44   BEQ ZERO, ZERO, _ntoa_long::_ntoa_format::_out_rev
9D0021B8  A0430000   SB V1, 0(V0)
9D0021BC  1000FF3B   BEQ ZERO, ZERO, _ntoa_long
9D0021C0  00001825   OR V1, ZERO, ZERO
9D0021C4  1040FF2D   BEQ V0, ZERO, _ntoa_long
9D0021C8  24020020   ADDIU V0, ZERO, 32
9D0021CC  5462FFD6   BNEL V1, V0, _ntoa_long
9D0021D0  27B30010   ADDIU S3, SP, 16
9D0021D4  1000FF29   BEQ ZERO, ZERO, _ntoa_long
9D0021D8  00000000   NOP
9D0021DC  5062FF5A   BEQL V1, V0, _ntoa_long
9D0021E0  314A0003   ANDI T2, T2, 3
9D0021E4  27B30010   ADDIU S3, SP, 16
9D0021E8  02634821   ADDU T1, S3, V1
9D0021EC  24020062   ADDIU V0, ZERO, 98
9D0021F0  24630001   ADDIU V1, V1, 1
9D0021F4  1000FFB5   BEQ ZERO, ZERO, _ntoa_long
9D0021F8  A1220000   SB V0, 0(T1)
9D0021FC  31420020   ANDI V0, T2, 32
9D002200  1440000D   BNE V0, ZERO, _ntoa_long::_ntoa_format
9D002204  24020020   ADDIU V0, ZERO, 32
9D002208  5062FF4F   BEQL V1, V0, _ntoa_long
9D00220C  314A0003   ANDI T2, T2, 3
9D002210  27B30010   ADDIU S3, SP, 16
9D002214  02634821   ADDU T1, S3, V1
9D002218  24020078   ADDIU V0, ZERO, 120
9D00221C  24630001   ADDIU V1, V1, 1
9D002220  1000FFAA   BEQ ZERO, ZERO, _ntoa_long
9D002224  A1220000   SB V0, 0(T1)
9D002228  247E0001   ADDIU FP, V1, 1
9D00222C  24030020   ADDIU V1, ZERO, 32
9D002230  1000FF25   BEQ ZERO, ZERO, _ntoa_long::_ntoa_format::_out_rev
9D002234  A0430000   SB V1, 0(V0)
9D002238  5062FF43   BEQL V1, V0, _ntoa_long
9D00223C  314A0003   ANDI T2, T2, 3
9D002240  03A31021   ADDU V0, SP, V1
9D002244  24040058   ADDIU A0, ZERO, 88
9D002248  A0440010   SB A0, 16(V0)
9D00224C  1000FF9F   BEQ ZERO, ZERO, _ntoa_long
9D002250  24630001   ADDIU V1, V1, 1
9D002254  24020062   ADDIU V0, ZERO, 98
9D002258  A3A20010   SB V0, 16(SP)
9D00225C  1000FF32   BEQ ZERO, ZERO, _ntoa_long
9D002260  24030001   ADDIU V1, ZERO, 1
9D002264  10A40012   BEQ A1, A0, _ntoa_long::_ntoa_format
9D002268  24040002   ADDIU A0, ZERO, 2
9D00226C  14A4FF2E   BNE A1, A0, _ntoa_long
9D002270  00401825   OR V1, V0, ZERO
9D002274  27B30010   ADDIU S3, SP, 16
9D002278  02624821   ADDU T1, S3, V0
9D00227C  24430001   ADDIU V1, V0, 1
9D002280  24020062   ADDIU V0, ZERO, 98
9D002284  1000FF91   BEQ ZERO, ZERO, _ntoa_long
9D002288  A1220000   SB V0, 0(T1)
9D00228C  31420020   ANDI V0, T2, 32
9D002290  5440FFEC   BNEL V0, ZERO, _ntoa_long
9D002294  03A31021   ADDU V0, SP, V1
9D002298  27B30010   ADDIU S3, SP, 16
9D00229C  02624821   ADDU T1, S3, V0
9D0022A0  24430001   ADDIU V1, V0, 1
9D0022A4  24020078   ADDIU V0, ZERO, 120
9D0022A8  1000FF88   BEQ ZERO, ZERO, _ntoa_long
9D0022AC  A1220000   SB V0, 0(T1)
9D0022B0  31420020   ANDI V0, T2, 32
9D0022B4  1440FFE2   BNE V0, ZERO, _ntoa_long
9D0022B8  2463FFFE   ADDIU V1, V1, -2
9D0022BC  1000FFF6   BEQ ZERO, ZERO, _ntoa_long
9D0022C0  00601025   OR V0, V1, ZERO
9D0022C4  31420020   ANDI V0, T2, 32
9D0022C8  14400005   BNE V0, ZERO, _ntoa_long::_ntoa_format
9D0022CC  24020058   ADDIU V0, ZERO, 88
9D0022D0  24020078   ADDIU V0, ZERO, 120
9D0022D4  A3A20010   SB V0, 16(SP)
9D0022D8  1000FF13   BEQ ZERO, ZERO, _ntoa_long
9D0022DC  24030001   ADDIU V1, ZERO, 1
9D0022E0  A3A20010   SB V0, 16(SP)
9D0022E4  1000FF10   BEQ ZERO, ZERO, _ntoa_long
9D0022E8  24030001   ADDIU V1, ZERO, 1
9D007D84  27BDFFD8   ADDIU SP, SP, -40
9D007D88  27A20030   ADDIU V0, SP, 48
9D007D8C  AFA70034   SW A3, 52(SP)
9D007D90  00A03825   OR A3, A1, ZERO
9D007D94  00802825   OR A1, A0, ZERO
9D007D98  3C049D00   LUI A0, -25344
9D007D9C  AFA60030   SW A2, 48(SP)
9D007DA0  AFA20010   SW V0, 16(SP)
9D007DA4  2406FFFF   ADDIU A2, ZERO, -1
9D007DA8  24840248   ADDIU A0, A0, 584
9D007DAC  AFBF0024   SW RA, 36(SP)
9D007DB0  0F4001DA   JAL _vsnprintf
9D007DB4  AFA20018   SW V0, 24(SP)
9D007DB8  8FBF0024   LW RA, 36(SP)
9D007DBC  03E00008   JR RA
9D007DC0  27BD0028   ADDIU SP, SP, 40
9D0080AC  27BDFFE0   ADDIU SP, SP, -32
9D0080B0  AFA70010   SW A3, 16(SP)
9D0080B4  00C03825   OR A3, A2, ZERO
9D0080B8  00A03025   OR A2, A1, ZERO
9D0080BC  00802825   OR A1, A0, ZERO
9D0080C0  3C049D00   LUI A0, -25344
9D0080C4  AFBF001C   SW RA, 28(SP)
9D0080C8  0F4001DA   JAL _vsnprintf
9D0080CC  24840248   ADDIU A0, A0, 584
9D0080D0  8FBF001C   LW RA, 28(SP)
9D0080D4  03E00008   JR RA
9D0080D8  27BD0020   ADDIU SP, SP, 32
---  c:/users/db/desktop/nano_tx/firmware/src/user_hal/conversion.c  ------------------------------------
1:                   /**
2:                    * @file conversion.c
3:                    * @brief Bit and byte order (endianness) conversion
4:                    * @author David Bender <d_bender@bluewin.ch>
5:                    * @date 05.12.2022
6:                    */
7:                   
8:                   #include "conversion.h"
9:                   
10:                  /**
11:                   * Bit reversal algorithm from http://aggregate.org/MAGIC/#Bit%20Reversal .
12:                   * @param[in]   x       Original 16 bits value.
13:                   * @return              Bit reversed 16 bits value.
14:                   */
15:                  uint16_t bitrev16(uint16_t x)
16:                  {
17:                  	x = (((x & 0xaaaa) >> 1) | ((x & 0x5555) << 1));
18:                  	x = (((x & 0xcccc) >> 2) | ((x & 0x3333) << 2));
19:                  	x = (((x & 0xf0f0) >> 4) | ((x & 0x0f0f) << 4));
20:                  	return ((x >> 8) | (x << 8));
21:                  }
22:                  
23:                  /**
24:                   * Byte (endianness) reversal.
25:                   * @param[in]   x       Original 16 bits value.
26:                   * @return              Byte (or endianness) reversed 16 bits value.
27:                   */
28:                  uint16_t byterev16(uint16_t x)
29:                  {
30:                      return (((x & 0xFF00) >> 8) | ((x & 0x00FF) << 8));
31:                  }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
00000024  00000000   NOP
00000028  00000000   NOP
0000002C  00000000   NOP
00000034  00000000   NOP
00000038  00000000   NOP
0000003C  00000000   NOP
00000040  00000000   NOP
00000044  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/user_hal/btl_ringbuffer.c  --------------------------------
1:                   /**
2:                    * @file ringbuffer.c
3:                    * @brief Ring buffer (FIFO) implementation
4:                    * @author David Bender <d_bender@bluewin.ch>
5:                    * @date 22.12.2022
6:                    */
7:                   
8:                   #include "ringbuffer.h"
9:                   #include <string.h>
10:                  #include <stdarg.h>
11:                  //#include <stdio.h>
12:                  #include "user_hal/printf.h"
13:                  
14:                  /**
15:                   * Initializes a ring buffer (FIFO).
16:                   * @param[in]       rb          Pointer to ring buffer.
17:                   * @param[in]       buffer      Data buffer assigned to this ring buffer.
18:                   * @param[in]       size        Buffer size in bytes.
19:                   */
20:                  void RB_Init(RINGBUFFER* rb, void* buffer, uint32_t size)
21:                  {
22:                      rb->buffer = buffer;
23:                      rb->size = size;
24:                      rb->used = 0;
25:                      rb->tail = 0;
26:                  }
27:                  
28:                  /**
29:                   * Reports the number of bytes that can be read from the buffer before it
30:                   * becomes empty.
31:                   * @param[in]       rb          Pointer to ring buffer.
32:                   * @return                      Number of used bytes.
33:                   */
34:                  uint32_t RB_GetUsed(RINGBUFFER* rb)
35:                  {
36:                      return rb->used;
37:                  }
38:                  
39:                  /**
40:                   * Reports the number of bytes that can be written to the buffer before it
41:                   * becomes full.
42:                   * @param[in]       rb          Pointer to ring buffer.
43:                   * @return                      Number of free bytes.
44:                   */
45:                  uint32_t RB_GetFree(RINGBUFFER* rb)
46:                  {
47:                      return rb->size - rb->used;
48:                  }
49:                  
50:                  /**
51:                   * Writes into the current contiguous range of a ring buffer.
52:                   * Since there are two separate contiguous ranges, one before and one after the
53:                   * head pointer wrap, two calls may be needed to write all data.
54:                   * @param[in]       rb          Pointer to ring buffer.
55:                   * @param[in]       data        Write data.
56:                   * @param[in]       size        Write data length in bytes.
57:                   * @return                      Number of bytes written to the ring buffer. 0 is
58:                   *                              returned if the buffer is full.
59:                   */
60:                  uint32_t RB_WriteContiguous(RINGBUFFER* rb, void* data, uint32_t size)
61:                  {
62:                      uint32_t free = rb->size - rb->used;
63:                      uint32_t head = rb->tail + rb->used;
64:                      head -= (head >= rb->size)? rb->size: 0;
65:                      uint32_t chunk = rb->size - head;
66:                      chunk = (chunk > size)? size: chunk;
67:                      chunk = (chunk > free)? free: chunk;
68:                      if (chunk > 0) {
69:                          memcpy((uint8_t*)rb->buffer + head, data, chunk);
70:                          rb->used += chunk;
71:                      }
72:                      return chunk;
73:                  }
74:                  
75:                  /**
76:                   * Writes into a ring buffer.
77:                   * @param[in]       rb          Pointer to ring buffer.
78:                   * @param[in]       data        Write data.
79:                   * @param[in]       size        Write data length in bytes.
80:                   * @return                      Number of bytes written to the ring buffer.
81:                   *                              Usually the same as size. 0 is returned if the
82:                   *                              buffer is full. Less than size if the buffer
83:                   *                              became full before writing all bytes.
84:                   */
85:                  uint32_t RB_Write(RINGBUFFER* rb, void* data, uint32_t size)
86:                  {
87:                      uint32_t done = 0;
88:                      done += RB_WriteContiguous(rb, (uint8_t*)data + done, size - done);
89:                      done += RB_WriteContiguous(rb, (uint8_t*)data + done, size - done);
90:                      return done;
91:                  }
92:                  
93:                  /**
94:                   * Writes a NULL-terminated C string into a ring buffer.
95:                   * @param[in]       rb          Pointer to ring buffer.
96:                   * @param[in]       data        NULL-terminated C string.
97:                   * @return                      Number of bytes written to the ring buffer.
98:                   *                              The same as the string length or 0 if the buffer
99:                   *                              is (almost) full.
100:                  */
101:                 uint32_t RB_WriteString(RINGBUFFER* rb, char* data)
102:                 {
103:                     uint32_t size = strlen(data);
104:                     if (RB_GetFree(rb) < size) {
105:                         return 0;
106:                     }
107:                     return RB_Write(rb, data, size);
108:                 }
109:                 
110:                 /**
111:                  * Prints a NULL-terminated C string into a ring buffer.
112:                  * @param[in]       rb          Pointer to ring buffer.
113:                  * @param[in]       format      Like printf().
114:                  * @param[in]       ...         Like printf().
115:                  * @return                      Number of bytes written to the ring buffer.
116:                  *                              Usually the same as the string length.
117:                  *                              0 is returned if the buffer is full. Less than
118:                  *                              size if the buffer became full before writing
119:                  *                              all bytes.
120:                  */
121:                 uint32_t RB_Printf(RINGBUFFER* rb, const char* format, ...)
122:                 {
123:                     char str[128];
124:                     va_list vlist;
125:                     va_start(vlist, format);
126:                     vsnprintf_(str, sizeof(str), format, vlist);
127:                     va_end(vlist);
128:                     return RB_WriteString(rb, str);
129:                 }
130:                 
131:                 /**
132:                  * Reads from the current contiguous range of a ring buffer.
133:                  * Since there are two separate contiguous ranges, one before and one after the
134:                  * tail pointer wrap, two calls may be needed to read all data.
135:                  * @param[in]       rb          Pointer to ring buffer.
136:                  * @param[out]      data        Read data.
137:                  * @param[in]       size        Read data length in bytes.
138:                  * @return                      Number of bytes read from the ring buffer. 0 is
139:                  *                              returned if the buffer is full.
140:                  */
141:                 uint32_t RB_ReadContiguous(RINGBUFFER* rb, void* data, uint32_t size)
142:                 {
143:                     uint32_t chunk = rb->size - rb->tail;
144:                     chunk = (chunk > size)? size: chunk;
145:                     chunk = (chunk > rb->used)? rb->used: chunk;
146:                     if (chunk > 0) {
147:                         memcpy(data, (uint8_t*)rb->buffer + rb->tail, chunk);
148:                         rb->used -= chunk;
149:                         rb->tail += chunk;
150:                         rb->tail -= (rb->tail >= rb->size)? rb->size: 0;
151:                     }
152:                     return chunk;
153:                 }
154:                 
155:                 /**
156:                  * Reads from a ring buffer.
157:                  * @param[in]       rb          Pointer to ring buffer.
158:                  * @param[out]      data        Read data.
159:                  * @param[in]       size        Read data length in bytes.
160:                  * @return                      Number of bytes read from the ring buffer.
161:                  *                              Usually the same as size. 0 is returned if the
162:                  *                              buffer is empty. Less than size if the buffer
163:                  *                              became empty before reading all bytes.
164:                  */
165:                 uint32_t RB_Read(RINGBUFFER* rb, void* data, uint32_t size)
166:                 {
167:                     uint32_t done = 0;
168:                     done += RB_ReadContiguous(rb, (uint8_t*)data + done, size - done);
169:                     done += RB_ReadContiguous(rb, (uint8_t*)data + done, size - done);
170:                     return done;
171:                 }
172:                 
173:                 /**
174:                  * Reads from a ring buffer, until (and including) a delimiter character.
175:                  * @param[in]       rb          Pointer to ring buffer.
176:                  * @param[out]      data        Read data, NULL terminated string.
177:                  * @param[in]       size        Read data length in bytes excluding termination
178:                  *                              character.
179:                  * @return                      Number of bytes read from the ring buffer,
180:                  *                              including the delimiter. 0 if ring buffer is
181:                  *                              empty or does not contain the delimiter.
182:                  */
183:                 uint32_t RB_ReadLine(RINGBUFFER* rb, char* data, uint32_t size, char* delim)
184:                 {
185:                     // Reserve character for NULL termination
186:                     if (size == 0) {
187:                         return 0;
188:                     }
189:                     size--;
190:                 
191:                     // Start with zero checked characters and current tail and usage
192:                     uint32_t used = rb->used;
193:                     uint32_t tail = rb->tail;
194:                     uint32_t checked = 0;
195:                 
196:                     // Search for delimiter until reaching end of buffer
197:                     while (1) {
198:                         uint32_t chunk = rb->size - tail;
199:                         chunk = (chunk > size)? size: chunk;
200:                         chunk = (chunk > used)? used: chunk;
201:                 
202:                         if (chunk > 0) {
203:                             // See if delimiter is found within current chunk of data
204:                             //void* pDelim = memchr((uint8_t*)rb->buffer + tail, delim, chunk);
205:                             void* pBrk = RB_mempbrk((uint8_t*)rb->buffer + tail, delim, chunk);
206:                             if (pBrk != NULL) {
207:                                 // String size is 1 + delimiter position - tail position
208:                                 size = 1 + (uint8_t*)pBrk - ((uint8_t*)rb->buffer + tail);
209:                                 size += checked;
210:                 
211:                                 // Size underflows if tail is before and delimiter is after wrap
212:                                 // -> make it overflow to undo underflow :-)
213:                                 size += (size >= rb->size)? rb->size: 0;
214:                 
215:                                 // Read until and including delimiter
216:                                 RB_Read(rb, data, size);
217:                 
218:                                 // Null terminate and return, reported size is excluding
219:                                 // termination character
220:                                 data[size] = '\0';
221:                                 return size;
222:                             }
223:                 
224:                             // Move tail, update usage and remember number of checked characters
225:                             used -= chunk;
226:                             tail += chunk;
227:                             tail -= (tail >= rb->size)? rb->size: 0;
228:                             checked += chunk;
229:                 
230:                         } else {
231:                             // If current chunk is empty there is no delimiter so return empty
232:                             // string
233:                             data[0] = '\0';
234:                             return 0;
235:                         }
236:                     }
237:                 }
238:                 
239:                 /**
240:                  * Returns position of first break character in data buffer.
241:                  * Basically a combination of memchr() and strpbrk(), so unlike strpbrk() it
242:                  * does not only stop at a '\0' character but also at the specified size.
243:                  * @param[in]       void        Pointer to data buffer.
244:                  * @param[in]       str         Null-terminated array of break characters.
245:                  * @param[in]       size        Data buffer size in bytes.
246:                  * @return                      Pointer to first break character or NULL if no
247:                  *                              break character is found.
248:                  */
249:                 void* RB_mempbrk(void* mem, char* str, uint32_t size)
250:                 {
251:                     char* mem_c = (char*)mem;
252:                     uint32_t i;
253:                     for (i = 0; (i < size) && (mem_c[i] != '\0'); i++) {
254:                         uint32_t j;
255:                         for (j = 0; str[j] != '\0'; j++) {
256:                             if (mem_c[i] == str[j]) {
257:                                 return (void*)&mem_c[i];
258:                             }
259:                         }
260:                     }
261:                     return NULL;
262:                 }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
00000020  00000000   NOP
00000028  00000000   NOP
0000002C  00000000   NOP
00000030  00000000   NOP
00000034  00000000   NOP
00000038  00000000   NOP
00000040  00000000   NOP
00000044  00000000   NOP
00000048  00000000   NOP
0000004C  00000000   NOP
00000058  00000000   NOP
0000005C  00000000   NOP
00000064  00000000   NOP
00000068  00000000   NOP
9D000000  27BDFFE0   ADDIU SP, SP, -32
9D000004  AFBF001C   SW RA, 28(SP)
9D000008  AFB10018   SW S1, 24(SP)
9D00000C  10C00041   BEQ A2, ZERO, 0x9D000114
9D000010  AFB00014   SW S0, 20(SP)
9D000014  8C8C000C   LW T4, 12(A0)
9D000018  8C8B0004   LW T3, 4(A0)
9D00001C  8C8A0008   LW T2, 8(A0)
9D000020  24CEFFFF   ADDIU T6, A2, -1
9D000024  016C4823   SUBU T1, T3, T4
9D000028  0149102B   SLTU V0, T2, T1
9D00002C  0142480B   MOVN T1, T2, V0
9D000030  01201025   OR V0, T1, ZERO
9D000034  012E482B   SLTU T1, T1, T6
9D000038  01C9100A   MOVZ V0, T6, T1
9D00003C  1040002A   BEQ V0, ZERO, 0x9D0000E8
9D000040  00404825   OR T1, V0, ZERO
9D000044  8C980000   LW T8, 0(A0)
9D000048  00007825   OR T7, ZERO, ZERO
9D00004C  030C6821   ADDU T5, T8, T4
9D000050  01A04025   OR T0, T5, ZERO
9D000054  81060000   LB A2, 0(T0)
9D000058  10C00013   BEQ A2, ZERO, 0x9D0000A8
9D00005C  01891021   ADDU V0, T4, T1
9D000060  80E20000   LB V0, 0(A3)
9D000064  5040000B   BEQL V0, ZERO, 0x9D000094
9D000068  25080001   ADDIU T0, T0, 1
9D00006C  10C20030   BEQ A2, V0, 0x9D000130
9D000070  24E20001   ADDIU V0, A3, 1
9D000074  10000004   BEQ ZERO, ZERO, 0x9D000088
9D000078  80430000   LB V1, 0(V0)
9D00007C  1066002D   BEQ V1, A2, 0x9D000134
9D000080  25100001   ADDIU S0, T0, 1
9D000084  80430000   LB V1, 0(V0)
9D000088  1460FFFC   BNE V1, ZERO, RB_mempbrk
9D00008C  24420001   ADDIU V0, V0, 1
9D000090  25080001   ADDIU T0, T0, 1
9D000094  010D1023   SUBU V0, T0, T5
9D000098  0049102B   SLTU V0, V0, T1
9D00009C  5440FFEE   BNEL V0, ZERO, 0x9D000058
9D0000A0  81060000   LB A2, 0(T0)
9D0000A4  01891021   ADDU V0, T4, T1
9D0000A8  004B182B   SLTU V1, V0, T3
9D0000AC  14600016   BNE V1, ZERO, 0x9D000108
9D0000B0  01495023   SUBU T2, T2, T1
9D0000B4  004B6023   SUBU T4, V0, T3
9D0000B8  01603025   OR A2, T3, ZERO
9D0000BC  01621023   SUBU V0, T3, V0
9D0000C0  00461021   ADDU V0, V0, A2
9D0000C4  014E182B   SLTU V1, T2, T6
9D0000C8  01403025   OR A2, T2, ZERO
9D0000CC  01C3300A   MOVZ A2, T6, V1
9D0000D0  00C01825   OR V1, A2, ZERO
9D0000D4  0046302B   SLTU A2, V0, A2
9D0000D8  0066100A   MOVZ V0, V1, A2
9D0000DC  01E97821   ADDU T7, T7, T1
9D0000E0  1440FFDA   BNE V0, ZERO, RB_mempbrk
9D0000E4  00404825   OR T1, V0, ZERO
9D0000E8  A0A00000   SB ZERO, 0(A1)
9D0000EC  8FBF001C   LW RA, 28(SP)
9D0000F0  00008025   OR S0, ZERO, ZERO
9D0000F4  02001025   OR V0, S0, ZERO
9D0000F8  8FB10018   LW S1, 24(SP)
9D0000FC  8FB00014   LW S0, 20(SP)
9D000100  03E00008   JR RA
9D000104  27BD0020   ADDIU SP, SP, 32
9D000108  00406025   OR T4, V0, ZERO
9D00010C  1000FFEB   BEQ ZERO, ZERO, 0x9D0000BC
9D000110  00003025   OR A2, ZERO, ZERO
9D000114  8FBF001C   LW RA, 28(SP)
9D000118  00008025   OR S0, ZERO, ZERO
9D00011C  02001025   OR V0, S0, ZERO
9D000120  8FB10018   LW S1, 24(SP)
9D000124  8FB00014   LW S0, 20(SP)
9D000128  03E00008   JR RA
9D00012C  27BD0020   ADDIU SP, SP, 32
9D000130  25100001   ADDIU S0, T0, 1
9D000134  020D8023   SUBU S0, S0, T5
9D000138  020F8021   ADDU S0, S0, T7
9D00013C  020B102B   SLTU V0, S0, T3
9D000140  020B5821   ADDU T3, S0, T3
9D000144  0162800A   MOVZ S0, T3, V0
9D000148  00A08825   OR S1, A1, ZERO
9D00014C  0F401DF7   JAL RB_Read
9D000150  02003025   OR A2, S0, ZERO
9D000154  02302821   ADDU A1, S1, S0
9D000158  A0A00000   SB ZERO, 0(A1)
9D00015C  8FBF001C   LW RA, 28(SP)
9D000160  02001025   OR V0, S0, ZERO
9D000164  8FB10018   LW S1, 24(SP)
9D000168  8FB00014   LW S0, 20(SP)
9D00016C  03E00008   JR RA
9D000170  27BD0020   ADDIU SP, SP, 32
9D0002E8  AC850000   SW A1, 0(A0)
9D0002EC  AC860004   SW A2, 4(A0)
9D0002F0  AC800008   SW ZERO, 8(A0)
9D0002F4  03E00008   JR RA
9D0002F8  AC80000C   SW ZERO, 12(A0)
9D000348  8C830004   LW V1, 4(A0)
9D00034C  8C820008   LW V0, 8(A0)
9D000350  03E00008   JR RA
9D000354  00621023   SUBU V0, V1, V0
9D000390  03E00008   JR RA
9D000394  8C820008   LW V0, 8(A0)
9D0064EC  8C830008   LW V1, 8(A0)
9D0064F0  8C87000C   LW A3, 12(A0)
9D0064F4  8C820004   LW V0, 4(A0)
9D0064F8  27BDFFE0   ADDIU SP, SP, -32
9D0064FC  00673821   ADDU A3, V1, A3
9D006500  00E2402B   SLTU T0, A3, V0
9D006504  AFBF001C   SW RA, 28(SP)
9D006508  AFB10018   SW S1, 24(SP)
9D00650C  AFB00014   SW S0, 20(SP)
9D006510  15000011   BNE T0, ZERO, 0x9D006558
9D006514  00431823   SUBU V1, V0, V1
9D006518  00404025   OR T0, V0, ZERO
9D00651C  00C3802B   SLTU S0, A2, V1
9D006520  00E24823   SUBU T1, A3, V0
9D006524  00471023   SUBU V0, V0, A3
9D006528  00481021   ADDU V0, V0, T0
9D00652C  00D0180B   MOVN V1, A2, S0
9D006530  0043802B   SLTU S0, V0, V1
9D006534  0070100A   MOVZ V0, V1, S0
9D006538  14400011   BNE V0, ZERO, 0x9D006580
9D00653C  00408025   OR S0, V0, ZERO
9D006540  8FBF001C   LW RA, 28(SP)
9D006544  02001025   OR V0, S0, ZERO
9D006548  8FB10018   LW S1, 24(SP)
9D00654C  8FB00014   LW S0, 20(SP)
9D006550  03E00008   JR RA
9D006554  27BD0020   ADDIU SP, SP, 32
9D006558  00C3802B   SLTU S0, A2, V1
9D00655C  00004025   OR T0, ZERO, ZERO
9D006560  00471023   SUBU V0, V0, A3
9D006564  00481021   ADDU V0, V0, T0
9D006568  00D0180B   MOVN V1, A2, S0
9D00656C  0043802B   SLTU S0, V0, V1
9D006570  0070100A   MOVZ V0, V1, S0
9D006574  00E04825   OR T1, A3, ZERO
9D006578  1040FFF1   BEQ V0, ZERO, 0x9D006540
9D00657C  00408025   OR S0, V0, ZERO
9D006580  00808825   OR S1, A0, ZERO
9D006584  8C840000   LW A0, 0(A0)
9D006588  00403025   OR A2, V0, ZERO
9D00658C  0F401198   JAL memcpy
9D006590  00892021   ADDU A0, A0, T1
9D006594  8E220008   LW V0, 8(S1)
9D006598  8FBF001C   LW RA, 28(SP)
9D00659C  00501021   ADDU V0, V0, S0
9D0065A0  AE220008   SW V0, 8(S1)
9D0065A4  02001025   OR V0, S0, ZERO
9D0065A8  8FB10018   LW S1, 24(SP)
9D0065AC  8FB00014   LW S0, 20(SP)
9D0065B0  03E00008   JR RA
9D0065B4  27BD0020   ADDIU SP, SP, 32
9D006CA8  8C830008   LW V1, 8(A0)
9D006CAC  8C87000C   LW A3, 12(A0)
9D006CB0  8C820004   LW V0, 4(A0)
9D006CB4  27BDFFE0   ADDIU SP, SP, -32
9D006CB8  AFB10018   SW S1, 24(SP)
9D006CBC  00C3882B   SLTU S1, A2, V1
9D006CC0  00471023   SUBU V0, V0, A3
9D006CC4  0071300A   MOVZ A2, V1, S1
9D006CC8  0046882B   SLTU S1, V0, A2
9D006CCC  00D1100A   MOVZ V0, A2, S1
9D006CD0  AFBF001C   SW RA, 28(SP)
9D006CD4  AFB00014   SW S0, 20(SP)
9D006CD8  14400007   BNE V0, ZERO, 0x9D006CF8
9D006CDC  00408825   OR S1, V0, ZERO
9D006CE0  8FBF001C   LW RA, 28(SP)
9D006CE4  02201025   OR V0, S1, ZERO
9D006CE8  8FB00014   LW S0, 20(SP)
9D006CEC  8FB10018   LW S1, 24(SP)
9D006CF0  03E00008   JR RA
9D006CF4  27BD0020   ADDIU SP, SP, 32
9D006CF8  8C820000   LW V0, 0(A0)
9D006CFC  00808025   OR S0, A0, ZERO
9D006D00  02203025   OR A2, S1, ZERO
9D006D04  00A02025   OR A0, A1, ZERO
9D006D08  0F401198   JAL memcpy
9D006D0C  00472821   ADDU A1, V0, A3
9D006D10  8E02000C   LW V0, 12(S0)
9D006D14  8E030004   LW V1, 4(S0)
9D006D18  8E040008   LW A0, 8(S0)
9D006D1C  02221021   ADDU V0, S1, V0
9D006D20  8FBF001C   LW RA, 28(SP)
9D006D24  0043282B   SLTU A1, V0, V1
9D006D28  00431823   SUBU V1, V0, V1
9D006D2C  00912023   SUBU A0, A0, S1
9D006D30  0065100A   MOVZ V0, V1, A1
9D006D34  AE02000C   SW V0, 12(S0)
9D006D38  AE040008   SW A0, 8(S0)
9D006D3C  02201025   OR V0, S1, ZERO
9D006D40  8FB00014   LW S0, 20(SP)
9D006D44  8FB10018   LW S1, 24(SP)
9D006D48  03E00008   JR RA
9D006D4C  27BD0020   ADDIU SP, SP, 32
9D007588  27BDFFE0   ADDIU SP, SP, -32
9D00758C  AFB00014   SW S0, 20(SP)
9D007590  00808025   OR S0, A0, ZERO
9D007594  00A02025   OR A0, A1, ZERO
9D007598  AFB10018   SW S1, 24(SP)
9D00759C  AFBF001C   SW RA, 28(SP)
9D0075A0  0F4011F2   JAL strlen
9D0075A4  00A08825   OR S1, A1, ZERO
9D0075A8  8E030004   LW V1, 4(S0)
9D0075B4  0062182B   SLTU V1, V1, V0
9D0075B8  10600006   BEQ V1, ZERO, 0x9D0075D4
9D0075BC  8FBF001C   LW RA, 28(SP)
9D0075C0  00001025   OR V0, ZERO, ZERO
9D0075C4  8FB10018   LW S1, 24(SP)
9D0075C8  8FB00014   LW S0, 20(SP)
9D0075CC  03E00008   JR RA
9D0075D0  27BD0020   ADDIU SP, SP, 32
9D0075D4  02202825   OR A1, S1, ZERO
9D0075D8  02002025   OR A0, S0, ZERO
9D0075DC  8FB10018   LW S1, 24(SP)
9D0075E0  8FB00014   LW S0, 20(SP)
9D0075E4  00403025   OR A2, V0, ZERO
9D0075E8  0B401DE0   J RB_Write
9D0075EC  27BD0020   ADDIU SP, SP, 32
9D0075F0  27BDFFF8   ADDIU SP, SP, -8
9D007780  27BDFFD8   ADDIU SP, SP, -40
9D007784  AFBF0024   SW RA, 36(SP)
9D007788  AFB30020   SW S3, 32(SP)
9D00778C  AFB2001C   SW S2, 28(SP)
9D007790  AFB10018   SW S1, 24(SP)
9D007794  AFB00014   SW S0, 20(SP)
9D007798  00808825   OR S1, A0, ZERO
9D00779C  00A09025   OR S2, A1, ZERO
9D0077A0  0F40193B   JAL RB_WriteContiguous
9D0077A4  00C09825   OR S3, A2, ZERO
9D0077A8  02623023   SUBU A2, S3, V0
9D0077AC  02422821   ADDU A1, S2, V0
9D0077B0  02202025   OR A0, S1, ZERO
9D0077B4  0F40193B   JAL RB_WriteContiguous
9D0077B8  00408025   OR S0, V0, ZERO
9D0077BC  8FBF0024   LW RA, 36(SP)
9D0077C0  02021021   ADDU V0, S0, V0
9D0077C4  8FB30020   LW S3, 32(SP)
9D0077C8  8FB2001C   LW S2, 28(SP)
9D0077CC  8FB10018   LW S1, 24(SP)
9D0077D0  8FB00014   LW S0, 20(SP)
9D0077D4  03E00008   JR RA
9D0077D8  27BD0028   ADDIU SP, SP, 40
9D0077DC  27BDFFD8   ADDIU SP, SP, -40
9D0077E0  AFBF0024   SW RA, 36(SP)
9D0077E4  AFB30020   SW S3, 32(SP)
9D0077E8  AFB2001C   SW S2, 28(SP)
9D0077EC  AFB10018   SW S1, 24(SP)
9D0077F0  AFB00014   SW S0, 20(SP)
9D0077F4  00808825   OR S1, A0, ZERO
9D0077F8  00A09025   OR S2, A1, ZERO
9D0077FC  0F401B2A   JAL RB_ReadContiguous
9D007800  00C09825   OR S3, A2, ZERO
9D007804  02623023   SUBU A2, S3, V0
9D007808  02422821   ADDU A1, S2, V0
9D00780C  02202025   OR A0, S1, ZERO
9D007810  0F401B2A   JAL RB_ReadContiguous
9D007814  00408025   OR S0, V0, ZERO
9D007818  8FBF0024   LW RA, 36(SP)
9D00781C  02021021   ADDU V0, S0, V0
9D007820  8FB30020   LW S3, 32(SP)
9D007824  8FB2001C   LW S2, 28(SP)
9D007828  8FB10018   LW S1, 24(SP)
9D00782C  8FB00014   LW S0, 20(SP)
9D007830  03E00008   JR RA
9D007834  27BD0028   ADDIU SP, SP, 40
---  c:/users/db/desktop/nano_tx/firmware/src/user_hal/btl_debug.c  -------------------------------------
1:                   #include "debug.h"
2:                   #include "ringbuffer.h"
3:                   #include "configuration.h"
4:                   #include "definitions.h"
5:                   #include <string.h>
6:                   #include <stdarg.h>
7:                   #include <stdbool.h>
8:                   //#include <stdio.h>
9:                   #include "user_hal/printf.h"
10:                  
11:                  RINGBUFFER* debugRb = NULL;
12:                  ERROR_T gwsError = NO_ERROR;
13:                  
14:                  bool Debug_IsEnabled(void)
15:                  {
16:                      return (debugRb == NULL)? false: true;
17:                  }
18:                  
19:                  void Debug_Disable(void)
20:                  {
21:                      debugRb = NULL;
22:                  }
23:                  
24:                  void Debug_Enable(RINGBUFFER* rb)
25:                  {
26:                      debugRb = rb;
27:                  }
28:                  
29:                  RINGBUFFER* Debug_GetRb(void)
30:                  {
31:                      return debugRb;
32:                  }
33:                  
34:                  /**
35:                   * Prints a NULL-terminated C string into the active debug stream.
36:                   * @param[in]       format      Like printf().
37:                   * @param[in]       ...         Like printf().
38:                   * @return                      Number of bytes written to the ring buffer.
39:                   *                              Usually the same as the string length.
40:                   *                              0 is returned if the buffer is full. Less than
41:                   *                              size if the buffer became full before writing
42:                   *                              all bytes.
43:                   */
44:                  uint32_t dprintf(const char* format, ...)
45:                  {
46:                      if (debugRb == NULL) {
47:                          return 0;
48:                      }
49:                      
50:                      while (RB_GetUsed(debugRb) > 0) {
51:                          USB_DEVICE_Tasks(sysObj.usbDevObject0);
52:                          APP_USB_Tasks();
53:                      }
54:                      
55:                      char str[128];
56:                      va_list vlist;
57:                      va_start(vlist, format);
58:                      vsnprintf_(str, sizeof(str), format, vlist);
59:                      va_end(vlist);
60:                      return RB_WriteString(debugRb, str);
61:                  }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
9D000398  03E00008   JR RA
9D00039C  AF808018   SW ZERO, -32744(GP)
9D0003A8  03E00008   JR RA
9D0003AC  AF848018   SW A0, -32744(GP)
9D006E9C  8F828018   LW V0, -32744(GP)
9D006EA0  27BDFF60   ADDIU SP, SP, -160
9D006EA4  AFB00098   SW S0, 152(SP)
9D006EA8  AFBF009C   SW RA, 156(SP)
9D006EAC  AFA500A4   SW A1, 164(SP)
9D006EB0  AFA600A8   SW A2, 168(SP)
9D006EB4  AFA700AC   SW A3, 172(SP)
9D006EB8  14400008   BNE V0, ZERO, 0x9D006EDC
9D006EBC  00808025   OR S0, A0, ZERO
9D006EC0  10000017   BEQ ZERO, ZERO, 0x9D006F20
9D006EC4  8FBF009C   LW RA, 156(SP)
9D006EC8  0F40124C   JAL USB_DEVICE_Tasks
9D006ECC  8F848038   LW A0, -32712(GP)
9D006ED0  0F400B6A   JAL APP_USB_Tasks
9D006ED4  00000000   NOP
9D006ED8  8F828018   LW V0, -32744(GP)
9D006EDC  0F4000E4   JAL RB_GetUsed
9D006EE0  00402025   OR A0, V0, ZERO
9D006EE4  1440FFF8   BNE V0, ZERO, 0x9D006EC8
9D006EE8  27A200A4   ADDIU V0, SP, 164
9D006EEC  27A40010   ADDIU A0, SP, 16
9D006EF0  02003025   OR A2, S0, ZERO
9D006EF4  00403825   OR A3, V0, ZERO
9D006EF8  24050080   ADDIU A1, ZERO, 128
9D006EFC  0F40202B   JAL vsnprintf_
9D006F00  AFA20090   SW V0, 144(SP)
9D006F04  8F848018   LW A0, -32744(GP)
9D006F08  0F401D62   JAL RB_WriteString
9D006F0C  27A50010   ADDIU A1, SP, 16
9D006F10  8FBF009C   LW RA, 156(SP)
9D006F14  8FB00098   LW S0, 152(SP)
9D006F18  03E00008   JR RA
9D006F1C  27BD00A0   ADDIU SP, SP, 160
9D006F20  00001025   OR V0, ZERO, ZERO
9D006F24  8FB00098   LW S0, 152(SP)
9D006F28  03E00008   JR RA
9D006F2C  27BD00A0   ADDIU SP, SP, 160
---  c:/users/db/desktop/nano_tx/firmware/src/user_hal/bm7x.c  ------------------------------------------
1:                   /**
2:                    * @file bm7x.c
3:                    * @brief BM70/71 bluetooth low energy module interface
4:                    * @author David Bender <d_bender@bluewin.ch>
5:                    * @date 30.01.2023
6:                    */
7:                   
8:                   #include "bm7x.h"
9:                   #include "definitions.h"                // GPIO, UART
10:                  
11:                  void BM7X_Initialize(void)
12:                  {
13:                      // Wait for BM7X minimum reset pulse width
14:                      CORETIMER_DelayMs(1);
15:                      GPIO_RC2_BM70_HCI_RST_N_Set();
16:                  }
17:                  
18:                  uint32_t BM7X_Read(void* buffer, uint32_t size)
19:                  {
20:                      return UART1_Read(buffer, size);
21:                  }
22:                  
23:                  uint32_t BM7X_Write(void* buffer, uint32_t size)
24:                  {
25:                      return UART1_Write(buffer, size);
26:                  }
27:                  
28:                  uint32_t BM7X_GetWriteBufferFree(void)
29:                  {
30:                      return UART1_WriteFreeBufferCountGet();
31:                  }
32:                  
33:                  ERROR_T BM7X_GetError(void)
34:                  {
35:                      UART_ERROR eUart = UART1_ErrorGet();
36:                      ERROR_T eGws = 0;
37:                      eGws |= (eUart == UART_ERROR_OVERRUN)? BM7X_UART_RX_OVERRUN: 0;
38:                      eGws |= (eUart == UART_ERROR_FRAMING)? BM7X_UART_RX_FRAMING: 0;
39:                      eGws |= (eUart == UART_ERROR_PARITY)? BM7X_UART_RX_PARITY: 0;
40:                      return eGws;
41:                  }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0003B0  0B4018D5   J UART1_Read
9D0003B4  00000000   NOP
9D0003B8  0B401700   J UART1_Write
9D0003BC  00000000   NOP
9D0003C0  0B401EEB   J _DefaultInterrupt
9D0003C8  0B402013   J UART1_WriteFreeBufferCountGet
9D0003CC  00000000   NOP
9D0076B8  27BDFFE8   ADDIU SP, SP, -24
9D0076BC  AFBF0014   SW RA, 20(SP)
9D0076C0  0F40008A   JAL UART1_ErrorGet
9D0076C4  00000000   NOP
9D0076C8  24030002   ADDIU V1, ZERO, 2
9D0076CC  1043000E   BEQ V0, V1, 0x9D007708
9D0076D0  24040004   ADDIU A0, ZERO, 4
9D0076D4  14440005   BNE V0, A0, 0x9D0076EC
9D0076D8  24030020   ADDIU V1, ZERO, 32
9D0076DC  8FBF0014   LW RA, 20(SP)
9D0076E0  00601025   OR V0, V1, ZERO
9D0076E4  03E00008   JR RA
9D0076E8  27BD0018   ADDIU SP, SP, 24
9D0076EC  38420008   XORI V0, V0, 8
9D0076F0  8FBF0014   LW RA, 20(SP)
9D0076F4  2C420001   SLTIU V0, V0, 1
9D0076F8  00021980   SLL V1, V0, 6
9D0076FC  00601025   OR V0, V1, ZERO
9D007700  03E00008   JR RA
9D007704  27BD0018   ADDIU SP, SP, 24
9D007708  8FBF0014   LW RA, 20(SP)
9D00770C  24030010   ADDIU V1, ZERO, 16
9D007710  00601025   OR V0, V1, ZERO
9D007714  03E00008   JR RA
9D007718  27BD0018   ADDIU SP, SP, 24
9D0082F8  27BDFFE8   ADDIU SP, SP, -24
9D0082FC  AFBF0014   SW RA, 20(SP)
9D008300  0F401EFD   JAL CORETIMER_DelayMs
9D008304  24040001   ADDIU A0, ZERO, 1
9D008308  8FBF0014   LW RA, 20(SP)
9D00830C  3C02BF88   LUI V0, -16504
9D008310  24030004   ADDIU V1, ZERO, 4
9D008314  AC436238   SW V1, 25144(V0)
9D008318  03E00008   JR RA
9D00831C  27BD0018   ADDIU SP, SP, 24
---  c:/users/db/desktop/nano_tx/firmware/src/main.c  ---------------------------------------------------
1:                   /*******************************************************************************
2:                     Main Source File
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       main.c
9:                   
10:                    Summary:
11:                      This file contains the "main" function for a project.
12:                  
13:                    Description:
14:                      This file contains the "main" function for a project.  The
15:                      "main" function calls the "SYS_Initialize" function to initialize the state
16:                      machines of all modules in the system
17:                   *******************************************************************************/
18:                  
19:                  // *****************************************************************************
20:                  // *****************************************************************************
21:                  // Section: Included Files
22:                  // *****************************************************************************
23:                  // *****************************************************************************
24:                  
25:                  #include <stddef.h>                     // Defines NULL
26:                  #include <stdbool.h>                    // Defines true
27:                  #include <stdlib.h>                     // Defines EXIT_FAILURE
28:                  #include "definitions.h"                // SYS function prototypes
29:                  
30:                  
31:                  // *****************************************************************************
32:                  // *****************************************************************************
33:                  // Section: Main Entry Point
34:                  // *****************************************************************************
35:                  // *****************************************************************************
36:                  
37:                  int main ( void )
38:                  {
39:                      /* Initialize all modules */
40:                      SYS_Initialize ( NULL );
41:                  
42:                      while ( true )
43:                      {
44:                          /* Maintain state machines of all polled MPLAB Harmony modules. */
45:                          SYS_Tasks ( );
46:                      }
47:                  
48:                      /* Execution should not come here during normal operation */
49:                  
50:                      return ( EXIT_FAILURE );
51:                  }
52:                  
53:                  
54:                  /*******************************************************************************
55:                   End of File
56:                  */
57:                  
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D008348  27BDFFE8   ADDIU SP, SP, -24
9D00834C  AFBF0014   SW RA, 20(SP)
9D008350  0F401782   JAL SYS_Initialize
9D008354  00002025   OR A0, ZERO, ZERO
9D008358  0F40201F   JAL SYS_Tasks
9D00835C  00000000   NOP
9D008360  0F40201F   JAL SYS_Tasks
9D008364  00000000   NOP
9D008368  1000FFFB   BEQ ZERO, ZERO, main
9D00836C  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/usb/src/usb_device_cdc_acm.c  --------------
1:                   /*******************************************************************************
2:                    USB CDC ACM SubClass
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       usb_device_cdc_acm.c
9:                   
10:                    Summary:
11:                      USB CDC ACM SubClass
12:                  
13:                    Description:
14:                      USB CDC ACM SubClass
15:                   *******************************************************************************/
16:                  
17:                  // DOM-IGNORE-BEGIN
18:                  /*******************************************************************************
19:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
20:                  *
21:                  * Subject to your compliance with these terms, you may use Microchip software
22:                  * and any derivatives exclusively with Microchip products. It is your
23:                  * responsibility to comply with third party license terms applicable to your
24:                  * use of third party software (including open source software) that may
25:                  * accompany Microchip software.
26:                  *
27:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                  * PARTICULAR PURPOSE.
31:                  *
32:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
33:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
34:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
35:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
36:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
37:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
38:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
39:                   *******************************************************************************/
40:                  // DOM-IGNORE-END
41:                  
42:                  // *****************************************************************************
43:                  // *****************************************************************************
44:                  // Section: Included Files
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  /*  This section lists the other files that are included in this file.
48:                   */
49:                  #include <stdio.h>
50:                  #include <stdint.h>
51:                  #include "usb/usb_cdc.h"
52:                  #include "usb/usb_device_cdc.h"
53:                  #include "usb/src/usb_device_cdc_local.h"
54:                  
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  // Section: File Scope or Global Constants
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  
61:                  
62:                  // *****************************************************************************
63:                  // *****************************************************************************
64:                  // Section: File Scope or Global Data Types
65:                  // *****************************************************************************
66:                  // *****************************************************************************
67:                  
68:                  // *****************************************************************************
69:                  // *****************************************************************************
70:                  // Section: File Scope Functions
71:                  // *****************************************************************************
72:                  // *****************************************************************************
73:                  
74:                  //******************************************************************************
75:                  /* Function:
76:                      void _USB_DEVICE_CDC_ACMSetUpPacketHandler ( USB_DEVICE_CDC_INSTANCE *instance,
77:                                                                      uint16_t value )
78:                  
79:                    Summary:
80:                      Handles ACM sub class specific requests.
81:                  
82:                    Description:
83:                      This function handles ACM sub class specific requests.
84:                  
85:                    Remarks:
86:                      Called by the CDC function driver.
87:                   */
88:                  
89:                  void _USB_DEVICE_CDC_ACMSetUpPacketHandler 
90:                  (
91:                      SYS_MODULE_INDEX iCDC ,
92:                      USB_DEVICE_CDC_INSTANCE * thisCDCDevice,
93:                      USB_SETUP_PACKET * setupRequest
94:                  )
95:                  {
96:                      
97:                      /* Check the request */
98:                      switch (setupRequest->bRequest )
99:                      {
100:                         case USB_CDC_REQUEST_SET_LINE_CODING:
101:                 
102:                             /* Send this event to application. The application
103:                              * should issues a control receive request to receive
104:                              * the data from the host. */
105:                 
106:                             if(thisCDCDevice->appEventCallBack != NULL)
107:                             {
108:                                 thisCDCDevice->appEventCallBack(iCDC, 
109:                                         USB_DEVICE_CDC_EVENT_SET_LINE_CODING, 
110:                                         NULL, thisCDCDevice->userData);
111:                             }
112:                 
113:                             break;
114:                 
115:                         case USB_CDC_REQUEST_GET_LINE_CODING:
116:                 
117:                             /* Send this event to application. The application should
118:                              * issue a control send request to send this request to 
119:                              * the host. */
120:                 
121:                             if(thisCDCDevice->appEventCallBack != NULL)
122:                             {
123:                                 thisCDCDevice->appEventCallBack(iCDC, 
124:                                         USB_DEVICE_CDC_EVENT_GET_LINE_CODING, 
125:                                         NULL, thisCDCDevice->userData);
126:                             }
127:                 
128:                             break;
129:                 
130:                         case USB_CDC_REQUEST_SET_CONTROL_LINE_STATE:
131:                 
132:                             /* In this event, the data is available in the
133:                              * setup packet. Send it to the application */
134:                 
135:                             if(thisCDCDevice->appEventCallBack != NULL)
136:                             {
137:                                 thisCDCDevice->appEventCallBack(iCDC,
138:                                         USB_DEVICE_CDC_EVENT_SET_CONTROL_LINE_STATE,
139:                                         (USB_CDC_CONTROL_LINE_STATE *)(&setupRequest->wValue),
140:                                         thisCDCDevice->userData);
141:                             }
142:                 
143:                             break;
144:                 
145:                             /* AT commands */
146:                         case USB_CDC_REQUEST_SEND_ENCAPSULATED_COMMAND:
147:                         case USB_CDC_REQUEST_GET_ENCAPSULATED_RESPONSE:
148:                 
149:                             /* AT commands are not supported */
150:                             USB_DEVICE_ControlStatus(thisCDCDevice->deviceHandle, 
151:                                     USB_DEVICE_CONTROL_STATUS_ERROR);
152:                             break;
153:                 
154:                             /* break request */
155:                         case USB_CDC_REQUEST_SEND_BREAK:
156:                 
157:                             /* In this event, the data is available in the
158:                              * setup packet. Send it to the application */
159:                 
160:                             if(thisCDCDevice->appEventCallBack != NULL)
161:                             {
162:                                 thisCDCDevice->appEventCallBack(iCDC,
163:                                         USB_DEVICE_CDC_EVENT_SEND_BREAK,
164:                                         (uint16_t *)(&setupRequest->wValue), thisCDCDevice->userData);
165:                             }
166:                 
167:                             break;
168:                 
169:                             /* requests that do not belog to ACM sub class */
170:                         case USB_CDC_REQUEST_SET_COMM_FEATURE:
171:                         case USB_CDC_REQUEST_GET_COMM_FEATURE:
172:                         case USB_CDC_REQUEST_CLEAR_COMM_FEATURE:
173:                         case USB_CDC_REQUEST_SET_AUX_LINE_STATE:
174:                         case USB_CDC_REQUEST_SET_HOOK_STATE:
175:                         case USB_CDC_REQUEST_PULSE_SETUP:
176:                         case USB_CDC_REQUEST_SEND_PULSE:
177:                         case USB_CDC_REQUEST_SET_PULSE_TIME:
178:                         case USB_CDC_REQUEST_RING_AUX_JACK:
179:                         case USB_CDC_REQUEST_SET_RINGER_PARMS:
180:                         case USB_CDC_REQUEST_GET_RINGER_PARMS:
181:                         case USB_CDC_REQUEST_SET_OPERATIONAL_PARMS:
182:                         case USB_CDC_REQUEST_GET_OPERATIONAL_PARMS:
183:                         case USB_CDC_REQUEST_SET_LINE_PARMS:
184:                         case USB_CDC_REQUEST_GET_LINE_PARMS:
185:                         case USB_CDC_REQUEST_DIAL_DIGITS:
186:                         case USB_CDC_REQUEST_SET_UNIT_PARAMETER:
187:                         case USB_CDC_REQUEST_GET_UNIT_PARAMETER:
188:                         case USB_CDC_REQUEST_CLEAR_UNIT_PARAMETER:
189:                         case USB_CDC_REQUEST_GET_PROFILE:
190:                         case USB_CDC_REQUEST_SET_ETHERNET_MULTICAST_FILTERS:
191:                         case USB_CDC_REQUEST_SET_ETHERNET_POWER_MANAGEMENT_FILTER:
192:                         case USB_CDC_REQUEST_GET_ETHERNET_POWER_MANAGEMENT_FILTER:
193:                         case USB_CDC_REQUEST_SET_ETHERNET_PACKET_FILTER:
194:                         case USB_CDC_REQUEST_GET_ETHERNET_STATISTIC:
195:                         case USB_CDC_REQUEST_SET_ATM_DATA_FORMAT:
196:                         case USB_CDC_REQUEST_GET_ATM_DEVICE_STATISTICS:
197:                         case USB_CDC_REQUEST_SET_ATM_DEFAULT_VC:
198:                         case USB_CDC_REQUEST_GET_ATM_VC_STATISTICS:
199:                         default:
200:                 
201:                             /* These request are not supported */
202:                 
203:                             USB_DEVICE_ControlStatus(thisCDCDevice->deviceHandle,
204:                                        USB_DEVICE_CONTROL_STATUS_ERROR);
205:                 
206:                             break;
207:                     }
208:                 }
209:                 
210:                 
211:                 
212:                 /*******************************************************************************
213:                  End of File
214:                  */
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D006DF8  90C20001   LBU V0, 1(A2)
9D006DFC  2442FFE0   ADDIU V0, V0, -32
9D006E00  304200FF   ANDI V0, V0, 255
9D006E04  2C430004   SLTIU V1, V0, 4
9D006E08  1060000B   BEQ V1, ZERO, __jend__USB_DEVICE_CDC_ACMSetUpPacketHandler_4
9D006E0C  3C039D00   LUI V1, -25344
9D006E10  00021080   SLL V0, V0, 2
9D006E14  24636E28   ADDIU V1, V1, 28200
9D006E18  00621021   ADDU V0, V1, V0
9D006E1C  8C420000   LW V0, 0(V0)
9D006E20  00400008   JR V0
9D006E24  8CB90020   LW T9, 32(A1)
9D006E38  8CA40000   LW A0, 0(A1)
9D006E3C  0B401C56   J USB_DEVICE_ControlStatus
9D006E40  24050001   ADDIU A1, ZERO, 1
9D006E44  13200013   BEQ T9, ZERO, 0x9D006E94
9D006E48  00003025   OR A2, ZERO, ZERO
9D006E4C  8CA70024   LW A3, 36(A1)
9D006E50  03200008   JR T9
9D006E54  24050001   ADDIU A1, ZERO, 1
9D006E58  1320000E   BEQ T9, ZERO, 0x9D006E94
9D006E5C  24C60002   ADDIU A2, A2, 2
9D006E60  8CA70024   LW A3, 36(A1)
9D006E64  03200008   JR T9
9D006E68  24050003   ADDIU A1, ZERO, 3
9D006E6C  13200009   BEQ T9, ZERO, 0x9D006E94
9D006E70  24C60002   ADDIU A2, A2, 2
9D006E74  8CA70024   LW A3, 36(A1)
9D006E78  03200008   JR T9
9D006E7C  24050002   ADDIU A1, ZERO, 2
9D006E80  13200004   BEQ T9, ZERO, 0x9D006E94
9D006E84  00003025   OR A2, ZERO, ZERO
9D006E88  8CA70024   LW A3, 36(A1)
9D006E8C  03200008   JR T9
9D006E90  00002825   OR A1, ZERO, ZERO
9D006E94  03E00008   JR RA
9D006E98  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/usb/src/usb_device_cdc.c  ------------------
1:                   /*******************************************************************************
2:                    USB CDC Class Function Driver
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       usb_device_cdc.c
9:                   
10:                    Summary:
11:                      USB CDC class function driver.
12:                  
13:                    Description:
14:                      USB CDC class function driver.
15:                   *******************************************************************************/
16:                  
17:                  // DOM-IGNORE-BEGIN
18:                  /*******************************************************************************
19:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
20:                  *
21:                  * Subject to your compliance with these terms, you may use Microchip software
22:                  * and any derivatives exclusively with Microchip products. It is your
23:                  * responsibility to comply with third party license terms applicable to your
24:                  * use of third party software (including open source software) that may
25:                  * accompany Microchip software.
26:                  *
27:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                  * PARTICULAR PURPOSE.
31:                  *
32:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
33:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
34:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
35:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
36:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
37:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
38:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
39:                   *******************************************************************************/
40:                  // DOM-IGNORE-END
41:                  
42:                  // *****************************************************************************
43:                  // *****************************************************************************
44:                  // Section: Included Files
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  #include "usb/usb_device_cdc.h"
48:                  #include "usb/src/usb_device_cdc_local.h"
49:                  #include "usb/src/usb_external_dependencies.h"
50:                  
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: File Scope or Global Data Types
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  // *****************************************************************************
59:                  /* CDC Device function driver structure
60:                  
61:                    Summary:
62:                      Defines the function driver structure required for the device layer.
63:                  
64:                    Description:
65:                      This data type defines the function driver structure required for the
66:                      device layer.
67:                  
68:                    Remarks:
69:                      This structure is private to the USB stack.
70:                  */
71:                  
72:                  const USB_DEVICE_FUNCTION_DRIVER cdcFunctionDriver =
73:                  {
74:                  
75:                      /* CDC init function */
76:                      .initializeByDescriptor         = _USB_DEVICE_CDC_Initialization ,
77:                  
78:                      /* CDC de-init function */
79:                      .deInitialize                   = _USB_DEVICE_CDC_Deinitialization ,
80:                  
81:                      /* EP0 activity callback */
82:                      .controlTransferNotification    = _USB_DEVICE_CDC_ControlTransferHandler,
83:                  
84:                      /* CDC tasks function */
85:                      .tasks                          = NULL,
86:                  
87:                      /* CDC Global Initialize */
88:                      .globalInitialize = _USB_DEVICE_CDC_GlobalInitialize
89:                  };
90:                  
91:                  // *****************************************************************************
92:                  /* CDC Device IRPs
93:                  
94:                    Summary:
95:                      Array of CDC Device IRP. 
96:                  
97:                    Description:
98:                      Array of CDC Device IRP. This array of IRP will be shared by read, write and
99:                      notification data requests.
100:                 
101:                   Remarks:
102:                     This array is private to the USB stack.
103:                 */
104:                 
105:                 USB_DEVICE_IRP gUSBDeviceCDCIRP[USB_DEVICE_CDC_QUEUE_DEPTH_COMBINED];
106:                 
107:                 
108:                 /* Create a variable for holding CDC IRP mutex Handle and status */
109:                 USB_DEVICE_CDC_COMMON_DATA_OBJ gUSBDeviceCdcCommonDataObj;
110:                  
111:                 
112:                 // *****************************************************************************
113:                 /* CDC Instance structure
114:                 
115:                   Summary:
116:                     Defines the CDC instance(s).
117:                 
118:                   Description:
119:                     This data type defines the CDC instance(s). The number of instances is
120:                     defined by the application using USB_DEVICE_CDC_INSTANCES_NUMBER.
121:                 
122:                   Remarks:
123:                     This structure is private to the CDC.
124:                 */
125:                 
126:                 USB_DEVICE_CDC_INSTANCE gUSBDeviceCDCInstance[USB_DEVICE_CDC_INSTANCES_NUMBER];
127:                 
128:                 // *****************************************************************************
129:                 /* CDC Instance Serial State Response structure
130:                 
131:                   Summary:
132:                     Defines the Serial State Response structures.
133:                 
134:                   Description:
135:                     This data type defines the CDC Serial State Response structures. 
136:                 	The number of buffers is defined by the application using the 
137:                 	USB_DEVICE_CDC_INSTANCES_NUMBER.
138:                 
139:                   Remarks:
140:                     This structure is private to the CDC.
141:                 */
142:                 USB_CDC_SERIAL_STATE_RESPONSE gUSBDeviceCDCSerialStateResponse[USB_DEVICE_CDC_INSTANCES_NUMBER] USB_ALIGN;
143:                 
144:                 // *****************************************************************************
145:                 // *****************************************************************************
146:                 // Section: File Scope Functions
147:                 // *****************************************************************************
148:                 // *****************************************************************************
149:                 // ******************************************************************************
150:                 /* Function:
151:                     void _USB_DEVICE_CDC_GlobalInitialize ( void )
152:                 
153:                   Summary:
154:                     This function initializes resourses required common to all instances of CDC
155:                     function driver.
156:                 
157:                   Description:
158:                     This function initializes resourses common to all instances of CDC function
159:                     driver. This function is called by the USB Device layer during Initalization.
160:                 
161:                   Remarks:
162:                     This is local function and should not be called directly by the application.
163:                 */
164:                 void _USB_DEVICE_CDC_GlobalInitialize (void)
165:                 {
166:                     OSAL_RESULT osal_err;
167:                     
168:                     /* Create Mutex for CDC IRP objects if not created already */
169:                     if (gUSBDeviceCdcCommonDataObj.isMutexCdcIrpInitialized == false)
170:                     {
171:                         /* This means that mutexes where not created. Create them. */
172:                         osal_err = OSAL_MUTEX_Create(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP);
173:                 
174:                         if(osal_err != OSAL_RESULT_TRUE)
175:                         {
176:                             /*do not proceed lock was not created, let user know about error*/
177:                             return;
178:                         }
179:                 
180:                          /* Set this flag so that global mutexes get allocated only once */
181:                          gUSBDeviceCdcCommonDataObj.isMutexCdcIrpInitialized = true;
182:                     }
183:                 }
184:                 // ******************************************************************************
185:                 /* Function:
186:                     void _USB_DEVICE_CDC_Initialization 
187:                     ( 
188:                         SYS_MODULE_INDEX iCDC ,
189:                         DRV_HANDLE deviceHandle ,
190:                         void* initData ,
191:                         uint8_t infNum ,
192:                         uint8_t altSetting ,
193:                         uint8_t descType ,
194:                         uint8_t * pDesc 
195:                     )
196:                 
197:                   Summary:
198:                     USB Device CDC function called by the device layer during Set Configuration
199:                     processing.
200:                   
201:                   Description:
202:                     USB Device CDC function called by the device layer during Set Configuration
203:                     processing.
204:                 
205:                   Remarks:
206:                     This is local function and should not be called directly by the application.
207:                 */
208:                 
209:                 void _USB_DEVICE_CDC_Initialization 
210:                 ( 
211:                     SYS_MODULE_INDEX iCDC ,
212:                     USB_DEVICE_HANDLE deviceHandle ,
213:                     void* initData ,
214:                     uint8_t infNum ,
215:                     uint8_t altSetting ,
216:                     uint8_t descType ,
217:                     uint8_t * pDesc 
218:                 )
219:                 {
220:                     /* Avoid unused warning */
221:                     ( void ) ( altSetting );
222:                     ( void ) ( initData );
223:                     uint8_t epAddress;
224:                     uint8_t epDir;
225:                     uint16_t maxPacketSize;
226:                     USB_DEVICE_CDC_INSTANCE * thisCDCInstance;
227:                     USB_DEVICE_CDC_INIT * cdcInit;
228:                     USB_ENDPOINT_DESCRIPTOR *pEPDesc;
229:                     USB_INTERFACE_DESCRIPTOR *pInfDesc;
230:                     USB_DEVICE_CDC_ENDPOINT * deviceCDCEndpoint;
231:                 
232:                     /* Check the validity of the function driver index */
233:                     if (iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER)
234:                     {
235:                         /* Assert on invalid CDC index */
236:                         SYS_DEBUG(0, "USB Device CDC: Invalid index");
237:                         return;
238:                     }
239:                 
240:                     thisCDCInstance = &gUSBDeviceCDCInstance[iCDC];
241:                 
242:                 
243:                     /* Initialize the queue sizes. This code may run several times
244:                      * but then we dont expect the queue sizes to change.*/
245:                 
246:                     cdcInit = ((USB_DEVICE_CDC_INIT *)initData);
247:                     thisCDCInstance->queueSizeWrite = cdcInit->queueSizeWrite;
248:                     thisCDCInstance->queueSizeRead = cdcInit->queueSizeRead;
249:                     thisCDCInstance->queueSizeSerialStateNotification = 
250:                     cdcInit->queueSizeSerialStateNotification;
251:                     thisCDCInstance->currentQSizeWrite = 0;
252:                     thisCDCInstance->currentQSizeRead = 0;
253:                     thisCDCInstance->currentQSizeSerialStateNotification = 0;
254:                 	
255:                 	/* Initialize pointer to the Serial state notification buffer */ 
256:                 	thisCDCInstance->serialStateResponse = &gUSBDeviceCDCSerialStateResponse[iCDC]; 
257:                 
258:                     
259:                     /* check the type of descriptor passed by device layer */
260:                     switch ( descType )
261:                     {
262:                         /* Interface descriptor passed */
263:                         case USB_DESCRIPTOR_INTERFACE:
264:                             {
265:                                 pInfDesc = ( USB_INTERFACE_DESCRIPTOR * )pDesc;
266:                 
267:                                 /* Preserve the device layer handle */
268:                                 thisCDCInstance->deviceHandle = deviceHandle;
269:                 
270:                                 /* check if this is notification(communication) interface */
271:                                 if ( ( pInfDesc->bInterfaceClass == USB_CDC_COMMUNICATIONS_INTERFACE_CLASS_CODE ) &&
272:                                         ( pInfDesc->bInterfaceSubClass == USB_CDC_SUBCLASS_ABSTRACT_CONTROL_MODEL ) )
273:                                 {
274:                                     /* Save the notification interface number */
275:                                     thisCDCInstance->notificationInterface.interfaceNum = infNum;
276:                                 }
277:                 
278:                                 /* data interface */
279:                                 else if ( ( pInfDesc->bInterfaceClass == USB_CDC_DATA_INTERFACE_CLASS_CODE ) )
280:                                 {
281:                                     /* save the data interface number */
282:                                     thisCDCInstance->dataInterface.interfaceNum = infNum;
283:                                 }
284:                 
285:                                 else
286:                                 {
287:                                     /* Ignore anything else */
288:                                     SYS_DEBUG(0, "USB Device CDC: Invalid interface presented to CDC " );
289:                                 }
290:                 
291:                                 break;
292:                             }
293:                 
294:                             /* Endpoint descriptor passed */
295:                         case USB_DESCRIPTOR_ENDPOINT:
296:                             {
297:                                 pEPDesc = ( USB_ENDPOINT_DESCRIPTOR* ) pDesc;
298:                 
299:                                 /* Save the ep address */
300:                                 epAddress = pEPDesc->bEndpointAddress;
301:                 
302:                                 /* Get the direction */
303:                                 epDir = ( epAddress & 0x80 ) ? 
304:                                     ( USB_DEVICE_CDC_ENDPOINT_TX ) : ( USB_DEVICE_CDC_ENDPOINT_RX );
305:                 
306:                                 /* Save max packet size */
307:                                 maxPacketSize = ( ( USB_ENDPOINT_DESCRIPTOR* ) pDesc )->wMaxPacketSize;
308:                 
309:                                 if ( pEPDesc->transferType == USB_TRANSFER_TYPE_BULK )
310:                                 {
311:                                     /* This is a data interface endpoint */
312:                                     deviceCDCEndpoint = &thisCDCInstance->dataInterface.endpoint[epDir];
313:                                 }
314:                                 else if( pEPDesc->transferType == USB_TRANSFER_TYPE_INTERRUPT)
315:                                 {
316:                                     /* This is notification endpoint */
317:                                     deviceCDCEndpoint = &thisCDCInstance->notificationInterface.endpoint[epDir];
318:                                 }
319:                                 else
320:                                 {
321:                                     /* We cannot support ny other type of endpoint for now */
322:                                     SYS_DEBUG(0, "USB Device CDC: Cannot handle this endpoint type" );
323:                                     break;
324:                                 }
325:                 
326:                                 /* Save ep address to the data interface */
327:                                 deviceCDCEndpoint->address = epAddress;
328:                 
329:                                 /* Save max packet size to the data interface */
330:                                 deviceCDCEndpoint->maxPacketSize = maxPacketSize;
331:                 
332:                                 /* Enable the endpoint */
333:                                 USB_DEVICE_EndpointEnable ( deviceHandle ,
334:                                         0,
335:                                         epAddress ,
336:                                         (USB_TRANSFER_TYPE)pEPDesc->transferType ,
337:                                         maxPacketSize );
338:                 
339:                                 /* Indicate that the endpoint is configured */
340:                                 deviceCDCEndpoint->isConfigured = true;
341:                 
342:                                 break;
343:                             }
344:                 
345:                         case USB_CDC_DESC_CS_INTERFACE:
346:                             {
347:                                 break;
348:                             }
349:                 
350:                         default:
351:                             /* Unsupported descriptor type */
352:                             break;
353:                     }
354:                 }
355:                 
356:                 // ******************************************************************************
357:                 /* Function:
358:                     void _USB_DEVICE_CDC_EndpointDisable
359:                     (
360:                         USB_DEVICE_HANDLE deviceHandle, 
361:                         USB_DEVICE_CDC_ENDPOINT * deviceCDCEndpoint
362:                     )
363:                 
364:                   Summary:
365:                     Disabled USB Device CDC endpoints.
366:                   
367:                   Description:
368:                     Disabled USB Device CDC endpoints.
369:                 
370:                   Remarks:
371:                     This is local function and should not be called directly by the application.
372:                 */
373:                 
374:                 void _USB_DEVICE_CDC_EndpointDisable
375:                 (
376:                     USB_DEVICE_HANDLE deviceHandle, 
377:                     USB_DEVICE_CDC_ENDPOINT * deviceCDCEndpoint
378:                 )
379:                 {
380:                     if(deviceCDCEndpoint->isConfigured)
381:                     {
382:                         USB_DEVICE_IRPCancelAll(deviceHandle, deviceCDCEndpoint->address);
383:                         USB_DEVICE_EndpointDisable(deviceHandle, deviceCDCEndpoint->address);
384:                         deviceCDCEndpoint->isConfigured = false;
385:                     }
386:                 }
387:                 
388:                 // ******************************************************************************
389:                 /* Function:
390:                     void _USB_DEVICE_CDC_Deinitialization ( SYS_MODULE_INDEX iCDC )
391:                  
392:                   Summary:
393:                     Deinitializes the function driver instance.
394:                   
395:                   Description:
396:                     Deinitializes the function driver instance.
397:                 
398:                   Remarks:
399:                     This is local function and should not be called directly by the application.
400:                 */
401:                 
402:                 void _USB_DEVICE_CDC_Deinitialization ( SYS_MODULE_INDEX iCDC )
403:                 {
404:                     /* Cancel all IRPs on the owned endpoints and then 
405:                      * disable the endpoint */
406:                 
407:                     USB_DEVICE_HANDLE deviceHandle;
408:                     USB_DEVICE_CDC_ENDPOINT * deviceCDCEndpoint;
409:                 
410:                     if(iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER)
411:                     {
412:                         SYS_DEBUG(0, "USB Device CDC: Invalid instance");
413:                         return;
414:                     } 
415:                 
416:                     deviceHandle = gUSBDeviceCDCInstance[iCDC].deviceHandle;
417:                 
418:                     deviceCDCEndpoint = &gUSBDeviceCDCInstance[iCDC].dataInterface.endpoint[0];
419:                     _USB_DEVICE_CDC_EndpointDisable(deviceHandle, deviceCDCEndpoint);
420:                     
421:                     deviceCDCEndpoint = &gUSBDeviceCDCInstance[iCDC].dataInterface.endpoint[1];
422:                     _USB_DEVICE_CDC_EndpointDisable(deviceHandle, deviceCDCEndpoint);
423:                     
424:                     deviceCDCEndpoint = &gUSBDeviceCDCInstance[iCDC].notificationInterface.endpoint[0];
425:                     _USB_DEVICE_CDC_EndpointDisable(deviceHandle, deviceCDCEndpoint);
426:                     
427:                     deviceCDCEndpoint = &gUSBDeviceCDCInstance[iCDC].notificationInterface.endpoint[1];
428:                     _USB_DEVICE_CDC_EndpointDisable(deviceHandle, deviceCDCEndpoint);
429:                 
430:                 }
431:                 
432:                 // ******************************************************************************
433:                 /* Function:
434:                     void _USB_DEVICE_CDC_ControlTransferHandler 
435:                     (
436:                         USB_DEVICE_CONTROL_TRANSFER_HANDLE controlTransferHandle ,
437:                         SYS_MODULE_INDEX iCDC ,
438:                         USB_DEVICE_EVENT controlTransferEvent,
439:                         void * controlTransferEventData
440:                     )
441:                  
442:                   Summary:
443:                     Control Transfer Handler for class specific control transfer.
444:                   
445:                   Description:
446:                     This is theControl Transfer Handler for class specific control transfer. The
447:                     device layer calls this functions for control transfer that are targetted to
448:                     an interface or endpoint that is owned by this function driver.
449:                 
450:                   Remarks:
451:                     This is local function and should not be called directly by the application.
452:                 */
453:                 
454:                 void _USB_DEVICE_CDC_ControlTransferHandler 
455:                 (
456:                     SYS_MODULE_INDEX iCDC ,
457:                     USB_DEVICE_EVENT controlTransferEvent,
458:                     USB_SETUP_PACKET * setupRequest
459:                 )
460:                 {
461:                     USB_DEVICE_HANDLE deviceHandle;
462:                     USB_DEVICE_CDC_INSTANCE * thisCDCDevice;
463:                     
464:                     /* Check the validity of the function driver index */
465:                     if (iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER)
466:                     {
467:                         /* invalid CDC index */
468:                         SYS_DEBUG(0, "USB Device CDC: Invalid CDC index" );
469:                         return;
470:                     }
471:                 
472:                     /* Get a local reference */
473:                     thisCDCDevice = &gUSBDeviceCDCInstance[iCDC];
474:                 
475:                     /* Get the Device Layer handle */
476:                     deviceHandle = thisCDCDevice->deviceHandle;
477:                 
478:                     switch (controlTransferEvent)
479:                     {
480:                         /* Setup packet received */
481:                 
482:                         case USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST:
483:                 
484:                             /* This means we have a setup packet for this interface */
485:                             
486:                             if(!(setupRequest->bmRequestType & USB_CDC_REQUEST_CLASS_SPECIFIC))
487:                             {
488:                                 /* This means this is not a class specific request.
489:                                  * We stall this request */
490:                 
491:                                 USB_DEVICE_ControlStatus(deviceHandle, USB_DEVICE_CONTROL_STATUS_ERROR);
492:                             }
493:                             else
494:                             {
495:                                 /* Check if the requests belong to the ACM sub class */
496:                                 switch(setupRequest->bRequest)
497:                                 {
498:                                     case USB_CDC_REQUEST_SET_LINE_CODING:
499:                                     case USB_CDC_REQUEST_GET_LINE_CODING:
500:                                     case USB_CDC_REQUEST_SET_CONTROL_LINE_STATE:
501:                                     case USB_CDC_REQUEST_SEND_BREAK:
502:                                     case USB_CDC_REQUEST_SEND_ENCAPSULATED_COMMAND:
503:                                     case USB_CDC_REQUEST_GET_ENCAPSULATED_RESPONSE:
504:                 
505:                                         /* These are ACM requests */
506:                 
507:                                         _USB_DEVICE_CDC_ACMSetUpPacketHandler(iCDC, thisCDCDevice, 
508:                                                 setupRequest);
509:                 
510:                                         break;
511:                                     default:
512:                                         /* This is an un-supported request */
513:                                         USB_DEVICE_ControlStatus(deviceHandle, USB_DEVICE_CONTROL_STATUS_ERROR);
514:                                         break;
515:                                 }
516:                             }
517:                 
518:                             break;
519:                 
520:                         case USB_DEVICE_EVENT_CONTROL_TRANSFER_DATA_RECEIVED:
521:                 
522:                             /* A control transfer data stage is complete. Send
523:                              * this event to application */
524:                 
525:                             if(thisCDCDevice->appEventCallBack != NULL)
526:                             {
527:                                 thisCDCDevice->appEventCallBack(iCDC, 
528:                                         USB_DEVICE_CDC_EVENT_CONTROL_TRANSFER_DATA_RECEIVED,
529:                                         NULL, thisCDCDevice->userData );
530:                             }
531:                 
532:                             break;
533:                 
534:                         case USB_DEVICE_EVENT_CONTROL_TRANSFER_DATA_SENT:
535:                 
536:                             /* A control transfer data stage is complete. Send
537:                              * this event to application */
538:                 
539:                             if(thisCDCDevice->appEventCallBack != NULL)
540:                             {
541:                                 thisCDCDevice->appEventCallBack(iCDC, 
542:                                         USB_DEVICE_CDC_EVENT_CONTROL_TRANSFER_DATA_SENT,
543:                                         NULL, thisCDCDevice->userData );
544:                             }
545:                 
546:                         default:
547:                             break;
548:                     }
549:                 }
550:                 
551:                 // ******************************************************************************
552:                 /* Function:
553:                     void _USB_DEVICE_CDC_SerialStateSendIRPCallback (USB_DEVICE_IRP * irp )
554:                  
555:                   Summary:
556:                     IRP call back for Serial State Send IRPs.
557:                   
558:                   Description:
559:                     This is IRP call back for IRPs submitted through the
560:                     USB_DEVICE_CDC_SerialStateSend() function.
561:                 
562:                   Remarks:
563:                     This is local function and should not be called directly by the application.
564:                 */
565:                 
566:                 void _USB_DEVICE_CDC_SerialStateSendIRPCallback (USB_DEVICE_IRP * irp )
567:                 {
568:                     USB_DEVICE_CDC_INSTANCE * thisCDCDevice;
569:                 
570:                     /* This function is called when a CDC Write IRP has
571:                      * terminated */
572:                     
573:                     USB_DEVICE_CDC_EVENT_DATA_SERIAL_STATE_NOTIFICATION_COMPLETE serialStateEventData;
574:                 
575:                     /* The user data field of the IRP contains the CDC instance
576:                      * that submitted this IRP */
577:                     thisCDCDevice = &gUSBDeviceCDCInstance[irp->userData];
578:                 
579:                     /* populate the event handler for this transfer */
580:                     serialStateEventData.handle = ( USB_DEVICE_CDC_TRANSFER_HANDLE ) irp;
581:                 
582:                     /* update the size written */
583:                     serialStateEventData.length = irp->size;
584:                     
585:                     /* Get transfer status */
586:                     if ((irp->status == USB_DEVICE_IRP_STATUS_COMPLETED) 
587:                         || (irp->status == USB_DEVICE_IRP_STATUS_COMPLETED_SHORT))
588:                     {
589:                         /* Transfer completed successfully */
590:                         serialStateEventData.status = USB_DEVICE_CDC_RESULT_OK; 
591:                     }
592:                     else if (irp->status == USB_DEVICE_IRP_STATUS_ABORTED_ENDPOINT_HALT)
593:                     {
594:                         /* Transfer cancelled due to Endpoint Halt */
595:                         serialStateEventData.status = USB_DEVICE_CDC_RESULT_ERROR_ENDPOINT_HALTED; 
596:                     }
597:                     else if (irp->status == USB_DEVICE_IRP_STATUS_TERMINATED_BY_HOST)
598:                     {
599:                         /* Transfer Cancelled by Host (Host sent a Clear feature )*/
600:                         serialStateEventData.status = USB_DEVICE_CDC_RESULT_ERROR_TERMINATED_BY_HOST; 
601:                     }
602:                     else
603:                     {
604:                         /* Transfer was not completed successfully */
605:                         serialStateEventData.status = USB_DEVICE_CDC_RESULT_ERROR; 
606:                     }
607:                 
608:                     /* Reduce the queue size */
609:                 
610:                     thisCDCDevice->currentQSizeSerialStateNotification --;
611:                 
612:                     /* valid application event handler present? */
613:                     if ( thisCDCDevice->appEventCallBack )
614:                     {
615:                         /* inform the application */
616:                         thisCDCDevice->appEventCallBack ( (USB_DEVICE_CDC_INDEX)(irp->userData) , 
617:                                    USB_DEVICE_CDC_EVENT_SERIAL_STATE_NOTIFICATION_COMPLETE ,
618:                                    &serialStateEventData, thisCDCDevice->userData);
619:                     }
620:                 
621:                 }
622:                 
623:                 // ******************************************************************************
624:                 /* Function:
625:                     void _USB_DEVICE_CDC_ReadIRPCallback (USB_DEVICE_IRP * irp )
626:                  
627:                   Summary:
628:                     IRP call back for Data Read IRPs.
629:                   
630:                   Description:
631:                     This is IRP call back for IRPs submitted through the USB_DEVICE_CDC_Read()
632:                     function.
633:                 
634:                   Remarks:
635:                     This is local function and should not be called directly by the application.
636:                 */
637:                 
638:                 void _USB_DEVICE_CDC_ReadIRPCallback (USB_DEVICE_IRP * irp )
639:                 {
640:                     USB_DEVICE_CDC_INSTANCE * thisCDCDevice;
641:                 
642:                     /* This function is called when a CDC Write IRP has
643:                      * terminated */
644:                     
645:                     USB_DEVICE_CDC_EVENT_DATA_READ_COMPLETE readEventData;
646:                 
647:                     /* The user data field of the IRP contains the CDC instance
648:                      * that submitted this IRP */
649:                     thisCDCDevice = &gUSBDeviceCDCInstance[irp->userData];
650:                 
651:                     /* populate the event handler for this transfer */
652:                     readEventData.handle = ( USB_DEVICE_CDC_TRANSFER_HANDLE ) irp;
653:                 
654:                     /* update the size written */
655:                     readEventData.length = irp->size;
656:                     
657:                     /* Get transfer status */
658:                     if ((irp->status == USB_DEVICE_IRP_STATUS_COMPLETED) 
659:                         || (irp->status == USB_DEVICE_IRP_STATUS_COMPLETED_SHORT))
660:                     {
661:                         /* Transfer completed successfully */
662:                         readEventData.status = USB_DEVICE_CDC_RESULT_OK; 
663:                     }
664:                     else if (irp->status == USB_DEVICE_IRP_STATUS_ABORTED_ENDPOINT_HALT)
665:                     {
666:                         /* Transfer cancelled due to Endpoint Halt */
667:                         readEventData.status = USB_DEVICE_CDC_RESULT_ERROR_ENDPOINT_HALTED; 
668:                     }
669:                     else if (irp->status == USB_DEVICE_IRP_STATUS_TERMINATED_BY_HOST)
670:                     {
671:                         /* Transfer Cancelled by Host (Host sent a Clear feature )*/
672:                         readEventData.status = USB_DEVICE_CDC_RESULT_ERROR_TERMINATED_BY_HOST; 
673:                     }
674:                     else
675:                     {
676:                         /* Transfer was not completed successfully */
677:                         readEventData.status = USB_DEVICE_CDC_RESULT_ERROR; 
678:                     }
679:                 
680:                     /* update the queue size */
681:                     thisCDCDevice->currentQSizeRead --;
682:                 
683:                     /* valid application event handler present? */
684:                     if ( thisCDCDevice->appEventCallBack )
685:                     {
686:                         /* inform the application */
687:                         thisCDCDevice->appEventCallBack ( (USB_DEVICE_CDC_INDEX)(irp->userData) , 
688:                                    USB_DEVICE_CDC_EVENT_READ_COMPLETE , 
689:                                    &readEventData, thisCDCDevice->userData);
690:                     }
691:                 
692:                 }
693:                 
694:                 // ******************************************************************************
695:                 /* Function:
696:                     void _USB_DEVICE_CDC_WriteIRPCallback (USB_DEVICE_IRP * irp )
697:                  
698:                   Summary:
699:                     IRP call back for Data Write IRPs.
700:                   
701:                   Description:
702:                     This is IRP call back for IRPs submitted through the USB_DEVICE_CDC_Write()
703:                     function.
704:                 
705:                   Remarks:
706:                     This is local function and should not be called directly by the application.
707:                 */
708:                 
709:                 void _USB_DEVICE_CDC_WriteIRPCallback (USB_DEVICE_IRP * irp )
710:                 {
711:                     USB_DEVICE_CDC_INSTANCE * thisCDCDevice;
712:                 
713:                     /* This function is called when a CDC Write IRP has
714:                      * terminated */
715:                     
716:                     USB_DEVICE_CDC_EVENT_DATA_WRITE_COMPLETE writeEventData;
717:                 
718:                     /* The user data field of the IRP contains the CDC instance
719:                      * that submitted this IRP */
720:                     thisCDCDevice = &gUSBDeviceCDCInstance[irp->userData];
721:                 
722:                     /* populate the event handler for this transfer */
723:                     writeEventData.handle = ( USB_DEVICE_CDC_TRANSFER_HANDLE ) irp;
724:                 
725:                     /* update the size written */
726:                     writeEventData.length = irp->size;
727:                     
728:                     /* Get transfer status */
729:                     if ((irp->status == USB_DEVICE_IRP_STATUS_COMPLETED) 
730:                         || (irp->status == USB_DEVICE_IRP_STATUS_COMPLETED_SHORT))
731:                     {
732:                         /* Transfer completed successfully */
733:                         writeEventData.status = USB_DEVICE_CDC_RESULT_OK; 
734:                     }
735:                     else if (irp->status == USB_DEVICE_IRP_STATUS_ABORTED_ENDPOINT_HALT)
736:                     {
737:                         /* Transfer cancelled due to Endpoint Halt */
738:                         writeEventData.status = USB_DEVICE_CDC_RESULT_ERROR_ENDPOINT_HALTED; 
739:                     }
740:                     else if (irp->status == USB_DEVICE_IRP_STATUS_TERMINATED_BY_HOST)
741:                     {
742:                         /* Transfer Cancelled by Host (Host sent a Clear feature )*/
743:                         writeEventData.status = USB_DEVICE_CDC_RESULT_ERROR_TERMINATED_BY_HOST; 
744:                     }
745:                     else
746:                     {
747:                         /* Transfer was not completed successfully */
748:                         writeEventData.status = USB_DEVICE_CDC_RESULT_ERROR; 
749:                     }
750:                 
751:                     /* Update the queue size*/
752:                     thisCDCDevice->currentQSizeWrite --;
753:                 
754:                     /* valid application event handler present? */
755:                     if ( thisCDCDevice->appEventCallBack )
756:                     {
757:                         /* inform the application */
758:                         thisCDCDevice->appEventCallBack ( (USB_DEVICE_CDC_INDEX)(irp->userData) , 
759:                                    USB_DEVICE_CDC_EVENT_WRITE_COMPLETE , 
760:                                    &writeEventData, thisCDCDevice->userData);
761:                     }
762:                 
763:                 }
764:                 
765:                 // *****************************************************************************
766:                 // *****************************************************************************
767:                 // Section: CDC Interface Function Definitions
768:                 // *****************************************************************************
769:                 // *****************************************************************************
770:                 
771:                 
772:                 // *****************************************************************************
773:                 /* Function:
774:                     USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_Read 
775:                     (
776:                         USB_DEVICE_CDC_INDEX instance, 
777:                         USB_CDC_DEVICE_TRANSFER_HANDLE * transferHandle,
778:                         void * data, 
779:                         size_t size
780:                     );
781:                 
782:                   Summary:
783:                     This function requests a data read from the USB Device CDC Function Driver 
784:                     Layer.
785:                 
786:                   Description:
787:                     This function requests a data read from the USB Device CDC Function Driver
788:                     Layer. The function places a requests with driver, the request will get
789:                     serviced as data is made available by the USB Host. A handle to the request
790:                     is returned in the transferHandle parameter. The termination of the request
791:                     is indicated by the USB_DEVICE_CDC_EVENT_READ_COMPLETE event. The amount of
792:                     data read and the transfer handle associated with the request is returned
793:                     along with the event in the pData parameter of the event handler. The
794:                     transfer handle expires when event handler for the
795:                     USB_DEVICE_CDC_EVENT_READ_COMPLETE exits. If the read request could not be
796:                     accepted, the function returns an error code and transferHandle will contain
797:                     the value USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID.
798:                 
799:                     If the size parameter is not a multiple of maxPacketSize or is 0, the
800:                     function returns USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID in transferHandle
801:                     and returns an error code as a return value. If the size parameter is a
802:                     multiple of maxPacketSize and the host send less than maxPacketSize data in
803:                     any transaction, the transfer completes and the function driver will issue a
804:                     USB_DEVICE_CDC_EVENT_READ_COMPLETE event along with the
805:                     USB_DEVICE_CDC_EVENT_READ_COMPLETE_DATA data structure. If the size
806:                     parameter is a multiple of maxPacketSize and the host sends maxPacketSize
807:                     amount of data, and total data received does not exceed size, then the
808:                     function driver will wait for the next packet. 
809:                   
810:                   Remarks:
811:                     Refer to usb_device_cdc.h for usage information.
812:                 */   
813:                 
814:                 USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_Read 
815:                 (
816:                     USB_DEVICE_CDC_INDEX iCDC ,
817:                     USB_DEVICE_CDC_TRANSFER_HANDLE * transferHandle ,
818:                     void * data , size_t size
819:                 )
820:                 {
821:                     unsigned int cnt;
822:                     unsigned int remainder;
823:                     USB_DEVICE_IRP * irp;
824:                     USB_DEVICE_CDC_ENDPOINT * endpoint;
825:                     USB_DEVICE_CDC_INSTANCE * thisCDCDevice;
826:                     OSAL_RESULT osalError;
827:                     USB_ERROR irpError;
828:                     OSAL_CRITSECT_DATA_TYPE IntState;
829:                 
830:                     /* Check the validity of the function driver index */
831:                     
832:                     if (  iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER  )
833:                     {
834:                         /* Invalid CDC index */
835:                         SYS_ASSERT(false, "Invalid CDC Device Index");
836:                         return USB_DEVICE_CDC_RESULT_ERROR_INSTANCE_INVALID;
837:                     }
838:                 
839:                     thisCDCDevice = &gUSBDeviceCDCInstance[iCDC];
840:                     endpoint = &thisCDCDevice->dataInterface.endpoint[USB_DEVICE_CDC_ENDPOINT_RX];
841:                     *transferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
842:                 
843:                     /* Check if the endpoint is configured */
844:                     if(!(endpoint->isConfigured))
845:                     {
846:                         /* This means that the endpoint is not configured yet */
847:                         SYS_ASSERT(false, "Endpoint not configured");
848:                         return (USB_DEVICE_CDC_RESULT_ERROR_INSTANCE_NOT_CONFIGURED);
849:                     }
850:                 
851:                     /* For read the size should be a multiple of endpoint size*/
852:                     remainder = size % endpoint->maxPacketSize;
853:                 
854:                     if((size == 0) || (remainder != 0))
855:                     {
856:                         /* Size is not valid */
857:                         SYS_ASSERT(false, "Invalid size in IRP read");
858:                         return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_SIZE_INVALID);
859:                     }
860:                 
861:                     /* Make sure that we are with in the queue size for this instance */
862:                     if(thisCDCDevice->currentQSizeRead >= thisCDCDevice->queueSizeRead)
863:                     {
864:                         SYS_ASSERT(false, "Read Queue is full");
865:                         return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_QUEUE_FULL);
866:                     }
867:                 
868:                     /*Obtain mutex to get access to a shared resource, check return value*/
869:                     osalError = OSAL_MUTEX_Lock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP, OSAL_WAIT_FOREVER);
870:                     if(osalError != OSAL_RESULT_TRUE)
871:                     {
872:                       /*Do not proceed lock was not obtained, or error occurred, let user know about error*/
873:                       return (USB_DEVICE_CDC_RESULT_ERROR);
874:                     }
875:                 
876:                     /* Loop and find a free IRP in the Q */
877:                     for ( cnt = 0; cnt < USB_DEVICE_CDC_QUEUE_DEPTH_COMBINED; cnt ++ )
878:                     {
879:                         if(gUSBDeviceCDCIRP[cnt].status <
880:                                 (USB_DEVICE_IRP_STATUS)USB_DEVICE_IRP_FLAG_DATA_PENDING)
881:                         {
882:                             /* This means the IRP is free. Configure the IRP
883:                              * update the current queue size and then submit */
884:                 
885:                             irp = &gUSBDeviceCDCIRP[cnt];
886:                             irp->data = data;
887:                             irp->size = size;
888:                             irp->userData = (uintptr_t) iCDC;
889:                             irp->callback = _USB_DEVICE_CDC_ReadIRPCallback;
890:                             
891:                             /* Prevent other tasks pre-empting this sequence of code */ 
892:                             IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
893:                             /* Update the read queue size */ 
894:                             thisCDCDevice->currentQSizeRead++;
895:                             OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, IntState);
896:                             
897:                             *transferHandle = (USB_DEVICE_CDC_TRANSFER_HANDLE)irp;
898:                             irpError = USB_DEVICE_IRPSubmit(thisCDCDevice->deviceHandle,
899:                                     endpoint->address, irp);
900:                 
901:                             /* If IRP Submit function returned any error, then invalidate the
902:                                Transfer handle.  */
903:                             if (irpError != USB_ERROR_NONE )
904:                             {
905:                                 /* Prevent other tasks pre-empting this sequence of code */ 
906:                                 IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
907:                                 /* Update the read queue size */ 
908:                                 thisCDCDevice->currentQSizeRead--;
909:                                 OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, IntState);
910:                                 *transferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
911:                             }
912:                             
913:                             /*Release mutex, done with shared resource*/
914:                             osalError = OSAL_MUTEX_Unlock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP);
915:                             if(osalError != OSAL_RESULT_TRUE)
916:                             {
917:                                 /*Do not proceed unlock was not complete, or error occurred, let user know about error*/
918:                                 return (USB_DEVICE_CDC_RESULT_ERROR);
919:                             }
920:                             
921:                             return((USB_DEVICE_CDC_RESULT)irpError);
922:                         }
923:                     }
924:                     
925:                     /*Release mutex, done with shared resource*/
926:                     osalError = OSAL_MUTEX_Unlock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP);
927:                     if(osalError != OSAL_RESULT_TRUE)
928:                     {
929:                         /*Do not proceed unlock was not complete, or error occurred, let user know about error*/
930:                         return (USB_DEVICE_CDC_RESULT_ERROR);
931:                     }
932:                     /* If here means we could not find a spare IRP */
933:                     return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_QUEUE_FULL);
934:                 }
935:                 
936:                 // *****************************************************************************
937:                 /* Function:
938:                     USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_Write 
939:                     (   
940:                         USB_DEVICE_CDC_INDEX instance, 
941:                         USB_CDC_DEVICE_TRANSFER_HANDLE * transferHandle, 
942:                         const void * data, 
943:                         size_t size, 
944:                         USB_DEVICE_CDC_TRANSFER_FLAGS flags 
945:                     );
946:                 
947:                   Summary:
948:                     This function requests a data write to the USB Device CDC Function Driver 
949:                     Layer.
950:                 
951:                   Description:
952:                     This function requests a data write to the USB Device CDC Function Driver
953:                     Layer. The function places a requests with driver, the request will get
954:                     serviced as data is requested by the USB Host. A handle to the request is
955:                     returned in the transferHandle parameter. The termination of the request is
956:                     indicated by the USB_DEVICE_CDC_EVENT_WRITE_COMPLETE event. The amount of
957:                     data written and the transfer handle associated with the request is returned
958:                     along with the event in writeCompleteData member of the pData parameter in
959:                     the event handler. The transfer handle expires when event handler for the
960:                     USB_DEVICE_CDC_EVENT_WRITE_COMPLETE exits.  If the read request could not be
961:                     accepted, the function returns an error code and transferHandle will contain
962:                     the value USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID.
963:                 
964:                   Remarks:
965:                     Refer to usb_device_cdc.h for usage information.
966:                 */
967:                 
968:                 USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_Write 
969:                 (
970:                     USB_DEVICE_CDC_INDEX iCDC ,
971:                     USB_DEVICE_CDC_TRANSFER_HANDLE * transferHandle ,
972:                     const void * data , size_t size ,
973:                     USB_DEVICE_CDC_TRANSFER_FLAGS flags 
974:                 )
975:                 {
976:                     unsigned int cnt;
977:                     unsigned int remainder;
978:                     USB_DEVICE_IRP * irp;
979:                     USB_DEVICE_IRP_FLAG irpFlag = USB_DEVICE_IRP_FLAG_NONE;
980:                     USB_DEVICE_CDC_INSTANCE * thisCDCDevice;
981:                     USB_DEVICE_CDC_ENDPOINT * endpoint;
982:                     OSAL_RESULT osalError;
983:                     USB_ERROR irpError; 
984:                     OSAL_CRITSECT_DATA_TYPE IntState;
985:                 
986:                     /* Check the validity of the function driver index */
987:                     
988:                     if (  iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER  )
989:                     {
990:                         /* Invalid CDC index */
991:                         SYS_ASSERT(false, "Invalid CDC Device Index");
992:                         return USB_DEVICE_CDC_RESULT_ERROR_INSTANCE_INVALID;
993:                     }
994:                 
995:                     /* Initialize the transfer handle, get the instance object
996:                      * and the transmit endpoint */
997:                 
998:                     * transferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
999:                     thisCDCDevice = &gUSBDeviceCDCInstance[iCDC];
1000:                    endpoint = &thisCDCDevice->dataInterface.endpoint[USB_DEVICE_CDC_ENDPOINT_TX];
1001:                
1002:                    if(!(endpoint->isConfigured))
1003:                    {
1004:                        /* This means that the endpoint is not configured yet */
1005:                        SYS_ASSERT(false, "Endpoint not configured");
1006:                        return (USB_DEVICE_CDC_RESULT_ERROR_INSTANCE_NOT_CONFIGURED);
1007:                    }
1008:                
1009:                    if(size == 0) 
1010:                    {
1011:                        /* Size cannot be zero */
1012:                        return (USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_SIZE_INVALID);
1013:                    }
1014:                
1015:                    /* Check the flag */
1016:                
1017:                    if(flags & USB_DEVICE_CDC_TRANSFER_FLAGS_MORE_DATA_PENDING)
1018:                    {
1019:                        if(size < endpoint->maxPacketSize)
1020:                        {
1021:                            /* For a data pending flag, we must atleast get max packet
1022:                             * size worth data */
1023:                
1024:                            return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_SIZE_INVALID);
1025:                        }
1026:                
1027:                        remainder = size % endpoint->maxPacketSize;
1028:                        
1029:                        if(remainder != 0)
1030:                        {
1031:                            size -= remainder;
1032:                        }
1033:                
1034:                        irpFlag = USB_DEVICE_IRP_FLAG_DATA_PENDING;
1035:                    }
1036:                    else if(flags & USB_DEVICE_CDC_TRANSFER_FLAGS_DATA_COMPLETE)
1037:                    {
1038:                        irpFlag = USB_DEVICE_IRP_FLAG_DATA_COMPLETE;
1039:                    }
1040:                
1041:                    if(thisCDCDevice->currentQSizeWrite >= thisCDCDevice->queueSizeWrite)
1042:                    {
1043:                        SYS_ASSERT(false, "Write Queue is full");
1044:                        return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_QUEUE_FULL);
1045:                    }
1046:                
1047:                    /*Obtain mutex to get access to a shared resource, check return value*/
1048:                    osalError = OSAL_MUTEX_Lock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP, OSAL_WAIT_FOREVER);
1049:                    if(osalError != OSAL_RESULT_TRUE)
1050:                    {
1051:                      /*Do not proceed lock was not obtained, or error occurred, let user know about error*/
1052:                      return (USB_DEVICE_CDC_RESULT_ERROR);
1053:                    }
1054:                
1055:                    /* loop and find a free IRP in the Q */
1056:                    for ( cnt = 0; cnt < USB_DEVICE_CDC_QUEUE_DEPTH_COMBINED; cnt ++ )
1057:                    {
1058:                        if(gUSBDeviceCDCIRP[cnt].status <
1059:                                (USB_DEVICE_IRP_STATUS)USB_DEVICE_IRP_FLAG_DATA_PENDING)
1060:                        {
1061:                            /* This means the IRP is free */
1062:                
1063:                            irp         = &gUSBDeviceCDCIRP[cnt];
1064:                            irp->data   = (void *)data;
1065:                            irp->size   = size;
1066:                
1067:                            irp->userData   = (uintptr_t) iCDC;
1068:                            irp->callback   = _USB_DEVICE_CDC_WriteIRPCallback;
1069:                            irp->flags      = irpFlag;
1070:                
1071:                            /* Prevent other tasks pre-empting this sequence of code */ 
1072:                            IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
1073:                            /* Update the Write queue size */ 
1074:                            thisCDCDevice->currentQSizeWrite++;
1075:                            OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, IntState);
1076:                            
1077:                            *transferHandle = (USB_DEVICE_CDC_TRANSFER_HANDLE)irp;
1078:                
1079:                            irpError = USB_DEVICE_IRPSubmit(thisCDCDevice->deviceHandle,
1080:                                    endpoint->address, irp);
1081:                
1082:                            /* If IRP Submit function returned any error, then invalidate the
1083:                               Transfer handle.  */
1084:                            if (irpError != USB_ERROR_NONE )
1085:                            {
1086:                                /* Prevent other tasks pre-empting this sequence of code */ 
1087:                                IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
1088:                                /* Update the Write queue size */ 
1089:                                thisCDCDevice->currentQSizeWrite--;
1090:                                OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, IntState);
1091:                                *transferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
1092:                            }
1093:                            /*Release mutex, done with shared resource*/
1094:                            osalError = OSAL_MUTEX_Unlock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP);
1095:                            if(osalError != OSAL_RESULT_TRUE)
1096:                            {
1097:                                /*Do not proceed unlock was not complete, or error occurred, let user know about error*/
1098:                                return (USB_DEVICE_CDC_RESULT_ERROR);
1099:                            }
1100:                
1101:                            return((USB_DEVICE_CDC_RESULT)irpError);
1102:                        }
1103:                    }
1104:                    
1105:                    /*Release mutex, done with shared resource*/
1106:                    osalError = OSAL_MUTEX_Unlock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP);
1107:                    if(osalError != OSAL_RESULT_TRUE)
1108:                    {
1109:                        /*Do not proceed unlock was not complete, or error occurred, let user know about error*/
1110:                        return (USB_DEVICE_CDC_RESULT_ERROR);
1111:                    }
1112:                    /* If here means we could not find a spare IRP */
1113:                    return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_QUEUE_FULL);
1114:                }
1115:                
1116:                USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_EventHandlerSet 
1117:                (
1118:                    USB_DEVICE_CDC_INDEX iCDC ,
1119:                    USB_DEVICE_CDC_EVENT_HANDLER eventHandler,
1120:                    uintptr_t userData
1121:                
1122:                )
1123:                {
1124:                    /* Check the validity of the function driver index */
1125:                    if (( iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER ) )
1126:                    {
1127:                        /* invalid CDC index */
1128:                        return USB_DEVICE_CDC_RESULT_ERROR_INSTANCE_INVALID;
1129:                    }
1130:                
1131:                    /* Check if the given event handler is valid */
1132:                    if ( eventHandler )
1133:                    {
1134:                        /* update the event handler for this instance */
1135:                        gUSBDeviceCDCInstance[iCDC].appEventCallBack = eventHandler;
1136:                        gUSBDeviceCDCInstance[iCDC].userData = userData;
1137:                
1138:                        /* return success */
1139:                        return USB_DEVICE_CDC_RESULT_OK;
1140:                    }
1141:                
1142:                    else
1143:                    {
1144:                        /* invalid event handler passed */
1145:                        return USB_DEVICE_CDC_RESULT_ERROR_PARAMETER_INVALID;
1146:                    }
1147:                }
1148:                
1149:                uint16_t USB_DEVICE_CDC_ReadPacketSizeGet ( USB_DEVICE_CDC_INDEX iCDC )
1150:                {
1151:                    /* check the validity of the function driver index */
1152:                    if ( ( iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER ) )
1153:                    {
1154:                        /* Invalid CDC index */
1155:                        SYS_ASSERT ( false , "Invalid CDC index" );
1156:                        return (0);
1157:                    }
1158:                
1159:                    /* max read packet size for this instance */
1160:                    return (gUSBDeviceCDCInstance[iCDC].dataInterface
1161:                            .endpoint[USB_DEVICE_CDC_ENDPOINT_RX].maxPacketSize );
1162:                
1163:                }
1164:                
1165:                // *****************************************************************************
1166:                /* Function:
1167:                    USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_EventHandlerSet 
1168:                    (
1169:                        USB_DEVICE_CDC_INDEX instance 
1170:                        USB_DEVICE_CDC_EVENT_HANDLER eventHandler 
1171:                        uintptr_t context
1172:                    );
1173:                
1174:                  Summary:
1175:                    This function registers a event handler for the specified CDC function
1176:                    driver instance. 
1177:                
1178:                  Description:
1179:                    This function registers a event handler for the specified CDC function
1180:                    driver instance. This function should be called by the client when it
1181:                    receives a SET CONFIGURATION event from the device layer. A event handler
1182:                    must be registered for function driver to respond to function driver
1183:                    specific commands. If the event handler is not registered, the device layer
1184:                    will stall function driver specific commands and the USB device may not
1185:                    function. 
1186:                
1187:                  Remarks:
1188:                    Refer to usb_device_cdc.h for usage information.
1189:                */
1190:                
1191:                
1192:                uint16_t USB_DEVICE_CDC_WritePacketSizeGet ( USB_DEVICE_CDC_INDEX iCDC )
1193:                {
1194:                    /* check the validity of the function driver index */
1195:                    if ( ( iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER ) )
1196:                    {
1197:                        /* Invalid CDC index */
1198:                        SYS_ASSERT ( false , "Invalid CDC index" );
1199:                        return (0);
1200:                    }
1201:                
1202:                    /* max read packet size for this instance */
1203:                    return (gUSBDeviceCDCInstance[iCDC].dataInterface.
1204:                            endpoint[USB_DEVICE_CDC_ENDPOINT_TX].maxPacketSize );
1205:                }
1206:                // *****************************************************************************
1207:                /* Function:
1208:                    USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_SerialStateNotificationSend
1209:                    (
1210:                        USB_DEVICE_CDC_INDEX instanceIndex,
1211:                        USB_DEVICE_CDC_TRANSFER_HANDLE * transferHandle,
1212:                        USB_DEVICE_CDC_SERIAL_STATE_NOTIFICATION * notificationData
1213:                    );
1214:                    
1215:                  Summary:
1216:                    This function schedules a request to send serial state notification to the host.
1217:                
1218:                  Description:
1219:                    This function places a request to send serial state notificatin data to the
1220:                    host. The function will place the request with the driver, the request will
1221:                    get serviced when the data is requested by the USB host.  A handle to the
1222:                    request is returned in the transferHandle parameter. The termination of the
1223:                    request is indicated by the
1224:                    USB_DEVICE_CDC_EVENT_SERIAL_STATE_NOTIFICATION_COMPLETE event. The amount of
1225:                    data transmitted and the transfer handle associated with the request is
1226:                    returned along with the event in the serialStateNotificationCompleteData
1227:                    member of pData paramter of the event handler. The transfer handle expires
1228:                    when the event handler for the
1229:                    USB_DEVICE_CDC_EVENT_SERIAL_STATE_NOTIFICATION_COMPLETE event exits. If the
1230:                    send request could not be accepted, the function returns an error code and
1231:                    transferHandle will contain the value
1232:                    USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID.
1233:                
1234:                  Remarks:
1235:                    Refer to usb_device_cdc.h for usage information.
1236:                */
1237:                
1238:                USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_SerialStateNotificationSend 
1239:                (
1240:                    USB_DEVICE_CDC_INDEX iCDC ,
1241:                    USB_DEVICE_CDC_TRANSFER_HANDLE * transferHandle ,
1242:                    USB_CDC_SERIAL_STATE * notificationData 
1243:                )
1244:                {
1245:                    unsigned int cnt;
1246:                    USB_DEVICE_IRP * irp;
1247:                    USB_DEVICE_CDC_ENDPOINT * endpoint;
1248:                    USB_DEVICE_CDC_INSTANCE * thisCDCDevice;
1249:                    OSAL_RESULT osalError;
1250:                    USB_ERROR irpError;
1251:                    OSAL_CRITSECT_DATA_TYPE IntState;
1252:                	USB_CDC_SERIAL_STATE_RESPONSE * serialStateResponse; 
1253:                
1254:                    *transferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
1255:                
1256:                    /* Check the validity of the function driver index */
1257:                    
1258:                    if (  iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER  )
1259:                    {
1260:                        /* Invalid CDC index */
1261:                        SYS_ASSERT(false, "Invalid CDC Device Index");
1262:                        return USB_DEVICE_CDC_RESULT_ERROR_INSTANCE_INVALID;
1263:                    }
1264:                
1265:                    thisCDCDevice = &gUSBDeviceCDCInstance[iCDC];
1266:                    endpoint = &thisCDCDevice->notificationInterface.endpoint[USB_DEVICE_CDC_ENDPOINT_TX];
1267:                	
1268:                	serialStateResponse = thisCDCDevice->serialStateResponse; 
1269:                	
1270:                	/* Fill in the USB CDC Serial state buffer */ 
1271:                	
1272:                	/* bmRequestType = 10100001B (Direction = Device to Host, Request Type = Class, Recipient = Interface) */ 
1273:                	serialStateResponse->bmRequestType = 0xA1; 
1274:                	
1275:                	/* bRequest = SERIAL_STATE */ 
1276:                	serialStateResponse->bNotification = USB_CDC_NOTIFICATION_SERIAL_STATE; 
1277:                	
1278:                	/* wValue = Zero */ 
1279:                	serialStateResponse->wValue = 0; 
1280:                	
1281:                	/* Get the interface Number from the CDC instance */ 
1282:                	serialStateResponse->wIndex = (uint16_t)(thisCDCDevice->notificationInterface.interfaceNum); 
1283:                	
1284:                	/* Fill in the length */ 
1285:                	serialStateResponse->wLength = sizeof(USB_CDC_SERIAL_STATE);
1286:                	
1287:                	/* Copy Serial state data received from the client to the buffer */ 
1288:                	memcpy (&(serialStateResponse->stSerial), notificationData, sizeof(USB_CDC_SERIAL_STATE)); 
1289:                	
1290:                
1291:                    if(!(endpoint->isConfigured))
1292:                    {
1293:                        /* This means that the endpoint is not configured yet */
1294:                        SYS_ASSERT(false, "Endpoint not configured");
1295:                        return (USB_DEVICE_CDC_RESULT_ERROR_INSTANCE_NOT_CONFIGURED);
1296:                    }
1297:                
1298:                    if(thisCDCDevice->currentQSizeSerialStateNotification >=
1299:                            thisCDCDevice->queueSizeSerialStateNotification)
1300:                    {
1301:                        SYS_ASSERT(false, "Serial State Notification Send Queue is full");
1302:                        return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_QUEUE_FULL);
1303:                    }
1304:                
1305:                    /*Obtain mutex to get access to a shared resource, check return value*/
1306:                    osalError = OSAL_MUTEX_Lock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP, OSAL_WAIT_FOREVER);
1307:                    if(osalError != OSAL_RESULT_TRUE)
1308:                    {
1309:                      /*Do not proceed lock was not obtained, or error occurred, let user know about error*/
1310:                      return (USB_DEVICE_CDC_RESULT_ERROR);
1311:                    }
1312:                
1313:                    /* Loop and find a free IRP in the Q */
1314:                    for ( cnt = 0; cnt < USB_DEVICE_CDC_QUEUE_DEPTH_COMBINED; cnt ++ )
1315:                    {
1316:                        if(gUSBDeviceCDCIRP[cnt].status < (USB_DEVICE_IRP_STATUS)USB_DEVICE_IRP_FLAG_DATA_PENDING)
1317:                        {
1318:                            /* This means the IRP is free */
1319:                
1320:                            irp = &gUSBDeviceCDCIRP[cnt];
1321:                            irp->data = serialStateResponse;
1322:                            irp->size = sizeof(USB_CDC_SERIAL_STATE_RESPONSE);
1323:                            irp->userData = (uintptr_t) iCDC;
1324:                            irp->callback = _USB_DEVICE_CDC_SerialStateSendIRPCallback;
1325:                            irp->flags = USB_DEVICE_IRP_FLAG_DATA_COMPLETE;
1326:                            /* Prevent other tasks pre-empting this sequence of code */ 
1327:                            IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
1328:                            /* Update Serial State Notification Queue Size */ 
1329:                            thisCDCDevice->currentQSizeSerialStateNotification ++;
1330:                            OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, IntState);
1331:                            
1332:                            *transferHandle = (USB_DEVICE_CDC_TRANSFER_HANDLE) irp;
1333:                            irpError = USB_DEVICE_IRPSubmit(thisCDCDevice->deviceHandle, endpoint->address, irp);
1334:                            
1335:                            /* If IRP Submit function returned any error, then invalidate the
1336:                               Transfer handle.  */
1337:                            if (irpError != USB_ERROR_NONE )
1338:                            {
1339:                                /* Prevent other tasks pre-empting this sequence of code */ 
1340:                                IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
1341:                                /* Update Serial State Notification Queue Size */ 
1342:                                thisCDCDevice->currentQSizeSerialStateNotification --;
1343:                                OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, IntState);
1344:                                
1345:                                *transferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
1346:                            }
1347:                
1348:                            /*Release mutex, done with shared resource*/
1349:                            osalError = OSAL_MUTEX_Unlock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP);
1350:                            if(osalError != OSAL_RESULT_TRUE)
1351:                            {
1352:                                /*Do not proceed unlock was not complete, or error occurred, let user know about error*/
1353:                                return (USB_DEVICE_CDC_RESULT_ERROR);
1354:                            }
1355:                            
1356:                            return((USB_DEVICE_CDC_RESULT)irpError);
1357:                        }
1358:                    }
1359:                    
1360:                    /*Release mutex, done with shared resource*/
1361:                    osalError = OSAL_MUTEX_Unlock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP);
1362:                    if(osalError != OSAL_RESULT_TRUE)
1363:                    {
1364:                        /*Do not proceed unlock was not complete, or error occurred, let user know about error*/
1365:                        return (USB_DEVICE_CDC_RESULT_ERROR);
1366:                    }
1367:                    /* If here means we could not find a spare IRP */
1368:                    return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_QUEUE_FULL);
1369:                }
1370:                
1371:                /*******************************************************************************
1372:                 End of File
1373:                 */
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000024  00000000   NOP
00000030  00000000   NOP
00000038  00000000   NOP
0000003C  00000000   NOP
00000040  00000000   NOP
00000044  00000000   NOP
0000004C  00000000   NOP
00000050  00000000   NOP
00000054  00000000   NOP
00000058  00000000   NOP
0000005C  00000000   NOP
00000060  00000000   NOP
00000064  00000000   NOP
0000006C  00000000   NOP
00000070  00000000   NOP
00000074  00000000   NOP
0000007C  00000000   NOP
00000080  00000000   NOP
00000084  00000000   NOP
00000088  00000000   NOP
00000090  00000000   NOP
00000094  00000000   NOP
0000009C  00000000   NOP
000000BC  00000000   NOP
000000C4  00000000   NOP
000000C8  00000000   NOP
000000D4  00000000   NOP
000000D8  00000000   NOP
000000E4  00000000   NOP
000000F4  00000000   NOP
000000F8  00000000   NOP
000000FC  00000000   NOP
00000104  00000000   NOP
00000110  00000000   NOP
00000118  00000000   NOP
0000011C  00000000   NOP
00000130  00000000   NOP
00000134  00000000   NOP
00000138  00000000   NOP
00000144  00000000   NOP
0000014C  00000000   NOP
00000154  00000000   NOP
0000015C  00000000   NOP
00000164  00000000   NOP
0000016C  00000000   NOP
00000170  00000000   NOP
00000180  00000000   NOP
00000188  00000000   NOP
0000018C  00000000   NOP
00000194  00000000   NOP
0000019C  00000000   NOP
000001A4  00000000   NOP
000001AC  00000000   NOP
000001B4  00000000   NOP
000001BC  00000000   NOP
000001C0  00000000   NOP
000001C8  00000000   NOP
000001D0  00000000   NOP
000001D4  00000000   NOP
000001DC  00000000   NOP
000001E4  00000000   NOP
000001EC  00000000   NOP
000001F4  00000000   NOP
9D003B88  27BDFFD8   ADDIU SP, SP, -40
9D003B8C  AFBF0024   SW RA, 36(SP)
9D003B90  AFB30020   SW S3, 32(SP)
9D003B94  AFB2001C   SW S2, 28(SP)
9D003B98  AFB10018   SW S1, 24(SP)
9D003B9C  AFB00014   SW S0, 20(SP)
9D003BA0  1480006B   BNE A0, ZERO, 0x9D003D50
9D003BA4  8FA20038   LW V0, 56(SP)
9D003BA8  3C13A000   LUI S3, -24576
9D003BAC  267005C0   ADDIU S0, S3, 1472
9D003BB0  92030010   LBU V1, 16(S0)
9D003BB4  00A09025   OR S2, A1, ZERO
9D003BB8  2405FFFF   ADDIU A1, ZERO, -1
9D003BBC  10600066   BEQ V1, ZERO, 0x9D003D58
9D003BC0  AE450000   SW A1, 0(S2)
9D003BC4  50E0000D   BEQL A3, ZERO, 0x9D003BFC
9D003BC8  2411FF82   ADDIU S1, ZERO, -126
9D003BCC  30430002   ANDI V1, V0, 2
9D003BD0  54600012   BNEL V1, ZERO, 0x9D003C1C
9D003BD4  9602000E   LHU V0, 14(S0)
9D003BD8  30430001   ANDI V1, V0, 1
9D003BDC  8E020034   LW V0, 52(S0)
9D003BE0  8E050028   LW A1, 40(S0)
9D003BE4  0045102B   SLTU V0, V0, A1
9D003BE8  10400061   BEQ V0, ZERO, 0x9D003D70
9D003BEC  93828035   LBU V0, -32715(GP)
9D003BF0  24050001   ADDIU A1, ZERO, 1
9D003BFC  8FBF0024   LW RA, 36(SP)
9D003C00  02201025   OR V0, S1, ZERO
9D003C04  8FB30020   LW S3, 32(SP)
9D003C08  8FB2001C   LW S2, 28(SP)
9D003C0C  8FB10018   LW S1, 24(SP)
9D003C10  8FB00014   LW S0, 20(SP)
9D003C14  03E00008   JR RA
9D003C18  27BD0028   ADDIU SP, SP, 40
9D003C1C  00E2182B   SLTU V1, A3, V0
9D003C20  1460FFF6   BNE V1, ZERO, 0x9D003BFC
9D003C24  2411FF82   ADDIU S1, ZERO, -126
9D003C28  00E2001B   DIVU A3, V0
9D003C2C  004001F4   TEQ V0, ZERO
9D003C30  24030002   ADDIU V1, ZERO, 2
9D003C34  00001010   MFHI V0
9D003C38  1000FFE8   BEQ ZERO, ZERO, 0x9D003BDC
9D003C3C  00E23823   SUBU A3, A3, V0
9D003C40  3C05A000   LUI A1, -24576
9D003C48  8CA80008   LW T0, 8(A1)
9D003C4C  29080002   SLTI T0, T0, 2
9D003C50  15000012   BNE T0, ZERO, 0x9D003C9C
9D003C54  A3808035   SB ZERO, -32715(GP)
9D003C58  8CA4002C   LW A0, 44(A1)
9D003C5C  28840002   SLTI A0, A0, 2
9D003C60  14800038   BNE A0, ZERO, 0x9D003D44
9D003C64  3C11A000   LUI S1, -24576
9D003C68  8CA40050   LW A0, 80(A1)
9D003C6C  28840002   SLTI A0, A0, 2
9D003C70  1480003B   BNE A0, ZERO, 0x9D003D60
9D003C74  8FBF0024   LW RA, 36(SP)
9D003C78  2411FF80   ADDIU S1, ZERO, -128
9D003C80  8FB30020   LW S3, 32(SP)
9D003C8C  8FB10018   LW S1, 24(SP)
9D003C90  8FB00014   LW S0, 20(SP)
9D003C94  03E00008   JR RA
9D003C98  27BD0028   ADDIU SP, SP, 40
9D003C9C  00A08825   OR S1, A1, ZERO
9D003CA0  000410C0   SLL V0, A0, 3
9D003CA4  00441021   ADDU V0, V0, A0
9D003CA8  00021080   SLL V0, V0, 2
9D003CAC  00A22821   ADDU A1, A1, V0
9D003CB0  3C029D00   LUI V0, -25344
9D003CB4  24426AB0   ADDIU V0, V0, 27312
9D003CB8  ACA60000   SW A2, 0(A1)
9D003CBC  ACA70004   SW A3, 4(A1)
9D003CC0  ACA30010   SW V1, 16(A1)
9D003CC4  ACA2000C   SW V0, 12(A1)
9D003CC8  0F4000D6   JAL SYS_INT_Disable
9D003CD0  8E030034   LW V1, 52(S0)
9D003CD8  24630001   ADDIU V1, V1, 1
9D003CDC  AE030034   SW V1, 52(S0)
9D003CE0  0F4000E2   JAL SYS_INT_Restore
9D003CE8  AE510000   SW S1, 0(S2)
9D003CEC  9205000C   LBU A1, 12(S0)
9D003CF0  8E6405C0   LW A0, 1472(S3)
9D003CF4  0F401FC6   JAL USB_DEVICE_IRPSubmit
9D003CF8  02203025   OR A2, S1, ZERO
9D003CFC  14400004   BNE V0, ZERO, USB_DEVICE_CDC_Write::OSAL_CRIT_Enter
9D003D00  00408825   OR S1, V0, ZERO
9D003D04  24020001   ADDIU V0, ZERO, 1
9D003D08  1000FFBC   BEQ ZERO, ZERO, 0x9D003BFC
9D003D10  0F4000D6   JAL SYS_INT_Disable
9D003D18  8E030034   LW V1, 52(S0)
9D003D20  2463FFFF   ADDIU V1, V1, -1
9D003D24  AE030034   SW V1, 52(S0)
9D003D28  0F4000E2   JAL SYS_INT_Restore
9D003D2C  00000000   NOP
9D003D30  2402FFFF   ADDIU V0, ZERO, -1
9D003D34  AE420000   SW V0, 0(S2)
9D003D38  24020001   ADDIU V0, ZERO, 1
9D003D3C  1000FFAF   BEQ ZERO, ZERO, 0x9D003BFC
9D003D40  A3828035   SB V0, -32715(GP)
9D003D44  26310578   ADDIU S1, S1, 1400
9D003D48  1000FFD5   BEQ ZERO, ZERO, 0x9D003CA0
9D003D4C  24040001   ADDIU A0, ZERO, 1
9D003D50  1000FFAA   BEQ ZERO, ZERO, 0x9D003BFC
9D003D54  2411FF88   ADDIU S1, ZERO, -120
9D003D58  1000FFA8   BEQ ZERO, ZERO, 0x9D003BFC
9D003D5C  2411FF8A   ADDIU S1, ZERO, -118
9D003D60  3C11A000   LUI S1, -24576
9D003D64  2631059C   ADDIU S1, S1, 1436
9D003D68  1000FFCD   BEQ ZERO, ZERO, 0x9D003CA0
9D003D6C  24040002   ADDIU A0, ZERO, 2
9D003D70  1000FFA2   BEQ ZERO, ZERO, 0x9D003BFC
9D003D74  2411FF80   ADDIU S1, ZERO, -128
9D004130  27BDFFD8   ADDIU SP, SP, -40
9D004134  AFBF0024   SW RA, 36(SP)
9D004138  AFB30020   SW S3, 32(SP)
9D00413C  AFB2001C   SW S2, 28(SP)
9D004140  AFB10018   SW S1, 24(SP)
9D004144  14800065   BNE A0, ZERO, 0x9D0042DC
9D004148  AFB00014   SW S0, 20(SP)
9D00414C  3C12A000   LUI S2, -24576
9D004150  265005C0   ADDIU S0, S2, 1472
9D004154  9202000A   LBU V0, 10(S0)
9D004158  2403FFFF   ADDIU V1, ZERO, -1
9D00415C  10400061   BEQ V0, ZERO, 0x9D0042E4
9D004160  ACA30000   SW V1, 0(A1)
9D004164  96020008   LHU V0, 8(S0)
9D004168  00E2001B   DIVU A3, V0
9D00416C  004001F4   TEQ V0, ZERO
9D004170  00001010   MFHI V0
9D004174  10E0002A   BEQ A3, ZERO, 0x9D004220
9D004178  00402025   OR A0, V0, ZERO
9D00417C  54400009   BNEL V0, ZERO, 0x9D0041A4
9D004180  2411FF82   ADDIU S1, ZERO, -126
9D004184  8E020038   LW V0, 56(S0)
9D004188  8E03002C   LW V1, 44(S0)
9D00418C  0043102B   SLTU V0, V0, V1
9D004190  1040005A   BEQ V0, ZERO, 0x9D0042FC
9D004194  93828035   LBU V0, -32715(GP)
9D004198  24030001   ADDIU V1, ZERO, 1
9D0041A4  8FBF0024   LW RA, 36(SP)
9D0041C4  3C03A000   LUI V1, -24576
9D0041C8  24630554   ADDIU V1, V1, 1364
9D0041CC  8C680008   LW T0, 8(V1)
9D0041D0  29080002   SLTI T0, T0, 2
9D0041D4  15000014   BNE T0, ZERO, 0x9D004228
9D0041D8  A3808035   SB ZERO, -32715(GP)
9D0041DC  8C64002C   LW A0, 44(V1)
9D0041E0  28840002   SLTI A0, A0, 2
9D0041E4  1480003A   BNE A0, ZERO, 0x9D0042D0
9D0041E8  3C11A000   LUI S1, -24576
9D0041EC  8C640050   LW A0, 80(V1)
9D0041F0  28840002   SLTI A0, A0, 2
9D0041F4  1480003D   BNE A0, ZERO, 0x9D0042EC
9D0041F8  8FBF0024   LW RA, 36(SP)
9D0041FC  2411FF80   ADDIU S1, ZERO, -128
9D004204  8FB30020   LW S3, 32(SP)
9D004208  02201025   OR V0, S1, ZERO
9D00420C  8FB2001C   LW S2, 28(SP)
9D004210  8FB10018   LW S1, 24(SP)
9D004214  8FB00014   LW S0, 20(SP)
9D004218  03E00008   JR RA
9D00421C  27BD0028   ADDIU SP, SP, 40
9D004220  1000FFE0   BEQ ZERO, ZERO, 0x9D0041A4
9D004224  2411FF82   ADDIU S1, ZERO, -126
9D004228  00608825   OR S1, V1, ZERO
9D00422C  00A09825   OR S3, A1, ZERO
9D004230  000428C0   SLL A1, A0, 3
9D004234  00A42021   ADDU A0, A1, A0
9D004238  00042080   SLL A0, A0, 2
9D00423C  3C029D00   LUI V0, -25344
9D004240  00641821   ADDU V1, V1, A0
9D004244  24426A08   ADDIU V0, V0, 27144
9D004248  AC660000   SW A2, 0(V1)
9D00424C  AC670004   SW A3, 4(V1)
9D004250  AC62000C   SW V0, 12(V1)
9D004254  0F4000D6   JAL SYS_INT_Disable
9D00425C  8E030038   LW V1, 56(S0)
9D004264  24630001   ADDIU V1, V1, 1
9D004268  AE030038   SW V1, 56(S0)
9D00426C  0F4000E2   JAL SYS_INT_Restore
9D004274  AE710000   SW S1, 0(S3)
9D004278  92050006   LBU A1, 6(S0)
9D00427C  8E4405C0   LW A0, 1472(S2)
9D004280  0F401FC6   JAL USB_DEVICE_IRPSubmit
9D004284  02203025   OR A2, S1, ZERO
9D004288  14400004   BNE V0, ZERO, USB_DEVICE_CDC_Read::OSAL_CRIT_Enter
9D00428C  00408825   OR S1, V0, ZERO
9D004290  24020001   ADDIU V0, ZERO, 1
9D004294  1000FFC3   BEQ ZERO, ZERO, 0x9D0041A4
9D00429C  0F4000D6   JAL SYS_INT_Disable
9D0042A4  8E030038   LW V1, 56(S0)
9D0042AC  2463FFFF   ADDIU V1, V1, -1
9D0042B0  AE030038   SW V1, 56(S0)
9D0042B4  0F4000E2   JAL SYS_INT_Restore
9D0042BC  2402FFFF   ADDIU V0, ZERO, -1
9D0042C0  AE620000   SW V0, 0(S3)
9D0042C4  24020001   ADDIU V0, ZERO, 1
9D0042C8  1000FFB6   BEQ ZERO, ZERO, 0x9D0041A4
9D0042D0  26310578   ADDIU S1, S1, 1400
9D0042D4  1000FFD5   BEQ ZERO, ZERO, 0x9D00422C
9D0042D8  24040001   ADDIU A0, ZERO, 1
9D0042DC  1000FFB1   BEQ ZERO, ZERO, 0x9D0041A4
9D0042E0  2411FF88   ADDIU S1, ZERO, -120
9D0042E4  1000FFAF   BEQ ZERO, ZERO, 0x9D0041A4
9D0042E8  2411FF8A   ADDIU S1, ZERO, -118
9D0042EC  3C11A000   LUI S1, -24576
9D0042F0  2631059C   ADDIU S1, S1, 1436
9D0042F4  1000FFCD   BEQ ZERO, ZERO, 0x9D00422C
9D0042F8  24040002   ADDIU A0, ZERO, 2
9D0042FC  1000FFA9   BEQ ZERO, ZERO, 0x9D0041A4
9D004300  2411FF80   ADDIU S1, ZERO, -128
9D004BCC  27BDFFE0   ADDIU SP, SP, -32
9D004BD0  AFBF001C   SW RA, 28(SP)
9D004BD4  AFB00018   SW S0, 24(SP)
9D004BD8  93A80034   LBU T0, 52(SP)
9D004BDC  14800014   BNE A0, ZERO, _USB_DEVICE_CDC_Initialization
9D004BE0  8FA90038   LW T1, 56(SP)
9D004BE4  8CC30008   LW V1, 8(A2)
9D004BE8  3C04A000   LUI A0, -24576
9D004BEC  8CCB0004   LW T3, 4(A2)
9D004BF0  8CCA0000   LW T2, 0(A2)
9D004BF4  248205C0   ADDIU V0, A0, 1472
9D004BF8  AC430030   SW V1, 48(V0)
9D004BFC  3C03A000   LUI V1, -24576
9D004C00  24630548   ADDIU V1, V1, 1352
9D004C04  24060004   ADDIU A2, ZERO, 4
9D004C08  AC400034   SW ZERO, 52(V0)
9D004C0C  AC4B0028   SW T3, 40(V0)
9D004C10  AC400038   SW ZERO, 56(V0)
9D004C14  AC4A002C   SW T2, 44(V0)
9D004C18  AC40003C   SW ZERO, 60(V0)
9D004C1C  11060016   BEQ T0, A2, _USB_DEVICE_CDC_Initialization
9D004C20  AC430040   SW V1, 64(V0)
9D004C24  24030005   ADDIU V1, ZERO, 5
9D004C28  51030005   BEQL T0, V1, _USB_DEVICE_CDC_Initialization::_USB_DEVICE_CDC_Initialization
9D004C2C  91230003   LBU V1, 3(T1)
9D004C30  8FBF001C   LW RA, 28(SP)
9D004C34  8FB00018   LW S0, 24(SP)
9D004C38  03E00008   JR RA
9D004C3C  27BD0020   ADDIU SP, SP, 32
9D004C40  91260002   LBU A2, 2(T1)
9D004C44  24070002   ADDIU A3, ZERO, 2
9D004C48  30630003   ANDI V1, V1, 3
9D004C4C  10670018   BEQ V1, A3, _USB_DEVICE_CDC_Initialization::_USB_DEVICE_CDC_Initialization
9D004C50  000621C2   SRL A0, A2, 7
9D004C54  24070003   ADDIU A3, ZERO, 3
9D004C58  1467FFF6   BNE V1, A3, _USB_DEVICE_CDC_Initialization
9D004C5C  8FBF001C   LW RA, 28(SP)
9D004C60  00048040   SLL S0, A0, 1
9D004C64  02048021   ADDU S0, S0, A0
9D004C68  00108040   SLL S0, S0, 1
9D004C6C  26100014   ADDIU S0, S0, 20
9D004C70  10000014   BEQ ZERO, ZERO, _USB_DEVICE_CDC_Initialization
9D004C74  00508021   ADDU S0, V0, S0
9D004C78  91230005   LBU V1, 5(T1)
9D004C7C  24060002   ADDIU A2, ZERO, 2
9D004C80  10660006   BEQ V1, A2, _USB_DEVICE_CDC_Initialization
9D004C84  AC8505C0   SW A1, 1472(A0)
9D004C88  2404000A   ADDIU A0, ZERO, 10
9D004C8C  5064FFE8   BEQL V1, A0, _USB_DEVICE_CDC_Initialization
9D004C90  A0470004   SB A3, 4(V0)
9D004C94  1000FFE7   BEQ ZERO, ZERO, _USB_DEVICE_CDC_Initialization
9D004C98  8FBF001C   LW RA, 28(SP)
9D004C9C  91240006   LBU A0, 6(T1)
9D004CA0  5083FFE3   BEQL A0, V1, _USB_DEVICE_CDC_Initialization
9D004CA4  A0470012   SB A3, 18(V0)
9D004CA8  1000FFE2   BEQ ZERO, ZERO, _USB_DEVICE_CDC_Initialization
9D004CAC  8FBF001C   LW RA, 28(SP)
9D004CB0  24840001   ADDIU A0, A0, 1
9D004CB4  00048040   SLL S0, A0, 1
9D004CB8  02042021   ADDU A0, S0, A0
9D004CBC  00048040   SLL S0, A0, 1
9D004CC0  00508021   ADDU S0, V0, S0
9D004CC4  91220005   LBU V0, 5(T1)
9D004CC8  91230004   LBU V1, 4(T1)
9D004CCC  A2060000   SB A2, 0(S0)
9D004CD0  91270003   LBU A3, 3(T1)
9D004CD4  00021200   SLL V0, V0, 8
9D004CD8  00431025   OR V0, V0, V1
9D004CDC  AFA20010   SW V0, 16(SP)
9D004CE0  00A02025   OR A0, A1, ZERO
9D004CE4  A6020002   SH V0, 2(S0)
9D004CE8  30E70003   ANDI A3, A3, 3
9D004CEC  0F401F51   JAL USB_DEVICE_EndpointEnable
9D004CF0  00002825   OR A1, ZERO, ZERO
9D004CF4  8FBF001C   LW RA, 28(SP)
9D004CF8  24020001   ADDIU V0, ZERO, 1
9D004CFC  A2020004   SB V0, 4(S0)
9D004D00  8FB00018   LW S0, 24(SP)
9D004D04  03E00008   JR RA
9D004D08  27BD0020   ADDIU SP, SP, 32
9D005F00  14800038   BNE A0, ZERO, _USB_DEVICE_CDC_Deinitialization
9D005F04  00000000   NOP
9D005F08  27BDFFE0   ADDIU SP, SP, -32
9D005F0C  3C02A000   LUI V0, -24576
9D005F10  AFB00014   SW S0, 20(SP)
9D005F14  245005C0   ADDIU S0, V0, 1472
9D005F18  9203000A   LBU V1, 10(S0)
9D005F1C  AFB10018   SW S1, 24(SP)
9D005F20  AFBF001C   SW RA, 28(SP)
9D005F24  14600026   BNE V1, ZERO, _USB_DEVICE_CDC_Deinitialization::_USB_DEVICE_CDC_Deinitialization
9D005F28  8C5105C0   LW S1, 1472(V0)
9D005F2C  92020010   LBU V0, 16(S0)
9D005F30  1440001B   BNE V0, ZERO, _USB_DEVICE_CDC_Deinitialization::_USB_DEVICE_CDC_Deinitialization
9D005F34  3C05A000   LUI A1, -24576
9D005F38  92020018   LBU V0, 24(S0)
9D005F3C  14400010   BNE V0, ZERO, _USB_DEVICE_CDC_EndpointDisable
9D005F40  3C05A000   LUI A1, -24576
9D005F44  9202001E   LBU V0, 30(S0)
9D005F48  14400006   BNE V0, ZERO, _USB_DEVICE_CDC_Deinitialization
9D005F4C  02202025   OR A0, S1, ZERO
9D005F50  8FBF001C   LW RA, 28(SP)
9D005F54  8FB10018   LW S1, 24(SP)
9D005F58  8FB00014   LW S0, 20(SP)
9D005F5C  03E00008   JR RA
9D005F60  27BD0020   ADDIU SP, SP, 32
9D005F64  8FBF001C   LW RA, 28(SP)
9D005F68  8FB10018   LW S1, 24(SP)
9D005F6C  8FB00014   LW S0, 20(SP)
9D005F70  3C05A000   LUI A1, -24576
9D005F74  24A505DA   ADDIU A1, A1, 1498
9D005F78  0B401F0E   J _USB_DEVICE_CDC_EndpointDisable
9D005F7C  27BD0020   ADDIU SP, SP, 32
9D005F80  24A505D4   ADDIU A1, A1, 1492
9D005F84  0F401F0E   JAL _USB_DEVICE_CDC_EndpointDisable
9D005F88  02202025   OR A0, S1, ZERO
9D005F8C  9202001E   LBU V0, 30(S0)
9D005F90  1040FFF0   BEQ V0, ZERO, _USB_DEVICE_CDC_Deinitialization
9D005F94  8FBF001C   LW RA, 28(SP)
9D005F98  1000FFF3   BEQ ZERO, ZERO, _USB_DEVICE_CDC_Deinitialization
9D005F9C  02202025   OR A0, S1, ZERO
9D005FA0  24A505CC   ADDIU A1, A1, 1484
9D005FA4  0F401F0E   JAL _USB_DEVICE_CDC_EndpointDisable
9D005FA8  02202025   OR A0, S1, ZERO
9D005FAC  92020018   LBU V0, 24(S0)
9D005FB0  5040FFE5   BEQL V0, ZERO, _USB_DEVICE_CDC_Deinitialization
9D005FB4  9202001E   LBU V0, 30(S0)
9D005FB8  1000FFF1   BEQ ZERO, ZERO, _USB_DEVICE_CDC_EndpointDisable
9D005FBC  3C05A000   LUI A1, -24576
9D005FC0  3C05A000   LUI A1, -24576
9D005FC4  24A505C6   ADDIU A1, A1, 1478
9D005FC8  0F401F0E   JAL _USB_DEVICE_CDC_EndpointDisable
9D005FCC  02202025   OR A0, S1, ZERO
9D005FD0  92020010   LBU V0, 16(S0)
9D005FD4  5040FFD9   BEQL V0, ZERO, _USB_DEVICE_CDC_Deinitialization
9D005FD8  92020018   LBU V0, 24(S0)
9D005FDC  1000FFF0   BEQ ZERO, ZERO, _USB_DEVICE_CDC_Deinitialization::_USB_DEVICE_CDC_Deinitialization
9D005FE0  3C05A000   LUI A1, -24576
9D005FE4  03E00008   JR RA
9D005FE8  00000000   NOP
9D006A08  8C820008   LW V0, 8(A0)
9D006A0C  8C850004   LW A1, 4(A0)
9D006A10  27BDFFD8   ADDIU SP, SP, -40
9D006A14  2C430002   SLTIU V1, V0, 2
9D006A18  AFBF0024   SW RA, 36(SP)
9D006A1C  8C880014   LW T0, 20(A0)
9D006A20  AFA40010   SW A0, 16(SP)
9D006A24  1460001D   BNE V1, ZERO, 0x9D006A9C
9D006A28  AFA50014   SW A1, 20(SP)
9D006A2C  2403FFFD   ADDIU V1, ZERO, -3
9D006A30  10430017   BEQ V0, V1, 0x9D006A90
9D006A34  2403FFFC   ADDIU V1, ZERO, -4
9D006A38  1043001A   BEQ V0, V1, 0x9D006AA4
9D006A3C  2402FFA0   ADDIU V0, ZERO, -96
9D006A40  AFA20018   SW V0, 24(SP)
9D006A44  00081100   SLL V0, T0, 4
9D006A48  00481021   ADDU V0, V0, T0
9D006A4C  3C03A000   LUI V1, -24576
9D006A50  246305C0   ADDIU V1, V1, 1472
9D006A54  00021080   SLL V0, V0, 2
9D006A58  00431021   ADDU V0, V0, V1
9D006A5C  8C430038   LW V1, 56(V0)
9D006A60  8C490020   LW T1, 32(V0)
9D006A64  2463FFFF   ADDIU V1, V1, -1
9D006A68  AC430038   SW V1, 56(V0)
9D006A6C  11200005   BEQ T1, ZERO, 0x9D006A84
9D006A70  27A60010   ADDIU A2, SP, 16
9D006A74  8C470024   LW A3, 36(V0)
9D006A78  24050005   ADDIU A1, ZERO, 5
9D006A7C  0120F809   JALR T1
9D006A80  01002025   OR A0, T0, ZERO
9D006A84  8FBF0024   LW RA, 36(SP)
9D006A88  03E00008   JR RA
9D006A8C  27BD0028   ADDIU SP, SP, 40
9D006A90  2402FF9E   ADDIU V0, ZERO, -98
9D006A94  1000FFEB   BEQ ZERO, ZERO, 0x9D006A44
9D006A98  AFA20018   SW V0, 24(SP)
9D006A9C  1000FFE9   BEQ ZERO, ZERO, 0x9D006A44
9D006AA0  AFA00018   SW ZERO, 24(SP)
9D006AA4  2402FF9F   ADDIU V0, ZERO, -97
9D006AA8  1000FFE6   BEQ ZERO, ZERO, 0x9D006A44
9D006AAC  AFA20018   SW V0, 24(SP)
9D006AB0  8C820008   LW V0, 8(A0)
9D006AB4  8C850004   LW A1, 4(A0)
9D006AB8  27BDFFD8   ADDIU SP, SP, -40
9D006ABC  2C430002   SLTIU V1, V0, 2
9D006AC0  AFBF0024   SW RA, 36(SP)
9D006AC4  8C880014   LW T0, 20(A0)
9D006AC8  AFA40010   SW A0, 16(SP)
9D006ACC  1460001D   BNE V1, ZERO, 0x9D006B44
9D006AD0  AFA50014   SW A1, 20(SP)
9D006AD4  2403FFFD   ADDIU V1, ZERO, -3
9D006AD8  10430017   BEQ V0, V1, 0x9D006B38
9D006ADC  2403FFFC   ADDIU V1, ZERO, -4
9D006AE0  1043001A   BEQ V0, V1, 0x9D006B4C
9D006AE4  2402FFA0   ADDIU V0, ZERO, -96
9D006AE8  AFA20018   SW V0, 24(SP)
9D006AEC  00081900   SLL V1, T0, 4
9D006AF0  00681821   ADDU V1, V1, T0
9D006AF4  3C02A000   LUI V0, -24576
9D006AF8  00031880   SLL V1, V1, 2
9D006AFC  244205C0   ADDIU V0, V0, 1472
9D006B00  00431021   ADDU V0, V0, V1
9D006B04  8C430034   LW V1, 52(V0)
9D006B08  8C490020   LW T1, 32(V0)
9D006B0C  2463FFFF   ADDIU V1, V1, -1
9D006B10  AC430034   SW V1, 52(V0)
9D006B14  11200005   BEQ T1, ZERO, 0x9D006B2C
9D006B18  27A60010   ADDIU A2, SP, 16
9D006B1C  8C470024   LW A3, 36(V0)
9D006B20  24050004   ADDIU A1, ZERO, 4
9D006B24  0120F809   JALR T1
9D006B28  01002025   OR A0, T0, ZERO
9D006B2C  8FBF0024   LW RA, 36(SP)
9D006B30  03E00008   JR RA
9D006B34  27BD0028   ADDIU SP, SP, 40
9D006B38  2402FF9E   ADDIU V0, ZERO, -98
9D006B3C  1000FFEB   BEQ ZERO, ZERO, 0x9D006AEC
9D006B40  AFA20018   SW V0, 24(SP)
9D006B44  1000FFE9   BEQ ZERO, ZERO, 0x9D006AEC
9D006B48  AFA00018   SW ZERO, 24(SP)
9D006B4C  2402FF9F   ADDIU V0, ZERO, -97
9D006B50  1000FFE6   BEQ ZERO, ZERO, 0x9D006AEC
9D006B54  AFA20018   SW V0, 24(SP)
9D006B58  14800007   BNE A0, ZERO, _USB_DEVICE_CDC_ControlTransferHandler
9D006B5C  2402000E   ADDIU V0, ZERO, 14
9D006B60  10A20016   BEQ A1, V0, _USB_DEVICE_CDC_ControlTransferHandler
9D006B64  2402000F   ADDIU V0, ZERO, 15
9D006B68  10A2000C   BEQ A1, V0, _USB_DEVICE_CDC_ControlTransferHandler
9D006B6C  2402000D   ADDIU V0, ZERO, 13
9D006B70  10A20003   BEQ A1, V0, _USB_DEVICE_CDC_ControlTransferHandler::_USB_DEVICE_CDC_ControlTransferHandler
9D006B74  3C02A000   LUI V0, -24576
9D006B78  03E00008   JR RA
9D006B7C  00000000   NOP
9D006B80  244205C0   ADDIU V0, V0, 1472
9D006B84  8C590020   LW T9, 32(V0)
9D006B88  1320FFFB   BEQ T9, ZERO, _USB_DEVICE_CDC_ControlTransferHandler
9D006B8C  00003025   OR A2, ZERO, ZERO
9D006B90  8C470024   LW A3, 36(V0)
9D006B94  03200008   JR T9
9D006B98  24050008   ADDIU A1, ZERO, 8
9D006B9C  3C02A000   LUI V0, -24576
9D006BA0  244205C0   ADDIU V0, V0, 1472
9D006BA4  8C590020   LW T9, 32(V0)
9D006BA8  1320FFF3   BEQ T9, ZERO, _USB_DEVICE_CDC_ControlTransferHandler
9D006BAC  00003025   OR A2, ZERO, ZERO
9D006BB0  8C470024   LW A3, 36(V0)
9D006BB4  03200008   JR T9
9D006BB8  24050007   ADDIU A1, ZERO, 7
9D006BBC  90C20000   LBU V0, 0(A2)
9D006BC0  3C05A000   LUI A1, -24576
9D006BC4  30420020   ANDI V0, V0, 32
9D006BC8  10400008   BEQ V0, ZERO, _USB_DEVICE_CDC_ControlTransferHandler
9D006BCC  8CA405C0   LW A0, 1472(A1)
9D006BD0  90C20001   LBU V0, 1(A2)
9D006BD4  2C430002   SLTIU V1, V0, 2
9D006BD8  14600006   BNE V1, ZERO, _USB_DEVICE_CDC_ControlTransferHandler
9D006BDC  2442FFE0   ADDIU V0, V0, -32
9D006BE0  2C420004   SLTIU V0, V0, 4
9D006BE4  14400004   BNE V0, ZERO, _USB_DEVICE_CDC_ControlTransferHandler
9D006BE8  24A505C0   ADDIU A1, A1, 1472
9D006BEC  0B401C56   J USB_DEVICE_ControlStatus
9D006BF0  24050001   ADDIU A1, ZERO, 1
9D006BF4  24A505C0   ADDIU A1, A1, 1472
9D006BF8  0B401B7E   J _USB_DEVICE_CDC_ACMSetUpPacketHandler
9D006BFC  00002025   OR A0, ZERO, ZERO
9D006C00  2482FFFF   ADDIU V0, A0, -1
9D007C38  27BDFFE0   ADDIU SP, SP, -32
9D007C48  00A08025   OR S0, A1, ZERO
9D007C4C  90A50000   LBU A1, 0(A1)
9D007C50  0F401FD3   JAL USB_DEVICE_IRPCancelAll
9D007C54  00808825   OR S1, A0, ZERO
9D007C58  92050000   LBU A1, 0(S0)
9D007C5C  0F401FB9   JAL USB_DEVICE_EndpointDisable
9D007C60  02202025   OR A0, S1, ZERO
9D007C64  8FBF001C   LW RA, 28(SP)
9D007C68  A2000004   SB ZERO, 4(S0)
9D007C6C  8FB10018   LW S1, 24(SP)
9D007C70  8FB00014   LW S0, 20(SP)
9D007C74  03E00008   JR RA
9D007C78  27BD0020   ADDIU SP, SP, 32
9D007E3C  14800009   BNE A0, ZERO, 0x9D007E64
9D007E40  00000000   NOP
9D007E44  10A00009   BEQ A1, ZERO, 0x9D007E6C
9D007E48  00000000   NOP
9D007E4C  3C02A000   LUI V0, -24576
9D007E50  244205C0   ADDIU V0, V0, 1472
9D007E54  AC450020   SW A1, 32(V0)
9D007E58  AC460024   SW A2, 36(V0)
9D007E5C  03E00008   JR RA
9D007E60  00001025   OR V0, ZERO, ZERO
9D007E64  03E00008   JR RA
9D007E68  2402FF88   ADDIU V0, ZERO, -120
9D007E6C  03E00008   JR RA
9D007E70  2402FF83   ADDIU V0, ZERO, -125
9D0083F4  93828034   LBU V0, -32716(GP)
9D0083F8  14400003   BNE V0, ZERO, 0x9D008408
9D0083FC  24020001   ADDIU V0, ZERO, 1
9D008400  A3828035   SB V0, -32715(GP)
9D008404  A3828034   SB V0, -32716(GP)
9D008408  03E00008   JR RA
9D00840C  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/usb/src/usb_device.c  ----------------------
1:                   /**************************************************************************
2:                    USB Device Layer Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                       
7:                     File Name:
8:                       usb_device.c
9:                       
10:                    Summary:
11:                      This file contains implementations of both private and public functions
12:                      of the USB Device Layer.
13:                      
14:                    Description:
15:                      This file contains the USB device layer implementation.
16:                  **************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
21:                  *
22:                  * Subject to your compliance with these terms, you may use Microchip software
23:                  * and any derivatives exclusively with Microchip products. It is your
24:                  * responsibility to comply with third party license terms applicable to your
25:                  * use of third party software (including open source software) that may
26:                  * accompany Microchip software.
27:                  *
28:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                  * PARTICULAR PURPOSE.
32:                  *
33:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                   *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  #include <stdlib.h>
44:                  #include <stdint.h>
45:                  #include <stdbool.h>
46:                  
47:                  #include "usb/src/usb_external_dependencies.h"
48:                  #include "usb/usb_common.h"
49:                  #include "usb/usb_chapter_9.h"
50:                  #include "usb/usb_device.h"
51:                  #include "usb/src/usb_device_function_driver.h"
52:                  
53:                  
54:                  #include "usb/src/usb_device_local.h"
55:                  #include "driver/usb/drv_usb.h"
56:                  
57:                  /**********************************
58:                   * Device layer instance objects.
59:                   *********************************/
60:                  static USB_DEVICE_OBJ usbDeviceInstance[USB_DEVICE_INSTANCES_NUMBER];
61:                  
62:                  /*************************************
63:                   * Device layer endpoint constants. 
64:                   *************************************/
65:                  static const USB_ENDPOINT controlEndpointTx = 0x80;
66:                  static const USB_ENDPOINT controlEndpointRx  = 0x00;
67:                  
68:                  // *****************************************************************************
69:                  // *****************************************************************************
70:                  // Section: USB Device Layer System Interface functions.
71:                  // *****************************************************************************
72:                  // *****************************************************************************
73:                  
74:                  // ******************************************************************************
75:                  /* Function:
76:                      SYS_MODULE_OBJ USB_DEVICE_Initialize
77:                      (
78:                          const SYS_MODULE_INDEX index, 
79:                          const SYS_MODULE_INIT * const initData
80:                      )
81:                  
82:                    Summary:
83:                      Initializes the required USB device layer state machines.
84:                  
85:                    Description:
86:                      This function initializes the required state machines of the USB device
87:                      layer.
88:                  
89:                    Remarks:
90:                      Refer to usb_device.h for usage information.
91:                  */
92:                  
93:                  SYS_MODULE_OBJ USB_DEVICE_Initialize
94:                  (
95:                      const SYS_MODULE_INDEX index, 
96:                      const SYS_MODULE_INIT * const initData
97:                  )
98:                  {
99:                      USB_DEVICE_INIT *deviceInit;
100:                     USB_DEVICE_OBJ* usbDeviceThisInstance;
101:                     USB_DEVICE_IRP * irpEp0Rx;
102:                     USB_DEVICE_IRP * irpEp0Tx;
103:                     uint8_t count;
104:                     USB_DEVICE_FUNCTION_DRIVER * driver;
105:                     USB_DEVICE_FUNCTION_REGISTRATION_TABLE * funcRegTable;
106:                          
107:                     /* Copy init data to local variable. */
108:                     deviceInit = (USB_DEVICE_INIT *)initData;
109:                     
110:                     /* Make sure the index is with in range. */
111:                     if(index >= USB_DEVICE_INSTANCES_NUMBER)
112:                     {
113:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid index value");
114:                         return (SYS_MODULE_OBJ_INVALID);
115:                     }
116:                     
117:                     /* Make sure that initData is not NULL. */
118:                     if(deviceInit == NULL)
119:                     {
120:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Initialization data is NULL");
121:                         return (SYS_MODULE_OBJ_INVALID);
122:                     }
123:                     
124:                     /* Make sure that the USB Device Master Descriptor is valid */
125:                     if(deviceInit->usbMasterDescriptor == NULL)
126:                     {
127:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: USB Master Descriptor table is NULL");
128:                         return (SYS_MODULE_OBJ_INVALID);
129:                     }
130:                     
131:                     /* Get this instance of USB device layer. */
132:                     usbDeviceThisInstance = &usbDeviceInstance[index];
133:                 
134:                     /* Initialize this instance */        
135:                     usbDeviceThisInstance->usbDeviceInstanceState = SYS_STATUS_BUSY;
136:                 
137:                     /* Save the "self" index for future use */    
138:                     usbDeviceThisInstance->usbDevLayerIndex = index;
139:                     
140:                     /* Set the device state to detached.*/
141:                     usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_DETACHED;
142:                     
143:                     /* Initialize the instance structure. */
144:                     usbDeviceThisInstance->ptrMasterDescTable           = deviceInit->usbMasterDescriptor;
145:                     usbDeviceThisInstance->registeredFuncDriverCount    = deviceInit->registeredFuncCount;
146:                     usbDeviceThisInstance->registeredFuncDrivers        = deviceInit->registeredFunctions;
147:                     
148:                     /* Get the user configured speed */
149:                     usbDeviceThisInstance->usbDeviceStatusStruct.usbConfiguredSpeed = deviceInit->deviceSpeed; 
150:                 
151:                     /* Initialize remote wakeup to disabled */
152:                     usbDeviceThisInstance->remoteWakeupStatus = USB_DEVICE_REMOTE_WAKEUP_DISABLED;
153:                 
154:                     /* Initialize power source to bus power */
155:                     usbDeviceThisInstance->usbDeviceStatusStruct.powerState = USB_DEVICE_POWER_STATE_BUS_POWERED;
156:                     
157:                     /* Reset set address flag.*/
158:                     usbDeviceThisInstance->usbDeviceStatusStruct.setAddressPending = false;
159:                     
160:                     /* Reset Test mode flag.*/
161:                     usbDeviceThisInstance->usbDeviceStatusStruct.testModePending = false;
162:                     
163:                     /* Initialize the RX IRP */
164:                     irpEp0Rx            = &usbDeviceThisInstance->irpEp0Rx;
165:                     irpEp0Rx->data      = usbDeviceThisInstance->ep0RxBuffer;
166:                     irpEp0Rx->size      = USB_DEVICE_EP0_BUFFER_SIZE;
167:                     irpEp0Rx->flags     = USB_DEVICE_IRP_FLAG_DATA_COMPLETE;
168:                     irpEp0Rx->status    = USB_DEVICE_IRP_STATUS_COMPLETED;
169:                     irpEp0Rx->callback  = &_USB_DEVICE_Ep0ReceiveCompleteCallback;
170:                     irpEp0Rx->userData  = (uintptr_t)usbDeviceThisInstance;
171:                 
172:                     /* Initialize the TX IRP */
173:                     irpEp0Tx            = &usbDeviceThisInstance->irpEp0Tx;
174:                     irpEp0Tx->callback  = &_USB_DEVICE_Ep0TransmitCompleteCallback;
175:                     irpEp0Tx->userData  = (uintptr_t)usbDeviceThisInstance;
176:                     irpEp0Tx->flags     = USB_DEVICE_IRP_FLAG_DATA_COMPLETE;
177:                 
178:                     /* Device is not suspended */
179:                     usbDeviceThisInstance->usbDeviceStatusStruct.isSuspended = false;
180:                 
181:                     /* Set the task state to opening the USB driver */
182:                     usbDeviceThisInstance->taskState = USB_DEVICE_TASK_STATE_OPENING_USBCD;
183:                 
184:                     /* Get a pointer to the driver interface */
185:                     usbDeviceThisInstance->driverInterface = (DRV_USB_DEVICE_INTERFACE *)(deviceInit->usbDriverInterface);
186:                     usbDeviceThisInstance->driverIndex = deviceInit->driverIndex;
187:                 
188:                     /* Initialize Endpoint Q size */ 
189:                     _USB_DEVICE_Initialize_Endpoint_Q(index, deviceInit->queueSizeEndpointRead, deviceInit->queueSizeEndpointWrite);
190:                 
191:                     /* Create Mutex for Endpoint Read Write */
192:                     _USB_DEVICE_EndpointMutexCreate (usbDeviceThisInstance);
193:                 
194:                     funcRegTable    = usbDeviceThisInstance->registeredFuncDrivers;
195:                 
196:                     for(count = 0; count < usbDeviceThisInstance->registeredFuncDriverCount; count++ )
197:                     {
198:                         /* The global intialize function of each registered function driver is
199:                          * called once when the device layer is initialized. This allows the
200:                          * function driver to create any mutexes once when the device stack is
201:                          * initialized. This happens only once. */
202:                 
203:                         driver = (USB_DEVICE_FUNCTION_DRIVER *)funcRegTable->driver;
204:                 
205:                         if (driver != NULL)
206:                         {
207:                             if(driver->globalInitialize != NULL)
208:                             {
209:                                 driver->globalInitialize();
210:                             }
211:                         }
212:                         funcRegTable++;
213:                     }
214:                 
215:                     /* Return the index as the system module object */
216:                     return index;  
217:                 }  
218:                   
219:                 // *****************************************************************************
220:                 /* Function:
221:                     void USB_DEVICE_Attach( USB_DEVICE_HANDLE usbDeviceHandle )
222:                 
223:                   Summary:
224:                     This function will attach the device to the USB.
225:                 
226:                   Description:
227:                     This function will attach the device to the USB. It does this by enabling
228:                     the pull up resistors on the D+ or D- lines. This function should be called
229:                     after the USB device layer has generated the USB_DEVICE_EVENT_POWER_DETECTED
230:                     event.
231:                 
232:                   Returns:
233:                     None.
234:                 
235:                   Remarks:
236:                      Refer to usb_device.h for usage information.
237:                 */
238:                 
239:                 void USB_DEVICE_Attach( USB_DEVICE_HANDLE usbDeviceHandle )
240:                 {
241:                     USB_DEVICE_OBJ* usbClientHandle;
242:                 
243:                     /* Validate the handle */
244:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
245:                 
246:                     if(usbClientHandle == NULL)
247:                     {
248:                         /* Handle is not valid */
249:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
250:                     }
251:                     else
252:                     {
253:                         /* Attach to Host */
254:                         usbClientHandle->driverInterface->deviceAttach(usbClientHandle->usbCDHandle); 
255:                     
256:                         /* Update the USB Device state */
257:                         usbClientHandle->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_POWERED;
258:                     } 
259:                 }
260:                 
261:                 // *****************************************************************************
262:                 /* Function:
263:                     void USB_DEVICE_Detach( USB_DEVICE_HANDLE usbDeviceHandle );
264:                 
265:                   Summary:
266:                     This function will detach the device from the USB. 
267:                 
268:                   Description:
269:                     This function will detach the device from the USB. It does this by disabling
270:                     the pull up resistors on the D+ or D- lines. This function should be called
271:                     when the application wants to disconnect the device from the bus (typically
272:                     to implement a soft detach or switch to host mode operation). It should
273:                     be called when the Device Layer has generated the
274:                     USB_DEVICE_EVENT_POWER_REMOVED event.
275:                 
276:                   Remarks:
277:                     Refer to usb_device.h for usage information.
278:                 */
279:                 
280:                 void USB_DEVICE_Detach( USB_DEVICE_HANDLE usbDeviceHandle )
281:                 {
282:                     USB_DEVICE_OBJ* usbClientHandle;
283:                 
284:                     /* Validate the handle */
285:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
286:                 
287:                     if(usbClientHandle == NULL)
288:                     {
289:                         /* Handle is not valid */
290:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
291:                     }
292:                     else
293:                     {
294:                         /* Detach from the Host */
295:                         usbClientHandle->driverInterface->deviceDetach(usbClientHandle->usbCDHandle); 
296:                     
297:                         /* Clear the suspended state */
298:                         usbClientHandle->usbDeviceStatusStruct.isSuspended = false;
299:                     
300:                         /* Update the USB Device state */
301:                         usbClientHandle->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_DETACHED;
302:                     }  
303:                 }
304:                 
305:                 //******************************************************************************
306:                 /* Function:
307:                     USB_DEVICE_RESULT USB_DEVICE_EndpointEnable
308:                     (
309:                         USB_DEVICE_HANDLE usbDeviceHandle,
310:                         uint8_t interface,
311:                         USB_ENDPOINT_ADDRESS endpoint,
312:                         USB_TRANSFER_TYPE transferType
313:                         size_t size
314:                     );
315:                  
316:                   Summary:
317:                     Enables a device endpoint.
318:                 
319:                   Description:
320:                     This function enables a device endpoint for the specified transfer type and
321:                     size. A Vendor specific device application may typically call this function
322:                     in response to a Set Interface request from the host. Note that Device Layer
323:                     will enable endpoints contained in Alternate Setting 0 of an interface, when
324:                     the host configures the device. If there is only one alternate setting in an
325:                     interface, the application may not need to call the
326:                     USB_DEVICE_EndpointEnable function. 
327:                 
328:                     If the device supports multiple alternate settings in an Interface, the
329:                     device application must then disable an endpoint (if it was enabled) before
330:                     re-enabling it with the new settings.The application can use the
331:                     USB_DEVICE_EndpointIsEnabled function to check the status of the endpoint and
332:                     USB_DEVICE_EndpointDisable function to disable the endpoint. 
333:                 
334:                   Remarks:
335:                     Refer to usb_device.h for usage information.
336:                 */
337:                 
338:                 USB_DEVICE_RESULT USB_DEVICE_EndpointEnable
339:                 (
340:                     USB_DEVICE_HANDLE usbDeviceHandle,
341:                     uint8_t interface,
342:                     USB_ENDPOINT_ADDRESS endpoint,
343:                     USB_TRANSFER_TYPE transferType,
344:                     size_t size
345:                 )
346:                 {
347:                     USB_DEVICE_OBJ* usbClientHandle;
348:                     USB_DEVICE_RESULT result; 
349:                 
350:                     /* Validate the handle */
351:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
352:                 
353:                     if(usbClientHandle == NULL)
354:                     {
355:                         /* Handle is not valid */
356:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
357:                         result = USB_DEVICE_RESULT_ERROR_ENDPOINT_INVALID; 
358:                     }
359:                     else
360:                     {
361:                         /* Enable the endpoint */
362:                         result = (USB_DEVICE_RESULT)usbClientHandle->driverInterface->deviceEndpointEnable(usbClientHandle->usbCDHandle, endpoint, transferType, size);
363:                     }
364:                     
365:                     return result; 
366:                 }
367:                 
368:                 //******************************************************************************
369:                 /* Function:
370:                     USB_DEVICE_RESULT USB_DEVICE_EndpointDisable
371:                     (
372:                         USB_DEVICE_HANDLE usbDeviceHandle,
373:                         USB_ENDPOINT_ADDRESS endpoint,
374:                     );
375:                  
376:                   Summary:
377:                     Disables a device endpoint.
378:                 
379:                   Description:
380:                     This function disables a device endpoint. The application may need to
381:                     disable the endpoint when it want to change the endpoint characteristics.
382:                     This could happen when the device features interfaces with multiple
383:                     alternate settings.  If such cases, the host may request the device to
384:                     switch to specific alternate setting by sending the Set Interface request.
385:                     The device application must then disable the endpoint (if it was enabled)
386:                     before re-enabling it with the new settings.The application can use the
387:                     USB_DEVICE_EndpointIsEnabled function to check the status of the endpoint and
388:                     USB_DEVICE_EndpointEnable function to enable the endpoint. 
389:                 
390:                   Remarks:
391:                     Refer to usb_device.h for usage information.
392:                 */
393:                 
394:                 USB_DEVICE_RESULT USB_DEVICE_EndpointDisable
395:                 (
396:                     USB_DEVICE_HANDLE usbDeviceHandle,
397:                     USB_ENDPOINT_ADDRESS endpoint
398:                 )
399:                 {
400:                     USB_DEVICE_OBJ* usbClientHandle;
401:                     USB_DEVICE_RESULT result; 
402:                 
403:                     /* Validate the handle */
404:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
405:                 
406:                     if(usbClientHandle == NULL)
407:                     {
408:                         /* Handle is not valid */
409:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
410:                         result = USB_DEVICE_RESULT_ERROR_ENDPOINT_INVALID; 
411:                     }
412:                     else
413:                     {
414:                         /* Disable the Endpoint */
415:                         result = (USB_DEVICE_RESULT)usbClientHandle->driverInterface->deviceEndpointDisable(usbClientHandle->usbCDHandle, endpoint);
416:                     }
417:                     
418:                     return result; 
419:                 }
420:                 
421:                 //******************************************************************************
422:                 /* Function:
423:                     bool USB_DEVICE_EndpointIsEnabled
424:                     (
425:                         USB_DEVICE_HANDLE usbDeviceHandle,
426:                         USB_ENDPOINT_ADDRESS endpoint,
427:                     );
428:                  
429:                   Summary:
430:                     Returns true if the endpoint is enabled.
431:                 
432:                   Description:
433:                     This function returns true if the endpoint is enabled. The application can
434:                     use this function when handling Set Interface requests in case of Vendor or
435:                     Custom USB devices.
436:                 
437:                   Remarks:
438:                     Refer to usb_device.h for usage information.
439:                 */
440:                 
441:                 bool USB_DEVICE_EndpointIsEnabled
442:                 (
443:                     USB_DEVICE_HANDLE usbDeviceHandle,
444:                     USB_ENDPOINT_ADDRESS endpoint
445:                 )
446:                 {
447:                     USB_DEVICE_OBJ* usbClientHandle;
448:                     bool result;
449:                     
450:                     /* Validate the handle */
451:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
452:                 
453:                     if(usbClientHandle == NULL)
454:                     {
455:                         /* Handle is not valid */
456:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
457:                         result = false; 
458:                     }
459:                     else
460:                     {
461:                         /* Check if the endpoint is enabled */
462:                         result = usbClientHandle->driverInterface->deviceEndpointIsEnabled(usbClientHandle->usbCDHandle, endpoint); 
463:                     }
464:                     
465:                     return result; 
466:                 }
467:                 
468:                 // *****************************************************************************
469:                 /* Function:
470:                     void USB_DEVICE_EndpointStall
471:                     (
472:                         USB_DEVICE_HANDLE usbDeviceHandle,
473:                         USB_ENDPOINT_ADDRESS endpoint
474:                     )
475:                 
476:                   Summary:
477:                     This function stalls an endpoint in the specified direction.
478:                 
479:                   Description:
480:                     This function stalls an endpoint in the specified direction.
481:                 
482:                   Remarks:
483:                     Refer to usb_device.h for usage information.
484:                 */
485:                 
486:                 void USB_DEVICE_EndpointStall 
487:                 (
488:                     USB_DEVICE_HANDLE usbDeviceHandle, 
489:                     USB_ENDPOINT_ADDRESS endpoint
490:                 )
491:                 {
492:                     USB_DEVICE_OBJ* usbClientHandle;
493:                 
494:                     /* Validate the handle */
495:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
496:                 
497:                     if(usbClientHandle == NULL)
498:                     {
499:                         /* Handle is not valid */
500:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
501:                     }
502:                     else
503:                     {
504:                         /* Stall the endpoint */
505:                         usbClientHandle->driverInterface->deviceEndpointStall(usbClientHandle->usbCDHandle, endpoint); 
506:                     }
507:                 }
508:                 
509:                 // *****************************************************************************
510:                 /* Function:
511:                     void USB_DEVICE_EndpointStallClear
512:                     (
513:                         USB_DEVICE_HANDLE usbDeviceHandle,
514:                         USB_ENDPOINT_ADDRESS endpoint
515:                     )
516:                 
517:                   Summary:
518:                     This function clears the stall on an endpoint in the specified direction.
519:                 
520:                   Description:
521:                     This function clear the stall on an endpoint in the specified direction. 
522:                 
523:                   Remarks:
524:                     Refer to usb_device.h for usage information.
525:                 */
526:                 
527:                 void USB_DEVICE_EndpointStallClear 
528:                 (
529:                     USB_DEVICE_HANDLE usbDeviceHandle, 
530:                     USB_ENDPOINT_ADDRESS endpoint
531:                 )
532:                 {
533:                     USB_DEVICE_OBJ* usbClientHandle;
534:                 
535:                     /* Validate the handle */
536:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
537:                 
538:                     if(usbClientHandle == NULL)
539:                     {
540:                         /* Handle is not valid */
541:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
542:                     }
543:                     else
544:                     { 
545:                         /* Clear endpoint stall condition */
546:                         usbClientHandle->driverInterface->deviceEndpointStallClear(usbClientHandle->usbCDHandle, endpoint); 
547:                     }
548:                 }
549:                 
550:                 // *****************************************************************************
551:                 /* Function:
552:                     bool USB_DEVICE_EndpointIsStalled
553:                     (
554:                         USB_DEVICE_HANDLE usbDeviceHandle,
555:                         USB_ENDPOINT_ADDRESS endpoint
556:                     )
557:                 
558:                   Summary:
559:                     This function returns the stall status of the specified endpoint and
560:                     direction.
561:                 
562:                   Description:
563:                     This function returns the stall status of the specified endpoint and
564:                     direction.
565:                 
566:                   Remarks:
567:                     Refer to usb_device.h for usage information.
568:                 */
569:                 
570:                 bool USB_DEVICE_EndpointIsStalled
571:                 (
572:                     USB_DEVICE_HANDLE usbDeviceHandle,
573:                     USB_ENDPOINT_ADDRESS endpoint
574:                 )
575:                 {
576:                     USB_DEVICE_OBJ* usbClientHandle;
577:                     bool result; 
578:                 
579:                     /* Validate the handle */
580:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
581:                 
582:                     if(usbClientHandle == NULL)
583:                     {
584:                         /* Handle is not valid */
585:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
586:                         result = false; 
587:                     }
588:                     else
589:                     {
590:                         /* Check if the endpoint is stalled */
591:                         result = usbClientHandle->driverInterface->deviceEndpointIsStalled(usbClientHandle->usbCDHandle, endpoint); 
592:                     }
593:                     
594:                     return result; 
595:                 }
596:                 
597:                 // *****************************************************************************
598:                 /* Function:
599:                     SYS_STATUS USB_DEVICE_Status ( SYS_MODULE_OBJ object )
600:                 
601:                   Summary:
602:                     Provides the current status of the USB device layer.
603:                 
604:                   Description:
605:                     This function provides the current status of the USB device layer.
606:                 
607:                   Remarks
608:                     Refer to usb_device.h for usage information.
609:                 */
610:                 
611:                 SYS_STATUS USB_DEVICE_Status( SYS_MODULE_OBJ object )
612:                 {
613:                     SYS_MODULE_INDEX index = (SYS_MODULE_INDEX)object;
614:                 
615:                     if(object == SYS_MODULE_OBJ_INVALID)
616:                     {
617:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid System Module Object");
618:                         return(SYS_STATUS_UNINITIALIZED);
619:                     }
620:                 
621:                     return( usbDeviceInstance[index].usbDeviceInstanceState );
622:                 }
623:                 
624:                 // *****************************************************************************
625:                 /* Function:
626:                     bool USB_DEVICE_IsSuspended( USB_DEVICE_HANDLE usbDeviceHandle )
627:                 
628:                   Summary:
629:                     Returns true if the device is in a suspended state.
630:                 
631:                   Description:
632:                     This function returns true if the device is presently in suspended state.
633:                 
634:                   Remarks:
635:                     Refer to usb_device.h for usage information.
636:                 */
637:                 
638:                 bool USB_DEVICE_IsSuspended( USB_DEVICE_HANDLE usbDeviceHandle )
639:                 {
640:                     USB_DEVICE_OBJ* usbClientHandle;
641:                     bool result; 
642:                 
643:                     /* Validate the handle */
644:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
645:                 
646:                     if(usbClientHandle == NULL)
647:                     {
648:                        /* Handle is not valid */
649:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
650:                        result = false; 
651:                     }
652:                     else
653:                     {
654:                         result = usbClientHandle->usbDeviceStatusStruct.isSuspended; 
655:                     }
656:                     
657:                     return result;  
658:                 }
659:                 
660:                 // *****************************************************************************
661:                 /* Function:
662:                     USB_DEVICE_STATE USB_DEVICE_StateGet( USB_DEVICE_HANDLE usbDeviceHandle )
663:                 
664:                   Summary:
665:                     Returns the current state of the USB device.
666:                 
667:                   Description:
668:                     This function returns the current state of the USB device, as described in
669:                     Chapter 9 of the USB 2.0 Specification.
670:                 
671:                   Remarks:
672:                     Refer to usb_device.h for usage information.
673:                 */
674:                 
675:                 USB_DEVICE_STATE USB_DEVICE_StateGet( USB_DEVICE_HANDLE usbDeviceHandle )
676:                 {
677:                     USB_DEVICE_OBJ* usbClientHandle;
678:                     USB_DEVICE_STATE result; 
679:                 
680:                     /* Validate the handle */
681:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
682:                 
683:                     if(usbClientHandle == NULL)
684:                     {
685:                        /* Handle is not valid */
686:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
687:                        result = USB_DEVICE_STATE_DETACHED; 
688:                     }
689:                     else
690:                     {
691:                         result = usbClientHandle->usbDeviceStatusStruct.usbDeviceState;
692:                     }
693:                     return result; 
694:                 }
695:                     
696:                 
697:                 // *****************************************************************************
698:                 /* Function:
699:                     void USB_DEVICE_Deinitialize ( SYS_MODULE_OBJ usbDeviceobj)
700:                 
701:                   Summary:
702:                     De initializes the specified instance of the USB device layer.
703:                 
704:                   Description:
705:                     This function de initializes the specified instance of the USB device layer,
706:                     disabling its operation (and any hardware) and invalidates all of the
707:                     internal data.
708:                 
709:                   Remarks:
710:                     Refer to usb_device.h for usage information.
711:                 */
712:                 
713:                 void USB_DEVICE_Deinitialize ( SYS_MODULE_OBJ usbDeviceObj )
714:                 {
715:                     USB_DEVICE_OBJ * usbDeviceThisInstance;
716:                     SYS_MODULE_INDEX index = (SYS_MODULE_INDEX)usbDeviceObj;
717:                 
718:                     /* Check if we have a valid system module object */
719:                     if(usbDeviceObj == SYS_MODULE_OBJ_INVALID)
720:                     {
721:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid System Module Object");
722:                         return;
723:                     }
724:                 
725:                     /* In this release of the device stack, we really dont do much in the
726:                      * deinitialize function, as we dont expect the USB Device Layer to be
727:                      * deinitialized in a typical application. */
728:                 
729:                     usbDeviceThisInstance = ( USB_DEVICE_OBJ *)&usbDeviceInstance[index];
730:                 
731:                     /* Invalidate the object */
732:                     usbDeviceThisInstance->usbDeviceInstanceState =  SYS_STATUS_UNINITIALIZED;
733:                 }
734:                  
735:                 // *****************************************************************************
736:                 /* Function:
737:                     void USB_DEVICE_Tasks( SYS_MODULE_OBJ devLayerObj )
738:                 
739:                   Summary:
740:                     Calls all USB device layer tasks.
741:                 
742:                   Description:
743:                     This function internally calls all USB Device layer tasks.
744:                 
745:                   Remarks:
746:                     Refer to usb_device.h for usage information.
747:                 */
748:                 
749:                 void USB_DEVICE_Tasks( SYS_MODULE_OBJ devLayerObj )
750:                 {
751:                     uint8_t count;
752:                     USB_SPEED speed;
753:                     uint16_t configValue;
754:                     uint16_t maxFunctionCounts;
755:                     USB_DEVICE_OBJ * usbDeviceThisInstance;
756:                     USB_DEVICE_FUNCTION_REGISTRATION_TABLE * funcRegTable;
757:                     USB_DEVICE_FUNCTION_DRIVER * driver;
758:                 
759:                     /* Assert object is valid. */
760:                     if(devLayerObj == SYS_MODULE_OBJ_INVALID)
761:                     {
762:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: System Module Object is invalid");
763:                         return;
764:                     }
765:                 
766:                     /* Get this instance of USB device layer.*/
767:                     usbDeviceThisInstance = &usbDeviceInstance[devLayerObj];    
768:                 
769:                     /* Proceed only if this instance is in initialized state. */
770:                     if( usbDeviceThisInstance->usbDeviceInstanceState <= SYS_STATUS_UNINITIALIZED )
771:                     {
772:                         /* Instance is not yet initialized. Just do a return. */
773:                         return;
774:                     }
775:                 
776:                     /* Get device layer data. */
777:                     speed           = usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed ;
778:                     configValue     = usbDeviceThisInstance->activeConfiguration ;
779:                     funcRegTable    = usbDeviceThisInstance->registeredFuncDrivers;
780:                     maxFunctionCounts = usbDeviceThisInstance->registeredFuncDriverCount;
781:                 
782:                     /* Run the device layer task routine */
783:                     switch(usbDeviceThisInstance->taskState)
784:                     {
785:                         case USB_DEVICE_TASK_STATE_OPENING_USBCD:
786:                 
787:                             /* Try to open the driver handle. This could fail if the driver is
788:                              * not ready to be opened. */
789:                             usbDeviceThisInstance->usbCDHandle = usbDeviceThisInstance->driverInterface->open( usbDeviceThisInstance->driverIndex, (DRV_IO_INTENT)(DRV_IO_INTENT_EXCLUSIVE|DRV_IO_INTENT_NONBLOCKING|DRV_IO_INTENT_READWRITE));
790:                 
791:                             /* Check if the driver was opened */
792:                             if(usbDeviceThisInstance->usbCDHandle != DRV_HANDLE_INVALID)
793:                             {
794:                                 /* Yes the driver could be opened. Advance the state to the next
795:                                  * state */
796:                                 usbDeviceThisInstance->taskState = USB_DEVICE_TASK_STATE_RUNNING;
797:                 
798:                                 /* Update the USB Device Layer state to indicate that it can be
799:                                  * opened */
800:                                 usbDeviceThisInstance->usbDeviceInstanceState = SYS_STATUS_READY;
801:                             }
802:                 
803:                             break;
804:                 
805:                         case USB_DEVICE_TASK_STATE_RUNNING:
806:                 
807:                             /* In this state, the device layer performs it's actual task, that
808:                              * is calling the tasks routines of the functions drivers. The task
809:                              * routine of a function driver is called in the context of the
810:                              * USB_DEVICE_Tasks() function. The task routine is called only if
811:                              * the current device speed matches the function driver speed
812:                              * mentioned in the function driver registration table, the current
813:                              * configuration matches the configuration value mentioned in the
814:                              * function driver registration table, if the device is not
815:                              * suspended and if the device state is in a configured state. */
816:                 
817:                             for(count = 0; count < maxFunctionCounts; count++ )
818:                             {
819:                                 if( (funcRegTable->speed & speed) && (funcRegTable->configurationValue == configValue))
820:                                 {
821:                                     if((usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState == USB_DEVICE_STATE_CONFIGURED) &&
822:                                             (usbDeviceThisInstance->usbDeviceStatusStruct.isSuspended == false))
823:                                     {
824:                                         /* Get a pointer to the driver function pointer table and
825:                                            call the task routine of the driver. */
826:                                         driver = (USB_DEVICE_FUNCTION_DRIVER *)funcRegTable->driver;
827:                 
828:                                         if (driver != NULL)
829:                                         {
830:                                             if(driver->tasks != NULL)
831:                                             {
832:                                                 driver->tasks( funcRegTable->funcDriverIndex );
833:                                             }
834:                                         }
835:                                     }
836:                                 }
837:                 
838:                                 /* Run the task routine for the next driver in the function
839:                                  * driver registration table */
840:                                 funcRegTable++;
841:                             }
842:                             break;
843:                 
844:                         default:
845:                             break;
846:                     }
847:                 }
848:                 
849:                 // *****************************************************************************
850:                 // *****************************************************************************
851:                 // Section: USB Device Layer Client Interface Functions
852:                 // *****************************************************************************
853:                 // *****************************************************************************
854:                 
855:                 // *****************************************************************************
856:                 /* Function:
857:                     USB_DEVICE_HANDLE USB_DEVICE_Open
858:                     (
859:                         const SYS_MODULE_INDEX index,
860:                         const DRV_IO_INTENT intent
861:                     )
862:                 
863:                   Summary:
864:                     Opens the specific module instance and returns a handle.
865:                 
866:                   Description:
867:                     This function opens the USB device layer for use by any client module and
868:                     provides a handle that must be provided to any of the other device layer
869:                     operations to identify the caller and the instance of the driver/hardware
870:                     module.
871:                 
872:                   Remarks
873:                     Refer to usb_device.h for usage information.
874:                 */
875:                 
876:                 USB_DEVICE_HANDLE USB_DEVICE_Open
877:                 (
878:                     const SYS_MODULE_INDEX index, 
879:                     const DRV_IO_INTENT intent
880:                 )
881:                 {
882:                     USB_DEVICE_OBJ * usbDeviceThisClient;
883:                 
884:                     /* Make sure the index is with in range. */
885:                     if(index >= USB_DEVICE_INSTANCES_NUMBER)
886:                     {
887:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Index is invalid");
888:                         return(USB_DEVICE_HANDLE_INVALID);
889:                     }
890:                 
891:                     /* Check if the instance is initialized. */   
892:                     if(usbDeviceInstance[index].usbDeviceInstanceState != SYS_STATUS_READY)
893:                     {
894:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Device Layer is not ready to be opened");
895:                         return(USB_DEVICE_HANDLE_INVALID);
896:                     }
897:                 
898:                     /* Copy this local client. This implementation of the device layer only
899:                      * allows one client. Hence there is not seperate client object. The client
900:                      * object is really the device layer object. */
901:                     usbDeviceThisClient = &usbDeviceInstance[index];
902:                 
903:                     if(!usbDeviceThisClient->inUse)
904:                     {
905:                         /* We found a free client object */
906:                         usbDeviceThisClient->inUse = true;
907:                 
908:                         /* Update client status */
909:                         usbDeviceThisClient->clientState = USB_DEVICE_CLIENT_STATUS_READY;
910:                 
911:                         /* Get the Client Handle */
912:                         return((USB_DEVICE_HANDLE)usbDeviceThisClient);
913:                     }
914:                       
915:                     /* If we have reached here, then we did not find a free client object */
916:                     SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: No free client objects");
917:                 
918:                     return(USB_DEVICE_HANDLE_INVALID);   
919:                 }    
920:                 
921:                 // *****************************************************************************
922:                 /* Function:
923:                     void USB_DEVICE_Close( DRV_HANDLE usbDevHandle )
924:                 
925:                   Summary:
926:                     Closes an opened instance of the USB device layer.
927:                 
928:                   Description:
929:                     This function closes an opened instance of the USB device layer,
930:                     invalidating the handle.
931:                 
932:                   Remarks:
933:                     Refer to usb_device.h for usage information.
934:                 */
935:                 
936:                 void USB_DEVICE_Close(USB_DEVICE_HANDLE hClient )
937:                 {
938:                     USB_DEVICE_OBJ* usbClientHandle;
939:                     
940:                     /* Validate the handle */
941:                     
942:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(hClient);
943:                     if(usbClientHandle == NULL)
944:                     {
945:                        /* Handle is not valid */
946:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
947:                        return; 
948:                     }
949:                     
950:                     /* Close this client */
951:                     usbClientHandle->clientState = (USB_DEVICE_CLIENT_STATUS)DRV_CLIENT_STATUS_CLOSED;
952:                     usbClientHandle->inUse = false;
953:                 }    
954:                 
955:                 // *****************************************************************************
956:                 /* Function:
957:                     USB_DEVICE_CLIENT_STATUS USB_DEVICE_ClientStatusGet
958:                     (
959:                         USB_DEVICE_HANDLE usbDevHandle
960:                     );
961:                 
962:                   Summary:
963:                     Gets the current client-specific status of the USB device layer.
964:                 
965:                   Description:
966:                     This function gets the client-specific status of the USB device layer
967:                     associated with the specified handle.
968:                 
969:                   Returns:
970:                     Refer to usb_device.h for usage information.
971:                 */
972:                 
973:                 USB_DEVICE_CLIENT_STATUS USB_DEVICE_ClientStatusGet( USB_DEVICE_HANDLE hHandle )
974:                 {
975:                     USB_DEVICE_OBJ * devClientHandle;
976:                 
977:                     devClientHandle = _USB_DEVICE_ClientHandleValidate(hHandle);
978:                 
979:                     if(devClientHandle == NULL)
980:                     {
981:                         return (USB_DEVICE_CLIENT_STATUS_CLOSED);
982:                     }
983:                     
984:                     /* Return the state of the client. */  
985:                     return( devClientHandle->clientState ); 
986:                 }
987:                 // ******************************************************************************
988:                 /* Function:
989:                     void USB_DEVICE_EventCallBackSet
990:                     (
991:                         USB_DEVICE_HANDLE hHandle,
992:                         const USB_DEVICE_EVENT_HANDLER callBackFunc
993:                         uintptr_t context
994:                     );
995:                 
996:                   Summary:
997:                     Sets up the callback function that will be called in case of an
998:                     event from the USB device layer.
999:                 
1000:                  Description:
1001:                    This function sets up the callback function. This callback function 
1002:                    will be called when an event occurs in the USB device layer.
1003:                
1004:                  Remarks:
1005:                    Refer to usb_device.h for usage information.
1006:                */
1007:                
1008:                void USB_DEVICE_EventHandlerSet
1009:                (
1010:                    USB_DEVICE_HANDLE hHandle, 
1011:                    const USB_DEVICE_EVENT_HANDLER callBackFunc,
1012:                    uintptr_t context
1013:                )
1014:                {
1015:                    USB_DEVICE_OBJ* devClientHandle;
1016:                
1017:                    /* Validate the handle */
1018:                
1019:                    devClientHandle = _USB_DEVICE_ClientHandleValidate(hHandle);
1020:                    if(devClientHandle == NULL)
1021:                    {
1022:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid client handle");
1023:                        return;
1024:                    }
1025:                
1026:                    /* Register the callback function. Note that the call back function is
1027:                     * invoked for control transfer events.  */
1028:                    devClientHandle->callBackFunc = callBackFunc;
1029:                    devClientHandle->context = context;
1030:                
1031:                    /* Register a callback with the driver. */
1032:                    devClientHandle->driverInterface->eventHandlerSet(devClientHandle->usbCDHandle, (uintptr_t)devClientHandle, &_USB_DEVICE_EventHandler);
1033:                }   
1034:                
1035:                // ******************************************************************************
1036:                /* Function:
1037:                   uint8_t USB_DEVICE_ActiveConfigurationGet( USB_DEVICE_HANDLE usbDeviceHandle )
1038:                
1039:                  Summary:
1040:                    Informs the client of the current USB device configuration set by the USB
1041:                    host.
1042:                
1043:                  Description:
1044:                    This function returns the current active USB device configuration.
1045:                
1046:                  Precondition:
1047:                    The USB Device Layer must have been initialized and opened before calling this
1048:                    function.
1049:                
1050:                  Remarks:  
1051:                    See usb_device.h for usage information.
1052:                */
1053:                
1054:                uint8_t USB_DEVICE_ActiveConfigurationGet(USB_DEVICE_HANDLE hHandle)
1055:                {
1056:                    USB_DEVICE_OBJ * devClientHandle;
1057:                
1058:                    /* Validate the client handle */
1059:                
1060:                    devClientHandle = _USB_DEVICE_ClientHandleValidate(hHandle);
1061:                    if(devClientHandle == NULL)
1062:                    {
1063:                        /* Client handle is invalid */
1064:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid client handle");
1065:                        return(0);
1066:                    }
1067:                    
1068:                    return(devClientHandle->activeConfiguration);
1069:                }
1070:                
1071:                // *****************************************************************************
1072:                /* Function:
1073:                    USB_SPEED USB_DEVICE_ActiveSpeedGet(USB_DEVICE_HANDLE usbDeviceHandle)
1074:                
1075:                  Summary:
1076:                    Informs the client of the current operation speed of the USB bus.
1077:                
1078:                  Description:
1079:                    The USB device stack supports both high speed and full speed operations.
1080:                    This function returns the current operation speed of the USB bus. This
1081:                    function should be called after the USB_DEVICE_EVENT_RESET event has
1082:                    occurred.
1083:                
1084:                  Precondition:
1085:                    The USB device layer must have been initialized and a valid handle
1086:                    to USB device layer must have been opened.
1087:                  
1088:                  Remarks:  
1089:                    See usb_device.h for usage information.
1090:                */
1091:                
1092:                USB_SPEED USB_DEVICE_ActiveSpeedGet(USB_DEVICE_HANDLE hHandle)
1093:                {
1094:                    USB_DEVICE_OBJ* devClientHandle;
1095:                    
1096:                    /* Validate the handle */
1097:                    devClientHandle = _USB_DEVICE_ClientHandleValidate(hHandle);
1098:                
1099:                    if(devClientHandle == NULL)
1100:                    {
1101:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid Handle");
1102:                        return(USB_SPEED_LOW);
1103:                    }
1104:                
1105:                    /* Return the current speed */
1106:                    return(devClientHandle->usbDeviceStatusStruct.usbSpeed);
1107:                }
1108:                
1109:                // *****************************************************************************
1110:                /* Function:
1111:                    USB_DEVICE_CONTROL_TRANSFER_RESULT USB_DEVICE_ControlSend
1112:                    (
1113:                        USB_DEVICE_HANDLE usbDeviceHandle,
1114:                        uint8_t * data, 
1115:                        size_t length 
1116:                    )
1117:                
1118:                  Summary:
1119:                    Sends data stage of the control transfer from device to host.
1120:                
1121:                  Description:
1122:                    Sends data stage of the control transfer from device to host.
1123:                
1124:                  Remarks:
1125:                    Refer to usb_device.h for usage information.
1126:                */
1127:                
1128:                USB_DEVICE_CONTROL_TRANSFER_RESULT USB_DEVICE_ControlSend
1129:                (
1130:                    USB_DEVICE_HANDLE hClient,
1131:                    void * data, 
1132:                    size_t length 
1133:                )
1134:                {
1135:                    USB_DEVICE_OBJ * usbDeviceThisInstance;
1136:                    USB_DEVICE_IRP * irpHandle;   
1137:                
1138:                    usbDeviceThisInstance = _USB_DEVICE_ClientHandleValidate(hClient);
1139:                
1140:                    /* Validate the client handle */
1141:                    if(usbDeviceThisInstance == NULL)
1142:                    {
1143:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid Client Handle");
1144:                        return(USB_DEVICE_CONTROL_TRANSFER_RESULT_FAILED);
1145:                    }
1146:                
1147:                    /* Get a handle to the TX IRP */
1148:                    irpHandle = &usbDeviceThisInstance->irpEp0Tx;     
1149:                    irpHandle->data = data;
1150:                    irpHandle->size = (unsigned int )length;
1151:                
1152:                    /* The function assumes the control transfer was initiated by the host and
1153:                     * the setup command has been received. controlTransferDataStageSize in such
1154:                     * a case will have the size of the control transfer data stage size. If the
1155:                     * length submitted by application is what the host is expecting, then we
1156:                     * dont have to send a ZLP. If the length is less than the what the host is
1157:                     * expecting then we should send a ZLP. */
1158:                
1159:                    if(length == usbDeviceThisInstance->controlTransferDataStageSize)
1160:                    {
1161:                        /* This means we are sending the amount of data that is required.
1162:                         * So no need to send send ZLP */
1163:                        irpHandle->flags = USB_DEVICE_IRP_FLAG_DATA_PENDING;
1164:                    }
1165:                    else if (length < usbDeviceThisInstance->controlTransferDataStageSize )
1166:                    {
1167:                        /* The length is less than requested. We let the driver manage the
1168:                         * ZLP. */
1169:                        irpHandle->flags = USB_DEVICE_IRP_FLAG_DATA_COMPLETE;
1170:                    }
1171:                
1172:                    /* Submit the IRP to the USBCD */
1173:                    (void)usbDeviceThisInstance->driverInterface->deviceIRPSubmit( usbDeviceThisInstance->usbCDHandle, controlEndpointTx, irpHandle);
1174:                
1175:                    return USB_DEVICE_CONTROL_TRANSFER_RESULT_SUCCESS;
1176:                }
1177:                
1178:                // *****************************************************************************
1179:                /* Function:
1180:                    USB_DEVICE_CONTROL_TRANSFER_RESULT USB_DEVICE_ControlReceive
1181:                    (
1182:                        USB_DEVICE_HANDLE usbDeviceHandle,
1183:                        void * data, 
1184:                        size_t length
1185:                    )
1186:                
1187:                  Summary:
1188:                    Receives data stage of the control transfer from host to device.
1189:                
1190:                  Description:
1191:                    Receives data stage of the control transfer from host to device.
1192:                
1193:                  Remarks:
1194:                    Refer to usb_device.h for usage information.
1195:                */
1196:                
1197:                USB_DEVICE_CONTROL_TRANSFER_RESULT USB_DEVICE_ControlReceive
1198:                (
1199:                    USB_DEVICE_HANDLE handle,
1200:                    void * data, 
1201:                    size_t length
1202:                )
1203:                {
1204:                    USB_DEVICE_CONTROL_TRANSFER_STRUCT * pControlTransfer;
1205:                    USB_DEVICE_OBJ * client;
1206:                
1207:                    /* Validate the client handle */
1208:                    client = _USB_DEVICE_ClientHandleValidate(handle);
1209:                    if(client == NULL)
1210:                    {
1211:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid Client Handle");
1212:                        return(USB_DEVICE_CONTROL_TRANSFER_RESULT_FAILED);
1213:                    }
1214:                
1215:                    /* Get the control transfer object. The device layer is always ready to
1216:                     * receive data from the device. It needs to know however where the received
1217:                     * data should be placed. This is determined by the rxBuffer member of the
1218:                     * control transfer object. */
1219:                    pControlTransfer = &client->controlTransfer;
1220:                    pControlTransfer->rxBuffer = data ;
1221:                    pControlTransfer->rxDataCount = 0;
1222:                    pControlTransfer->expectedRxDataCount = length ;
1223:                
1224:                    /* We are always ready to receive data on endpoint 0. So no need to submit a
1225:                     * IRP */
1226:                    return USB_DEVICE_CONTROL_TRANSFER_RESULT_SUCCESS;
1227:                }
1228:                
1229:                // *****************************************************************************
1230:                /* Function:
1231:                    USB_DEVICE_CONTROL_TRANSFER_RESULT USB_DEVICE_ControlStatus
1232:                    (
1233:                        USB_DEVICE_HANDLE hClient,
1234:                        USB_DEVICE_CONTROL_STATUS status 
1235:                    )
1236:                
1237:                  Summary:
1238:                    Initiates status stage of the control transfer.
1239:                
1240:                  Description:
1241:                    Initiates status stage of the control transfer.
1242:                
1243:                  Remarks:
1244:                    Refer to usb_device.h for usage information.
1245:                */
1246:                
1247:                USB_DEVICE_CONTROL_TRANSFER_RESULT USB_DEVICE_ControlStatus
1248:                (
1249:                    USB_DEVICE_HANDLE handle,
1250:                    USB_DEVICE_CONTROL_STATUS status
1251:                )
1252:                {
1253:                    USB_DEVICE_OBJ * usbDeviceThisInstance;
1254:                    USB_DEVICE_IRP * irpHandle;
1255:                
1256:                    usbDeviceThisInstance = _USB_DEVICE_ClientHandleValidate(handle);
1257:                    if(usbDeviceThisInstance == NULL)
1258:                    {
1259:                        /* Client handle is not valid */
1260:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid Client Handle");
1261:                        return(USB_DEVICE_CONTROL_TRANSFER_RESULT_FAILED);
1262:                    }
1263:                
1264:                    usbDeviceThisInstance->controlTransfer.inProgress = false;
1265:                
1266:                    if(USB_DEVICE_CONTROL_STATUS_ERROR == status)
1267:                    {
1268:                        /* This means the control transfer should be stalled. We stall endpoint
1269:                         * 0 */
1270:                        usbDeviceThisInstance->driverInterface->deviceEndpointStall(usbDeviceThisInstance->usbCDHandle , controlEndpointTx);        
1271:                    }
1272:                    else
1273:                    {
1274:                        /* We must acknowledge the control transfer. This is done by sending a
1275:                         * ZLP */
1276:                        irpHandle = &usbDeviceThisInstance->irpEp0Tx;
1277:                        irpHandle->data = NULL;
1278:                        irpHandle->size = 0;
1279:                
1280:                        (void)usbDeviceThisInstance->driverInterface->deviceIRPSubmit( usbDeviceThisInstance->usbCDHandle, controlEndpointTx, irpHandle);
1281:                    }
1282:                
1283:                    return USB_DEVICE_CONTROL_TRANSFER_RESULT_SUCCESS;
1284:                }
1285:                // *****************************************************************************
1286:                /* Function:
1287:                    void USB_DEVICE_PowerStateSet
1288:                    (
1289:                        USB_DEVICE_HANDLE handle,
1290:                        USB_DEVICE_POWER_STATE state
1291:                    )
1292:                
1293:                  Summary:
1294:                    Sets the power state of the device.
1295:                
1296:                  Description:
1297:                    Sets the power state of the device.
1298:                    
1299:                  Remarks:
1300:                    Refer to usb_device.h for usage information.
1301:                */
1302:                
1303:                void USB_DEVICE_PowerStateSet
1304:                (
1305:                    USB_DEVICE_HANDLE handle,
1306:                    USB_DEVICE_POWER_STATE state
1307:                )
1308:                {
1309:                    USB_DEVICE_OBJ* client;
1310:                
1311:                    /* Validate the client handle */
1312:                
1313:                    client = _USB_DEVICE_ClientHandleValidate(handle);
1314:                    if(client == NULL)
1315:                    {
1316:                        /* Client handle is invalid */
1317:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid Handle");
1318:                        return;
1319:                    }
1320:                
1321:                    /* Store the power state */
1322:                    client->usbDeviceStatusStruct.powerState = state;
1323:                }
1324:                
1325:                // ******************************************************************************
1326:                /* Function:
1327:                    USB_DEVICE_REMOTE_WAKEUP_STATUS USB_DEVICE_RemoteWakeupStatusGet
1328:                    (
1329:                        USB_DEVICE_HANDLE handle
1330:                    )
1331:                
1332:                  Summary:
1333:                    This function returns the status of remote wakeup capability of the device.
1334:                
1335:                  Description:
1336:                    This function returns the status of remote wakeup capability of the device.
1337:                
1338:                  Remarks:
1339:                    Refer to usb_device.h for usage information.
1340:                */
1341:                
1342:                USB_DEVICE_REMOTE_WAKEUP_STATUS USB_DEVICE_RemoteWakeupStatusGet
1343:                (
1344:                    USB_DEVICE_HANDLE handle
1345:                )
1346:                {
1347:                    USB_DEVICE_OBJ* client;
1348:                
1349:                    /* Validate the client handle */
1350:                
1351:                    client = _USB_DEVICE_ClientHandleValidate(handle);
1352:                    if(client == NULL)
1353:                    {
1354:                        /* Client handle is invalid */
1355:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid Handle");
1356:                        return USB_DEVICE_REMOTE_WAKEUP_DISABLED;
1357:                    }
1358:                
1359:                    return (client->remoteWakeupStatus);
1360:                }
1361:                
1362:                // *****************************************************************************
1363:                /* Function:
1364:                    void USB_DEVICE_RemoteWakeupStop ( USB_DEVICE_HANDLE usbDeviceHandle )
1365:                
1366:                  Summary:
1367:                    This function will stop the resume signalling.
1368:                
1369:                  Description:
1370:                    This function will stop the resume signalling. This function should be
1371:                    called after the client has called the USB_DEVICE_RemoteWakeupStart()
1372:                    function.
1373:                
1374:                  Remarks:
1375:                    Refer to usb_device.h for usage information.
1376:                */
1377:                
1378:                void USB_DEVICE_RemoteWakeupStop( USB_DEVICE_HANDLE handle )
1379:                {
1380:                    USB_DEVICE_OBJ* usbDeviceThisInstance;
1381:                
1382:                    /* Validate the device handle */
1383:                    usbDeviceThisInstance = _USB_DEVICE_ClientHandleValidate(handle);
1384:                    if(NULL == usbDeviceThisInstance)
1385:                    {
1386:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer Client Handle is invalid");
1387:                        return;
1388:                    }
1389:                
1390:                    /* Call the driver remote wake up function here */
1391:                    usbDeviceThisInstance->driverInterface->deviceRemoteWakeupStop(usbDeviceThisInstance->usbCDHandle);
1392:                }
1393:                
1394:                // *****************************************************************************
1395:                /* Function:
1396:                    void USB_DEVICE_RemoteWakeupStart( USB_DEVICE_HANDLE usbDeviceHandle )
1397:                
1398:                  Summary:
1399:                    This function will start the resume signalling.
1400:                
1401:                  Description:
1402:                    This function will start the resume signalling on the bus. The client calls
1403:                    this function after it has detected a idle bus (through the
1404:                    USB_DEVICE_EVENT_SUSPENDED event). The remote wakeup feature should have
1405:                    been enabled by the host, before the client can call this function. The
1406:                    client can use the USB_DEVICE_RemoteWakeupStatusGet() function to check if
1407:                    the host has enabled the remote wakeup feature.
1408:                
1409:                  Remarks:
1410:                    Refer to usb_device.h for usage information.
1411:                */
1412:                
1413:                void USB_DEVICE_RemoteWakeupStart( USB_DEVICE_HANDLE usbDeviceHandle )
1414:                {
1415:                    USB_DEVICE_OBJ * usbDeviceThisInstance;
1416:                
1417:                    /* Validate the device handle */
1418:                    usbDeviceThisInstance = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle);
1419:                    if(NULL == usbDeviceThisInstance)
1420:                    {
1421:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer Client Handle is invalid");
1422:                        return;
1423:                    }
1424:                
1425:                    /* Call the driver remote wake up function here */
1426:                    usbDeviceThisInstance->driverInterface->deviceRemoteWakeupStart(usbDeviceThisInstance->usbCDHandle);
1427:                }
1428:                // *****************************************************************************
1429:                // *****************************************************************************
1430:                // Section: USB Device Layer System Interface functions.
1431:                // *****************************************************************************
1432:                // *****************************************************************************
1433:                
1434:                // *****************************************************************************
1435:                /* Function:
1436:                    USB_ERROR USB_DEVICE_IRPSubmit
1437:                    (
1438:                        USB_DEVICE_HANDLE usbDeviceHandle, 
1439:                        USB_ENDPOINT endpointAndDirection, 
1440:                        USB_DEVICE_IRP * irp
1441:                    );
1442:                    
1443:                  Summary:
1444:                    This function submits an I/O Request Packet (IRP) for processing to the
1445:                    Hi-Speed USB Driver.
1446:                	
1447:                  Description:
1448:                    This function submits an I/O Request Packet (IRP) for processing to the USB
1449:                    Driver. The IRP allows a client to send and receive data from the USB Host.
1450:                    The data will be sent or received through the specified endpoint. The direction
1451:                    of the data transfer is indicated by the direction flag in the
1452:                    endpointAndDirection parameter. Submitting an IRP arms the endpoint to
1453:                    either send data to or receive data from the Host.  If an IRP is already
1454:                    being processed on the endpoint, the subsequent IRP submit operation
1455:                    will be queued. The contents of the IRP (including the application buffers)
1456:                    should not be changed until the IRP has been processed.
1457:                	
1458:                  Remarks:
1459:                    Refer to usb_device_function_driver.h for usage information.                                                                          
1460:                */
1461:                
1462:                USB_ERROR USB_DEVICE_IRPSubmit
1463:                (
1464:                    USB_DEVICE_HANDLE usbDeviceHandle, 
1465:                    USB_ENDPOINT endpointAndDirection, 
1466:                    USB_DEVICE_IRP * irp
1467:                )
1468:                {
1469:                    USB_DEVICE_OBJ* usbClientHandle;
1470:                    USB_ERROR result;
1471:                    
1472:                    /* Validate the handle */
1473:                    usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
1474:                
1475:                    if(usbClientHandle == NULL)
1476:                    {
1477:                       /* Handle is not valid */
1478:                       SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
1479:                       result = USB_ERROR_PARAMETER_INVALID; 
1480:                    }
1481:                    else
1482:                    {
1483:                         /* Submit IRP */
1484:                        result = usbClientHandle->driverInterface->deviceIRPSubmit(usbClientHandle->usbCDHandle,endpointAndDirection, irp ); 
1485:                    }
1486:                    
1487:                    return result; 
1488:                }
1489:                
1490:                // **************************************************************************
1491:                /* Function:
1492:                    USB_ERROR USB_DEVICE_IRPCancelAll 
1493:                    (
1494:                        USB_DEVICE_HANDLE usbDeviceHandle,
1495:                        USB_ENDPOINT endpointAndDirection
1496:                    );
1497:                    
1498:                  Summary:
1499:                    This function cancels all IRPs that are queued and in progress at the
1500:                    specified endpoint.
1501:                	
1502:                  Description:
1503:                    This function cancels all IRPs that are queued and in progress at the
1504:                    specified endpoint.
1505:                	
1506:                  Remarks:
1507:                    Refer to usb_device_function_driver.h for usage information.                                                               
1508:                */
1509:                
1510:                USB_ERROR USB_DEVICE_IRPCancelAll 
1511:                (
1512:                    USB_DEVICE_HANDLE usbDeviceHandle,
1513:                    USB_ENDPOINT endpointAndDirection
1514:                )
1515:                {
1516:                    USB_DEVICE_OBJ* usbClientHandle;
1517:                    USB_ERROR result; 
1518:                
1519:                    /* Validate the handle */
1520:                    usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
1521:                
1522:                    if(usbClientHandle == NULL)
1523:                    {
1524:                       /* Handle is not valid */
1525:                       SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
1526:                       result = USB_ERROR_PARAMETER_INVALID; 
1527:                    }
1528:                    else
1529:                    {
1530:                        /* Cancel all IRPs pending on the Endpoint */
1531:                        result = usbClientHandle->driverInterface->deviceIRPCancelAll(usbClientHandle->usbCDHandle,endpointAndDirection); 
1532:                    }
1533:                    
1534:                    return result;  
1535:                }
1536:                
1537:                // **************************************************************************
1538:                /* Function:
1539:                    USB_ERROR USB_DEVICE_IRPCancel
1540:                	(
1541:                		USB_DEVICE_HANDLE usbDeviceHandle,
1542:                		USB_DEVICE_IRP * irp
1543:                	)
1544:                    
1545:                  Summary:
1546:                    This function cancels the specific IRP that are queued and in progress at the
1547:                    specified endpoint.
1548:                	
1549:                  Description:
1550:                    This function attempts to cancel the processing of a queued IRP. An IRP that
1551:                    was in the queue but yet to be processed will be cancelled successfully and
1552:                    the IRP callback function will be called from this function with the
1553:                    USB_DEVICE_IRP_STATUS_ABORTED status. The application can release the data
1554:                    buffer memory used by the IRP when this callback occurs.  If the IRP was in
1555:                    progress (a transaction in on the bus) when the cancel function was called,
1556:                    the IRP will be canceled only when an ongoing or the next transaction has
1557:                    completed. The IRP callback function will then be called in an interrupt
1558:                    context. The application should not release the related data buffer unless
1559:                    the IRP callback has occurred.
1560:                	
1561:                  Remarks:
1562:                    Refer to usb_device_function_driver.h for usage information.
1563:                                                                                  
1564:                */
1565:                
1566:                USB_ERROR USB_DEVICE_IRPCancel
1567:                (
1568:                    USB_DEVICE_HANDLE usbDeviceHandle, 
1569:                    USB_DEVICE_IRP * irp
1570:                )
1571:                {
1572:                    USB_DEVICE_OBJ* usbClientHandle;
1573:                    USB_ERROR result;
1574:                
1575:                    /* Validate the handle */
1576:                    usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
1577:                
1578:                    if(usbClientHandle == NULL)
1579:                    {
1580:                       /* Handle is not valid */
1581:                       SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
1582:                       result = USB_ERROR_PARAMETER_INVALID; 
1583:                    }
1584:                    else
1585:                    {
1586:                        /* Cancel IRP */
1587:                        result = usbClientHandle->driverInterface->deviceIRPCancel(usbClientHandle->usbCDHandle,irp); 
1588:                        
1589:                    }
1590:                  
1591:                    return result; 
1592:                }
1593:                // *****************************************************************************
1594:                // *****************************************************************************
1595:                // Section: USB Device Layer Local Functions
1596:                // *****************************************************************************
1597:                // *****************************************************************************
1598:                
1599:                // ******************************************************************************
1600:                /* Function:
1601:                    void _USB_DEVICE_Ep0ReceiveCompleteCallback( USB_DEVICE_IRP * handle )
1602:                
1603:                  Summary:
1604:                    Control receive complete callback.
1605:                
1606:                  Description:
1607:                    This callback is called when either data/SETUP packet is received
1608:                    on the control endpoint.
1609:                
1610:                  Remarks:
1611:                    This is local function. It should not be used directly by the client.
1612:                */
1613:                
1614:                void _USB_DEVICE_Ep0ReceiveCompleteCallback( USB_DEVICE_IRP * handle )
1615:                {
1616:                    USB_DEVICE_IRP * irpHandle = (USB_DEVICE_IRP *)handle;
1617:                    USB_DEVICE_OBJ * usbDeviceThisInstance;  
1618:                    USB_DEVICE_EVENT controlEvent = USB_DEVICE_EVENT_ERROR;
1619:                    USB_DEVICE_CONTROL_TRANSFER_STRUCT * controlTransfer;
1620:                    void * eventData = NULL;
1621:                
1622:                    /* If the IRP was aborted, there is nothing for us to do */
1623:                    if(irpHandle->status == USB_DEVICE_IRP_STATUS_ABORTED)
1624:                    {
1625:                        return;
1626:                    }
1627:                
1628:                    usbDeviceThisInstance = (USB_DEVICE_OBJ *)irpHandle->userData;
1629:                    controlTransfer = &usbDeviceThisInstance->controlTransfer;
1630:                
1631:                    /* Something is received on EP0. */
1632:                
1633:                    if(irpHandle->status == USB_DEVICE_IRP_STATUS_SETUP)
1634:                    {
1635:                        /* If we have received a SETUP packet, then abort any on-going control
1636:                         * transfer. Reset the control transfer handler back to the device layer
1637:                         * */
1638:                
1639:                        if(controlTransfer->inProgress )
1640:                        {
1641:                            /* Abort any previous transfer */
1642:                            if ( controlTransfer->handler != NULL)
1643:                            {
1644:                                if (controlTransfer->handler == (void (*)(unsigned short, USB_DEVICE_EVENT, void *))usbDeviceThisInstance->callBackFunc)
1645:                                {
1646:                                    /* If the Control transfer handler is Application callback
1647:                                     * for USB Device layer, then invoke the application
1648:                                     * callback function.  */
1649:                
1650:                                    usbDeviceThisInstance->callBackFunc(USB_DEVICE_EVENT_CONTROL_TRANSFER_ABORTED, NULL, usbDeviceThisInstance->context ); 
1651:                                }
1652:                                else
1653:                                {
1654:                                    /* This means the in progress control transfer was initiated
1655:                                     * by a function driver or the device layer it self. */
1656:                                    controlTransfer->handler(controlTransfer->handlerIndex, USB_DEVICE_EVENT_CONTROL_TRANSFER_ABORTED , NULL );
1657:                                }
1658:                            }
1659:                            else
1660:                            {
1661:                                SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Control transfer Handler is NULL" );
1662:                            }
1663:                        }
1664:                
1665:                        /* Mark the control transfer as "in progress". */
1666:                        controlTransfer->inProgress = true;
1667:                
1668:                        /* Now change the transfer handler back to USB device layer handler. We
1669:                         * need to send the SETUP packet event and the SETUP packet to the
1670:                         * device layer */
1671:                        controlTransfer->handler = &_USB_DEVICE_ControlTransferHandler;
1672:                        controlTransfer->handlerIndex = usbDeviceThisInstance->usbDevLayerIndex;
1673:                        controlEvent = USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST; 
1674:                        eventData = usbDeviceThisInstance->ep0RxBuffer;
1675:                
1676:                    }
1677:                    else if( irpHandle->size == 0)
1678:                    {
1679:                        /* ZLP received. This marks the completion of control transfer. Inform
1680:                         * the handler. */
1681:                        controlTransfer->inProgress = false;
1682:                        controlEvent = USB_DEVICE_EVENT_CONTROL_TRANSFER_DATA_SENT;
1683:                        eventData = NULL;
1684:                    }
1685:                    else if( irpHandle->size &&  controlTransfer->inProgress )
1686:                    {
1687:                        /* We are in the data stage of the control transfer.  See if the control
1688:                         * transfer handler was expecting the data. */
1689:                
1690:                        if(controlTransfer->rxDataCount <  controlTransfer->expectedRxDataCount)
1691:                        {
1692:                            /* Copy the RX buffer to control transfer handler given driver
1693:                             * buffer and advance the buffer. Continue the transfer  */
1694:                            memcpy(&usbDeviceThisInstance->controlTransfer.rxBuffer[controlTransfer->rxDataCount], usbDeviceThisInstance->ep0RxBuffer, irpHandle->size );
1695:                            controlTransfer->rxDataCount += irpHandle->size;
1696:                        }
1697:                        
1698:                        /* Now that we have received the data, check if the IRP is completed */
1699:                        if(controlTransfer->rxDataCount >=  controlTransfer->expectedRxDataCount)
1700:                        {
1701:                            /* We have received all the the data that we need. Send an event to
1702:                             * the upper layer */
1703:                            controlEvent = USB_DEVICE_EVENT_CONTROL_TRANSFER_DATA_RECEIVED;
1704:                            eventData = NULL;
1705:                        }
1706:                    }
1707:                
1708:                    if(controlEvent)
1709:                    {
1710:                        /* This means that some type of control transfer event needs to be sent
1711:                         * either to the the device layer or to the function driver or client
1712:                         * driver function driver layer. If a Setup packet was recieved, then
1713:                         * this will always go the device layer first. If this was a data stage
1714:                         * or handshake stage, then entity that was responsible for completing
1715:                         * the control transfer handles the events. */
1716:                
1717:                        if (controlTransfer->handler == (void (*)(unsigned short, USB_DEVICE_EVENT, void *))usbDeviceThisInstance->callBackFunc)
1718:                        {
1719:                            /* If the Control transfer handler is Application callback for USB Device layer,
1720:                             * then invoke the application callback function.  */
1721:                            usbDeviceThisInstance->callBackFunc(controlEvent, eventData, usbDeviceThisInstance->context ); 
1722:                        }
1723:                        else
1724:                        {
1725:                            /* Propagate the event to the control transfer handler */
1726:                            controlTransfer->handler(controlTransfer->handlerIndex, controlEvent , eventData);
1727:                        }
1728:                    }
1729:                
1730:                    usbDeviceThisInstance->irpEp0Rx.size = USB_DEVICE_EP0_BUFFER_SIZE;
1731:                
1732:                    /* Submit IRP to endpoint 0 to receive the next data packet. */
1733:                    (void)usbDeviceThisInstance->driverInterface->deviceIRPSubmit( usbDeviceThisInstance->usbCDHandle, controlEndpointRx , &usbDeviceThisInstance->irpEp0Rx);
1734:                }
1735:                
1736:                // ******************************************************************************
1737:                /* Function:
1738:                    void _USB_DEVICE_Ep0TransmitCompleteCallback( void * handle)
1739:                
1740:                  Summary:
1741:                    EP0 transmit complete callback.
1742:                
1743:                  Description:
1744:                    This function is called by the controller driver after the completing the
1745:                    EP0 transmit.
1746:                
1747:                  Returns:
1748:                    This is local function. It should not be used directly by the client.
1749:                */
1750:                
1751:                void _USB_DEVICE_Ep0TransmitCompleteCallback(USB_DEVICE_IRP * handle)
1752:                {
1753:                    USB_DEVICE_IRP * irpHandle = (USB_DEVICE_IRP *)handle;
1754:                    USB_DEVICE_OBJ * usbDeviceThisInstance;
1755:                    USB_DEVICE_CONTROL_TRANSFER_STRUCT * controlTransfer;
1756:                
1757:                    usbDeviceThisInstance = (USB_DEVICE_OBJ *)irpHandle->userData;
1758:                    controlTransfer = &(usbDeviceThisInstance->controlTransfer);
1759:                    
1760:                    if(irpHandle->status == USB_DEVICE_IRP_STATUS_ABORTED)
1761:                    {
1762:                        return;
1763:                    }
1764:                
1765:                    /* If the device layer had recieved the set address request from the host
1766:                     * and we have now recieved a transmit complete callback, then this means we
1767:                     * have completed the handshake stage of the callback function and now need
1768:                     * to set the device address. */ 
1769:                    if(usbDeviceThisInstance->usbDeviceStatusStruct.setAddressPending)
1770:                    {
1771:                        usbDeviceThisInstance->driverInterface->deviceAddressSet(usbDeviceThisInstance->usbCDHandle, usbDeviceThisInstance->deviceAddress);
1772:                        usbDeviceThisInstance->usbDeviceStatusStruct.setAddressPending = false;
1773:                        
1774:                        /* Update the USB Device state */
1775:                        usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_ADDRESSED;
1776:                    }
1777:                
1778:                    /* Or else, if the host had sent a request to enter test mode, we have
1779:                     * acknowledged that request and now should enter test mode. */
1780:                
1781:                    else if(usbDeviceThisInstance->usbDeviceStatusStruct.testModePending)
1782:                    {
1783:                        /* Set the flag to false and enter test mode */
1784:                        usbDeviceThisInstance->usbDeviceStatusStruct.testModePending = false;
1785:                        usbDeviceThisInstance->driverInterface->deviceTestModeEnter(usbDeviceThisInstance->usbCDHandle, (USB_TEST_MODE_SELECTORS)usbDeviceThisInstance->usbDeviceStatusStruct.testSelector );
1786:                    }
1787:                
1788:                    if(irpHandle->status == USB_DEVICE_IRP_STATUS_COMPLETED)
1789:                    {
1790:                        if( irpHandle->size == 0 )
1791:                        {
1792:                            controlTransfer->inProgress = false;
1793:                        }
1794:                    }
1795:                }
1796:                
1797:                // *****************************************************************************
1798:                /* Function:
1799:                    void _USB_DEVICE_DeInitializeAllFunctionDrivers
1800:                    (
1801:                        USB_DEVICE_OBJ * usbDeviceThisInstance
1802:                    )
1803:                
1804:                  Summary:
1805:                    De-initializes all function drivers that are presently loaded for the
1806:                    selected configuration.
1807:                
1808:                  Description:
1809:                    De initializes all function drivers that are presently loaded for the
1810:                    selected configuration.
1811:                
1812:                  Remarks
1813:                    This function is a local function and should not be called directly by the
1814:                    client.
1815:                */
1816:                
1817:                void _USB_DEVICE_DeInitializeAllFunctionDrivers
1818:                (
1819:                    USB_DEVICE_OBJ * usbDeviceThisInstance
1820:                )
1821:                {
1822:                    /* This function is called when device layer has detected a USB reset
1823:                     * signalling or when the host has set device configuration 0. */
1824:                
1825:                    uint8_t count = 0;
1826:                    USB_SPEED speed = usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed ;
1827:                    uint16_t configValue = usbDeviceThisInstance->activeConfiguration ;
1828:                    uint16_t maxFunctionCounts = usbDeviceThisInstance->registeredFuncDriverCount;
1829:                    USB_DEVICE_FUNCTION_REGISTRATION_TABLE * funcRegTable = usbDeviceThisInstance->registeredFuncDrivers;
1830:                    USB_DEVICE_FUNCTION_DRIVER * driver;
1831:                
1832:                    for(count = 0; count < maxFunctionCounts; count++ )
1833:                    {
1834:                        if( (funcRegTable->speed & speed) && (funcRegTable->configurationValue == configValue))
1835:                        {
1836:                            /* De initialize the function driver */
1837:                            driver = (USB_DEVICE_FUNCTION_DRIVER *)funcRegTable->driver;
1838:                            if (driver != NULL)
1839:                            {
1840:                                if(driver->deInitialize != NULL)
1841:                                {
1842:                                    /* Call the function driver deInitialize routine */
1843:                                    driver->deInitialize( funcRegTable->funcDriverIndex );
1844:                                }
1845:                            }           
1846:                        }
1847:                
1848:                        funcRegTable++;
1849:                    }
1850:                }
1851:                
1852:                // ******************************************************************************
1853:                /* Function:
1854:                    void _USB_DEVICE_EventHandler
1855:                    (
1856:                        uintptr_t referenceHandle,
1857:                        DRV_USB_EVENT eventType, 
1858:                        void * eventData
1859:                    )
1860:                
1861:                  Summary:
1862:                    Handles the events originating from the USB Controller driver.
1863:                
1864:                  Description:
1865:                    This function is registered into the USB Controller driver as a callback
1866:                    function. The USB Controller driver calls this function in case of events
1867:                    from the USB Controller driver.
1868:                    
1869:                  Remarks:
1870:                    This is a local function and should not be called directly by a client.
1871:                */
1872:                
1873:                void _USB_DEVICE_EventHandler
1874:                (
1875:                    uintptr_t referenceHandle,
1876:                    DRV_USB_EVENT eventType, 
1877:                    void * eventData
1878:                )
1879:                {
1880:                    USB_DEVICE_OBJ* usbDeviceThisInstance;
1881:                    USB_DEVICE_MASTER_DESCRIPTOR * ptrMasterDescTable;
1882:                    USB_DEVICE_EVENT_DATA_SOF SOFFrameNumber;
1883:                
1884:                    usbDeviceThisInstance = (USB_DEVICE_OBJ *)referenceHandle;
1885:                
1886:                    /* Handle events, only if this instance is in initialized state */
1887:                    if( usbDeviceThisInstance->usbDeviceInstanceState <= SYS_STATUS_UNINITIALIZED )
1888:                    {
1889:                        /* The device should anyway not be attached when the device layer is
1890:                         * not initialized. If we receive driver event when the device layer is
1891:                         * not initialized, there is nothing we can do but ignore them. */
1892:                        return;                
1893:                    }
1894:                
1895:                    switch(eventType)
1896:                    {
1897:                        case DRV_USB_EVENT_RESET_DETECT:
1898:                
1899:                            /* Clear the suspended state */
1900:                            usbDeviceThisInstance->usbDeviceStatusStruct.isSuspended = false;
1901:                
1902:                            /* Cancel any IRP already submitted in the RX direction. */
1903:                            usbDeviceThisInstance->driverInterface->deviceIRPCancelAll( usbDeviceThisInstance->usbCDHandle, controlEndpointRx );
1904:                
1905:                            /* Cancel any IRP already submitted in the TX direction. */
1906:                           usbDeviceThisInstance->driverInterface->deviceIRPCancelAll( usbDeviceThisInstance->usbCDHandle, controlEndpointTx );
1907:                
1908:                            /* Deinitialize all function drivers.*/
1909:                            _USB_DEVICE_DeInitializeAllFunctionDrivers ( usbDeviceThisInstance );
1910:                
1911:                            /* Disable all endpoints except for EP0.*/
1912:                            usbDeviceThisInstance->driverInterface->deviceEndpointDisable(usbDeviceThisInstance->usbCDHandle, DRV_USB_DEVICE_ENDPOINT_ALL);
1913:                
1914:                            /* Enable EP0 endpoint. Note that the driver will ignore the
1915:                             * direction because this is endpoint 0. */
1916:                            (void)usbDeviceThisInstance->driverInterface->deviceEndpointEnable( usbDeviceThisInstance->usbCDHandle, controlEndpointTx, USB_TRANSFER_TYPE_CONTROL, USB_DEVICE_EP0_BUFFER_SIZE);
1917:                
1918:                            if(usbDeviceThisInstance->irpEp0Rx.status <= USB_DEVICE_IRP_STATUS_SETUP)
1919:                            {
1920:                                /* Submit IRP to endpoint 0 to receive the setup packet */
1921:                                (void)usbDeviceThisInstance->driverInterface->deviceIRPSubmit( usbDeviceThisInstance->usbCDHandle, controlEndpointRx , &usbDeviceThisInstance->irpEp0Rx);
1922:                            }
1923:                
1924:                            /* Change device state to Default */
1925:                            usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_DEFAULT;
1926:                
1927:                            /* Reset means chirping has already happened. So, we must be knowing
1928:                               the speed. Get the speed and save it for future. */
1929:                            usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed = usbDeviceThisInstance->driverInterface->deviceCurrentSpeedGet(usbDeviceThisInstance->usbCDHandle);
1930:                
1931:                            /* Get the master descriptor table entry.*/
1932:                            ptrMasterDescTable = usbDeviceThisInstance->ptrMasterDescTable;
1933:                
1934:                            /* Now we know the speed. So for this speed get the pointer that
1935:                               points to correct group of configurations. */
1936:                            if( usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed == USB_SPEED_HIGH )
1937:                            {
1938:                                usbDeviceThisInstance->configDescriptorsPtr = ptrMasterDescTable->highSpeedConfigDescriptorTable;
1939:                
1940:                                /* Also get the max configurations available in this group.*/
1941:                                usbDeviceThisInstance->maxConfigs = ptrMasterDescTable->highSpeedConfigDescriptorCount;
1942:                            }
1943:                            else
1944:                            {
1945:                                /* Classic speeds (full/low speed) */
1946:                                usbDeviceThisInstance->configDescriptorsPtr = ptrMasterDescTable->configDescriptorTable;
1947:                
1948:                                /* Get the maximum configurations available in this group.*/
1949:                                usbDeviceThisInstance->maxConfigs = ptrMasterDescTable->configDescriptorCount;
1950:                            }
1951:                
1952:                            /* Invalidate the current active configuration */
1953:                            usbDeviceThisInstance->activeConfiguration = 0;
1954:                            break;
1955:                
1956:                        case DRV_USB_EVENT_RESUME_DETECT:
1957:                
1958:                            /* USB device resumed. Update the flag.*/
1959:                            usbDeviceThisInstance->usbDeviceStatusStruct.isSuspended = false;
1960:                            break;
1961:                
1962:                        case DRV_USB_EVENT_IDLE_DETECT:
1963:                
1964:                            /* USB Device is suspended */
1965:                            usbDeviceThisInstance->usbDeviceStatusStruct.isSuspended = true;
1966:                            break;        
1967:                
1968:                        case DRV_USB_EVENT_SOF_DETECT:
1969:                
1970:                            /* The _USB_DEVICE_SOFEventEnable() macro resolves to eventType 
1971:                             * events are enabled in system_config.h. If enabled the event
1972:                             * will sent to the application. Else the event will not be
1973:                             * processed. */
1974:                            eventType = _USB_DEVICE_SOFEventEnable(); 
1975:                            if (eventType)
1976:                            {
1977:                                eventType = (DRV_USB_EVENT)USB_DEVICE_EVENT_SOF;
1978:                                /* Get the frame number */
1979:                                SOFFrameNumber.frameNumber = usbDeviceThisInstance->driverInterface->deviceSOFNumberGet(usbDeviceThisInstance->usbCDHandle);
1980:                                eventData = &SOFFrameNumber;
1981:                            }
1982:                
1983:                            break;
1984:                
1985:                        case DRV_USB_EVENT_DEVICE_SESSION_VALID:
1986:                
1987:                            /* VBUS is valid.*/
1988:                            usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_ATTACHED;
1989:                            break;
1990:                
1991:                        case DRV_USB_EVENT_DEVICE_SESSION_INVALID:
1992:                
1993:                            /* VBUS is not valid. */ 
1994:                            usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_DETACHED;  
1995:                            break;
1996:                
1997:                        default:
1998:                            // Nothing to do for all other cases.
1999:                
2000:                            break;
2001:                    }
2002:                
2003:                    if(eventType)
2004:                    {
2005:                        /* Inform the client about the event */
2006:                        if((usbDeviceThisInstance->clientState == USB_DEVICE_CLIENT_STATUS_READY) && (usbDeviceThisInstance->callBackFunc != NULL))
2007:                        {
2008:                            /* This means this client is valid and is a client of this device
2009:                             * layer instance. Pass event to application */
2010:                            usbDeviceThisInstance->callBackFunc((USB_DEVICE_EVENT)eventType, eventData, usbDeviceThisInstance->context);
2011:                        }
2012:                    }
2013:                }    
2014:                
2015:                // ******************************************************************************
2016:                /* Function:
2017:                    void _USB_DEVICE_ControlTransferHandler
2018:                    (
2019:                        SYS_MODULE_INDEX handlerIndex,
2020:                        USB_DEVICE_CONTROL_TRANSFER_EVENT transferEvent,
2021:                        USB_DEVICE_CONTROL_TRANSFER_EVENT_DATA * eventData 
2022:                    )
2023:                
2024:                  Summary:
2025:                    Processes the SETUP packet received from the USB Controller driver.
2026:                
2027:                  Description:
2028:                    This function processes the SETUP packet received from the USB Controller 
2029:                    driver.
2030:                   
2031:                  Remarks:
2032:                    This is a local function and should not be called directly by the client.
2033:                */
2034:                
2035:                void  _USB_DEVICE_ControlTransferHandler
2036:                (    
2037:                    SYS_MODULE_INDEX handlerIndex,
2038:                    USB_DEVICE_EVENT transferEvent,
2039:                    void * eventData
2040:                )
2041:                {
2042:                    /* This function is called from _USB_DEVICE_Ep0ReceiveCompleteCallback
2043:                     * function when a Setup packet has been received. */
2044:                
2045:                    USB_DEVICE_OBJ * usbDeviceThisInstance = (USB_DEVICE_OBJ *)&usbDeviceInstance[handlerIndex];
2046:                    USB_SETUP_PACKET * setupPkt;
2047:                    uint8_t interfaceNumber = 0;
2048:                    USB_ENDPOINT endpointNumber;
2049:                    bool enpointFoundInDescriptors = false;
2050:                  
2051:                    if( transferEvent == USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST )
2052:                    {
2053:                        /* Get pointer to Setup Packet */ 
2054:                        setupPkt = (USB_SETUP_PACKET *)(eventData);
2055:                
2056:                        /* Get of Length of the Data Stage */
2057:                        usbDeviceThisInstance->controlTransferDataStageSize = setupPkt->wLength;
2058:                
2059:                        /* Cancel any IRP that is in the pipe. */
2060:                        usbDeviceThisInstance->driverInterface->deviceIRPCancelAll( usbDeviceThisInstance->usbCDHandle, controlEndpointTx );
2061:                        
2062:                        switch (setupPkt->Recipient)
2063:                        {
2064:                            case USB_SETUP_RECIPIENT_DEVICE:
2065:                                if (setupPkt->RequestType == USB_SETUP_REQUEST_TYPE_STANDARD)
2066:                                {
2067:                                    /* This is a standard Device Request */ 
2068:                                    if (setupPkt->DataDir == USB_SETUP_REQUEST_DIRECTION_HOST_TO_DEVICE)
2069:                                    {
2070:                                        /* Serve standard Device SET requests */
2071:                                        _USB_DEVICE_ProcessStandardDeviceSetRequests ( usbDeviceThisInstance, setupPkt );
2072:                                    }
2073:                                    else
2074:                                    {
2075:                                        /* Serve standard Device GET requests */
2076:                                        _USB_DEVICE_ProcessStandardDeviceGetRequests ( usbDeviceThisInstance, setupPkt );
2077:                                    }
2078:                                }
2079:                                else if (setupPkt->RequestType == USB_SETUP_REQUEST_TYPE_VENDOR)
2080:                                {
2081:                                    /* This is a SETUP request of Vendor type  to recipient
2082:                                     * Device. The device layer does not know how to Handle
2083:                                     * these requests. Forward this request to application. */
2084:                
2085:                                    _USB_DEVICE_RedirectControlXfrToClient (usbDeviceThisInstance, USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST, setupPkt);
2086:                                }
2087:                                else if (setupPkt->RequestType == USB_SETUP_REQUEST_TYPE_CLASS )
2088:                                {
2089:                                    /* This is a SETUP request of Type Class to recipient
2090:                                     * Device. */
2091:                
2092:                                    USB_DEVICE_ControlStatus ((USB_DEVICE_HANDLE)usbDeviceThisInstance, USB_DEVICE_CONTROL_STATUS_ERROR);
2093:                                }
2094:                                break;
2095:                
2096:                            case USB_SETUP_RECIPIENT_INTERFACE:
2097:                
2098:                                 /* Serve any requests that is not "standard" type and whose
2099:                                  * recipient is not "device". (Any request whose recipient is
2100:                                  * interface/endpoint must be handled by the function driver.
2101:                                  * This is because function driver has all the information
2102:                                  * about endpoint and interface) */				
2103:                				if (setupPkt->RequestType == USB_SETUP_REQUEST_TYPE_VENDOR)
2104:                				{
2105:                					_USB_DEVICE_VendorInterfaceRequestProcess(usbDeviceThisInstance, setupPkt->bIntfID,setupPkt); 
2106:                				}
2107:                				else
2108:                				{
2109:                					_USB_DEVICE_ForwardControlXfrToFunction(usbDeviceThisInstance, setupPkt->bIntfID,setupPkt ); 
2110:                				}
2111:                                break;
2112:                
2113:                            case USB_SETUP_RECIPIENT_ENDPOINT:
2114:                
2115:                                /* Retrieve Endpoint number from Setup Packet */
2116:                                endpointNumber = setupPkt->bEPID;
2117:                
2118:                                /* Any Control request to a Non Zero Endpoint should be Stalled
2119:                                 * if the Device is not in Configured State. The request will
2120:                                 * also be stalled if there is no descriptor available for this
2121:                                 * Endpoint */ 
2122:                
2123:                                if (endpointNumber != 0)
2124:                                {
2125:                                    /* Check if the Endpoint is present in the Descriptors. If
2126:                                     * yes find the interface number */
2127:                
2128:                                    enpointFoundInDescriptors = _USB_DEVICE_FindEndpoint( usbDeviceThisInstance, endpointNumber, &interfaceNumber);
2129:                                    if ((usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState != USB_DEVICE_STATE_CONFIGURED) ||(enpointFoundInDescriptors != true))
2130:                                    {
2131:                                        /* The Device should not service the Non Zero Endpoint
2132:                                         * request if the Device is not configured or the
2133:                                         * Endpoint is not present in descriptors. So stall this
2134:                                         * request.  */
2135:                
2136:                                        USB_DEVICE_ControlStatus ((USB_DEVICE_HANDLE)usbDeviceThisInstance, USB_DEVICE_CONTROL_STATUS_ERROR);
2137:                                        return;
2138:                                    }
2139:                                }
2140:                
2141:                                /* Program control reached here means that we have received an
2142:                                 * Endpoint request on a valid Endpoint Number. */
2143:                
2144:                                if (setupPkt->RequestType == USB_SETUP_REQUEST_TYPE_STANDARD)
2145:                                {
2146:                                    /* Standard Endpoint requests are handled by Device Layer */
2147:                                    _USB_DEVICE_ProcessStandardEndpointRequest( usbDeviceThisInstance, interfaceNumber, setupPkt);
2148:                                }
2149:                                else 
2150:                                {
2151:                                    /* This is Class or Vendor request. Forward the request to
2152:                                     * right Function driver or Client */ 
2153:                
2154:                                    _USB_DEVICE_ForwardControlXfrToFunction (usbDeviceThisInstance, interfaceNumber,setupPkt );
2155:                                   
2156:                                }
2157:                                break;
2158:                            
2159:                            case USB_SETUP_RECIPIENT_OTHER:
2160:                                
2161:                                /* This is a SETUP request of Type Vendor to recipient Device.
2162:                                 * The device layer does not know how to Handle these requests.
2163:                                 * Forward this request to application. */
2164:                
2165:                                _USB_DEVICE_RedirectControlXfrToClient( usbDeviceThisInstance, USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST, setupPkt);
2166:                                break;
2167:                               
2168:                            default: 
2169:                                SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Unknown Control Transfer received from Host" );
2170:                                break;
2171:                        }
2172:                    }   
2173:                }
2174:                
2175:                // *****************************************************************************
2176:                /* Function:
2177:                    void _USB_DEVICE_ForwardControlXfrToFunction 
2178:                    (
2179:                        USB_DEVICE_OBJ * usbDeviceThisInstance,
2180:                        uint8_t interfaceNumber,
2181:                        USB_SETUP_PACKET * setupPkt
2182:                    )
2183:                
2184:                  Summary:
2185:                    This function forwards control transfers to registred function drivers.
2186:                
2187:                  Description:
2188:                    This function Forwards control transfers to registred function drivers. If
2189:                    control handler fucntion callback is null, then the control transfer is
2190:                    forwarded to client.
2191:                
2192:                  Remarks:
2193:                    This is local function. It should not be used directly by the client.
2194:                */
2195:                
2196:                void _USB_DEVICE_ForwardControlXfrToFunction 
2197:                (
2198:                    USB_DEVICE_OBJ * usbDeviceThisInstance,
2199:                    uint8_t interfaceNumber,
2200:                    USB_SETUP_PACKET * setupPkt
2201:                )
2202:                {
2203:                    USB_DEVICE_FUNCTION_REGISTRATION_TABLE * lFuncDriverRegTable;
2204:                    USB_DEVICE_CONTROL_TRANSFER_STRUCT * controlTransfer = &usbDeviceThisInstance->controlTransfer;
2205:                    USB_DEVICE_FUNCTION_DRIVER * driver;
2206:                    
2207:                    /* This is a function driver /vendor specific setup packet. The recipient
2208:                     * field is either interface or other. Check which function driver has to
2209:                     * handle this setup packet. This function is called from Setup packet
2210:                     * handling function. We first find out which function driver owns this
2211:                     * interface.  */
2212:                    
2213:                    lFuncDriverRegTable = _USB_DEVICE_GetFunctionDriverEntryByInterface( interfaceNumber, usbDeviceThisInstance);
2214:                    if (lFuncDriverRegTable != NULL)
2215:                    {
2216:                        if (lFuncDriverRegTable->driver != NULL)
2217:                        {
2218:                            driver = (USB_DEVICE_FUNCTION_DRIVER *)(lFuncDriverRegTable->driver);
2219:                            if (driver->controlTransferNotification != NULL)
2220:                            {
2221:                                /* The interface number is owned by one of the registered
2222:                                 * function driver. Pass the SETUP packet to the function
2223:                                 * driver. */
2224:                
2225:                                /* Save the callback and index for future use.  Here we change
2226:                                 * the handler to function driver specific handler.  All further
2227:                                 * control transfer stage must be handled by the function driver
2228:                                 * control transfer handler.*/
2229:                
2230:                                controlTransfer->handler = (void (*)(unsigned short, USB_DEVICE_EVENT, void *))driver->controlTransferNotification;
2231:                
2232:                                controlTransfer->handlerIndex = lFuncDriverRegTable->funcDriverIndex;
2233:                
2234:                                /* Forward the SETUP packet to the function driver */
2235:                                controlTransfer->handler( controlTransfer->handlerIndex, USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST, setupPkt);
2236:                            }
2237:                            else
2238:                            {
2239:                                /* There is no valid control Transfer Notification Handler found
2240:                                 * in the Function registration Table. This control transfer
2241:                                 * will be handled by the client */
2242:                
2243:                                _USB_DEVICE_RedirectControlXfrToClient (usbDeviceThisInstance, USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST, setupPkt );
2244:                            }
2245:                        }
2246:                        else
2247:                        {
2248:                            /* If the driver member of the function driver registration table
2249:                             * entry is NULL, this means that the device layer client will
2250:                             * handle the control transfer. Forward the request to the device
2251:                             * layer client. */
2252:                
2253:                            _USB_DEVICE_RedirectControlXfrToClient (usbDeviceThisInstance, USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST, setupPkt );
2254:                        }
2255:                    }
2256:                    else
2257:                    {
2258:                        /* The interface number specified in the SETUP Packet does not belong to
2259:                         * any of the registered function driver. Host should not have sent this
2260:                         * request. STALL this request */
2261:                
2262:                        USB_DEVICE_ControlStatus((USB_DEVICE_HANDLE)usbDeviceThisInstance, USB_DEVICE_CONTROL_STATUS_ERROR);
2263:                    }
2264:                }
2265:                
2266:                // *****************************************************************************
2267:                /* Function:
2268:                    void _USB_DEVICE_ProcessStandardEndpointRequest
2269:                    (
2270:                        USB_DEVICE_OBJ * usbDeviceThisInstance,
2271:                        uint8_t interfaceNumber,
2272:                        USB_SETUP_PACKET * setupPkt
2273:                    )
2274:                
2275:                  Summary:
2276:                    This function handles standard Endpoint requests.
2277:                
2278:                  Description:
2279:                    This function handles standard Endpoint requests. 
2280:                
2281:                  Remarks:
2282:                    This is local function. It should not be used directly by the client.
2283:                */
2284:                
2285:                void _USB_DEVICE_ProcessStandardEndpointRequest
2286:                (
2287:                    USB_DEVICE_OBJ * usbDeviceThisInstance,
2288:                    uint8_t interfaceNumber,
2289:                    USB_SETUP_PACKET * setupPkt
2290:                )
2291:                {
2292:                    USB_ENDPOINT usbEndpoint;
2293:                    usbEndpoint = setupPkt->bEPID;
2294:                
2295:                    if( setupPkt->bRequest == USB_REQUEST_GET_STATUS )
2296:                    {
2297:                        /* This is an Endpoint Get Status request. Send the status to the host.
2298:                         * */
2299:                        usbDeviceThisInstance->getStatusResponse.status = 0x00;
2300:                        usbDeviceThisInstance->getStatusResponse.endPointHalt =  usbDeviceThisInstance->driverInterface->deviceEndpointIsStalled(usbDeviceThisInstance->usbCDHandle, usbEndpoint );
2301:                
2302:                        USB_DEVICE_ControlSend( (USB_DEVICE_HANDLE)usbDeviceThisInstance, (uint8_t *)&usbDeviceThisInstance->getStatusResponse, 2 );
2303:                    }
2304:                    else if( setupPkt->bRequest == USB_REQUEST_CLEAR_FEATURE )
2305:                    {
2306:                        if( setupPkt->wValue == USB_FEATURE_SELECTOR_ENDPOINT_HALT )
2307:                        {
2308:                            /* This means the host has requested for the stall condition on an
2309:                             * endpoint to be cleared. */
2310:                            usbDeviceThisInstance->driverInterface->deviceEndpointStallClear(usbDeviceThisInstance->usbCDHandle, usbEndpoint );
2311:                            USB_DEVICE_ControlStatus((USB_DEVICE_HANDLE)usbDeviceThisInstance, USB_DEVICE_CONTROL_STATUS_OK );
2312:                        }
2313:                    }
2314:                    else if (setupPkt->bRequest == USB_REQUEST_SET_FEATURE )
2315:                    {
2316:                        if( setupPkt->wValue == USB_FEATURE_SELECTOR_ENDPOINT_HALT )
2317:                        {
2318:                            /* This means the host has requested for an endpoint to be stalled
2319:                             * */
2320:                            usbEndpoint = setupPkt->bEPID;
2321:                            usbDeviceThisInstance->driverInterface->deviceEndpointStall(usbDeviceThisInstance->usbCDHandle, usbEndpoint );
2322:                            USB_DEVICE_ControlStatus((USB_DEVICE_HANDLE)usbDeviceThisInstance, USB_DEVICE_CONTROL_STATUS_OK );
2323:                        }
2324:                    }
2325:                    else if (setupPkt->bRequest == USB_REQUEST_SYNCH_FRAME)
2326:                    {
2327:                        /* Forward this request to Function driver. */
2328:                        _USB_DEVICE_Handle_Synch_Frame_Request(usbDeviceThisInstance, interfaceNumber, setupPkt);
2329:                    }
2330:                }
2331:                
2332:                // ******************************************************************************
2333:                /* Function:
2334:                    void _USB_DEVICE_ProcessStandardGetRequests
2335:                    (
2336:                        USB_DEVICE_OBJ * usbDeviceThisInstance,
2337:                        USB_SETUP_PACKET * setupPkt 
2338:                    )
2339:                
2340:                  Summary:
2341:                    Processes the standard "get" requests received from the USB Controller driver.
2342:                
2343:                  Description:
2344:                    This function processes the standard "get" requests received from the USB 
2345:                    Controller driver.
2346:                   
2347:                  Remarks:
2348:                    This is local function and should not be called directly by the client.
2349:                */
2350:                void _USB_DEVICE_ProcessStandardDeviceGetRequests
2351:                (
2352:                    USB_DEVICE_OBJ * usbDeviceThisInstance,
2353:                    USB_SETUP_PACKET * setupPkt 
2354:                )
2355:                {
2356:                    USB_CONFIGURATION_DESCRIPTOR * lConfigDescriptor = NULL;
2357:                    uint16_t size = 0;
2358:                    void*  pData = NULL;
2359:                    USB_DEVICE_MASTER_DESCRIPTOR * ptrMasterDescTable ;
2360:                    bool serviceGetRequest = true; 
2361:                
2362:                    /* Copy the Master descriptor table to a local pointer. */
2363:                    ptrMasterDescTable = usbDeviceThisInstance->ptrMasterDescTable ;
2364:                    
2365:                    if(setupPkt->bRequest == USB_REQUEST_GET_DESCRIPTOR)
2366:                    {
2367:                        switch(setupPkt->bDescriptorType)
2368:                        {
2369:                            case USB_DESCRIPTOR_DEVICE:
2370:                                if(usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed == USB_SPEED_HIGH)
2371:                                {
2372:                                    /* High speed descriptor. */
2373:                                    if( ptrMasterDescTable->highSpeedDeviceDescriptor == NULL )
2374:                                    {
2375:                                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: High speed device descriptor is NULL" );
2376:                                    }
2377:                
2378:                                    /* Pointer to high speed device descriptor.*/
2379:                                    pData = ( (uint8_t*) ptrMasterDescTable->highSpeedDeviceDescriptor );
2380:                                }
2381:                                else
2382:                                {
2383:                                    /* Full/low speed descriptor.*/
2384:                                    if( ptrMasterDescTable->deviceDescriptor == NULL )
2385:                                    {   
2386:                                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Full/Low speed device descriptor is NULL");
2387:                                    }
2388:                
2389:                                    /* Full/low speed device descriptor points usbDeviceThisInstance->ptrMasterDescTabler */
2390:                                    pData = ( (uint8_t*) ptrMasterDescTable->deviceDescriptor );
2391:                                }
2392:                
2393:                                /* Total size of the device descriptor (Its always 18). */
2394:                                size = 18;
2395:                                break;
2396:                
2397:                            case USB_DESCRIPTOR_CONFIGURATION:                
2398:                
2399:                                /* Get correct pointer to the descriptor based on config value.
2400:                                 * setupPkt->bDscIndex indicates the host requested
2401:                                 * configuration index.  Make sure that the requested
2402:                                 * configuration index is with in the limits.*/
2403:                
2404:                                if( (setupPkt->bDscIndex) < usbDeviceThisInstance->maxConfigs )
2405:                                {
2406:                                    lConfigDescriptor = (USB_CONFIGURATION_DESCRIPTOR *)usbDeviceThisInstance->configDescriptorsPtr[setupPkt->bDscIndex];
2407:                                    if(lConfigDescriptor != NULL )
2408:                                    {
2409:                                        /* We have a valid specified configuration. Prepare the
2410:                                         * output variables */
2411:                                        pData  = (uint8_t *)lConfigDescriptor;
2412:                                        size = lConfigDescriptor->wTotalLength;
2413:                                    }
2414:                                    else
2415:                                    {
2416:                                        /* Configuration not found */
2417:                                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid pointer to configuration descriptor");
2418:                                        pData = NULL;
2419:                                    }
2420:                                }
2421:                                break;
2422:                
2423:                            case USB_DESCRIPTOR_OTHER_SPEED: 
2424:                                /* Host has requested for the other speed descriptor. Other Speed 
2425:                                * Descriptor requests are handled differently. Respond to Other 
2426:                                * Speed configuration descriptor request only if USB peripheral is 
2427:                                * configured for High Speed operation. If the USB peripheral is 
2428:                                * configured for Full Speed operation then the request shall be 
2429:                                * stalled.*/
2430:                                if (usbDeviceThisInstance->usbDeviceStatusStruct.usbConfiguredSpeed == USB_SPEED_HIGH)
2431:                                {
2432:                                    /* Service Other Speed Configuration descriptor request. The 
2433:                                       function will respond to Host */
2434:                                    serviceGetRequest = false;
2435:                                    _USB_DEVICE_OtherSpeedDescriptorRequestService(usbDeviceThisInstance, setupPkt); 
2436:                                }
2437:                                else
2438:                                {
2439:                                    /* USB Peripheral is not configured for High Speed. The 
2440:                                     * request will be stalled. */
2441:                                    serviceGetRequest = true;
2442:                                }
2443:                                break; 
2444:                    
2445:                            case USB_DESCRIPTOR_DEVICE_QUALIFIER:
2446:                                /* Respond to Device Qualifier request only if USB peripheral is
2447:                                   configured for High Speed operation. If the peripheral is 
2448:                                   configured for Full Speed operation request shall be stalled.
2449:                                 */
2450:                                if (usbDeviceThisInstance->usbDeviceStatusStruct.usbConfiguredSpeed == USB_SPEED_HIGH)
2451:                                {
2452:                                    if( usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed == USB_SPEED_HIGH )
2453:                                    {
2454:                                        /* For high speed, respond with the other speed (full speed) device_qualifier. */
2455:                                        pData = (uint8_t*) ptrMasterDescTable->fullSpeedDeviceQualifier;
2456:                                    }
2457:                                    else
2458:                                    {
2459:                                        /* For full speed, respond with the other speed (high speed) device_qualifier. */
2460:                                        pData = ((uint8_t*) ptrMasterDescTable->highSpeedDeviceQualifier );
2461:                                    } 
2462:                
2463:                                    /* Size of device_qualifier descriptor is always 10. */
2464:                                    size = 10;
2465:                                }
2466:                                break;
2467:                
2468:                            case USB_DESCRIPTOR_STRING:
2469:                
2470:                                /* A string descriptor was requested */
2471:                                size = _USB_DEVICE_GetStringDescriptorRequest(ptrMasterDescTable, setupPkt, &pData );
2472:                                break;
2473:                
2474:                            case USB_DESCRIPTOR_BOS:
2475:                
2476:                                /* A BOS descriptor was requested */
2477:                                _USB_DEVICE_GetBosDescriptorRequest(ptrMasterDescTable->bosDescriptor, pData, size );
2478:                                break; 
2479:                
2480:                            default:
2481:                                break;
2482:                        } 
2483:                    }
2484:                    else if (setupPkt->bRequest == USB_REQUEST_GET_CONFIGURATION)
2485:                    {
2486:                        /* Host wants to know what is current configuration */
2487:                        pData = &(usbDeviceThisInstance->activeConfiguration);
2488:                        size = 1;
2489:                    }
2490:                    else if (setupPkt->bRequest == USB_REQUEST_GET_STATUS)
2491:                    {
2492:                        /* The host want to know the power status and remote wakeup status of
2493:                         * the device. */
2494:                        usbDeviceThisInstance->getStatusResponse.status = 0;
2495:                        usbDeviceThisInstance->getStatusResponse.selfPowered = usbDeviceThisInstance->usbDeviceStatusStruct.powerState;
2496:                        usbDeviceThisInstance->getStatusResponse.remoteWakeup = usbDeviceThisInstance->remoteWakeupStatus;
2497:                        pData = (uint8_t *)&usbDeviceThisInstance->getStatusResponse;
2498:                        size = 2;
2499:                    }
2500:                    
2501:                    if (serviceGetRequest == true)
2502:                    {
2503:                        if(pData == NULL)
2504:                        {
2505:                            /* We don't have valid data to send. STALL the transfer */
2506:                            USB_DEVICE_ControlStatus((USB_DEVICE_HANDLE)usbDeviceThisInstance, USB_DEVICE_CONTROL_STATUS_ERROR );
2507:                        }
2508:                        else
2509:                        {
2510:                            /* Limit the size. */
2511:                            if( size > setupPkt->wLength )
2512:                            {
2513:                                size = setupPkt->wLength;
2514:                            }
2515:                
2516:                            /* Send the data stage */
2517:                            USB_DEVICE_ControlSend( (USB_DEVICE_HANDLE)usbDeviceThisInstance, pData, size );
2518:                        }
2519:                    }
2520:                }
2521:                
2522:                // ******************************************************************************
2523:                /* Function:
2524:                    USB_DEVICE_FUNCTION_REGISTRATION_TABLE * _USB_DEVICE_GetFunctionDriverEntryByInterface
2525:                    (
2526:                        uint8_t interfaceNumber,
2527:                        USB_DEVICE_OBJ * usbDeviceThisInstance
2528:                    )
2529:                
2530:                  Summary:
2531:                    This function gets the correct entry in the function driver registration
2532:                    table for a given interface.
2533:                
2534:                  Description:
2535:                    This function gets the correct entry in the function driver registration
2536:                    table for a given interface.
2537:                
2538:                  Remarks:
2539:                    This is an internal function and should not be called directly by the client.
2540:                */
2541:                
2542:                USB_DEVICE_FUNCTION_REGISTRATION_TABLE * _USB_DEVICE_GetFunctionDriverEntryByInterface
2543:                (
2544:                    uint8_t interfaceNumber,
2545:                    USB_DEVICE_OBJ * usbDeviceThisInstance
2546:                )
2547:                {
2548:                    uint8_t count;
2549:                    uint16_t maxFunctionCounts = usbDeviceThisInstance->registeredFuncDriverCount;
2550:                    USB_DEVICE_FUNCTION_REGISTRATION_TABLE * funcRegTable = usbDeviceThisInstance->registeredFuncDrivers;
2551:                    uint8_t speed = usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed ;
2552:                    uint8_t configValue = usbDeviceThisInstance->activeConfiguration ;
2553:                
2554:                    /* This loop finds the function driver that owns this interface */
2555:                    for(count = 0; count < maxFunctionCounts; count++ )
2556:                    {
2557:                        if( (funcRegTable->speed & speed) && (funcRegTable->configurationValue == configValue)
2558:                                && ( interfaceNumber >= funcRegTable->interfaceNumber ) &&
2559:                                (interfaceNumber < ( funcRegTable->interfaceNumber + funcRegTable->numberOfInterfaces )))
2560:                        {
2561:                            return(funcRegTable);
2562:                        }
2563:                        funcRegTable++;
2564:                    }
2565:                
2566:                    return NULL;
2567:                }
2568:                
2569:                // ******************************************************************************
2570:                /* Function:
2571:                    void _USB_DEVICE_ConfigureDevice( USB_DEVICE_OBJ* usbDeviceThisInstance )
2572:                
2573:                  Summary:
2574:                    This function configures the device. 
2575:                
2576:                  Description:
2577:                    The initialization of all the function drivers and opening of all endpoints
2578:                    are done here.
2579:                
2580:                  Returns:
2581:                    This is a local function and should not be called directly by the
2582:                    application.
2583:                */
2584:                
2585:                void _USB_DEVICE_ConfigureDevice( USB_DEVICE_OBJ* usbDeviceThisInstance )
2586:                {
2587:                    uint16_t parsedLength= 0;
2588:                    uint16_t confTotalLength;
2589:                    uint8_t * pDescriptor = usbDeviceThisInstance->pActiveConfigDesc;
2590:                    uint8_t descriptorType;
2591:                    uint8_t interfaceNumber = 0;
2592:                    uint8_t alternateSetting = 0;
2593:                    USB_DEVICE_FUNCTION_REGISTRATION_TABLE * pFunctionRegTable = NULL;
2594:                    USB_DEVICE_FUNCTION_DRIVER * driver;
2595:                   
2596:                    confTotalLength = ((USB_CONFIGURATION_DESCRIPTOR *)pDescriptor)->wTotalLength;
2597:                
2598:                    /* Start parsing the configuration desciptor. For each interface descriptor
2599:                     * that was found, find out the owning function driver and then initialize
2600:                     * the function driver. */
2601:                
2602:                    while(parsedLength < confTotalLength)
2603:                    {
2604:                        descriptorType = ((USB_DEVICE_SERVICE_DESCRIPTOR_HEAD *)pDescriptor)->bDescriptorType;
2605:                        if(descriptorType == USB_DESCRIPTOR_INTERFACE)
2606:                        {
2607:                            /* If this descriptor was an interface, find out which function
2608:                             * driver owns this interface */ 
2609:                            pFunctionRegTable = NULL;
2610:                            interfaceNumber = ((USB_INTERFACE_DESCRIPTOR * )pDescriptor)->bInterfaceNumber;
2611:                            alternateSetting = ((USB_INTERFACE_DESCRIPTOR * )pDescriptor)->bAlternateSetting;
2612:                            pFunctionRegTable = _USB_DEVICE_GetFunctionDriverEntryByInterface(interfaceNumber , usbDeviceThisInstance);
2613:                        } 
2614:                
2615:                        if( pFunctionRegTable != NULL )
2616:                        {
2617:                            driver = (USB_DEVICE_FUNCTION_DRIVER *)(pFunctionRegTable->driver);
2618:                            
2619:                            if (driver != NULL)
2620:                            {
2621:                                /* Call the driver intialize by descriptor function. This will
2622:                                 * let the function driver know that it should start running and
2623:                                 * be initialized. */
2624:                                driver->initializeByDescriptor(pFunctionRegTable->funcDriverIndex, (USB_DEVICE_HANDLE)usbDeviceThisInstance,
2625:                                              pFunctionRegTable->funcDriverInit, interfaceNumber, alternateSetting, descriptorType, pDescriptor);
2626:                            }
2627:                        }
2628:                
2629:                        parsedLength += ((USB_DEVICE_SERVICE_DESCRIPTOR_HEAD *)pDescriptor)->bLength;
2630:                        pDescriptor += ((USB_DEVICE_SERVICE_DESCRIPTOR_HEAD *)pDescriptor)->bLength;
2631:                    }
2632:                }
2633:                
2634:                // ******************************************************************************
2635:                /* Function:
2636:                    bool _USB_DEVICE_FindEndpoint
2637:                    ( 
2638:                        USB_DEVICE_OBJ* usbDeviceThisInstance,
2639:                        USB_ENDPOINT endpointNumber, 
2640:                        uint8_t* interfaceNumber
2641:                    )
2642:                
2643:                  Summary:
2644:                    This function takes an Endpoint Number as a parameter and finds the Endpoint
2645:                    belongs to which Interface.
2646:                
2647:                  Description:
2648:                    This function takes an Endpoint Number as a parameter and finds the Endpoint
2649:                    belongs to which Interface. This function finds the interface by parsing the
2650:                    USB descriptors. This is a local function and should not be called by
2651:                    applications directly.
2652:                
2653:                  Parameters:
2654:                    usbDeviceThisInstance   - This instance of the USB device layer.
2655:                    endpointNumber          - Endpoint Number .
2656:                    interfaceNumber         - pointer to Interface Number. This is an out parameter.
2657:                    
2658:                
2659:                  Returns:
2660:                    true - Returns true if the Endpoint number belongs to any of the registered
2661:                           interfaces. True indicates that a valid interface is found and user
2662:                           can read the interface number from the interfaceNumber parameter.
2663:                    false -Endpoint does not belong to any registered interface.
2664:                */
2665:                
2666:                bool _USB_DEVICE_FindEndpoint
2667:                (
2668:                    USB_DEVICE_OBJ* usbDeviceThisInstance, 
2669:                    USB_ENDPOINT endpointNumber,
2670:                    uint8_t* interfaceNum
2671:                )
2672:                {
2673:                    uint16_t parsedLength= 0;
2674:                    uint16_t confTotalLength;
2675:                    uint8_t * pDescriptor = usbDeviceThisInstance->pActiveConfigDesc;
2676:                    uint8_t descriptorType;
2677:                
2678:                    confTotalLength = ((USB_CONFIGURATION_DESCRIPTOR *)pDescriptor)->wTotalLength;
2679:                
2680:                    /* Parse the configuration descriptor. When an endpoint descriptor is found,
2681:                     * check if the endpoint number matches the input endpoint number. */
2682:                    while(parsedLength < confTotalLength)
2683:                    {
2684:                        descriptorType = ((USB_DEVICE_SERVICE_DESCRIPTOR_HEAD *)pDescriptor)->bDescriptorType;
2685:                        if(descriptorType == USB_DESCRIPTOR_INTERFACE)
2686:                        {
2687:                            *(interfaceNum) = ((USB_INTERFACE_DESCRIPTOR *)pDescriptor)->bInterfaceNumber;
2688:                        }
2689:                        else if (descriptorType == USB_DESCRIPTOR_ENDPOINT)
2690:                        {
2691:                            if(endpointNumber == ((USB_ENDPOINT_DESCRIPTOR * )pDescriptor)->bEndpointAddress)
2692:                            {
2693:                                return true;
2694:                            }
2695:                        }
2696:                
2697:                        parsedLength += ((USB_DEVICE_SERVICE_DESCRIPTOR_HEAD *)pDescriptor)->bLength;
2698:                        pDescriptor += ((USB_DEVICE_SERVICE_DESCRIPTOR_HEAD *)pDescriptor)->bLength;
2699:                    }
2700:                
2701:                    return false;
2702:                }
2703:                
2704:                // ******************************************************************************
2705:                /* Function:
2706:                    void _USB_DEVICE_ProcessStandardSetRequests
2707:                    (
2708:                        USB_DEVICE_OBJ * usbDeviceThisInstance,
2709:                        USB_SETUP_PACKET * setupPkt
2710:                    )
2711:                
2712:                  Summary:
2713:                    Processes the standard "set" requests received from the USB Controller driver.
2714:                
2715:                  Description:
2716:                    This function processes the standard "set" requests received from the USB 
2717:                    Controller driver.
2718:                   
2719:                  Remarks:
2720:                    This is a local function and should not be called directly by the client.
2721:                */
2722:                
2723:                void _USB_DEVICE_ProcessStandardDeviceSetRequests
2724:                (
2725:                    USB_DEVICE_OBJ * usbDeviceThisInstance,
2726:                    USB_SETUP_PACKET * setupPkt
2727:                )
2728:                {   
2729:                    uint8_t count;
2730:                    USB_DEVICE_EVENT_DATA_CONFIGURED configuredEventData;
2731:                    USB_DEVICE_CONTROL_STATUS controlStatus = USB_DEVICE_CONTROL_STATUS_ERROR;
2732:                    bool sendStatus = true;
2733:                    
2734:                    switch(setupPkt->bRequest)
2735:                    {
2736:                        case USB_REQUEST_SET_ADDRESS:
2737:                
2738:                            /* Got set address command. Change the address only after responding
2739:                               to the current request.*/
2740:                            
2741:                            usbDeviceThisInstance->usbDeviceStatusStruct.setAddressPending = true;
2742:                            usbDeviceThisInstance->deviceAddress = setupPkt->bDevADR;
2743:                            controlStatus = USB_DEVICE_CONTROL_STATUS_OK;
2744:                            
2745:                            break;
2746:                
2747:                        case USB_REQUEST_SET_CONFIGURATION: 
2748:                
2749:                            /* Device falls back to addressed state if configuration value is 0,
2750:                             * and if the device is already in configured state. */
2751:                            
2752:                            if((setupPkt->wValue == 0) && (usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState == USB_DEVICE_STATE_CONFIGURED))
2753:                            {
2754:                                /* Configuration value 0 means, host is trying to de configure
2755:                                 * the device.  Set a event here. USB device layer task will
2756:                                 * de initialize the function drivers later.*/
2757:                                usbDeviceThisInstance->event = USB_DEVICE_EVENT_DECONFIGURED;
2758:                
2759:                                /* Deinit all function drivers. */
2760:                                _USB_DEVICE_DeInitializeAllFunctionDrivers ( usbDeviceThisInstance );
2761:                
2762:                                /* Change the current active configuration to Zero */
2763:                                usbDeviceThisInstance->activeConfiguration = 0;
2764:                
2765:                                /* Change the state to Addressed   */
2766:                                usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_ADDRESSED;
2767:                            }  
2768:                            else
2769:                            {
2770:                                /* Proceed only if new configuration value is different from
2771:                                 * current configuration value. */
2772:                                if( usbDeviceThisInstance->activeConfiguration != (uint8_t)setupPkt->wValue)
2773:                                {
2774:                                    for(count = 0; count < usbDeviceThisInstance->maxConfigs; count++)
2775:                                    {
2776:                                        /* 5th byte in the configuration descriptor table
2777:                                         * specifies the configuration value. */
2778:                
2779:                                        if( usbDeviceThisInstance->configDescriptorsPtr[count][5] == setupPkt->bConfigurationValue )
2780:                                        {
2781:                                            /* Got a configuration match. Get the pointer to
2782:                                             * configuration descriptor. We have to pass this to
2783:                                             * function driver, so that function driver can
2784:                                             * parse configuration descriptor and get the
2785:                                             * required info. */
2786:                
2787:                                            usbDeviceThisInstance->pActiveConfigDesc = (uint8_t *)usbDeviceThisInstance->configDescriptorsPtr[count];
2788:                                        }
2789:                                    }
2790:                
2791:                                    /* Save the current active configuration.  This may be
2792:                                     * required for clients to know which configuration is
2793:                                     * presently active. */
2794:                
2795:                                    usbDeviceThisInstance->activeConfiguration = (uint8_t)setupPkt->wValue;
2796:                
2797:                                    /* In case the endpoint functions are enabled for Vendor operation,
2798:                                     * the endpoint queue sizes need to reset. */
2799:                                    _USB_DEVICE_EndpointCurrentQueueSizeReset(usbDeviceThisInstance->usbDevLayerIndex);
2800:                
2801:                                    /* Initialize all function drivers and change to configured
2802:                                     * state only if all function drivers are initialized
2803:                                     * successfully. */
2804:                                    _USB_DEVICE_ConfigureDevice(usbDeviceThisInstance);
2805:                
2806:                                    /* Change the state to configured. */
2807:                                    usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_CONFIGURED;
2808:                
2809:                                    /* Set an event, so that application and function drivers
2810:                                     * are informed  about the same. */
2811:                                    configuredEventData.configurationValue = (uint8_t)setupPkt->wValue;
2812:                
2813:                                    /* Inform the client about the event */
2814:                                    if((usbDeviceThisInstance->clientState == USB_DEVICE_CLIENT_STATUS_READY) &&
2815:                                            (usbDeviceThisInstance->callBackFunc != NULL))
2816:                                    {
2817:                                        /* This means this client is valid and is a client of this device
2818:                                           layer instance. Pass event to application */
2819:                                        usbDeviceThisInstance->callBackFunc (USB_DEVICE_EVENT_CONFIGURED, &configuredEventData, usbDeviceThisInstance->context);
2820:                                    }
2821:                                }
2822:                            }
2823:                            
2824:                            controlStatus = USB_DEVICE_CONTROL_STATUS_OK;
2825:                            break;
2826:                
2827:                         case  USB_REQUEST_CLEAR_FEATURE:
2828:                
2829:                            if( setupPkt->wValue == USB_FEATURE_SELECTOR_DEVICE_REMOTE_WAKEUP )
2830:                            {
2831:                                /* The host is disabling the remote wakeup capability */
2832:                                usbDeviceThisInstance->remoteWakeupStatus = USB_DEVICE_REMOTE_WAKEUP_DISABLED ;
2833:                                controlStatus = USB_DEVICE_CONTROL_STATUS_OK;
2834:                            }
2835:                            break;
2836:                
2837:                        case USB_REQUEST_SET_FEATURE:
2838:                
2839:                            if (setupPkt->wValue == USB_FEATURE_SELECTOR_DEVICE_REMOTE_WAKEUP)
2840:                            {
2841:                                usbDeviceThisInstance->remoteWakeupStatus = USB_DEVICE_REMOTE_WAKEUP_ENABLED;
2842:                                controlStatus = USB_DEVICE_CONTROL_STATUS_OK;
2843:                            }
2844:                            else if (setupPkt->wValue == USB_FEATURE_SELECTOR_DEVICE_TEST_MODE)
2845:                            {
2846:                                /* Enable test mode only if the Device Speed is High Speed */
2847:                                if (usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed == USB_SPEED_HIGH)
2848:                                {
2849:                                    /* Send ACK to the Test Mode request. */
2850:                                    controlStatus = USB_DEVICE_CONTROL_STATUS_OK;
2851:                
2852:                                    /* Save the Test Selector from SETUP Packet */
2853:                                    usbDeviceThisInstance->usbDeviceStatusStruct.testSelector = setupPkt->W_Index.byte.HB;
2854:                
2855:                                    /* Switching to Test mode is done in the
2856:                                     * _USB_DEVICE_EP0_TransmitComplete function. */
2857:                                    usbDeviceThisInstance->usbDeviceStatusStruct.testModePending = true;
2858:                                }
2859:                                else
2860:                                {
2861:                                    /* Device is not High Speed. STALL the request. */
2862:                                    controlStatus = USB_DEVICE_CONTROL_STATUS_ERROR;
2863:                                }
2864:                            }
2865:                            break;
2866:                
2867:                        case USB_REQUEST_SET_DESCRIPTOR:      
2868:                
2869:                            /* All SET_DESCRIPTOR requests are directly forwarded to application */
2870:                            _USB_DEVICE_Handle_Set_Descriptor_Request ( usbDeviceThisInstance, USB_DEVICE_EVENT_SET_DESCRIPTOR, setupPkt);
2871:                            controlStatus = USB_DEVICE_CONTROL_STATUS_ERROR;
2872:                            break;
2873:                
2874:                        default:
2875:                            /* Respond with a request error. Stall the endpoint. Stall the EP0
2876:                             * TX. */
2877:                            controlStatus = USB_DEVICE_CONTROL_STATUS_ERROR;
2878:                            break;
2879:                    }
2880:                
2881:                    /* Send ZLP */
2882:                    if (sendStatus)
2883:                    {
2884:                        USB_DEVICE_ControlStatus( (USB_DEVICE_HANDLE)usbDeviceThisInstance, controlStatus);
2885:                    }
2886:                }
2887:                
2888:                // ******************************************************************************
2889:                /* Function:
2890:                    void _USB_DEVICE_RedirectControlXfrToClient
2891:                    (
2892:                        USB_DEVICE_OBJ* usbDeviceThisInstance ,
2893:                        USB_DEVICE_EVENT event,
2894:                        USB_SETUP_PACKET * setupPkt
2895:                    )
2896:                
2897:                  Summary:
2898:                    This function forwards control transfers to client.
2899:                
2900:                  Description:
2901:                    This function forwards control transfers to client.
2902:                
2903:                  Remarks:
2904:                    This is local function. It should not be used directly by the client.
2905:                */
2906:                
2907:                void _USB_DEVICE_RedirectControlXfrToClient
2908:                (
2909:                    USB_DEVICE_OBJ* usbDeviceThisInstance ,
2910:                    USB_DEVICE_EVENT event,
2911:                    USB_SETUP_PACKET * setupPkt
2912:                )
2913:                {
2914:                    USB_DEVICE_CONTROL_TRANSFER_STRUCT * controlTransfer = &usbDeviceThisInstance->controlTransfer;
2915:                    
2916:                    /* This control transfer will be handled by the client */
2917:                    controlTransfer->handler = (void (*)(unsigned short, USB_DEVICE_EVENT, void *))usbDeviceThisInstance->callBackFunc;
2918:                
2919:                    controlTransfer->handlerIndex = usbDeviceThisInstance->usbDevLayerIndex ;
2920:                
2921:                    /* Let app clients handle the SETUP packet. */
2922:                    if((usbDeviceThisInstance->clientState == USB_DEVICE_CLIENT_STATUS_READY) && (usbDeviceThisInstance->callBackFunc != NULL))
2923:                    {
2924:                        /* This means this is a valid client. Pass the control transfer
2925:                         * event to the client. */
2926:                        usbDeviceThisInstance->callBackFunc( event, setupPkt, usbDeviceThisInstance->context );
2927:                    }
2928:                
2929:                }
2930:                
2931:                // ******************************************************************************
2932:                /* Function:
2933:                    USB_DEVICE_CLIENT_HANDLE _USB_DEVICE_ClientHandleValidate
2934:                    (
2935:                        USB_DEVICE_HANDLE deviceHandle
2936:                    )
2937:                
2938:                  Summary:
2939:                    Validates the client device handle.
2940:                
2941:                  Description:
2942:                    This function validates a device handle. It returns NULL if the device
2943:                    handle is not valid. It returns the pointer to the client object associated
2944:                    with the handle otherwise.
2945:                
2946:                  Remarks:
2947:                    This is a local function and should not be called directly by the client.
2948:                */
2949:                
2950:                USB_DEVICE_OBJ* _USB_DEVICE_ClientHandleValidate(USB_DEVICE_HANDLE deviceHandle)
2951:                {
2952:                    /* This function validates the client handle and return NULL if the client
2953:                       handle is invalid or if the client has closed the device layer. */
2954:                
2955:                    USB_DEVICE_OBJ* client;
2956:                
2957:                    if((USB_DEVICE_HANDLE_INVALID == deviceHandle) || (0 == deviceHandle))
2958:                    {
2959:                        return (NULL);
2960:                    }
2961:                
2962:                    /* Check if the client object is in use */
2963:                    client = (USB_DEVICE_OBJ *) deviceHandle;
2964:                
2965:                    if(!client->inUse)
2966:                    {
2967:                        return(NULL);
2968:                    }
2969:                
2970:                    /* Return the client handle */
2971:                    return(client);
2972:                }
2973:                
2974:                // ******************************************************************************
2975:                /* Function:
2976:                    void _USB_DEVICE_EndpointMutexCreateFunction
2977:                    (
2978:                        USB_DEVICE_OBJ* usbDeviceThisInstance
2979:                    )
2980:                
2981:                  Summary:
2982:                    Creats mutex which is required for Endpoint read write functions.
2983:                
2984:                  Description:
2985:                    Creats mutex which is required for Endpoint read write functions.
2986:                
2987:                  Remarks:
2988:                    This is a local function and should not be called directly by the client.
2989:                */
2990:                
2991:                void _USB_DEVICE_EndpointMutexCreateFunction(USB_DEVICE_OBJ* usbDeviceThisInstance)
2992:                {
2993:                    
2994:                    OSAL_RESULT osalResult;
2995:                    
2996:                    if (usbDeviceThisInstance->isMutexEndpointIrpInitialized == false)
2997:                    {
2998:                        /* Use the OSAL to create Mutex */
2999:                        osalResult = OSAL_MUTEX_Create(&(usbDeviceThisInstance->mutexEndpointIRP));
3000:                    
3001:                    
3002:                        if(osalResult != OSAL_RESULT_TRUE)
3003:                        {
3004:                            /* Mutex creation failed*/
3005:                            usbDeviceThisInstance->isMutexEndpointIrpInitialized = false;
3006:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Mutex Create Failed");
3007:                        }
3008:                        else
3009:                        {
3010:                            /* Update the flag indicating that the Mutex has been created */
3011:                            usbDeviceThisInstance->isMutexEndpointIrpInitialized = true;
3012:                        }
3013:                    }
3014:                }
3015:                
3016:                // ******************************************************************************
3017:                /* Function:
3018:                    void _USB_DEVICE_EndpointMutexDeleteFunction
3019:                    (
3020:                        USB_DEVICE_OBJ* usbDeviceThisInstance
3021:                    )
3022:                
3023:                  Summary:
3024:                    Deletes mutex which is required for Endpoint read write functions.
3025:                
3026:                  Description:
3027:                    Deletes mutex which is required for Endpoint read write functions.
3028:                
3029:                  Remarks:
3030:                    This is a local function and should not be called directly by the client.
3031:                */
3032:                
3033:                void _USB_DEVICE_EndpointMutexDeleteFunction(USB_DEVICE_OBJ* usbDeviceThisInstance)
3034:                {
3035:                    OSAL_RESULT osalResult;
3036:                
3037:                    /* Use the OSAL to delete the Mutex */
3038:                    osalResult = OSAL_MUTEX_Delete(&(usbDeviceThisInstance->mutexEndpointIRP));
3039:                
3040:                    if(osalResult != OSAL_RESULT_TRUE)
3041:                    {
3042:                        /* Mutex delete failed */
3043:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Mutex Delete Failed");
3044:                    }
3045:                    else
3046:                    {
3047:                        /* Update the flag indicating that the mutex needs to be created again
3048:                         * */
3049:                        usbDeviceThisInstance->isMutexEndpointIrpInitialized = false;
3050:                    }
3051:                }
3052:                
3053:                // ******************************************************************************
3054:                /* Function:
3055:                    uint16_t _USB_DEVICE_GetStringDescriptorRequestProcess
3056:                    (
3057:                        USB_DEVICE_MASTER_DESCRIPTOR * ptrMasterDescTable,
3058:                        USB_SETUP_PACKET * setupPkt,
3059:                        void**  pDescriptorString
3060:                    )
3061:                  Summary:
3062:                    This function processes the Get Descriptor request received from Host.
3063:                
3064:                  Description:
3065:                    This function processes the Get Descriptor request received from Host.
3066:                    The USB Device Layer chooses this function when the macro
3067:                    USB_DEVICE_STRING_DESCRIPTOR_TABLE_ADVANCED_ENABLE is not defined.
3068:                
3069:                    This function is implemented based on the following String Descriptor 
3070:                    Table structure. 
3071:                    
3072:                    Following example assumes the Device supports 3 String Descriptors in 3 
3073:                    different Languages. 
3074:                    
3075:                        String Descriptor Index 0 -- Specifies Codes for all the Language 
3076:                                                     supported. 
3077:                        String -- Index 1 -- Language 1
3078:                        String -- Index 2 -- Language 1
3079:                        String -- Index 3 -- Language 1
3080:                        String -- Index 1 -- Language 2
3081:                        String -- Index 2 -- Language 2
3082:                        String -- Index 3 -- Language 2
3083:                        String -- Index 1 -- Language 3
3084:                        String -- Index 2 -- Language 3
3085:                        String -- Index 3 -- Language 3 
3086:                
3087:                  Remarks:
3088:                    This is a local function and should not be called directly by the client.
3089:                */
3090:                
3091:                uint16_t _USB_DEVICE_GetStringDescriptorRequestProcess
3092:                (
3093:                    USB_DEVICE_MASTER_DESCRIPTOR * ptrMasterDescTable,
3094:                    USB_SETUP_PACKET * setupPkt,
3095:                    void**  pDescriptorString
3096:                )
3097:                {
3098:                    uint8_t* stringDesc;
3099:                    uint8_t NumberLangSupported =0;
3100:                    uint16_t langID;
3101:                    uint16_t langIndex;
3102:                    uint16_t CurrentLangId;
3103:                    uint8_t stringIndex;
3104:                    uint16_t DescriptorStringSize = 0;
3105:                
3106:                    /* Get the string descriptor index from setup packet*/
3107:                    stringIndex = setupPkt->bDscIndex;
3108:                    uint8_t stringDescPerLang =0; 
3109:                    
3110:                    /* Find Number Languages supported from String Descriptor array index 0 */
3111:                    NumberLangSupported = (uint8_t)((ptrMasterDescTable->stringDescriptorTable[0][0]) - 2)/2;   
3112:                    
3113:                    if (NumberLangSupported)
3114:                    {
3115:                        /* Get Number of Strings per Language */
3116:                        stringDescPerLang = (ptrMasterDescTable->stringDescCount - 1)/NumberLangSupported; 
3117:                    }
3118:                    
3119:                    /* Check if the String Index requested by Host is with in the String
3120:                     * descriptor count specified in the Master descriptor Table */ 
3121:                
3122:                    if(setupPkt->bDscIndex <= stringDescPerLang)
3123:                    {
3124:                        /* This means the index is valid. Get correct string
3125:                         * descriptor and update the response variable */
3126:                
3127:                        if (stringIndex == 0)
3128:                        {
3129:                            /* Get pointer to String Descriptor */ 
3130:                            stringDesc = (uint8_t*)(ptrMasterDescTable->stringDescriptorTable[0] );
3131:                            *pDescriptorString = (uint8_t *)stringDesc;
3132:                
3133:                            /* Get Size of the String descriptor. Size is always the First
3134:                             * element in the String descriptor structure  */  
3135:                            DescriptorStringSize = stringDesc[0];
3136:                        }
3137:                        else
3138:                        {
3139:                            /* Retrieve Language ID from SETUP packet */
3140:                            langID = setupPkt->wLangID;
3141:                
3142:                            /* Search through the String Descriptor Array (Index Zero) to find
3143:                             * out Language ID Index*/
3144:                            for (langIndex = 1; langIndex <= NumberLangSupported; langIndex++)
3145:                            {
3146:                                /* Get the Language ID from String Descriptor Index 0 */ 
3147:                                CurrentLangId = *((uint16_t*)ptrMasterDescTable->stringDescriptorTable[0] + langIndex);
3148:                
3149:                                /* Check if the requested Language ID same as Current Language ID */ 
3150:                                if (CurrentLangId == langID)
3151:                                {
3152:                                    /* The Requested String Descriptor and Language was found.
3153:                                     * Get pointer to String Descriptor */ 
3154:                                    stringDesc = (uint8_t*)( ptrMasterDescTable->stringDescriptorTable[langIndex*stringIndex] );
3155:                                    *pDescriptorString = (uint8_t *)stringDesc;
3156:                                    
3157:                                    /* Get Size of the String descriptor. Size is always the
3158:                                     * First element in the String descriptor structure  */
3159:                                    DescriptorStringSize = stringDesc[0];
3160:                                    break;
3161:                                }
3162:                            }
3163:                        }
3164:                
3165:                        return DescriptorStringSize;
3166:                    }
3167:                
3168:                    /* We could not find the requested String Descriptor in the String 
3169:                       Descriptor Table. The request will be stalled. */  
3170:                    
3171:                    return 0; 
3172:                }
3173:                
3174:                // ******************************************************************************
3175:                /* Function:
3176:                    uint16_t _USB_DEVICE_GetStringDescriptorRequestProcessAdvanced
3177:                    (
3178:                        USB_DEVICE_MASTER_DESCRIPTOR * ptrMasterDescTable,
3179:                        USB_SETUP_PACKET * setupPkt,
3180:                        void**  pDescriptorString
3181:                    )
3182:                
3183:                  Summary:
3184:                    This function processes the Get Descriptor request received from Host.
3185:                
3186:                  Description:
3187:                    This function processes the Get Descriptor request received from Host.
3188:                    The USB Device Layer chooses this function when the macro
3189:                    USB_DEVICE_STRING_DESCRIPTOR_TABLE_ADVANCED_ENABLE is defined.
3190:                
3191:                    This function is implemented based on the following String Descriptor 
3192:                    Table structure. 
3193:                    
3194:                            |Size(Byte)|Type(Byte)|String Index 0(Byte)|0(Word)|Language ID 1(Word)|Language ID 2(Word)|...|Language ID n(Word)|
3195:                            |Size(Byte)|Type(Byte)|String Index x(Byte)|Language ID 1(Word)|String |
3196:                            |Size(Byte)|Type(Byte)|String Index x(Byte)|Language ID 1(Word)|String |
3197:                            .
3198:                            .
3199:                            .
3200:                            |Size(Byte)|Type(Byte)|String Index x(Byte)|Language ID n(Word)|String |
3201:                
3202:                  Remarks:
3203:                    This is a local function and should not be called directly by the client.
3204:                */
3205:                
3206:                uint16_t _USB_DEVICE_GetStringDescriptorRequestProcessAdvanced
3207:                (
3208:                    USB_DEVICE_MASTER_DESCRIPTOR * ptrMasterDescTable,
3209:                    USB_SETUP_PACKET * setupPkt,
3210:                    void**  pDescriptorString
3211:                )
3212:                {
3213:                    uint8_t* stringDesc;
3214:                    uint16_t langID;
3215:                    uint8_t stringIndexRequested;
3216:                    uint16_t DescriptorStringSize = 0;
3217:                    uint8_t count;
3218:                    uint8_t stringIndex;
3219:                     
3220:                     /* Get the string descriptor index from setup packet*/
3221:                    stringIndexRequested = setupPkt->bDscIndex;
3222:                
3223:                    if (stringIndexRequested == 0)
3224:                    {
3225:                        /* Get pointer to String Descriptor */ 
3226:                        stringDesc = (uint8_t*)&(ptrMasterDescTable->stringDescriptorTable[0][3] );
3227:                        *pDescriptorString = (uint8_t *)stringDesc;
3228:                
3229:                        /* Get Size of the String descriptor. Size is always the First element
3230:                         * in the String descriptor structure  */ 
3231:                
3232:                        DescriptorStringSize = stringDesc[0];
3233:                    }
3234:                    else
3235:                    {
3236:                        for (count = 1; count < ptrMasterDescTable->stringDescCount; count++ )
3237:                        {
3238:                            /* Get the string index from the String Descriptor.  String Index is
3239:                             * always the third element in the String Descriptor */  
3240:                            
3241:                            stringIndex = ptrMasterDescTable->stringDescriptorTable[count][0];
3242:                            
3243:                            /* Get Language ID from the string descriptor. Language ID is always
3244:                             * the Fourth element in the String Descriptor */ 
3245:                            
3246:                            langID = ((uint16_t)ptrMasterDescTable->stringDescriptorTable[count][2]<<8)
3247:                                               |ptrMasterDescTable->stringDescriptorTable[count][1];
3248:                
3249:                            /* Check if the Requested String Index and Language ID matches with
3250:                             * the values retrieved from String Descriptor */  
3251:                
3252:                            if ((stringIndex == stringIndexRequested) && (langID == setupPkt->wLangID))
3253:                            {
3254:                                    /* The Requested String Descriptor and Language was found.
3255:                                     * Get pointer to String Descriptor */ 
3256:                
3257:                                    stringDesc = (uint8_t*)&( ptrMasterDescTable->stringDescriptorTable[count][3] );
3258:                                    *pDescriptorString = (uint8_t *)stringDesc;
3259:                                    
3260:                                    /* Get Size of the String descriptor. Size is always the
3261:                                     * First element in the String descriptor structure  */
3262:                
3263:                                    DescriptorStringSize = stringDesc[0];
3264:                                    break;
3265:                            }
3266:                        }
3267:                    }
3268:                
3269:                    /* Return String descriptor size. USB device layer would stall the request
3270:                     * if the requested string descriptor was not found. If requested string was
3271:                     * not found the DescriptorStringSize would be zero and pDescriptorString
3272:                     * would be NULL.  */  
3273:                
3274:                    return DescriptorStringSize;
3275:                }
3276:                
3277:                // ******************************************************************************
3278:                /* Function:
3279:                    void _USB_DEVICE_Other_Speed_Descriptor_Request
3280:                    (
3281:                        USB_DEVICE_OBJ * usbDeviceThisInstance, 
3282:                        USB_SETUP_PACKET * setupPkt
3283:                    )
3284:                
3285:                  Summary:
3286:                    This function processes the Get Other Speed Configuration descriptor request
3287:                    from Host.
3288:                
3289:                  Description:
3290:                    This function processes the Get Other Speed Configuration descriptor request
3291:                    from Host. This function should be called only if the USB peripheral is 
3292:                    configured for High Speed operation. 
3293:                 
3294:                  Remarks:
3295:                    This is a local function and should not be called directly by the client.
3296:                */
3297:                void _USB_DEVICE_Other_Speed_Descriptor_Request
3298:                (
3299:                    USB_DEVICE_OBJ * usbDeviceThisInstance, 
3300:                    USB_SETUP_PACKET * setupPkt
3301:                )
3302:                {
3303:                    USB_CONFIGURATION_DESCRIPTOR * lConfigDescriptor = NULL;
3304:                    USB_DEVICE_MASTER_DESCRIPTOR * ptrMasterDescTable ;
3305:                    uint32_t size; 
3306:                    uint32_t pendingBytesOtherSpeedDescptr = 0; 
3307:                    
3308:                    /* Copy the Master descriptor table to a local pointer. */
3309:                    ptrMasterDescTable = usbDeviceThisInstance->ptrMasterDescTable ;
3310:                    
3311:                    /* Find out whether device is operating at full speed or high speed */
3312:                    if( usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed == USB_SPEED_HIGH )
3313:                    {
3314:                        if (((setupPkt->bDscIndex) < ptrMasterDescTable->configDescriptorCount) && (ptrMasterDescTable->configDescriptorTable != NULL))
3315:                        {
3316:                            /* If the Device is operating at High Speed, we send the full speed 
3317:                             * configuration descriptor */ 
3318:                            lConfigDescriptor = (USB_CONFIGURATION_DESCRIPTOR *)ptrMasterDescTable->configDescriptorTable[setupPkt->bDscIndex];
3319:                        }
3320:                    }
3321:                    else
3322:                    {
3323:                        if (((setupPkt->bDscIndex) < ptrMasterDescTable->highSpeedConfigDescriptorCount)
3324:                            && (ptrMasterDescTable->highSpeedConfigDescriptorTable != NULL))
3325:                        {
3326:                            /* If the device is operating at full speed, then send the high speed 
3327:                             * configuration descriptor */
3328:                            lConfigDescriptor = (USB_CONFIGURATION_DESCRIPTOR *)ptrMasterDescTable->highSpeedConfigDescriptorTable[setupPkt->bDscIndex];
3329:                        }
3330:                    }
3331:                
3332:                    if(lConfigDescriptor != NULL )
3333:                    { 
3334:                        /* Get the descriptor size */
3335:                        size = lConfigDescriptor->wTotalLength;
3336:                             
3337:                        /* Adjust data size as Host request */
3338:                        if( size > setupPkt->wLength )
3339:                        {
3340:                            
3341:                            size = setupPkt->wLength;  
3342:                        }
3343:                        
3344:                        /* Update IRP flag to complete the transfer initially */
3345:                        _USB_DEVICE_OtherSpeedDescriptorRequestIrpFlagsUpdate
3346:                        (
3347:                            &(usbDeviceThisInstance->irpEp0TxOtherSpeedDescriptor), 
3348:                            USB_DEVICE_IRP_FLAG_DATA_COMPLETE
3349:                        ); 
3350:                        
3351:                        /* We may have to submit two IRPs for the Other Speed Configuration 
3352:                           descriptor request. The Second IRP is only needed if the data size 
3353:                           requested by the Host is more than USB_DEVICE_EP0_BUFFER_SIZE. */
3354:                        if (size > USB_DEVICE_EP0_BUFFER_SIZE)
3355:                        {
3356:                            /* Update Pending Bytes. This data will go in the Second IRP */
3357:                            pendingBytesOtherSpeedDescptr = size - USB_DEVICE_EP0_BUFFER_SIZE;
3358:                            
3359:                            /* In the First IRP we will submit only EP0 Buffer Size worth of 
3360:                             * data. Remaining Bytes will be sent in the Second IRP */
3361:                            size = USB_DEVICE_EP0_BUFFER_SIZE; 
3362:                            
3363:                            /* Keep the IRP flags pending as we are going to submit another IRP. */
3364:                            _USB_DEVICE_OtherSpeedDescriptorRequestIrpFlagsUpdate
3365:                            (
3366:                                &(usbDeviceThisInstance->irpEp0TxOtherSpeedDescriptor), 
3367:                                USB_DEVICE_IRP_FLAG_DATA_PENDING
3368:                            );    
3369:                        }
3370:                        
3371:                        /* Copy Data into the EP0 Transmit buffer */
3372:                        _USB_DEVICE_OtherSpeedDescriptorRequestCopyData
3373:                        (
3374:                            usbDeviceThisInstance->ep0TxBuffer,
3375:                            lConfigDescriptor,
3376:                            size
3377:                        );
3378:                        
3379:                        /* Edit Descriptor type to OTHER_SPEED */
3380:                        _USB_DEVICE_OtherSpeedDescriptorRequestEditDescriptorType
3381:                        (
3382:                            usbDeviceThisInstance->ep0TxBuffer,
3383:                            1,
3384:                            USB_DESCRIPTOR_OTHER_SPEED
3385:                        ); 
3386:                        
3387:                        if (pendingBytesOtherSpeedDescptr == 0)
3388:                        {
3389:                            /* Fill in the Other Speed Descriptor IRP. */ 
3390:                            _USB_DEVICE_OtherSpeedDescriptorRequestIrpFill
3391:                            (
3392:                                &(usbDeviceThisInstance->irpEp0TxOtherSpeedDescriptor),
3393:                                usbDeviceThisInstance->ep0TxBuffer,
3394:                                size,
3395:                                _USB_DEVICE_Ep0TransmitCompleteCallback,
3396:                                (uintptr_t)usbDeviceThisInstance
3397:                            ); 
3398:                            
3399:                             /* Submit IRP */
3400:                            _USB_DEVICE_OtherSpeedDescriptorRequestIrpSubmit(usbDeviceThisInstance->usbCDHandle, controlEndpointTx, &usbDeviceThisInstance->irpEp0TxOtherSpeedDescriptor ); 
3401:                        }
3402:                        else
3403:                        {
3404:                            /* This means we have to submit two IRPs */   
3405:                            if (pendingBytesOtherSpeedDescptr % USB_DEVICE_EP0_BUFFER_SIZE == 0)
3406:                            {
3407:                                _USB_DEVICE_OtherSpeedDescriptorRequestIrpFlagsUpdate
3408:                                (
3409:                                    &(usbDeviceThisInstance->irpEp0Tx), 
3410:                                    USB_DEVICE_IRP_FLAG_DATA_PENDING
3411:                                ); 
3412:                            }
3413:                            else
3414:                            {
3415:                                _USB_DEVICE_OtherSpeedDescriptorRequestIrpFlagsUpdate
3416:                                (
3417:                                    &(usbDeviceThisInstance->irpEp0Tx), 
3418:                                    USB_DEVICE_IRP_FLAG_DATA_COMPLETE
3419:                                );
3420:                            }
3421:                            
3422:                            /* Fill in the Other Speed Descriptor IRP. Callback is NULL here. We
3423:                               do not want to be notified for first IRP */ 
3424:                            _USB_DEVICE_OtherSpeedDescriptorRequestIrpFill
3425:                            (
3426:                                &(usbDeviceThisInstance->irpEp0TxOtherSpeedDescriptor),
3427:                                usbDeviceThisInstance->ep0TxBuffer,
3428:                                size,
3429:                                NULL,
3430:                                (uintptr_t)usbDeviceThisInstance
3431:                            ); 
3432:                            
3433:                            /* Submit the first IRP */
3434:                            _USB_DEVICE_OtherSpeedDescriptorRequestIrpSubmit(usbDeviceThisInstance->usbCDHandle, controlEndpointTx, &usbDeviceThisInstance->irpEp0TxOtherSpeedDescriptor ); 
3435:                            
3436:                            /* Fill in the Second IRP for the pending data */
3437:                            _USB_DEVICE_OtherSpeedDescriptorRequestIrpFill
3438:                            (
3439:                                &(usbDeviceThisInstance->irpEp0Tx), 
3440:                                ((uint8_t*)lConfigDescriptor + USB_DEVICE_EP0_BUFFER_SIZE),
3441:                                pendingBytesOtherSpeedDescptr,
3442:                                _USB_DEVICE_Ep0TransmitCompleteCallback,
3443:                                (uintptr_t)usbDeviceThisInstance
3444:                            );   
3445:                       
3446:                            /* Submit second IRP */
3447:                            _USB_DEVICE_OtherSpeedDescriptorRequestIrpSubmit(usbDeviceThisInstance->usbCDHandle, controlEndpointTx, &usbDeviceThisInstance->irpEp0Tx); 
3448:                        }
3449:                        
3450:                    }
3451:                    else
3452:                    {
3453:                        /* Configuration not found */
3454:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid pointer to configuration descriptor");
3455:                    }
3456:                }
3457:                
3458:                /********************End of file********************************/
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
00000024  00000000   NOP
00000028  00000000   NOP
0000002C  00000000   NOP
00000030  00000000   NOP
00000034  00000000   NOP
00000038  00000000   NOP
0000003C  00000000   NOP
00000040  00000000   NOP
00000044  00000000   NOP
00000048  00000000   NOP
0000004C  00000000   NOP
00000050  00000000   NOP
00000054  00000000   NOP
00000058  00000000   NOP
0000005C  00000000   NOP
00000060  00000000   NOP
00000064  00000000   NOP
00000068  00000000   NOP
0000006C  00000000   NOP
00000074  00000000   NOP
00000078  00000000   NOP
0000007C  00000000   NOP
00000080  00000000   NOP
00000084  00000000   NOP
00000088  00000000   NOP
0000008C  00000000   NOP
00000090  00000000   NOP
00000094  00000000   NOP
0000009C  00000000   NOP
9D000190  2482FFFF   ADDIU V0, A0, -1
9D000194  2C42FFFE   SLTIU V0, V0, -2
9D0001A0  908200DC   LBU V0, 220(A0)
9D0001AC  8C8200EC   LW V0, 236(A0)
9D0001B0  27BDFFE8   ADDIU SP, SP, -24
9D0001B4  AFB00010   SW S0, 16(SP)
9D0001B8  8C42001C   LW V0, 28(V0)
9D0001BC  00808025   OR S0, A0, ZERO
9D0001C0  8C84001C   LW A0, 28(A0)
9D0001C4  AFBF0014   SW RA, 20(SP)
9D0001C8  0040F809   JALR V0
9D0001CC  00000000   NOP
9D0001D0  96030000   LHU V1, 0(S0)
9D0001D4  92020003   LBU V0, 3(S0)
9D0001D8  7C035284   INS V1, ZERO, 10, 1
9D0001DC  7C021004   INS V0, ZERO, 0, 3
9D0001E0  A6030000   SH V1, 0(S0)
9D0001E4  A2020003   SB V0, 3(S0)
9D0001E8  8FBF0014   LW RA, 20(SP)
9D0001EC  8FB00010   LW S0, 16(SP)
9D0001F0  03E00008   JR RA
9D0001F4  27BD0018   ADDIU SP, SP, 24
9D0001F8  03E00008   JR RA
9D0001FC  00000000   NOP
9D002ABC  2402000E   ADDIU V0, ZERO, 14
9D002AC0  10A20003   BEQ A1, V0, 0x9D002AD0
9D002AC4  00000000   NOP
9D002AC8  03E00008   JR RA
9D002ACC  00000000   NOP
9D002AD0  27BDFFD8   ADDIU SP, SP, -40
9D002AD4  AFB40020   SW S4, 32(SP)
9D002AD8  0004A100   SLL S4, A0, 4
9D002ADC  AFB00010   SW S0, 16(SP)
9D002AE0  02848023   SUBU S0, S4, A0
9D002AE4  00108080   SLL S0, S0, 2
9D002AE8  AFB3001C   SW S3, 28(SP)
9D002AEC  02048021   ADDU S0, S0, A0
9D002AF0  3C13A000   LUI S3, -24576
9D002AF4  00108080   SLL S0, S0, 2
9D002AF8  26730280   ADDIU S3, S3, 640
9D002AFC  AFB20018   SW S2, 24(SP)
9D002B00  AFB10014   SW S1, 20(SP)
9D002B04  AFBF0024   SW RA, 36(SP)
9D002B08  02708021   ADDU S0, S3, S0
9D002B0C  90C20007   LBU V0, 7(A2)
9D002B10  8E0300EC   LW V1, 236(S0)
9D002B14  90C50006   LBU A1, 6(A2)
9D002B18  00809025   OR S2, A0, ZERO
9D002B1C  8C630040   LW V1, 64(V1)
9D002B20  8E04001C   LW A0, 28(S0)
9D002B24  00021200   SLL V0, V0, 8
9D002B28  00451025   OR V0, V0, A1
9D002B2C  00C08825   OR S1, A2, ZERO
9D002B30  A60200E8   SH V0, 232(S0)
9D002B34  0060F809   JALR V1
9D002B38  24050080   ADDIU A1, ZERO, 128
9D002B3C  92270000   LBU A3, 0(S1)
9D002B40  24040001   ADDIU A0, ZERO, 1
9D002B44  7CE22000   EXT V0, A3, 0, 5
9D002B48  304300FF   ANDI V1, V0, 255
9D002B4C  10640055   BEQ V1, A0, 0x9D002CA4
9D002B50  7C021420   SEB V0, V0
9D002B54  1040003A   BEQ V0, ZERO, 0x9D002C40
9D002B58  24020002   ADDIU V0, ZERO, 2
9D002B5C  1062001D   BEQ V1, V0, 0x9D002BD4
9D002B60  24020003   ADDIU V0, ZERO, 3
9D002B64  5062000A   BEQL V1, V0, 0x9D002B90
9D002B68  8E1900E0   LW T9, 224(S0)
9D002B6C  8FBF0024   LW RA, 36(SP)
9D002B70  8FB40020   LW S4, 32(SP)
9D002B74  8FB3001C   LW S3, 28(SP)
9D002B78  8FB20018   LW S2, 24(SP)
9D002B7C  8FB10014   LW S1, 20(SP)
9D002B80  8FB00010   LW S0, 16(SP)
9D002B84  03E00008   JR RA
9D002B88  27BD0028   ADDIU SP, SP, 40
9D002B8C  8E1900E0   LW T9, 224(S0)
9D002B90  96030018   LHU V1, 24(S0)
9D002B94  8E0200D8   LW V0, 216(S0)
9D002B98  AE1900D0   SW T9, 208(S0)
9D002B9C  1444FFF3   BNE V0, A0, 0x9D002B6C
9D002BA0  A60300C8   SH V1, 200(S0)
9D002BA4  1320FFF1   BEQ T9, ZERO, 0x9D002B6C
9D002BA8  8FBF0024   LW RA, 36(SP)
9D002BAC  8E0600E4   LW A2, 228(S0)
9D002BB0  02202825   OR A1, S1, ZERO
9D002BB4  8FB40020   LW S4, 32(SP)
9D002BB8  8FB3001C   LW S3, 28(SP)
9D002BBC  8FB20018   LW S2, 24(SP)
9D002BC0  8FB10014   LW S1, 20(SP)
9D002BC4  8FB00010   LW S0, 16(SP)
9D002BC8  2404000E   ADDIU A0, ZERO, 14
9D002BCC  03200008   JR T9
9D002BD0  27BD0028   ADDIU SP, SP, 40
9D002BD4  92250004   LBU A1, 4(S1)
9D002BD8  50A00049   BEQL A1, ZERO, 0x9D002D00
9D002BDC  30E70060   ANDI A3, A3, 96
9D002BE0  8E0300B4   LW V1, 180(S0)
9D002BE4  90680003   LBU T0, 3(V1)
9D002BE8  90620002   LBU V0, 2(V1)
9D002BEC  00084200   SLL T0, T0, 8
9D002BF0  01024025   OR T0, T0, V0
9D002BF4  11000058   BEQ T0, ZERO, _USB_DEVICE_ControlTransferHandler::USB_DEVICE_ControlStatus
9D002BF8  00005825   OR T3, ZERO, ZERO
9D002BFC  00001025   OR V0, ZERO, ZERO
9D002C00  24090004   ADDIU T1, ZERO, 4
9D002C04  10000009   BEQ ZERO, ZERO, 0x9D002C2C
9D002C08  240A0005   ADDIU T2, ZERO, 5
9D002C0C  508A0030   BEQL A0, T2, _USB_DEVICE_ControlTransferHandler::_USB_DEVICE_FindEndpoint
9D002C10  90640002   LBU A0, 2(V1)
9D002C14  90640000   LBU A0, 0(V1)
9D002C18  00441021   ADDU V0, V0, A0
9D002C1C  3042FFFF   ANDI V0, V0, -1
9D002C20  0048302B   SLTU A2, V0, T0
9D002C24  10C0004C   BEQ A2, ZERO, _USB_DEVICE_ControlTransferHandler::USB_DEVICE_ControlStatus
9D002C28  00641821   ADDU V1, V1, A0
9D002C2C  90640001   LBU A0, 1(V1)
9D002C30  1489FFF6   BNE A0, T1, _USB_DEVICE_ControlTransferHandler::_USB_DEVICE_FindEndpoint
9D002C34  00000000   NOP
9D002C38  1000FFF6   BEQ ZERO, ZERO, 0x9D002C14
9D002C3C  906B0002   LBU T3, 2(V1)
9D002C40  92220000   LBU V0, 0(S1)
9D002C44  30430060   ANDI V1, V0, 96
9D002C48  10600038   BEQ V1, ZERO, 0x9D002D2C
9D002C4C  7C021420   SEB V0, V0
9D002C50  24020040   ADDIU V0, ZERO, 64
9D002C54  1062FFCD   BEQ V1, V0, _USB_DEVICE_ControlTransferHandler::_USB_DEVICE_RedirectControlXfrToClient
9D002C58  24020020   ADDIU V0, ZERO, 32
9D002C5C  1462FFC4   BNE V1, V0, 0x9D002B70
9D002C60  8FBF0024   LW RA, 36(SP)
9D002C64  920200DC   LBU V0, 220(S0)
9D002C70  8E0200EC   LW V0, 236(S0)
9D002C74  8E04001C   LW A0, 28(S0)
9D002C78  A20000C4   SB ZERO, 196(S0)
9D002C7C  8FBF0024   LW RA, 36(SP)
9D002C80  8FB40020   LW S4, 32(SP)
9D002C84  8FB3001C   LW S3, 28(SP)
9D002C88  8FB20018   LW S2, 24(SP)
9D002C8C  8FB10014   LW S1, 20(SP)
9D002C90  8FB00010   LW S0, 16(SP)
9D002C94  8C590028   LW T9, 40(V0)
9D002C98  24050080   ADDIU A1, ZERO, 128
9D002C9C  03200008   JR T9
9D002CA0  27BD0028   ADDIU SP, SP, 40
9D002CA4  92250004   LBU A1, 4(S1)
9D002CA8  02203025   OR A2, S1, ZERO
9D002CAC  02002025   OR A0, S0, ZERO
9D002CB0  8FBF0024   LW RA, 36(SP)
9D002CB4  8FB40020   LW S4, 32(SP)
9D002CB8  8FB3001C   LW S3, 28(SP)
9D002CBC  8FB20018   LW S2, 24(SP)
9D002CC0  8FB10014   LW S1, 20(SP)
9D002CC4  8FB00010   LW S0, 16(SP)
9D002CC8  0B401908   J _USB_DEVICE_ForwardControlXfrToFunction
9D002CCC  27BD0028   ADDIU SP, SP, 40
9D002CD0  5485FFD1   BNEL A0, A1, 0x9D002C18
9D002CD4  90640000   LBU A0, 0(V1)
9D002CD8  02921023   SUBU V0, S4, S2
9D002CDC  00021080   SLL V0, V0, 2
9D002CE0  00521021   ADDU V0, V0, S2
9D002CE4  00021080   SLL V0, V0, 2
9D002CE8  02621021   ADDU V0, S3, V0
9D002CEC  90420003   LBU V0, 3(V0)
9D002CF0  30420007   ANDI V0, V0, 7
9D002CF4  144A0018   BNE V0, T2, _USB_DEVICE_ControlTransferHandler::USB_DEVICE_ControlStatus
9D002CF8  01602825   OR A1, T3, ZERO
9D002CFC  30E70060   ANDI A3, A3, 96
9D002D00  02203025   OR A2, S1, ZERO
9D002D04  14E0FFEA   BNE A3, ZERO, 0x9D002CB0
9D002D08  02002025   OR A0, S0, ZERO
9D002D0C  8FBF0024   LW RA, 36(SP)
9D002D10  8FB40020   LW S4, 32(SP)
9D002D14  8FB3001C   LW S3, 28(SP)
9D002D18  8FB20018   LW S2, 24(SP)
9D002D1C  8FB10014   LW S1, 20(SP)
9D002D20  8FB00010   LW S0, 16(SP)
9D002D24  0B40147A   J _USB_DEVICE_ProcessStandardEndpointRequest
9D002D28  27BD0028   ADDIU SP, SP, 40
9D002D2C  02202825   OR A1, S1, ZERO
9D002D30  04400015   BLTZ V0, 0x9D002D88
9D002D34  02002025   OR A0, S0, ZERO
9D002D38  8FBF0024   LW RA, 36(SP)
9D002D3C  8FB40020   LW S4, 32(SP)
9D002D40  8FB3001C   LW S3, 28(SP)
9D002D44  8FB20018   LW S2, 24(SP)
9D002D48  8FB10014   LW S1, 20(SP)
9D002D4C  8FB00010   LW S0, 16(SP)
9D002D50  0B400DD7   J _USB_DEVICE_ProcessStandardDeviceSetRequests
9D002D54  27BD0028   ADDIU SP, SP, 40
9D002D58  0292A023   SUBU S4, S4, S2
9D002D6C  926200DC   LBU V0, 220(S3)
9D002D78  8E6200EC   LW V0, 236(S3)
9D002D7C  8E64001C   LW A0, 28(S3)
9D002D80  1000FFBE   BEQ ZERO, ZERO, 0x9D002C7C
9D002D84  A26000C4   SB ZERO, 196(S3)
9D002D88  8FBF0024   LW RA, 36(SP)
9D002D8C  8FB40020   LW S4, 32(SP)
9D002D90  8FB3001C   LW S3, 28(SP)
9D002D94  8FB20018   LW S2, 24(SP)
9D002D98  8FB10014   LW S1, 20(SP)
9D002D9C  8FB00010   LW S0, 16(SP)
9D002DA0  0B400E61   J _USB_DEVICE_ProcessStandardDeviceGetRequests
9D002DA4  27BD0028   ADDIU SP, SP, 40
9D002DA8  27BDFFD8   ADDIU SP, SP, -40
9D003030  8C820008   LW V0, 8(A0)
9D003034  18400034   BLEZ V0, 0x9D003108
9D003038  00000000   NOP
9D00303C  27BDFFD8   ADDIU SP, SP, -40
9D003040  2CA2000A   SLTIU V0, A1, 10
9D003044  AFB20020   SW S2, 32(SP)
9D003048  AFB1001C   SW S1, 28(SP)
9D00304C  AFB00018   SW S0, 24(SP)
9D003050  AFBF0024   SW RA, 36(SP)
9D003054  00808025   OR S0, A0, ZERO
9D003058  00A08825   OR S1, A1, ZERO
9D00305C  10400012   BEQ V0, ZERO, __jend__USB_DEVICE_EventHandler_273
9D003060  00C09025   OR S2, A2, ZERO
9D003064  3C029D00   LUI V0, -25344
9D003068  00051880   SLL V1, A1, 2
9D00306C  24423080   ADDIU V0, V0, 12416
9D003070  00431021   ADDU V0, V0, V1
9D003074  8C420000   LW V0, 0(V0)
9D003078  00400008   JR V0
9D00307C  00000000   NOP
9D0030A8  5620000C   BNEL S1, ZERO, 0x9D0030DC
9D0030B0  8FBF0024   LW RA, 36(SP)
9D0030B4  8FB20020   LW S2, 32(SP)
9D0030B8  8FB1001C   LW S1, 28(SP)
9D0030BC  8FB00018   LW S0, 24(SP)
9D0030C0  03E00008   JR RA
9D0030C4  27BD0028   ADDIU SP, SP, 40
9D0030C8  94820000   LHU V0, 0(A0)
9D0030CC  24030001   ADDIU V1, ZERO, 1
9D0030D0  7C625284   INS V0, V1, 10, 1
9D0030D4  A4820000   SH V0, 0(A0)
9D0030D8  8E0300D8   LW V1, 216(S0)
9D0030DC  24020001   ADDIU V0, ZERO, 1
9D0030E0  1462FFF4   BNE V1, V0, 0x9D0030B4
9D0030E4  8FBF0024   LW RA, 36(SP)
9D0030E8  8E0200E0   LW V0, 224(S0)
9D0030EC  1040FFF0   BEQ V0, ZERO, 0x9D0030B0
9D0030F0  02402825   OR A1, S2, ZERO
9D0030F4  8E0600E4   LW A2, 228(S0)
9D0030F8  0040F809   JALR V0
9D0030FC  02202025   OR A0, S1, ZERO
9D003100  1000FFEC   BEQ ZERO, ZERO, 0x9D0030B4
9D003104  8FBF0024   LW RA, 36(SP)
9D003108  03E00008   JR RA
9D00310C  00000000   NOP
9D003110  94820000   LHU V0, 0(A0)
9D003114  8C8300EC   LW V1, 236(A0)
9D003118  8C84001C   LW A0, 28(A0)
9D00311C  7C025284   INS V0, ZERO, 10, 1
9D003120  A6020000   SH V0, 0(S0)
9D003124  8C620040   LW V0, 64(V1)
9D003128  0040F809   JALR V0
9D00312C  00002825   OR A1, ZERO, ZERO
9D003130  8E0200EC   LW V0, 236(S0)
9D003134  8E04001C   LW A0, 28(S0)
9D003138  8C420040   LW V0, 64(V0)
9D00313C  0040F809   JALR V0
9D003140  24050080   ADDIU A1, ZERO, 128
9D003144  0F4019FE   JAL _USB_DEVICE_DeInitializeAllFunctionDrivers
9D003148  02002025   OR A0, S0, ZERO
9D00314C  8E0200EC   LW V0, 236(S0)
9D003150  8E04001C   LW A0, 28(S0)
9D003154  8C420024   LW V0, 36(V0)
9D003158  0040F809   JALR V0
9D00315C  24050010   ADDIU A1, ZERO, 16
9D003160  8E0200EC   LW V0, 236(S0)
9D003164  8E04001C   LW A0, 28(S0)
9D003168  24070040   ADDIU A3, ZERO, 64
9D00316C  8C420020   LW V0, 32(V0)
9D003170  00003025   OR A2, ZERO, ZERO
9D003174  0040F809   JALR V0
9D003178  24050080   ADDIU A1, ZERO, 128
9D00317C  8E020090   LW V0, 144(S0)
9D003180  28420003   SLTI V0, V0, 3
9D003184  50400008   BEQL V0, ZERO, 0x9D0031A8
9D003188  92020003   LBU V0, 3(S0)
9D00318C  8E0200EC   LW V0, 236(S0)
9D003190  8E04001C   LW A0, 28(S0)
9D003194  26060088   ADDIU A2, S0, 136
9D003198  8C420038   LW V0, 56(V0)
9D00319C  0040F809   JALR V0
9D0031A0  00002825   OR A1, ZERO, ZERO
9D0031A4  92020003   LBU V0, 3(S0)
9D0031A8  8E0300EC   LW V1, 236(S0)
9D0031AC  24040003   ADDIU A0, ZERO, 3
9D0031B0  7C821004   INS V0, A0, 0, 3
9D0031B4  A2020003   SB V0, 3(S0)
9D0031B8  8C620010   LW V0, 16(V1)
9D0031BC  0040F809   JALR V0
9D0031C0  8E04001C   LW A0, 28(S0)
9D0031C4  96030000   LHU V1, 0(S0)
9D0031C8  24050002   ADDIU A1, ZERO, 2
9D0031CC  8E04000C   LW A0, 12(S0)
9D0031D0  7C431844   INS V1, V0, 1, 3
9D0031D4  3062000E   ANDI V0, V1, 14
9D0031D8  1045002F   BEQ V0, A1, 0x9D003298
9D0031DC  A6030000   SH V1, 0(S0)
9D0031E0  8C820008   LW V0, 8(A0)
9D0031E4  AE0200B0   SW V0, 176(S0)
9D0031E8  90820004   LBU V0, 4(A0)
9D0031EC  A20000AD   SB ZERO, 173(S0)
9D0031F0  A20200AE   SB V0, 174(S0)
9D0031F4  8E0300D8   LW V1, 216(S0)
9D0031F8  24020001   ADDIU V0, ZERO, 1
9D0031FC  1462FFAD   BNE V1, V0, 0x9D0030B4
9D003200  8FBF0024   LW RA, 36(SP)
9D003204  1000FFB9   BEQ ZERO, ZERO, 0x9D0030EC
9D003208  8E0200E0   LW V0, 224(S0)
9D00320C  94820000   LHU V0, 0(A0)
9D003210  7C025284   INS V0, ZERO, 10, 1
9D003214  A4820000   SH V0, 0(A0)
9D003218  8E0300D8   LW V1, 216(S0)
9D00321C  24020001   ADDIU V0, ZERO, 1
9D003220  1462FFA4   BNE V1, V0, 0x9D0030B4
9D003224  8FBF0024   LW RA, 36(SP)
9D003228  1000FFB0   BEQ ZERO, ZERO, 0x9D0030EC
9D00322C  8E0200E0   LW V0, 224(S0)
9D003230  90820003   LBU V0, 3(A0)
9D003234  24030001   ADDIU V1, ZERO, 1
9D003238  7C621004   INS V0, V1, 0, 3
9D00323C  A0820003   SB V0, 3(A0)
9D003240  8E0300D8   LW V1, 216(S0)
9D003244  24020001   ADDIU V0, ZERO, 1
9D003248  1462FF9A   BNE V1, V0, 0x9D0030B4
9D00324C  8FBF0024   LW RA, 36(SP)
9D003250  1000FFA6   BEQ ZERO, ZERO, 0x9D0030EC
9D003254  8E0200E0   LW V0, 224(S0)
9D003258  90820003   LBU V0, 3(A0)
9D00325C  7C021004   INS V0, ZERO, 0, 3
9D003260  A0820003   SB V0, 3(A0)
9D003264  8E0300D8   LW V1, 216(S0)
9D003268  24020001   ADDIU V0, ZERO, 1
9D00326C  1462FF91   BNE V1, V0, 0x9D0030B4
9D003270  8FBF0024   LW RA, 36(SP)
9D003274  1000FF9D   BEQ ZERO, ZERO, 0x9D0030EC
9D003278  8E0200E0   LW V0, 224(S0)
9D00327C  8C8200EC   LW V0, 236(A0)
9D003280  8C84001C   LW A0, 28(A0)
9D003284  8C420014   LW V0, 20(V0)
9D003288  0040F809   JALR V0
9D00328C  27B20010   ADDIU S2, SP, 16
9D003290  1000FF91   BEQ ZERO, ZERO, 0x9D0030D8
9D003294  A7A20010   SH V0, 16(SP)
9D003298  8C820014   LW V0, 20(A0)
9D00329C  AE0200B0   SW V0, 176(S0)
9D0032A0  90820010   LBU V0, 16(A0)
9D0032A4  A20000AD   SB ZERO, 173(S0)
9D0032A8  1000FFD2   BEQ ZERO, ZERO, 0x9D0031F4
9D0032AC  A20200AE   SB V0, 174(S0)
9D00375C  90A20001   LBU V0, 1(A1)
9D003760  27BDFFD8   ADDIU SP, SP, -40
9D003764  24030003   ADDIU V1, ZERO, 3
9D003768  AFB10020   SW S1, 32(SP)
9D00376C  AFB0001C   SW S0, 28(SP)
9D003770  AFBF0024   SW RA, 36(SP)
9D003774  00A08825   OR S1, A1, ZERO
9D003778  10430058   BEQ V0, V1, 0x9D0038DC
9D00377C  00808025   OR S0, A0, ZERO
9D003780  2C430004   SLTIU V1, V0, 4
9D003784  14600033   BNE V1, ZERO, 0x9D003854
9D003788  24030005   ADDIU V1, ZERO, 5
9D00378C  10430045   BEQ V0, V1, 0x9D0038A4
9D003790  24050009   ADDIU A1, ZERO, 9
9D003794  5445003C   BNEL V0, A1, 0x9D003888
9D003798  02002025   OR A0, S0, ZERO
9D00379C  92220003   LBU V0, 3(S1)
9D0037A0  92250002   LBU A1, 2(S1)
9D0037A4  00021200   SLL V0, V0, 8
9D0037A8  00451025   OR V0, V0, A1
9D0037AC  5040005D   BEQL V0, ZERO, 0x9D003924
9D0037B0  90850003   LBU A1, 3(A0)
9D0037B4  920300AD   LBU V1, 173(S0)
9D0037B8  304700FF   ANDI A3, V0, 255
9D0037BC  1067001E   BEQ V1, A3, 0x9D003838
9D0037C0  00002825   OR A1, ZERO, ZERO
9D0037C4  920200AE   LBU V0, 174(S0)
9D0037C8  1040000E   BEQ V0, ZERO, 0x9D003804
9D0037CC  2445FFFF   ADDIU A1, V0, -1
9D0037D0  8E0400B0   LW A0, 176(S0)
9D0037D4  30A500FF   ANDI A1, A1, 255
9D0037D8  00052880   SLL A1, A1, 2
9D0037DC  24820004   ADDIU V0, A0, 4
9D0037E0  92280002   LBU T0, 2(S1)
9D0037E4  00A22821   ADDU A1, A1, V0
9D0037E8  8C830000   LW V1, 0(A0)
9D0037EC  90660005   LBU A2, 5(V1)
9D0037F0  14C80002   BNE A2, T0, 0x9D0037FC
9D0037F4  00402025   OR A0, V0, ZERO
9D0037F8  AE0300B4   SW V1, 180(S0)
9D0037FC  14A2FFFA   BNE A1, V0, 0x9D0037E8
9D003800  24420004   ADDIU V0, V0, 4
9D003804  02002025   OR A0, S0, ZERO
9D003808  0F401742   JAL _USB_DEVICE_ConfigureDevice
9D00380C  A20700AD   SB A3, 173(S0)
9D003810  92020003   LBU V0, 3(S0)
9D003814  24040005   ADDIU A0, ZERO, 5
9D003818  8E0300D8   LW V1, 216(S0)
9D00381C  7C821004   INS V0, A0, 0, 3
9D003820  A2020003   SB V0, 3(S0)
9D003824  92240002   LBU A0, 2(S1)
9D003828  24020001   ADDIU V0, ZERO, 1
9D00382C  1062004D   BEQ V1, V0, 0x9D003964
9D003830  A3A40010   SB A0, 16(SP)
9D003834  00002825   OR A1, ZERO, ZERO
9D003838  0F401C56   JAL USB_DEVICE_ControlStatus
9D00383C  02002025   OR A0, S0, ZERO
9D003840  8FBF0024   LW RA, 36(SP)
9D003844  8FB10020   LW S1, 32(SP)
9D003848  8FB0001C   LW S0, 28(SP)
9D00384C  03E00008   JR RA
9D003850  27BD0028   ADDIU SP, SP, 40
9D003854  24030001   ADDIU V1, ZERO, 1
9D003858  5443000B   BNEL V0, V1, 0x9D003888
9D00385C  02002025   OR A0, S0, ZERO
9D003860  90A20003   LBU V0, 3(A1)
9D003864  90A30002   LBU V1, 2(A1)
9D003868  24050001   ADDIU A1, ZERO, 1
9D00386C  00021200   SLL V0, V0, 8
9D003870  00431025   OR V0, V0, V1
9D003874  1445FFF0   BNE V0, A1, 0x9D003838
9D003878  00000000   NOP
9D00387C  AC8000C0   SW ZERO, 192(A0)
9D003880  1000FFED   BEQ ZERO, ZERO, 0x9D003838
9D003884  00002825   OR A1, ZERO, ZERO
9D003888  0F401C56   JAL USB_DEVICE_ControlStatus
9D00388C  24050001   ADDIU A1, ZERO, 1
9D003890  8FBF0024   LW RA, 36(SP)
9D003894  8FB10020   LW S1, 32(SP)
9D003898  8FB0001C   LW S0, 28(SP)
9D00389C  03E00008   JR RA
9D0038A0  27BD0028   ADDIU SP, SP, 40
9D0038A4  94820000   LHU V0, 0(A0)
9D0038A8  24030001   ADDIU V1, ZERO, 1
9D0038AC  00002825   OR A1, ZERO, ZERO
9D0038B0  7C6239C4   INS V0, V1, 7, 1
9D0038B4  A4820000   SH V0, 0(A0)
9D0038B8  92220002   LBU V0, 2(S1)
9D0038BC  A08200AC   SB V0, 172(A0)
9D0038C0  0F401C56   JAL USB_DEVICE_ControlStatus
9D0038C4  02002025   OR A0, S0, ZERO
9D0038C8  8FBF0024   LW RA, 36(SP)
9D0038CC  8FB10020   LW S1, 32(SP)
9D0038D0  8FB0001C   LW S0, 28(SP)
9D0038D4  03E00008   JR RA
9D0038D8  27BD0028   ADDIU SP, SP, 40
9D0038DC  90A20003   LBU V0, 3(A1)
9D0038E0  90A40002   LBU A0, 2(A1)
9D0038E4  24030001   ADDIU V1, ZERO, 1
9D0038E8  00021200   SLL V0, V0, 8
9D0038EC  00441025   OR V0, V0, A0
9D0038F0  10430019   BEQ V0, V1, 0x9D003958
9D0038F4  24030002   ADDIU V1, ZERO, 2
9D0038F8  1443FFCF   BNE V0, V1, 0x9D003838
9D0038FC  24050001   ADDIU A1, ZERO, 1
9D003900  96030000   LHU V1, 0(S0)
9D003904  3064000E   ANDI A0, V1, 14
9D003908  1482FFCB   BNE A0, V0, 0x9D003838
9D00390C  7CA34204   INS V1, A1, 8, 1
9D003910  92220005   LBU V0, 5(S1)
9D003914  A6030000   SH V1, 0(S0)
9D003918  A2020002   SB V0, 2(S0)
9D00391C  1000FFC6   BEQ ZERO, ZERO, 0x9D003838
9D003920  00002825   OR A1, ZERO, ZERO
9D003924  30A50007   ANDI A1, A1, 7
9D003928  54A3FFA3   BNEL A1, V1, 0x9D0037B8
9D00392C  920300AD   LBU V1, 173(S0)
9D003930  2402000B   ADDIU V0, ZERO, 11
9D003934  0F4019FE   JAL _USB_DEVICE_DeInitializeAllFunctionDrivers
9D003938  AC8200B8   SW V0, 184(A0)
9D00393C  92020003   LBU V0, 3(S0)
9D003940  24030004   ADDIU V1, ZERO, 4
9D003944  A20000AD   SB ZERO, 173(S0)
9D003948  7C621004   INS V0, V1, 0, 3
9D00394C  A2020003   SB V0, 3(S0)
9D003950  1000FFB9   BEQ ZERO, ZERO, 0x9D003838
9D003954  00002825   OR A1, ZERO, ZERO
9D003958  AE0200C0   SW V0, 192(S0)
9D00395C  1000FFB6   BEQ ZERO, ZERO, 0x9D003838
9D003960  00002825   OR A1, ZERO, ZERO
9D003964  8E0200E0   LW V0, 224(S0)
9D003968  1040FFB2   BEQ V0, ZERO, 0x9D003834
9D00396C  27A50010   ADDIU A1, SP, 16
9D003970  8E0600E4   LW A2, 228(S0)
9D003974  0040F809   JALR V0
9D003978  2404000A   ADDIU A0, ZERO, 10
9D00397C  1000FFAE   BEQ ZERO, ZERO, 0x9D003838
9D003980  00002825   OR A1, ZERO, ZERO
9D003984  90A20001   LBU V0, 1(A1)
9D003988  27BDFFE0   ADDIU SP, SP, -32
9D00398C  24030006   ADDIU V1, ZERO, 6
9D003990  AFBF001C   SW RA, 28(SP)
9D003994  00A06825   OR T5, A1, ZERO
9D003998  00806025   OR T4, A0, ZERO
9D00399C  10430033   BEQ V0, V1, 0x9D003A6C
9D0039A0  AFA00010   SW ZERO, 16(SP)
9D0039A4  24030008   ADDIU V1, ZERO, 8
9D0039A8  50430019   BEQL V0, V1, 0x9D003A10
9D0039AC  248500AD   ADDIU A1, A0, 173
9D0039B0  54400020   BNEL V0, ZERO, 0x9D003A34
9D0039B4  2402FFFF   ADDIU V0, ZERO, -1
9D0039B8  8C830000   LW V1, 0(A0)
9D0039BC  8C8400C0   LW A0, 192(A0)
9D0039C0  258500BC   ADDIU A1, T4, 188
9D0039C4  7C630000   EXT V1, V1, 0, 1
9D0039C8  7C620004   INS V0, V1, 0, 1
9D0039CC  7C820844   INS V0, A0, 1, 1
9D0039D0  A58200BC   SH V0, 188(T4)
9D0039D4  AFA50010   SW A1, 16(SP)
9D0039D8  24020002   ADDIU V0, ZERO, 2
9D0039DC  91A60007   LBU A2, 7(T5)
9D0039E0  91A30006   LBU V1, 6(T5)
9D0039E4  00063200   SLL A2, A2, 8
9D0039E8  00C33025   OR A2, A2, V1
9D0039EC  0046182B   SLTU V1, V0, A2
9D0039F0  54600001   BNEL V1, ZERO, 0x9D0039F8
9D0039F4  00403025   OR A2, V0, ZERO
9D0039F8  30C6FFFF   ANDI A2, A2, -1
9D0039FC  0F401B00   JAL USB_DEVICE_ControlSend
9D003A00  01802025   OR A0, T4, ZERO
9D003A04  8FBF001C   LW RA, 28(SP)
9D003A08  03E00008   JR RA
9D003A0C  27BD0020   ADDIU SP, SP, 32
9D003A10  AFA50010   SW A1, 16(SP)
9D003A14  1000FFF1   BEQ ZERO, ZERO, 0x9D0039DC
9D003A18  24020001   ADDIU V0, ZERO, 1
9D003A1C  0F4018A1   JAL _USB_DEVICE_GetStringDescriptorRequestProcess
9D003A20  27A60010   ADDIU A2, SP, 16
9D003A24  8FA50010   LW A1, 16(SP)
9D003A28  54A0FFED   BNEL A1, ZERO, 0x9D0039E0
9D003A2C  91A60007   LBU A2, 7(T5)
9D003A30  2402FFFF   ADDIU V0, ZERO, -1
9D003A3C  918200DC   LBU V0, 220(T4)
9D003A48  8D8200EC   LW V0, 236(T4)
9D003A4C  8D84001C   LW A0, 28(T4)
9D003A50  A18000C4   SB ZERO, 196(T4)
9D003A54  8C420028   LW V0, 40(V0)
9D003A60  8FBF001C   LW RA, 28(SP)
9D003A64  03E00008   JR RA
9D003A68  27BD0020   ADDIU SP, SP, 32
9D003A6C  90A20003   LBU V0, 3(A1)
9D003A70  2C430008   SLTIU V1, V0, 8
9D003A74  1060FFEE   BEQ V1, ZERO, _USB_DEVICE_ProcessStandardDeviceGetRequests::USB_DEVICE_ControlStatus
9D003A78  8C84000C   LW A0, 12(A0)
9D003A7C  00021880   SLL V1, V0, 2
9D003A80  3C029D00   LUI V0, -25344
9D003A84  24423A98   ADDIU V0, V0, 15000
9D003A88  00431021   ADDU V0, V0, V1
9D003A8C  8C420000   LW V0, 0(V0)
9D003A90  00400008   JR V0
9D003A94  00000000   NOP
9D003AB8  95820000   LHU V0, 0(T4)
9D003ABC  24030010   ADDIU V1, ZERO, 16
9D003AC0  30420070   ANDI V0, V0, 112
9D003AC4  1443FFDB   BNE V0, V1, 0x9D003A34
9D003AC8  2402FFFF   ADDIU V0, ZERO, -1
9D003ACC  1000FFCE   BEQ ZERO, ZERO, 0x9D003A08
9D003AD0  8FBF001C   LW RA, 28(SP)
9D003AD4  95820000   LHU V0, 0(T4)
9D003AD8  24030010   ADDIU V1, ZERO, 16
9D003ADC  30450070   ANDI A1, V0, 112
9D003AE0  54A3FFD4   BNEL A1, V1, 0x9D003A34
9D003AE4  2402FFFF   ADDIU V0, ZERO, -1
9D003AE8  3042000E   ANDI V0, V0, 14
9D003AEC  24030002   ADDIU V1, ZERO, 2
9D003AF0  50430022   BEQL V0, V1, 0x9D003B7C
9D003AF4  8C850020   LW A1, 32(A0)
9D003AF8  8C850024   LW A1, 36(A0)
9D003AFC  2402000A   ADDIU V0, ZERO, 10
9D003B00  1000FFC9   BEQ ZERO, ZERO, 0x9D003A28
9D003B04  AFA50010   SW A1, 16(SP)
9D003B08  90A30002   LBU V1, 2(A1)
9D003B0C  918200AE   LBU V0, 174(T4)
9D003B10  0062102B   SLTU V0, V1, V0
9D003B14  1040FFC7   BEQ V0, ZERO, 0x9D003A34
9D003B18  2402FFFF   ADDIU V0, ZERO, -1
9D003B1C  8D8200B0   LW V0, 176(T4)
9D003B20  00031880   SLL V1, V1, 2
9D003B24  00431821   ADDU V1, V0, V1
9D003B28  8C650000   LW A1, 0(V1)
9D003B2C  50A0FFC1   BEQL A1, ZERO, 0x9D003A34
9D003B30  2402FFFF   ADDIU V0, ZERO, -1
9D003B34  AFA50010   SW A1, 16(SP)
9D003B38  90A20003   LBU V0, 3(A1)
9D003B3C  90A30002   LBU V1, 2(A1)
9D003B40  00021200   SLL V0, V0, 8
9D003B44  1000FFA5   BEQ ZERO, ZERO, 0x9D0039DC
9D003B48  00431025   OR V0, V0, V1
9D003B4C  95820000   LHU V0, 0(T4)
9D003B50  24030002   ADDIU V1, ZERO, 2
9D003B54  3042000E   ANDI V0, V0, 14
9D003B58  50430005   BEQL V0, V1, 0x9D003B70
9D003B5C  8C85000C   LW A1, 12(A0)
9D003B60  8C850000   LW A1, 0(A0)
9D003B64  24020012   ADDIU V0, ZERO, 18
9D003B68  1000FFAF   BEQ ZERO, ZERO, 0x9D003A28
9D003B6C  AFA50010   SW A1, 16(SP)
9D003B70  24020012   ADDIU V0, ZERO, 18
9D003B74  1000FFAC   BEQ ZERO, ZERO, 0x9D003A28
9D003B78  AFA50010   SW A1, 16(SP)
9D003B7C  2402000A   ADDIU V0, ZERO, 10
9D003B80  1000FFA9   BEQ ZERO, ZERO, 0x9D003A28
9D003B84  AFA50010   SW A1, 16(SP)
9D003F54  8C820008   LW V0, 8(A0)
9D003F58  2403FFFE   ADDIU V1, ZERO, -2
9D003F5C  10430053   BEQ V0, V1, 0x9D0040AC
9D003F60  00000000   NOP
9D003F64  27BDFFE0   ADDIU SP, SP, -32
9D003F68  24030002   ADDIU V1, ZERO, 2
9D003F6C  AFB10018   SW S1, 24(SP)
9D003F70  AFB00014   SW S0, 20(SP)
9D003F74  AFBF001C   SW RA, 28(SP)
9D003F78  00808825   OR S1, A0, ZERO
9D003F7C  10430026   BEQ V0, V1, 0x9D004018
9D003F80  8C900014   LW S0, 20(A0)
9D003F84  8C860004   LW A2, 4(A0)
9D003F88  54C00018   BNEL A2, ZERO, 0x9D003FEC
9D003F8C  920200C4   LBU V0, 196(S0)
9D003F90  8E0200D0   LW V0, 208(S0)
9D003F94  8E0300E0   LW V1, 224(S0)
9D003F98  A20000C4   SB ZERO, 196(S0)
9D003F9C  00002825   OR A1, ZERO, ZERO
9D003FA0  2407000F   ADDIU A3, ZERO, 15
9D003FA4  50430033   BEQL V0, V1, 0x9D004074
9D003FA8  8E0600E4   LW A2, 228(S0)
9D003FAC  960400C8   LHU A0, 200(S0)
9D003FB0  00A03025   OR A2, A1, ZERO
9D003FB4  0040F809   JALR V0
9D003FB8  00E02825   OR A1, A3, ZERO
9D003FBC  8E0200EC   LW V0, 236(S0)
9D003FC0  8E04001C   LW A0, 28(S0)
9D003FC4  26060088   ADDIU A2, S0, 136
9D003FC8  8C590038   LW T9, 56(V0)
9D003FCC  24020040   ADDIU V0, ZERO, 64
9D003FD0  AE02008C   SW V0, 140(S0)
9D003FD4  8FBF001C   LW RA, 28(SP)
9D003FD8  8FB10018   LW S1, 24(SP)
9D003FDC  8FB00014   LW S0, 20(SP)
9D003FE0  00002825   OR A1, ZERO, ZERO
9D003FE4  03200008   JR T9
9D003FE8  27BD0020   ADDIU SP, SP, 32
9D003FEC  50400031   BEQL V0, ZERO, 0x9D0040B4
9D003FF0  8E0200D0   LW V0, 208(S0)
9D003FF4  920300C5   LBU V1, 197(S0)
9D003FF8  920200C6   LBU V0, 198(S0)
9D003FFC  0062102B   SLTU V0, V1, V0
9D004000  14400030   BNE V0, ZERO, 0x9D0040C4
9D004004  00002825   OR A1, ZERO, ZERO
9D004008  8E0200D0   LW V0, 208(S0)
9D00400C  8E0300E0   LW V1, 224(S0)
9D004010  1000FFE4   BEQ ZERO, ZERO, 0x9D003FA4
9D004014  2407000D   ADDIU A3, ZERO, 13
9D004018  920200C4   LBU V0, 196(S0)
9D00401C  1040000A   BEQ V0, ZERO, 0x9D004048
9D004020  8E0300E0   LW V1, 224(S0)
9D004024  8E0200D0   LW V0, 208(S0)
9D004028  50400008   BEQL V0, ZERO, 0x9D00404C
9D00402C  96040018   LHU A0, 24(S0)
9D004030  10430035   BEQ V0, V1, 0x9D004108
9D004034  00003025   OR A2, ZERO, ZERO
9D004038  960400C8   LHU A0, 200(S0)
9D00403C  0040F809   JALR V0
9D004040  2405000C   ADDIU A1, ZERO, 12
9D004044  8E0300E0   LW V1, 224(S0)
9D004048  96040018   LHU A0, 24(S0)
9D00404C  3C029D00   LUI V0, -25344
9D004050  24050001   ADDIU A1, ZERO, 1
9D004054  24422ABC   ADDIU V0, V0, 10940
9D004058  A20500C4   SB A1, 196(S0)
9D00405C  AE0200D0   SW V0, 208(S0)
9D004060  A60400C8   SH A0, 200(S0)
9D004064  26050024   ADDIU A1, S0, 36
9D004068  1443FFD0   BNE V0, V1, 0x9D003FAC
9D00406C  2407000E   ADDIU A3, ZERO, 14
9D004070  8E0600E4   LW A2, 228(S0)
9D004074  0040F809   JALR V0
9D004078  00E02025   OR A0, A3, ZERO
9D00407C  8E0200EC   LW V0, 236(S0)
9D004080  8E04001C   LW A0, 28(S0)
9D004084  26060088   ADDIU A2, S0, 136
9D004088  8C590038   LW T9, 56(V0)
9D00408C  24020040   ADDIU V0, ZERO, 64
9D004090  AE02008C   SW V0, 140(S0)
9D004094  8FBF001C   LW RA, 28(SP)
9D004098  8FB10018   LW S1, 24(SP)
9D00409C  8FB00014   LW S0, 20(SP)
9D0040A0  00002825   OR A1, ZERO, ZERO
9D0040A4  03200008   JR T9
9D0040A8  27BD0020   ADDIU SP, SP, 32
9D0040AC  03E00008   JR RA
9D0040B0  00000000   NOP
9D0040B4  8E0300E0   LW V1, 224(S0)
9D0040B8  00002825   OR A1, ZERO, ZERO
9D0040BC  1000FFB9   BEQ ZERO, ZERO, 0x9D003FA4
9D0040C0  24070001   ADDIU A3, ZERO, 1
9D0040C4  8E0400CC   LW A0, 204(S0)
9D0040C8  26050024   ADDIU A1, S0, 36
9D0040CC  0F401198   JAL memcpy
9D0040D0  00832021   ADDU A0, A0, V1
9D0040D4  8E220004   LW V0, 4(S1)
9D0040D8  920400C5   LBU A0, 197(S0)
9D0040DC  920300C6   LBU V1, 198(S0)
9D0040E0  00441021   ADDU V0, V0, A0
9D0040E4  304200FF   ANDI V0, V0, 255
9D0040E8  0043182B   SLTU V1, V0, V1
9D0040EC  A20200C5   SB V0, 197(S0)
9D0040F0  1060000B   BEQ V1, ZERO, 0x9D004120
9D0040F4  8E0200D0   LW V0, 208(S0)
9D0040F8  8E0300E0   LW V1, 224(S0)
9D0040FC  00002825   OR A1, ZERO, ZERO
9D004100  1000FFA8   BEQ ZERO, ZERO, 0x9D003FA4
9D004104  24070001   ADDIU A3, ZERO, 1
9D004108  8E0600E4   LW A2, 228(S0)
9D00410C  00002825   OR A1, ZERO, ZERO
9D004110  0060F809   JALR V1
9D004114  2404000C   ADDIU A0, ZERO, 12
9D004118  1000FFCB   BEQ ZERO, ZERO, 0x9D004048
9D00411C  8E0300E0   LW V1, 224(S0)
9D004120  8E0300E0   LW V1, 224(S0)
9D004124  00002825   OR A1, ZERO, ZERO
9D004128  1000FF9E   BEQ ZERO, ZERO, 0x9D003FA4
9D00412C  2407000D   ADDIU A3, ZERO, 13
9D004930  27BDFFD0   ADDIU SP, SP, -48
9D004934  AFB00014   SW S0, 20(SP)
9D004938  2410FFFF   ADDIU S0, ZERO, -1
9D00493C  AFBF002C   SW RA, 44(SP)
9D004940  AFB50028   SW S5, 40(SP)
9D004944  AFB40024   SW S4, 36(SP)
9D004948  AFB30020   SW S3, 32(SP)
9D00494C  AFB2001C   SW S2, 28(SP)
9D004950  10900042   BEQ A0, S0, 0x9D004A5C
9D004954  AFB10018   SW S1, 24(SP)
9D004958  00041100   SLL V0, A0, 4
9D00495C  00441023   SUBU V0, V0, A0
9D004960  00021080   SLL V0, V0, 2
9D004964  00441021   ADDU V0, V0, A0
9D004968  3C11A000   LUI S1, -24576
9D00496C  00021080   SLL V0, V0, 2
9D004970  26310280   ADDIU S1, S1, 640
9D004974  02228821   ADDU S1, S1, V0
9D004978  8E220008   LW V0, 8(S1)
9D00497C  58400038   BLEZL V0, 0x9D004A60
9D004980  8FBF002C   LW RA, 44(SP)
9D004984  8E2200D4   LW V0, 212(S1)
9D004988  10400029   BEQ V0, ZERO, 0x9D004A30
9D00498C  24030001   ADDIU V1, ZERO, 1
9D004990  54430033   BNEL V0, V1, 0x9D004A60
9D004994  8FBF002C   LW RA, 44(SP)
9D004998  96340010   LHU S4, 16(S1)
9D00499C  1280002F   BEQ S4, ZERO, 0x9D004A5C
9D0049A0  00008025   OR S0, ZERO, ZERO
9D0049A4  8E330000   LW S3, 0(S1)
9D0049A8  923500AD   LBU S5, 173(S1)
9D0049AC  8E320014   LW S2, 20(S1)
9D0049B0  10000005   BEQ ZERO, ZERO, 0x9D0049C8
9D0049B4  7E731040   EXT S3, S3, 1, 3
9D0049B8  321000FF   ANDI S0, S0, 255
9D0049BC  0214102B   SLTU V0, S0, S4
9D0049C0  10400026   BEQ V0, ZERO, 0x9D004A5C
9D0049C4  26520014   ADDIU S2, S2, 20
9D0049C8  8E420000   LW V0, 0(S2)
9D0049CC  02621024   AND V0, S3, V0
9D0049D0  5040FFF9   BEQL V0, ZERO, 0x9D0049B8
9D0049D4  26100001   ADDIU S0, S0, 1
9D0049D8  92420004   LBU V0, 4(S2)
9D0049DC  5455FFF6   BNEL V0, S5, 0x9D0049B8
9D0049E0  26100001   ADDIU S0, S0, 1
9D0049E4  92220003   LBU V0, 3(S1)
9D0049E8  24030005   ADDIU V1, ZERO, 5
9D0049EC  30420007   ANDI V0, V0, 7
9D0049F0  5443FFF1   BNEL V0, V1, 0x9D0049B8
9D0049F4  26100001   ADDIU S0, S0, 1
9D0049F8  8E220000   LW V0, 0(S1)
9D0049FC  7C420280   EXT V0, V0, 10, 1
9D004A00  5440FFED   BNEL V0, ZERO, 0x9D0049B8
9D004A04  26100001   ADDIU S0, S0, 1
9D004A08  8E420010   LW V0, 16(S2)
9D004A0C  5040FFEA   BEQL V0, ZERO, 0x9D0049B8
9D004A10  26100001   ADDIU S0, S0, 1
9D004A14  8C42000C   LW V0, 12(V0)
9D004A18  5040FFE7   BEQL V0, ZERO, 0x9D0049B8
9D004A1C  26100001   ADDIU S0, S0, 1
9D004A20  0040F809   JALR V0
9D004A24  96440008   LHU A0, 8(S2)
9D004A28  1000FFE3   BEQ ZERO, ZERO, 0x9D0049B8
9D004A2C  26100001   ADDIU S0, S0, 1
9D004A30  8E2200EC   LW V0, 236(S1)
9D004A34  962400F0   LHU A0, 240(S1)
9D004A38  8C420000   LW V0, 0(V0)
9D004A3C  0040F809   JALR V0
9D004A40  2405000F   ADDIU A1, ZERO, 15
9D004A44  10500005   BEQ V0, S0, 0x9D004A5C
9D004A48  AE22001C   SW V0, 28(S1)
9D004A4C  24020001   ADDIU V0, ZERO, 1
9D004A50  AE2200D4   SW V0, 212(S1)
9D004A54  24020002   ADDIU V0, ZERO, 2
9D004A58  AE220008   SW V0, 8(S1)
9D004A5C  8FBF002C   LW RA, 44(SP)
9D004A60  8FB50028   LW S5, 40(SP)
9D004A64  8FB40024   LW S4, 36(SP)
9D004A68  8FB30020   LW S3, 32(SP)
9D004A6C  8FB2001C   LW S2, 28(SP)
9D004A70  8FB10018   LW S1, 24(SP)
9D004A74  8FB00014   LW S0, 20(SP)
9D004A78  03E00008   JR RA
9D004A7C  27BD0030   ADDIU SP, SP, 48
9D0050B8  14800049   BNE A0, ZERO, 0x9D0051E0
9D0050BC  00000000   NOP
9D0050C0  10A00047   BEQ A1, ZERO, 0x9D0051E0
9D0050C4  00000000   NOP
9D0050C8  8CA60020   LW A2, 32(A1)
9D0050CC  10C00044   BEQ A2, ZERO, 0x9D0051E0
9D0050D0  3C03A000   LUI V1, -24576
9D0050D4  27BDFFE0   ADDIU SP, SP, -32
9D0050D8  AFB10014   SW S1, 20(SP)
9D0050DC  24710280   ADDIU S1, V1, 640
9D0050E0  92240003   LBU A0, 3(S1)
9D0050E4  94620280   LHU V0, 640(V1)
9D0050E8  AFB20018   SW S2, 24(SP)
9D0050EC  7C041004   INS A0, ZERO, 0, 3
9D0050F0  A2240003   SB A0, 3(S1)
9D0050F4  8CA40024   LW A0, 36(A1)
9D0050F8  94A70018   LHU A3, 24(A1)
9D0050FC  8CB2001C   LW S2, 28(A1)
9D005100  8CA90030   LW T1, 48(A1)
9D005104  94A8002C   LHU T0, 44(A1)
9D005108  3C05A000   LUI A1, -24576
9D00510C  24A502A4   ADDIU A1, A1, 676
9D005110  AE250088   SW A1, 136(S1)
9D005114  24050040   ADDIU A1, ZERO, 64
9D005118  AE25008C   SW A1, 140(S1)
9D00511C  3C059D00   LUI A1, -25344
9D005120  24A53F54   ADDIU A1, A1, 16212
9D005124  7C823104   INS V0, A0, 4, 3
9D005128  AE250094   SW A1, 148(S1)
9D00512C  3C059D00   LUI A1, -25344
9D005130  24040001   ADDIU A0, ZERO, 1
9D005134  3042FA7E   ANDI V0, V0, -1410
9D005138  24A56740   ADDIU A1, A1, 26432
9D00513C  AFB00010   SW S0, 16(SP)
9D005140  AFBF001C   SW RA, 28(SP)
9D005144  AE240008   SW A0, 8(S1)
9D005148  A6200018   SH ZERO, 24(S1)
9D00514C  AE26000C   SW A2, 12(S1)
9D005150  A6270010   SH A3, 16(S1)
9D005154  AE320014   SW S2, 20(S1)
9D005158  AE2000C0   SW ZERO, 192(S1)
9D00515C  AE240098   SW A0, 152(S1)
9D005160  AE200090   SW ZERO, 144(S1)
9D005164  AE31009C   SW S1, 156(S1)
9D005168  AE250070   SW A1, 112(S1)
9D00516C  AE310078   SW S1, 120(S1)
9D005170  AE240074   SW A0, 116(S1)
9D005174  A4620280   SH V0, 640(V1)
9D005178  AE2000D4   SW ZERO, 212(S1)
9D00517C  AE2900EC   SW T1, 236(S1)
9D005180  A62800F0   SH T0, 240(S1)
9D005184  10E0000F   BEQ A3, ZERO, 0x9D0051C4
9D005188  00008025   OR S0, ZERO, ZERO
9D00518C  8E420010   LW V0, 16(S2)
9D005190  10400006   BEQ V0, ZERO, 0x9D0051AC
9D005194  26520014   ADDIU S2, S2, 20
9D005198  8C420010   LW V0, 16(V0)
9D00519C  50400004   BEQL V0, ZERO, 0x9D0051B0
9D0051A0  96220010   LHU V0, 16(S1)
9D0051A4  0040F809   JALR V0
9D0051A8  00000000   NOP
9D0051AC  96220010   LHU V0, 16(S1)
9D0051B0  26100001   ADDIU S0, S0, 1
9D0051B4  321000FF   ANDI S0, S0, 255
9D0051B8  0202102B   SLTU V0, S0, V0
9D0051BC  5440FFF4   BNEL V0, ZERO, 0x9D005190
9D0051C0  8E420010   LW V0, 16(S2)
9D0051C4  8FBF001C   LW RA, 28(SP)
9D0051C8  00001025   OR V0, ZERO, ZERO
9D0051CC  8FB20018   LW S2, 24(SP)
9D0051D0  8FB10014   LW S1, 20(SP)
9D0051D4  8FB00010   LW S0, 16(SP)
9D0051D8  03E00008   JR RA
9D0051DC  27BD0020   ADDIU SP, SP, 32
9D0051E0  03E00008   JR RA
9D0051E4  2402FFFF   ADDIU V0, ZERO, -1
9D0051E8  90C20001   LBU V0, 1(A2)
9D0051EC  27BDFFE8   ADDIU SP, SP, -24
9D0051F0  AFB00010   SW S0, 16(SP)
9D0051F4  AFBF0014   SW RA, 20(SP)
9D0051F8  00808025   OR S0, A0, ZERO
9D0051FC  14400010   BNE V0, ZERO, 0x9D005240
9D005200  90C50004   LBU A1, 4(A2)
9D005204  8C8200EC   LW V0, 236(A0)
9D005208  8C84001C   LW A0, 28(A0)
9D00520C  8C420034   LW V0, 52(V0)
9D005210  0040F809   JALR V0
9D005214  A60000BC   SH ZERO, 188(S0)
9D005218  960300BC   LHU V1, 188(S0)
9D00521C  260500BC   ADDIU A1, S0, 188
9D005220  02002025   OR A0, S0, ZERO
9D005224  7C430004   INS V1, V0, 0, 1
9D005228  A60300BC   SH V1, 188(S0)
9D00522C  8FBF0014   LW RA, 20(SP)
9D005230  8FB00010   LW S0, 16(SP)
9D005234  24060002   ADDIU A2, ZERO, 2
9D005238  0B401B00   J USB_DEVICE_ControlSend
9D00523C  27BD0018   ADDIU SP, SP, 24
9D005240  24030001   ADDIU V1, ZERO, 1
9D005244  10430017   BEQ V0, V1, 0x9D0052A4
9D005248  24030003   ADDIU V1, ZERO, 3
9D00524C  10430026   BEQ V0, V1, 0x9D0052E8
9D005250  2403000C   ADDIU V1, ZERO, 12
9D005254  10430005   BEQ V0, V1, _USB_DEVICE_ProcessStandardEndpointRequest::USB_DEVICE_ControlStatus
9D005258  2482FFFF   ADDIU V0, A0, -1
9D00525C  8FBF0014   LW RA, 20(SP)
9D005260  8FB00010   LW S0, 16(SP)
9D005264  03E00008   JR RA
9D005268  27BD0018   ADDIU SP, SP, 24
9D00526C  2C42FFFE   SLTIU V0, V0, -2
9D005278  908200DC   LBU V0, 220(A0)
9D005284  8C8200EC   LW V0, 236(A0)
9D005288  8C84001C   LW A0, 28(A0)
9D00528C  8C590028   LW T9, 40(V0)
9D005290  A20000C4   SB ZERO, 196(S0)
9D005294  8FB00010   LW S0, 16(SP)
9D005298  24050080   ADDIU A1, ZERO, 128
9D00529C  03200008   JR T9
9D0052A0  27BD0018   ADDIU SP, SP, 24
9D0052A4  90C20003   LBU V0, 3(A2)
9D0052A8  90C30002   LBU V1, 2(A2)
9D0052AC  00021200   SLL V0, V0, 8
9D0052B0  00431025   OR V0, V0, V1
9D0052B4  1440FFEA   BNE V0, ZERO, 0x9D005260
9D0052B8  8FBF0014   LW RA, 20(SP)
9D0052BC  8C8200EC   LW V0, 236(A0)
9D0052C0  8C84001C   LW A0, 28(A0)
9D0052C4  8C42002C   LW V0, 44(V0)
9D0052C8  0040F809   JALR V0
9D0052CC  00000000   NOP
9D0052D0  02002025   OR A0, S0, ZERO
9D0052D4  8FBF0014   LW RA, 20(SP)
9D0052D8  8FB00010   LW S0, 16(SP)
9D0052DC  00002825   OR A1, ZERO, ZERO
9D0052E0  0B401C56   J USB_DEVICE_ControlStatus
9D0052E4  27BD0018   ADDIU SP, SP, 24
9D0052E8  90C20003   LBU V0, 3(A2)
9D0052EC  90C30002   LBU V1, 2(A2)
9D0052F0  00021200   SLL V0, V0, 8
9D0052F4  00431025   OR V0, V0, V1
9D0052F8  1440FFD9   BNE V0, ZERO, 0x9D005260
9D0052FC  8FBF0014   LW RA, 20(SP)
9D005300  8C8200EC   LW V0, 236(A0)
9D005304  8C84001C   LW A0, 28(A0)
9D005308  1000FFEF   BEQ ZERO, ZERO, 0x9D0052C8
9D00530C  8C420028   LW V0, 40(V0)
9D005D08  27BDFFB8   ADDIU SP, SP, -72
9D005D0C  AFB00024   SW S0, 36(SP)
9D005D10  8C9000B4   LW S0, 180(A0)
9D005D14  AFBF0044   SW RA, 68(SP)
9D005D18  AFB70040   SW S7, 64(SP)
9D005D1C  AFB6003C   SW S6, 60(SP)
9D005D20  AFB50038   SW S5, 56(SP)
9D005D24  AFB40034   SW S4, 52(SP)
9D005D28  AFB30030   SW S3, 48(SP)
9D005D2C  AFB2002C   SW S2, 44(SP)
9D005D30  AFB10028   SW S1, 40(SP)
9D005D34  92130003   LBU S3, 3(S0)
9D005D38  92020002   LBU V0, 2(S0)
9D005D3C  00139A00   SLL S3, S3, 8
9D005D40  02629825   OR S3, S3, V0
9D005D44  12600025   BEQ S3, ZERO, 0x9D005DDC
9D005D48  0080A025   OR S4, A0, ZERO
9D005D4C  00009025   OR S2, ZERO, ZERO
9D005D50  0000B025   OR S6, ZERO, ZERO
9D005D54  0000B825   OR S7, ZERO, ZERO
9D005D58  00008825   OR S1, ZERO, ZERO
9D005D5C  10000015   BEQ ZERO, ZERO, 0x9D005DB4
9D005D60  24150004   ADDIU S5, ZERO, 4
9D005D64  02E03825   OR A3, S7, ZERO
9D005D68  1240000C   BEQ S2, ZERO, 0x9D005D9C
9D005D6C  02802825   OR A1, S4, ZERO
9D005D70  8E420010   LW V0, 16(S2)
9D005D74  5040000A   BEQL V0, ZERO, 0x9D005DA0
9D005D78  92030000   LBU V1, 0(S0)
9D005D7C  8E46000C   LW A2, 12(S2)
9D005D80  96440008   LHU A0, 8(S2)
9D005D84  AFB00018   SW S0, 24(SP)
9D005D88  AFAB0014   SW T3, 20(SP)
9D005D8C  AFB60010   SW S6, 16(SP)
9D005D90  8C420000   LW V0, 0(V0)
9D005D94  0040F809   JALR V0
9D005D98  00000000   NOP
9D005D9C  92030000   LBU V1, 0(S0)
9D005DA0  02238821   ADDU S1, S1, V1
9D005DA4  3231FFFF   ANDI S1, S1, -1
9D005DA8  0233102B   SLTU V0, S1, S3
9D005DAC  1040000B   BEQ V0, ZERO, 0x9D005DDC
9D005DB0  02038021   ADDU S0, S0, V1
9D005DB4  920B0001   LBU T3, 1(S0)
9D005DB8  1575FFEB   BNE T3, S5, 0x9D005D68
9D005DBC  02E03825   OR A3, S7, ZERO
9D005DC0  92170002   LBU S7, 2(S0)
9D005DC4  02802825   OR A1, S4, ZERO
9D005DC8  92160003   LBU S6, 3(S0)
9D005DCC  0F401C77   JAL _USB_DEVICE_GetFunctionDriverEntryByInterface
9D005DD0  02E02025   OR A0, S7, ZERO
9D005DD4  1000FFE3   BEQ ZERO, ZERO, 0x9D005D64
9D005DD8  00409025   OR S2, V0, ZERO
9D005DDC  8FBF0044   LW RA, 68(SP)
9D005DE0  8FB70040   LW S7, 64(SP)
9D005DE4  8FB6003C   LW S6, 60(SP)
9D005DE8  8FB50038   LW S5, 56(SP)
9D005DEC  8FB40034   LW S4, 52(SP)
9D005DF0  8FB30030   LW S3, 48(SP)
9D005DF4  8FB2002C   LW S2, 44(SP)
9D005DF8  8FB10028   LW S1, 40(SP)
9D005DFC  8FB00024   LW S0, 36(SP)
9D005E00  03E00008   JR RA
9D005E04  27BD0048   ADDIU SP, SP, 72
9D006284  8C8A001C   LW T2, 28(A0)
9D006288  90A90002   LBU T1, 2(A1)
9D00628C  00003825   OR A3, ZERO, ZERO
9D006290  8D480000   LW T0, 0(T2)
9D006294  91020000   LBU V0, 0(T0)
9D006298  2442FFFE   ADDIU V0, V0, -2
9D00629C  304200FF   ANDI V0, V0, 255
9D0062A0  2C4B0002   SLTIU T3, V0, 2
9D0062A4  15600007   BNE T3, ZERO, 0x9D0062C4
9D0062A8  00021842   SRL V1, V0, 1
9D0062AC  90870018   LBU A3, 24(A0)
9D0062B0  24E7FFFF   ADDIU A3, A3, -1
9D0062B4  00E3001A   DIV A3, V1
9D0062B8  006001F4   TEQ V1, ZERO
9D0062BC  00003812   MFLO A3
9D0062C0  30E700FF   ANDI A3, A3, 255
9D0062C4  00E9382B   SLTU A3, A3, T1
9D0062C8  10E00003   BEQ A3, ZERO, 0x9D0062D8
9D0062CC  00001025   OR V0, ZERO, ZERO
9D0062D0  03E00008   JR RA
9D0062D4  00000000   NOP
9D0062D8  51200015   BEQL T1, ZERO, 0x9D006330
9D0062DC  ACC80000   SW T0, 0(A2)
9D0062E0  90A40005   LBU A0, 5(A1)
9D0062E4  90A70004   LBU A3, 4(A1)
9D0062E8  306BFFFF   ANDI T3, V1, -1
9D0062EC  00042200   SLL A0, A0, 8
9D0062F0  1060FFF7   BEQ V1, ZERO, 0x9D0062D0
9D0062F4  00873825   OR A3, A0, A3
9D0062F8  95020002   LHU V0, 2(T0)
9D0062FC  1047000E   BEQ V0, A3, 0x9D006338
9D006300  24040001   ADDIU A0, ZERO, 1
9D006304  10000004   BEQ ZERO, ZERO, 0x9D006318
9D006308  25020004   ADDIU V0, T0, 4
9D00630C  9445FFFE   LHU A1, -2(V0)
9D006310  10A70009   BEQ A1, A3, 0x9D006338
9D006314  00602025   OR A0, V1, ZERO
9D006318  24830001   ADDIU V1, A0, 1
9D00631C  24420002   ADDIU V0, V0, 2
9D006320  1564FFFA   BNE T3, A0, 0x9D00630C
9D006324  3063FFFF   ANDI V1, V1, -1
9D006328  03E00008   JR RA
9D00632C  00001025   OR V0, ZERO, ZERO
9D006330  03E00008   JR RA
9D006334  91020000   LBU V0, 0(T0)
9D006338  71241002   MUL V0, T1, A0
9D00633C  00021080   SLL V0, V0, 2
9D006340  01421021   ADDU V0, T2, V0
9D006344  8C420000   LW V0, 0(V0)
9D006348  ACC20000   SW V0, 0(A2)
9D00634C  03E00008   JR RA
9D006350  90420000   LBU V0, 0(V0)
9D006420  00805825   OR T3, A0, ZERO
9D006424  27BDFFE8   ADDIU SP, SP, -24
9D006428  00A02025   OR A0, A1, ZERO
9D00642C  01602825   OR A1, T3, ZERO
9D006430  AFBF0014   SW RA, 20(SP)
9D006434  0F401C77   JAL _USB_DEVICE_GetFunctionDriverEntryByInterface
9D006438  00C06025   OR T4, A2, ZERO
9D00643C  50400018   BEQL V0, ZERO, _USB_DEVICE_ForwardControlXfrToFunction::USB_DEVICE_ControlStatus
9D006440  2562FFFF   ADDIU V0, T3, -1
9D006444  8C430010   LW V1, 16(V0)
9D006448  5060000C   BEQL V1, ZERO, 0x9D00647C
9D00644C  8D7900E0   LW T9, 224(T3)
9D006450  8C790008   LW T9, 8(V1)
9D006454  13200008   BEQ T9, ZERO, _USB_DEVICE_ForwardControlXfrToFunction::_USB_DEVICE_RedirectControlXfrToClient
9D006458  8FBF0014   LW RA, 20(SP)
9D00645C  94440008   LHU A0, 8(V0)
9D006460  AD7900D0   SW T9, 208(T3)
9D006464  01803025   OR A2, T4, ZERO
9D006468  A56400C8   SH A0, 200(T3)
9D00646C  2405000E   ADDIU A1, ZERO, 14
9D006470  03200008   JR T9
9D006474  27BD0018   ADDIU SP, SP, 24
9D006478  8D7900E0   LW T9, 224(T3)
9D00647C  95640018   LHU A0, 24(T3)
9D006480  8D6300D8   LW V1, 216(T3)
9D006484  24020001   ADDIU V0, ZERO, 1
9D006488  AD7900D0   SW T9, 208(T3)
9D00648C  10620010   BEQ V1, V0, _USB_DEVICE_ForwardControlXfrToFunction::_USB_DEVICE_RedirectControlXfrToClient
9D006490  A56400C8   SH A0, 200(T3)
9D006494  8FBF0014   LW RA, 20(SP)
9D006498  03E00008   JR RA
9D00649C  27BD0018   ADDIU SP, SP, 24
9D0064A0  2C42FFFE   SLTIU V0, V0, -2
9D0064AC  916200DC   LBU V0, 220(T3)
9D0064B8  8D6200EC   LW V0, 236(T3)
9D0064BC  8D64001C   LW A0, 28(T3)
9D0064C4  A16000C4   SB ZERO, 196(T3)
9D0064C8  03200008   JR T9
9D0064D0  1320FFF0   BEQ T9, ZERO, 0x9D006494
9D0064D4  8FBF0014   LW RA, 20(SP)
9D0064D8  8D6600E4   LW A2, 228(T3)
9D0064DC  01802825   OR A1, T4, ZERO
9D0064E0  2404000E   ADDIU A0, ZERO, 14
9D0064E4  03200008   JR T9
9D0064E8  27BD0018   ADDIU SP, SP, 24
9D0064EC  8C830008   LW V1, 8(A0)
9D006740  8C820008   LW V0, 8(A0)
9D006744  27BDFFE0   ADDIU SP, SP, -32
9D006748  2403FFFE   ADDIU V1, ZERO, -2
9D00674C  AFB10018   SW S1, 24(SP)
9D006750  AFBF001C   SW RA, 28(SP)
9D006754  AFB00014   SW S0, 20(SP)
9D006758  10430018   BEQ V0, V1, 0x9D0067BC
9D00675C  8C910014   LW S1, 20(A0)
9D006760  96230000   LHU V1, 0(S1)
9D006764  00808025   OR S0, A0, ZERO
9D006768  30640080   ANDI A0, V1, 128
9D00676C  10800018   BEQ A0, ZERO, 0x9D0067D0
9D006770  30640100   ANDI A0, V1, 256
9D006774  8E2200EC   LW V0, 236(S1)
9D006778  8E24001C   LW A0, 28(S1)
9D00677C  8C42000C   LW V0, 12(V0)
9D006780  0040F809   JALR V0
9D006784  922500AC   LBU A1, 172(S1)
9D006788  96230000   LHU V1, 0(S1)
9D00678C  92220003   LBU V0, 3(S1)
9D006790  24040004   ADDIU A0, ZERO, 4
9D006794  7C0339C4   INS V1, ZERO, 7, 1
9D006798  7C821004   INS V0, A0, 0, 3
9D00679C  A6230000   SH V1, 0(S1)
9D0067A0  A2220003   SB V0, 3(S1)
9D0067A4  8E020008   LW V0, 8(S0)
9D0067A8  14400005   BNE V0, ZERO, 0x9D0067C0
9D0067AC  8FBF001C   LW RA, 28(SP)
9D0067B0  8E020004   LW V0, 4(S0)
9D0067B4  50400001   BEQL V0, ZERO, 0x9D0067BC
9D0067B8  A22000C4   SB ZERO, 196(S1)
9D0067BC  8FBF001C   LW RA, 28(SP)
9D0067C0  8FB10018   LW S1, 24(SP)
9D0067C4  8FB00014   LW S0, 20(SP)
9D0067C8  03E00008   JR RA
9D0067CC  27BD0020   ADDIU SP, SP, 32
9D0067D0  1080FFF5   BEQ A0, ZERO, 0x9D0067A8
9D0067D4  7C034204   INS V1, ZERO, 8, 1
9D0067D8  8E2200EC   LW V0, 236(S1)
9D0067DC  A6230000   SH V1, 0(S1)
9D0067E0  8C42004C   LW V0, 76(V0)
9D0067E4  92250002   LBU A1, 2(S1)
9D0067E8  0040F809   JALR V0
9D0067EC  8E24001C   LW A0, 28(S1)
9D0067F0  1000FFED   BEQ ZERO, ZERO, 0x9D0067A8
9D0067F4  8E020008   LW V0, 8(S0)
9D0067F8  27BDFFD8   ADDIU SP, SP, -40
9D0067FC  AFB3001C   SW S3, 28(SP)
9D006800  AFB10014   SW S1, 20(SP)
9D006804  AFBF0024   SW RA, 36(SP)
9D006808  AFB40020   SW S4, 32(SP)
9D00680C  AFB20018   SW S2, 24(SP)
9D006810  AFB00010   SW S0, 16(SP)
9D006814  8C920000   LW S2, 0(A0)
9D006818  94930010   LHU S3, 16(A0)
9D00681C  909400AD   LBU S4, 173(A0)
9D006820  7E521040   EXT S2, S2, 1, 3
9D006824  1260001A   BEQ S3, ZERO, 0x9D006890
9D006828  8C910014   LW S1, 20(A0)
9D00682C  10000005   BEQ ZERO, ZERO, 0x9D006844
9D006830  00008025   OR S0, ZERO, ZERO
9D006834  321000FF   ANDI S0, S0, 255
9D006838  0213102B   SLTU V0, S0, S3
9D00683C  10400014   BEQ V0, ZERO, 0x9D006890
9D006840  26310014   ADDIU S1, S1, 20
9D006844  8E220000   LW V0, 0(S1)
9D006848  02421024   AND V0, S2, V0
9D00684C  5040FFF9   BEQL V0, ZERO, 0x9D006834
9D006850  26100001   ADDIU S0, S0, 1
9D006854  92220004   LBU V0, 4(S1)
9D006858  5454FFF6   BNEL V0, S4, 0x9D006834
9D00685C  26100001   ADDIU S0, S0, 1
9D006860  8E220010   LW V0, 16(S1)
9D006864  1040FFF3   BEQ V0, ZERO, 0x9D006834
9D006868  26100001   ADDIU S0, S0, 1
9D00686C  8C420004   LW V0, 4(V0)
9D006870  1040FFF0   BEQ V0, ZERO, 0x9D006834
9D006874  00000000   NOP
9D006878  96240008   LHU A0, 8(S1)
9D00687C  0040F809   JALR V0
9D006880  321000FF   ANDI S0, S0, 255
9D006884  0213102B   SLTU V0, S0, S3
9D006888  1440FFEE   BNE V0, ZERO, 0x9D006844
9D00688C  26310014   ADDIU S1, S1, 20
9D006890  8FBF0024   LW RA, 36(SP)
9D006894  8FB40020   LW S4, 32(SP)
9D006898  8FB3001C   LW S3, 28(SP)
9D00689C  8FB20018   LW S2, 24(SP)
9D0068A0  8FB10014   LW S1, 20(SP)
9D0068A4  8FB00010   LW S0, 16(SP)
9D0068A8  03E00008   JR RA
9D0068AC  27BD0028   ADDIU SP, SP, 40
9D006C00  2482FFFF   ADDIU V0, A0, -1
9D006C04  2C42FFFE   SLTIU V0, V0, -2
9D006C10  908200DC   LBU V0, 220(A0)
9D006C1C  948200E8   LHU V0, 232(A0)
9D006C20  27BDFFE8   ADDIU SP, SP, -24
9D006C24  AFBF0014   SW RA, 20(SP)
9D006C28  AC850064   SW A1, 100(A0)
9D006C2C  10460010   BEQ V0, A2, 0x9D006C70
9D006C30  AC860068   SW A2, 104(A0)
9D006C34  00C2102B   SLTU V0, A2, V0
9D006C38  50400004   BEQL V0, ZERO, 0x9D006C4C
9D006C3C  8C8200EC   LW V0, 236(A0)
9D006C40  24020001   ADDIU V0, ZERO, 1
9D006C44  AC820074   SW V0, 116(A0)
9D006C48  8C8200EC   LW V0, 236(A0)
9D006C4C  8C84001C   LW A0, 28(A0)
9D006C50  00603025   OR A2, V1, ZERO
9D006C54  8C420038   LW V0, 56(V0)
9D006C58  0040F809   JALR V0
9D006C5C  24050080   ADDIU A1, ZERO, 128
9D006C60  8FBF0014   LW RA, 20(SP)
9D006C64  00001025   OR V0, ZERO, ZERO
9D006C68  03E00008   JR RA
9D006C6C  27BD0018   ADDIU SP, SP, 24
9D006C70  24020002   ADDIU V0, ZERO, 2
9D006C74  AC820074   SW V0, 116(A0)
9D006C78  8C8200EC   LW V0, 236(A0)
9D006C7C  8C84001C   LW A0, 28(A0)
9D006C80  00603025   OR A2, V1, ZERO
9D006C84  8C420038   LW V0, 56(V0)
9D006C88  0040F809   JALR V0
9D006C8C  24050080   ADDIU A1, ZERO, 128
9D006C90  8FBF0014   LW RA, 20(SP)
9D006C94  00001025   OR V0, ZERO, ZERO
9D006C98  03E00008   JR RA
9D006C9C  27BD0018   ADDIU SP, SP, 24
9D006CA0  03E00008   JR RA
9D006CA4  2402FF8B   ADDIU V0, ZERO, -117
9D007158  2482FFFF   ADDIU V0, A0, -1
9D00715C  2C42FFFE   SLTIU V0, V0, -2
9D007168  908200DC   LBU V0, 220(A0)
9D007174  27BDFFE8   ADDIU SP, SP, -24
9D007178  AFBF0014   SW RA, 20(SP)
9D00717C  00803025   OR A2, A0, ZERO
9D007180  A08000C4   SB ZERO, 196(A0)
9D007184  8C8200EC   LW V0, 236(A0)
9D007188  10A3000B   BEQ A1, V1, USB_DEVICE_ControlStatus
9D00718C  8C84001C   LW A0, 28(A0)
9D007190  8C420038   LW V0, 56(V0)
9D007194  24C60064   ADDIU A2, A2, 100
9D007198  ACC00000   SW ZERO, 0(A2)
9D00719C  ACC00004   SW ZERO, 4(A2)
9D0071A0  0040F809   JALR V0
9D0071A4  24050080   ADDIU A1, ZERO, 128
9D0071A8  8FBF0014   LW RA, 20(SP)
9D0071AC  00001025   OR V0, ZERO, ZERO
9D0071B0  03E00008   JR RA
9D0071B4  27BD0018   ADDIU SP, SP, 24
9D0071B8  8C420028   LW V0, 40(V0)
9D0071BC  0040F809   JALR V0
9D0071C0  24050080   ADDIU A1, ZERO, 128
9D0071C4  8FBF0014   LW RA, 20(SP)
9D0071C8  00001025   OR V0, ZERO, ZERO
9D0071CC  03E00008   JR RA
9D0071D0  27BD0018   ADDIU SP, SP, 24
9D0071D4  03E00008   JR RA
9D0071D8  2402FF8B   ADDIU V0, ZERO, -117
9D0071DC  8CA70000   LW A3, 0(A1)
9D0071E0  94A80010   LHU T0, 16(A1)
9D0071E4  8CA20014   LW V0, 20(A1)
9D0071E8  7CE71040   EXT A3, A3, 1, 3
9D0071EC  11000019   BEQ T0, ZERO, 0x9D007254
9D0071F0  90A900AD   LBU T1, 173(A1)
9D0071F4  10000003   BEQ ZERO, ZERO, 0x9D007204
9D0071F8  00001825   OR V1, ZERO, ZERO
9D0071FC  10C00015   BEQ A2, ZERO, 0x9D007254
9D007200  24420014   ADDIU V0, V0, 20
9D007204  8C450000   LW A1, 0(V0)
9D007208  24630001   ADDIU V1, V1, 1
9D00720C  306300FF   ANDI V1, V1, 255
9D007210  00E52824   AND A1, A3, A1
9D007214  10A0FFF9   BEQ A1, ZERO, 0x9D0071FC
9D007218  0068302B   SLTU A2, V1, T0
9D00721C  90450004   LBU A1, 4(V0)
9D007220  14A9FFF6   BNE A1, T1, 0x9D0071FC
9D007224  00000000   NOP
9D007228  904A0005   LBU T2, 5(V0)
9D00722C  008A282B   SLTU A1, A0, T2
9D007230  14A0FFF2   BNE A1, ZERO, 0x9D0071FC
9D007234  00000000   NOP
9D007238  90450006   LBU A1, 6(V0)
9D00723C  00AA2821   ADDU A1, A1, T2
9D007240  0085282A   SLT A1, A0, A1
9D007244  10A0FFED   BEQ A1, ZERO, 0x9D0071FC
9D007248  00000000   NOP
9D00724C  03E00008   JR RA
9D007250  00000000   NOP
9D007254  03E00008   JR RA
9D007258  00001025   OR V0, ZERO, ZERO
9D007520  2482FFFF   ADDIU V0, A0, -1
9D007524  2C42FFFE   SLTIU V0, V0, -2
9D007530  908200DC   LBU V0, 220(A0)
9D00753C  8C8200EC   LW V0, 236(A0)
9D007540  27BDFFE8   ADDIU SP, SP, -24
9D007544  AFB00010   SW S0, 16(SP)
9D007548  8C420018   LW V0, 24(V0)
9D00754C  00808025   OR S0, A0, ZERO
9D007550  8C84001C   LW A0, 28(A0)
9D007554  AFBF0014   SW RA, 20(SP)
9D007558  0040F809   JALR V0
9D00755C  00000000   NOP
9D007560  92020003   LBU V0, 3(S0)
9D007564  24030002   ADDIU V1, ZERO, 2
9D007568  7C621004   INS V0, V1, 0, 3
9D00756C  A2020003   SB V0, 3(S0)
9D007570  8FBF0014   LW RA, 20(SP)
9D007574  8FB00010   LW S0, 16(SP)
9D007578  03E00008   JR RA
9D00757C  27BD0018   ADDIU SP, SP, 24
9D007580  03E00008   JR RA
9D007584  00000000   NOP
9D007A7C  14800011   BNE A0, ZERO, 0x9D007AC4
9D007A80  3C03A000   LUI V1, -24576
9D007A84  24630280   ADDIU V1, V1, 640
9D007A88  8C640008   LW A0, 8(V1)
9D007A8C  24020002   ADDIU V0, ZERO, 2
9D007A90  1482000C   BNE A0, V0, 0x9D007AC4
9D007A94  00000000   NOP
9D007A98  906400DC   LBU A0, 220(V1)
9D007A9C  10800003   BEQ A0, ZERO, 0x9D007AAC
9D007AA0  2402FFFF   ADDIU V0, ZERO, -1
9D007AA4  03E00008   JR RA
9D007AA8  00000000   NOP
9D007AAC  24020001   ADDIU V0, ZERO, 1
9D007AB0  A06200DC   SB V0, 220(V1)
9D007AB4  24020001   ADDIU V0, ZERO, 1
9D007AB8  AC6200D8   SW V0, 216(V1)
9D007ABC  03E00008   JR RA
9D007AC0  00601025   OR V0, V1, ZERO
9D007AC4  03E00008   JR RA
9D007AC8  2402FFFF   ADDIU V0, ZERO, -1
9D007B64  2483FFFF   ADDIU V1, A0, -1
9D007B68  2C63FFFE   SLTIU V1, V1, -2
9D007B6C  1060000D   BEQ V1, ZERO, 0x9D007BA4
9D007B74  908300DC   LBU V1, 220(A0)
9D007B80  8C8300EC   LW V1, 236(A0)
9D007B84  8C84001C   LW A0, 28(A0)
9D007B88  8C790008   LW T9, 8(V1)
9D007B8C  AC4600E4   SW A2, 228(V0)
9D007B90  3C069D00   LUI A2, -25344
9D007B94  AC4500E0   SW A1, 224(V0)
9D007B98  24C63030   ADDIU A2, A2, 12336
9D007B9C  03200008   JR T9
9D007BA0  00402825   OR A1, V0, ZERO
9D007BA4  03E00008   JR RA
9D007BA8  00000000   NOP
9D007D44  2482FFFF   ADDIU V0, A0, -1
9D007D48  2C42FFFE   SLTIU V0, V0, -2
9D007D4C  00C02825   OR A1, A2, ZERO
9D007D50  00E03025   OR A2, A3, ZERO
9D007D54  10400009   BEQ V0, ZERO, 0x9D007D7C
9D007D58  8FA70010   LW A3, 16(SP)
9D007D5C  908200DC   LBU V0, 220(A0)
9D007D60  10400006   BEQ V0, ZERO, 0x9D007D7C
9D007D64  00000000   NOP
9D007D68  8C8200EC   LW V0, 236(A0)
9D007D6C  8C84001C   LW A0, 28(A0)
9D007D70  8C590020   LW T9, 32(V0)
9D007D74  03200008   JR T9
9D007D78  30E7FFFF   ANDI A3, A3, -1
9D007D7C  03E00008   JR RA
9D007D80  2402FF84   ADDIU V0, ZERO, -124
9D007E74  2482FFFF   ADDIU V0, A0, -1
9D007E78  2C42FFFE   SLTIU V0, V0, -2
9D007E84  908200DC   LBU V0, 220(A0)
9D007E90  AC8500CC   SW A1, 204(A0)
9D007E94  A08000C5   SB ZERO, 197(A0)
9D007E98  A08600C6   SB A2, 198(A0)
9D007E9C  03E00008   JR RA
9D007EA0  00001025   OR V0, ZERO, ZERO
9D007EA4  03E00008   JR RA
9D007EA8  2402FF8B   ADDIU V0, ZERO, -117
9D007EE4  2482FFFF   ADDIU V0, A0, -1
9D007EE8  2C42FFFE   SLTIU V0, V0, -2
9D007EF4  908200DC   LBU V0, 220(A0)
9D007F00  8C8200EC   LW V0, 236(A0)
9D007F04  8C590024   LW T9, 36(V0)
9D007F08  03200008   JR T9
9D007F0C  8C84001C   LW A0, 28(A0)
9D007F10  03E00008   JR RA
9D007F14  2402FF84   ADDIU V0, ZERO, -124
9D007F18  2482FFFF   ADDIU V0, A0, -1
9D007F1C  2C42FFFE   SLTIU V0, V0, -2
9D007F28  908200DC   LBU V0, 220(A0)
9D007F34  8C8200EC   LW V0, 236(A0)
9D007F38  8C590038   LW T9, 56(V0)
9D007F3C  03200008   JR T9
9D007F40  8C84001C   LW A0, 28(A0)
9D007F44  03E00008   JR RA
9D007F48  2402FF83   ADDIU V0, ZERO, -125
9D007F4C  2482FFFF   ADDIU V0, A0, -1
9D007F50  2C42FFFE   SLTIU V0, V0, -2
9D007F5C  908200DC   LBU V0, 220(A0)
9D007F68  8C8200EC   LW V0, 236(A0)
9D007F6C  8C590040   LW T9, 64(V0)
9D007F70  03200008   JR T9
9D007F74  8C84001C   LW A0, 28(A0)
9D007F78  03E00008   JR RA
9D007F7C  2402FF83   ADDIU V0, ZERO, -125
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/system/int/src/sys_int.c  ------------------
1:                   /*******************************************************************************
2:                     Interrupt System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_int.c
9:                   
10:                    Summary:
11:                      Interrupt System Service APIs.
12:                  
13:                    Description:
14:                      This file contains functions related to the Interrupt System Service for PIC32
15:                      devices.
16:                  *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
21:                  *
22:                  * Subject to your compliance with these terms, you may use Microchip software
23:                  * and any derivatives exclusively with Microchip products. It is your
24:                  * responsibility to comply with third party license terms applicable to your
25:                  * use of third party software (including open source software) that may
26:                  * accompany Microchip software.
27:                  *
28:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                  * PARTICULAR PURPOSE.
32:                  *
33:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                  *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  // *****************************************************************************
44:                  // *****************************************************************************
45:                  // Section: Included Files
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  
49:                  #include "system/int/sys_int.h"
50:                  #include "peripheral/evic/plib_evic.h"
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Function Definitions
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  void SYS_INT_Enable( void )
59:                  {
60:                      EVIC_INT_Enable();
61:                  }
62:                  
63:                  bool SYS_INT_Disable( void )
64:                  {
65:                      /* return the interrupt status */
66:                      return EVIC_INT_Disable();
67:                  }
68:                  
69:                  void SYS_INT_Restore( bool state )
70:                  {
71:                      EVIC_INT_Restore(state);
72:                  }
73:                  
74:                  bool SYS_INT_SourceDisable( INT_SOURCE source )
75:                  {
76:                      bool intSrcStatus;
77:                      bool interruptStatus;
78:                  
79:                      /* Save the interrupt status and then Disable the global interrupt */
80:                      interruptStatus = (bool)(( uint32_t )__builtin_disable_interrupts() & 0x01);
81:                  
82:                      /* get the interrupt status of this source before disable is called */
83:                      intSrcStatus = SYS_INT_SourceIsEnabled(source);
84:                  
85:                      /* disable the interrupts */
86:                      EVIC_SourceDisable(source);
87:                  
88:                      SYS_INT_Restore(interruptStatus);
89:                  
90:                      /* return the source status */
91:                      return intSrcStatus;
92:                  }
93:                  
94:                  void SYS_INT_SourceRestore( INT_SOURCE source, bool status )
95:                  {
96:                      if( status )
97:                      {
98:                          SYS_INT_SourceEnable( source );
99:                      }
100:                 }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000008  00000000   NOP
00000010  00000000   NOP
00000018  00000000   NOP
9D000358  0B4020E5   J EVIC_INT_Disable
9D00035C  00000000   NOP
9D000388  0B4020AA   J EVIC_INT_Restore
9D00038C  00000000   NOP
9D000390  03E00008   JR RA
9D007A2C  27BDFFD8   ADDIU SP, SP, -40
9D007A30  AFB10020   SW S1, 32(SP)
9D007A34  00808825   OR S1, A0, ZERO
9D007A38  AFBF0024   SW RA, 36(SP)
9D007A3C  AFB0001C   SW S0, 28(SP)
9D007A40  41706000   DI S0
9D007A44  000000C0   EHB
9D007A48  0F4020DC   JAL EVIC_SourceIsEnabled
9D007A4C  00000000   NOP
9D007A50  02202025   OR A0, S1, ZERO
9D007A54  0F402096   JAL EVIC_SourceDisable
9D007A58  AFA20010   SW V0, 16(SP)
9D007A5C  0F4020AA   JAL EVIC_INT_Restore
9D007A64  8FBF0024   LW RA, 36(SP)
9D007A68  8FA20010   LW V0, 16(SP)
9D007A6C  8FB10020   LW S1, 32(SP)
9D007A70  8FB0001C   LW S0, 28(SP)
9D007A74  03E00008   JR RA
9D007A78  27BD0028   ADDIU SP, SP, 40
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/stdio/xc32_monitor.c  ----------------------
1:                   /*******************************************************************************
2:                    Debug Console Source file
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       xc32_monitor.c
9:                   
10:                    Summary:
11:                      debug console Source File
12:                  
13:                    Description:
14:                      None
15:                  
16:                  *******************************************************************************/
17:                  
18:                  /*******************************************************************************
19:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
20:                  *
21:                  * Subject to your compliance with these terms, you may use Microchip software
22:                  * and any derivatives exclusively with Microchip products. It is your
23:                  * responsibility to comply with third party license terms applicable to your
24:                  * use of third party software (including open source software) that may
25:                  * accompany Microchip software.
26:                  *
27:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                  * PARTICULAR PURPOSE.
31:                  *
32:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
33:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
34:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
35:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
36:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
37:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
38:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
39:                  *******************************************************************************/
40:                  #include <stddef.h>
41:                  
42:                  extern int read(int handle, void *buffer, unsigned int len);
43:                  extern int write(int handle, void * buffer, size_t count);
44:                  
45:                  
46:                  int read(int handle, void *buffer, unsigned int len)
47:                  {
48:                     return -1;
49:                  }
50:                  
51:                  int write(int handle, void * buffer, size_t count)
52:                  {
53:                     return -1;
54:                  }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/peripheral/uart/plib_uart1.c  --------------
1:                   /*******************************************************************************
2:                     UART1 PLIB
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_uart1.c
9:                   
10:                    Summary:
11:                      UART1 PLIB Implementation File
12:                  
13:                    Description:
14:                      None
15:                  
16:                  *******************************************************************************/
17:                  
18:                  /*******************************************************************************
19:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
20:                  *
21:                  * Subject to your compliance with these terms, you may use Microchip software
22:                  * and any derivatives exclusively with Microchip products. It is your
23:                  * responsibility to comply with third party license terms applicable to your
24:                  * use of third party software (including open source software) that may
25:                  * accompany Microchip software.
26:                  *
27:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                  * PARTICULAR PURPOSE.
31:                  *
32:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
33:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
34:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
35:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
36:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
37:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
38:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
39:                  *******************************************************************************/
40:                  
41:                  #include "device.h"
42:                  #include "plib_uart1.h"
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Section: UART1 Implementation
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  
50:                  UART_RING_BUFFER_OBJECT uart1Obj;
51:                  
52:                  #define UART1_READ_BUFFER_SIZE      128
53:                  #define UART1_READ_BUFFER_SIZE_9BIT (128 >> 1)
54:                  #define UART1_RX_INT_DISABLE()      IEC1CLR = _IEC1_U1RXIE_MASK;
55:                  #define UART1_RX_INT_ENABLE()       IEC1SET = _IEC1_U1RXIE_MASK;
56:                  
57:                  static uint8_t UART1_ReadBuffer[UART1_READ_BUFFER_SIZE];
58:                  
59:                  #define UART1_WRITE_BUFFER_SIZE     128
60:                  #define UART1_WRITE_BUFFER_SIZE_9BIT       (128 >> 1)
61:                  #define UART1_TX_INT_DISABLE()      IEC1CLR = _IEC1_U1TXIE_MASK;
62:                  #define UART1_TX_INT_ENABLE()       IEC1SET = _IEC1_U1TXIE_MASK;
63:                  
64:                  static uint8_t UART1_WriteBuffer[UART1_WRITE_BUFFER_SIZE];
65:                  
66:                  #define UART1_IS_9BIT_MODE_ENABLED()    ( U1MODE & (_U1MODE_PDSEL0_MASK | _U1MODE_PDSEL1_MASK)) == (_U1MODE_PDSEL0_MASK | _U1MODE_PDSEL1_MASK) ? true:false
67:                  
68:                  void static UART1_ErrorClear( void )
69:                  {
70:                      UART_ERROR errors = UART_ERROR_NONE;
71:                      uint8_t dummyData = 0u;
72:                  
73:                      errors = (UART_ERROR)(U1STA & (_U1STA_OERR_MASK | _U1STA_FERR_MASK | _U1STA_PERR_MASK));
74:                  
75:                      if(errors != UART_ERROR_NONE)
76:                      {
77:                          /* If it's a overrun error then clear it to flush FIFO */
78:                          if(U1STA & _U1STA_OERR_MASK)
79:                          {
80:                              U1STACLR = _U1STA_OERR_MASK;
81:                          }
82:                  
83:                          /* Read existing error bytes from FIFO to clear parity and framing error flags */
84:                          while(U1STA & _U1STA_URXDA_MASK)
85:                          {
86:                              dummyData = U1RXREG;
87:                          }
88:                  
89:                          /* Clear error interrupt flag */
90:                          IFS1CLR = _IFS1_U1EIF_MASK;
91:                  
92:                          /* Clear up the receive interrupt flag so that RX interrupt is not
93:                           * triggered for error bytes */
94:                          IFS1CLR = _IFS1_U1RXIF_MASK;
95:                  
96:                      }
97:                  
98:                      // Ignore the warning
99:                      (void)dummyData;
100:                 }
101:                 
102:                 void UART1_Initialize( void )
103:                 {
104:                     /* Set up UxMODE bits */
105:                     /* STSEL  = 0*/
106:                     /* PDSEL = 0 */
107:                     /* BRGH = 1 */
108:                     /* RXINV = 0 */
109:                     /* ABAUD = 0 */
110:                     /* LPBACK = 0 */
111:                     /* WAKE = 0 */
112:                     /* SIDL = 0 */
113:                     /* RUNOVF = 0 */
114:                     /* CLKSEL = 0 */
115:                     /* SLPEN = 0 */
116:                     U1MODE = 0x8;
117:                 
118:                     /* Enable UART1 Receiver, Transmitter and TX Interrupt selection */
119:                     U1STASET = (_U1STA_UTXEN_MASK | _U1STA_URXEN_MASK | _U1STA_UTXISEL1_MASK );
120:                 
121:                     /* BAUD Rate register Setup */
122:                     U1BRG = 155;
123:                 
124:                     IEC1CLR = _IEC1_U1TXIE_MASK;
125:                 
126:                     /* Initialize instance object */
127:                     uart1Obj.rdCallback = NULL;
128:                     uart1Obj.rdInIndex = 0;
129:                     uart1Obj.rdOutIndex = 0;
130:                     uart1Obj.isRdNotificationEnabled = false;
131:                     uart1Obj.isRdNotifyPersistently = false;
132:                     uart1Obj.rdThreshold = 0;
133:                 
134:                     uart1Obj.wrCallback = NULL;
135:                     uart1Obj.wrInIndex = 0;
136:                     uart1Obj.wrOutIndex = 0;
137:                     uart1Obj.isWrNotificationEnabled = false;
138:                     uart1Obj.isWrNotifyPersistently = false;
139:                     uart1Obj.wrThreshold = 0;
140:                 
141:                     uart1Obj.errors = UART_ERROR_NONE;
142:                 
143:                     if (UART1_IS_9BIT_MODE_ENABLED())
144:                     {
145:                         uart1Obj.rdBufferSize = UART1_READ_BUFFER_SIZE_9BIT;
146:                         uart1Obj.wrBufferSize = UART1_WRITE_BUFFER_SIZE_9BIT;
147:                     }
148:                     else
149:                     {
150:                         uart1Obj.rdBufferSize = UART1_READ_BUFFER_SIZE;
151:                         uart1Obj.wrBufferSize = UART1_WRITE_BUFFER_SIZE;
152:                     }
153:                 
154:                 
155:                     /* Turn ON UART1 */
156:                     U1MODESET = _U1MODE_ON_MASK;
157:                 
158:                     /* Enable UART1_FAULT Interrupt */
159:                     IEC1SET = _IEC1_U1EIE_MASK;
160:                 
161:                     /* Enable UART1_RX Interrupt */
162:                     IEC1SET = _IEC1_U1RXIE_MASK;
163:                 }
164:                 
165:                 bool UART1_SerialSetup( UART_SERIAL_SETUP *setup, uint32_t srcClkFreq )
166:                 {
167:                     bool status = false;
168:                     uint32_t baud;
169:                     uint32_t status_ctrl;
170:                     uint8_t brgh = 1;
171:                     int32_t uxbrg = 0;
172:                 
173:                     if (setup != NULL)
174:                     {
175:                         baud = setup->baudRate;
176:                 
177:                         if ((baud == 0) || ((setup->dataWidth == UART_DATA_9_BIT) && (setup->parity != UART_PARITY_NONE)))
178:                         {
179:                             return status;
180:                         }
181:                 
182:                         if(srcClkFreq == 0)
183:                         {
184:                             srcClkFreq = UART1_FrequencyGet();
185:                         }
186:                 
187:                          /* Calculate BRG value */
188:                         if (brgh == 0)
189:                         {
190:                             uxbrg = (((srcClkFreq >> 4) + (baud >> 1)) / baud ) - 1;
191:                         }
192:                         else
193:                         {
194:                             uxbrg = (((srcClkFreq >> 2) + (baud >> 1)) / baud ) - 1;
195:                         }
196:                 
197:                         /* Check if the baud value can be set with low baud settings */
198:                         if((uxbrg < 0) || (uxbrg > UINT16_MAX))
199:                         {
200:                             return status;
201:                         }
202:                 
203:                         /* Turn OFF UART1. Save UTXEN, URXEN and UTXBRK bits as these are cleared upon disabling UART */
204:                 
205:                         status_ctrl = U1STA & (_U1STA_UTXEN_MASK | _U1STA_URXEN_MASK | _U1STA_UTXBRK_MASK);
206:                 
207:                         U1MODECLR = _U1MODE_ON_MASK;
208:                 
209:                         if(setup->dataWidth == UART_DATA_9_BIT)
210:                         {
211:                             /* Configure UART1 mode */
212:                             U1MODE = (U1MODE & (~_U1MODE_PDSEL_MASK)) | setup->dataWidth;
213:                         }
214:                         else
215:                         {
216:                             /* Configure UART1 mode */
217:                             U1MODE = (U1MODE & (~_U1MODE_PDSEL_MASK)) | setup->parity;
218:                         }
219:                 
220:                         /* Configure UART1 mode */
221:                         U1MODE = (U1MODE & (~_U1MODE_STSEL_MASK)) | setup->stopBits;
222:                 
223:                         /* Configure UART1 Baud Rate */
224:                         U1BRG = uxbrg;
225:                 
226:                         if (UART1_IS_9BIT_MODE_ENABLED())
227:                         {
228:                             uart1Obj.rdBufferSize = UART1_READ_BUFFER_SIZE_9BIT;
229:                             uart1Obj.wrBufferSize = UART1_WRITE_BUFFER_SIZE_9BIT;
230:                         }
231:                         else
232:                         {
233:                             uart1Obj.rdBufferSize = UART1_READ_BUFFER_SIZE;
234:                             uart1Obj.wrBufferSize = UART1_WRITE_BUFFER_SIZE;
235:                         }
236:                 
237:                         U1MODESET = _U1MODE_ON_MASK;
238:                 
239:                         /* Restore UTXEN, URXEN and UTXBRK bits. */
240:                         U1STASET = status_ctrl;
241:                 
242:                         status = true;
243:                     }
244:                 
245:                     return status;
246:                 }
247:                 
248:                 /* This routine is only called from ISR. Hence do not disable/enable USART interrupts. */
249:                 static inline bool UART1_RxPushByte(uint16_t rdByte)
250:                 {
251:                     uint32_t tempInIndex;
252:                     bool isSuccess = false;
253:                 
254:                     tempInIndex = uart1Obj.rdInIndex + 1;
255:                 
256:                     if (tempInIndex >= uart1Obj.rdBufferSize)
257:                     {
258:                         tempInIndex = 0;
259:                     }
260:                 
261:                     if (tempInIndex == uart1Obj.rdOutIndex)
262:                     {
263:                         /* Queue is full - Report it to the application. Application gets a chance to free up space by reading data out from the RX ring buffer */
264:                         if(uart1Obj.rdCallback != NULL)
265:                         {
266:                             uart1Obj.rdCallback(UART_EVENT_READ_BUFFER_FULL, uart1Obj.rdContext);
267:                 
268:                             /* Read the indices again in case application has freed up space in RX ring buffer */
269:                             tempInIndex = uart1Obj.rdInIndex + 1;
270:                 
271:                             if (tempInIndex >= uart1Obj.rdBufferSize)
272:                             {
273:                                 tempInIndex = 0;
274:                             }
275:                         }
276:                     }
277:                 
278:                     /* Attempt to push the data into the ring buffer */
279:                     if (tempInIndex != uart1Obj.rdOutIndex)
280:                     {
281:                         if (UART1_IS_9BIT_MODE_ENABLED())
282:                         {
283:                             ((uint16_t*)&UART1_ReadBuffer)[uart1Obj.rdInIndex] = rdByte;
284:                         }
285:                         else
286:                         {
287:                             UART1_ReadBuffer[uart1Obj.rdInIndex] = (uint8_t)rdByte;
288:                         }
289:                 
290:                         uart1Obj.rdInIndex = tempInIndex;
291:                 
292:                         isSuccess = true;
293:                     }
294:                     else
295:                     {
296:                         /* Queue is full. Data will be lost. */
297:                     }
298:                 
299:                     return isSuccess;
300:                 }
301:                 
302:                 /* This routine is only called from ISR. Hence do not disable/enable USART interrupts. */
303:                 static void UART1_ReadNotificationSend(void)
304:                 {
305:                     uint32_t nUnreadBytesAvailable;
306:                 
307:                     if (uart1Obj.isRdNotificationEnabled == true)
308:                     {
309:                         nUnreadBytesAvailable = UART1_ReadCountGet();
310:                 
311:                         if(uart1Obj.rdCallback != NULL)
312:                         {
313:                             if (uart1Obj.isRdNotifyPersistently == true)
314:                             {
315:                                 if (nUnreadBytesAvailable >= uart1Obj.rdThreshold)
316:                                 {
317:                                     uart1Obj.rdCallback(UART_EVENT_READ_THRESHOLD_REACHED, uart1Obj.rdContext);
318:                                 }
319:                             }
320:                             else
321:                             {
322:                                 if (nUnreadBytesAvailable == uart1Obj.rdThreshold)
323:                                 {
324:                                     uart1Obj.rdCallback(UART_EVENT_READ_THRESHOLD_REACHED, uart1Obj.rdContext);
325:                                 }
326:                             }
327:                         }
328:                     }
329:                 }
330:                 
331:                 size_t UART1_Read(uint8_t* pRdBuffer, const size_t size)
332:                 {
333:                     size_t nBytesRead = 0;
334:                     uint32_t rdOutIndex = 0;
335:                     uint32_t rdInIndex = 0;
336:                 
337:                     /* Take a snapshot of indices to avoid creation of critical section */
338:                     rdOutIndex = uart1Obj.rdOutIndex;
339:                     rdInIndex = uart1Obj.rdInIndex;
340:                 
341:                     while (nBytesRead < size)
342:                     {
343:                         if (rdOutIndex != rdInIndex)
344:                         {
345:                             if (UART1_IS_9BIT_MODE_ENABLED())
346:                             {
347:                                 ((uint16_t*)pRdBuffer)[nBytesRead++] = ((uint16_t*)&UART1_ReadBuffer)[rdOutIndex++];
348:                             }
349:                             else
350:                             {
351:                                 pRdBuffer[nBytesRead++] = UART1_ReadBuffer[rdOutIndex++];
352:                             }
353:                 
354:                             if (rdOutIndex >= uart1Obj.rdBufferSize)
355:                             {
356:                                 rdOutIndex = 0;
357:                             }
358:                         }
359:                         else
360:                         {
361:                             /* No more data available in the RX buffer */
362:                             break;
363:                         }
364:                     }
365:                 
366:                     uart1Obj.rdOutIndex = rdOutIndex;
367:                 
368:                     return nBytesRead;
369:                 }
370:                 
371:                 size_t UART1_ReadCountGet(void)
372:                 {
373:                     size_t nUnreadBytesAvailable;
374:                     uint32_t rdInIndex;
375:                     uint32_t rdOutIndex;
376:                 
377:                     /* Take a snapshot of indices to avoid processing in critical section */
378:                     rdInIndex = uart1Obj.rdInIndex;
379:                     rdOutIndex = uart1Obj.rdOutIndex;
380:                 
381:                     if ( rdInIndex >=  rdOutIndex)
382:                     {
383:                         nUnreadBytesAvailable =  rdInIndex -  rdOutIndex;
384:                     }
385:                     else
386:                     {
387:                         nUnreadBytesAvailable =  (uart1Obj.rdBufferSize -  rdOutIndex) + rdInIndex;
388:                     }
389:                 
390:                     return nUnreadBytesAvailable;
391:                 }
392:                 
393:                 size_t UART1_ReadFreeBufferCountGet(void)
394:                 {
395:                     return (uart1Obj.rdBufferSize - 1) - UART1_ReadCountGet();
396:                 }
397:                 
398:                 size_t UART1_ReadBufferSizeGet(void)
399:                 {
400:                     return (uart1Obj.rdBufferSize - 1);
401:                 }
402:                 
403:                 bool UART1_ReadNotificationEnable(bool isEnabled, bool isPersistent)
404:                 {
405:                     bool previousStatus = uart1Obj.isRdNotificationEnabled;
406:                 
407:                     uart1Obj.isRdNotificationEnabled = isEnabled;
408:                 
409:                     uart1Obj.isRdNotifyPersistently = isPersistent;
410:                 
411:                     return previousStatus;
412:                 }
413:                 
414:                 void UART1_ReadThresholdSet(uint32_t nBytesThreshold)
415:                 {
416:                     if (nBytesThreshold > 0)
417:                     {
418:                         uart1Obj.rdThreshold = nBytesThreshold;
419:                     }
420:                 }
421:                 
422:                 void UART1_ReadCallbackRegister( UART_RING_BUFFER_CALLBACK callback, uintptr_t context)
423:                 {
424:                     uart1Obj.rdCallback = callback;
425:                 
426:                     uart1Obj.rdContext = context;
427:                 }
428:                 
429:                 /* This routine is only called from ISR. Hence do not disable/enable USART interrupts. */
430:                 static bool UART1_TxPullByte(uint16_t* pWrByte)
431:                 {
432:                     bool isSuccess = false;
433:                     uint32_t wrOutIndex = uart1Obj.wrOutIndex;
434:                     uint32_t wrInIndex = uart1Obj.wrInIndex;
435:                 
436:                     if (wrOutIndex != wrInIndex)
437:                     {
438:                         if (UART1_IS_9BIT_MODE_ENABLED())
439:                         {
440:                             *pWrByte = ((uint16_t*)&UART1_WriteBuffer)[wrOutIndex++];
441:                         }
442:                         else
443:                         {
444:                             *pWrByte = UART1_WriteBuffer[wrOutIndex++];
445:                         }
446:                 
447:                         if (wrOutIndex >= uart1Obj.wrBufferSize)
448:                         {
449:                             wrOutIndex = 0;
450:                         }
451:                 
452:                         uart1Obj.wrOutIndex = wrOutIndex;
453:                 
454:                         isSuccess = true;
455:                     }
456:                 
457:                     return isSuccess;
458:                 }
459:                 
460:                 static inline bool UART1_TxPushByte(uint16_t wrByte)
461:                 {
462:                     uint32_t tempInIndex;
463:                     bool isSuccess = false;
464:                 
465:                     uint32_t wrOutIndex = uart1Obj.wrOutIndex;
466:                     uint32_t wrInIndex = uart1Obj.wrInIndex;
467:                 
468:                     tempInIndex = wrInIndex + 1;
469:                 
470:                     if (tempInIndex >= uart1Obj.wrBufferSize)
471:                     {
472:                         tempInIndex = 0;
473:                     }
474:                     if (tempInIndex != wrOutIndex)
475:                     {
476:                         if (UART1_IS_9BIT_MODE_ENABLED())
477:                         {
478:                             ((uint16_t*)&UART1_WriteBuffer)[wrInIndex] = wrByte;
479:                         }
480:                         else
481:                         {
482:                             UART1_WriteBuffer[wrInIndex] = (uint8_t)wrByte;
483:                         }
484:                 
485:                         uart1Obj.wrInIndex = tempInIndex;
486:                 
487:                         isSuccess = true;
488:                     }
489:                     else
490:                     {
491:                         /* Queue is full. Report Error. */
492:                     }
493:                 
494:                     return isSuccess;
495:                 }
496:                 
497:                 /* This routine is only called from ISR. Hence do not disable/enable USART interrupts. */
498:                 static void UART1_WriteNotificationSend(void)
499:                 {
500:                     uint32_t nFreeWrBufferCount;
501:                 
502:                     if (uart1Obj.isWrNotificationEnabled == true)
503:                     {
504:                         nFreeWrBufferCount = UART1_WriteFreeBufferCountGet();
505:                 
506:                         if(uart1Obj.wrCallback != NULL)
507:                         {
508:                             if (uart1Obj.isWrNotifyPersistently == true)
509:                             {
510:                                 if (nFreeWrBufferCount >= uart1Obj.wrThreshold)
511:                                 {
512:                                     uart1Obj.wrCallback(UART_EVENT_WRITE_THRESHOLD_REACHED, uart1Obj.wrContext);
513:                                 }
514:                             }
515:                             else
516:                             {
517:                                 if (nFreeWrBufferCount == uart1Obj.wrThreshold)
518:                                 {
519:                                     uart1Obj.wrCallback(UART_EVENT_WRITE_THRESHOLD_REACHED, uart1Obj.wrContext);
520:                                 }
521:                             }
522:                         }
523:                     }
524:                 }
525:                 
526:                 static size_t UART1_WritePendingBytesGet(void)
527:                 {
528:                     size_t nPendingTxBytes;
529:                 
530:                     /* Take a snapshot of indices to avoid processing in critical section */
531:                 
532:                     uint32_t wrOutIndex = uart1Obj.wrOutIndex;
533:                     uint32_t wrInIndex = uart1Obj.wrInIndex;
534:                 
535:                     if ( wrInIndex >=  wrOutIndex)
536:                     {
537:                         nPendingTxBytes =  wrInIndex - wrOutIndex;
538:                     }
539:                     else
540:                     {
541:                         nPendingTxBytes =  (uart1Obj.wrBufferSize -  wrOutIndex) + wrInIndex;
542:                     }
543:                 
544:                     return nPendingTxBytes;
545:                 }
546:                 
547:                 size_t UART1_WriteCountGet(void)
548:                 {
549:                     size_t nPendingTxBytes;
550:                 
551:                     nPendingTxBytes = UART1_WritePendingBytesGet();
552:                 
553:                     return nPendingTxBytes;
554:                 }
555:                 
556:                 size_t UART1_Write(uint8_t* pWrBuffer, const size_t size )
557:                 {
558:                     size_t nBytesWritten  = 0;
559:                 
560:                     while (nBytesWritten < size)
561:                     {
562:                         if (UART1_IS_9BIT_MODE_ENABLED())
563:                         {
564:                             if (UART1_TxPushByte(((uint16_t*)pWrBuffer)[nBytesWritten]) == true)
565:                             {
566:                                 nBytesWritten++;
567:                             }
568:                             else
569:                             {
570:                                 /* Queue is full, exit the loop */
571:                                 break;
572:                             }
573:                         }
574:                         else
575:                         {
576:                             if (UART1_TxPushByte(pWrBuffer[nBytesWritten]) == true)
577:                             {
578:                                 nBytesWritten++;
579:                             }
580:                             else
581:                             {
582:                                 /* Queue is full, exit the loop */
583:                                 break;
584:                             }
585:                         }
586:                 
587:                     }
588:                 
589:                     /* Check if any data is pending for transmission */
590:                     if (UART1_WritePendingBytesGet() > 0)
591:                     {
592:                         /* Enable TX interrupt as data is pending for transmission */
593:                         UART1_TX_INT_ENABLE();
594:                     }
595:                 
596:                     return nBytesWritten;
597:                 }
598:                 
599:                 size_t UART1_WriteFreeBufferCountGet(void)
600:                 {
601:                     return (uart1Obj.wrBufferSize - 1) - UART1_WriteCountGet();
602:                 }
603:                 
604:                 size_t UART1_WriteBufferSizeGet(void)
605:                 {
606:                     return (uart1Obj.wrBufferSize - 1);
607:                 }
608:                 
609:                 bool UART1_TransmitComplete(void)
610:                 {
611:                     if((U1STA & _U1STA_TRMT_MASK))
612:                     {
613:                         return true;
614:                     }
615:                     else
616:                     {
617:                         return false;
618:                     }
619:                 }
620:                 
621:                 bool UART1_WriteNotificationEnable(bool isEnabled, bool isPersistent)
622:                 {
623:                     bool previousStatus = uart1Obj.isWrNotificationEnabled;
624:                 
625:                     uart1Obj.isWrNotificationEnabled = isEnabled;
626:                 
627:                     uart1Obj.isWrNotifyPersistently = isPersistent;
628:                 
629:                     return previousStatus;
630:                 }
631:                 
632:                 void UART1_WriteThresholdSet(uint32_t nBytesThreshold)
633:                 {
634:                     if (nBytesThreshold > 0)
635:                     {
636:                         uart1Obj.wrThreshold = nBytesThreshold;
637:                     }
638:                 }
639:                 
640:                 void UART1_WriteCallbackRegister( UART_RING_BUFFER_CALLBACK callback, uintptr_t context)
641:                 {
642:                     uart1Obj.wrCallback = callback;
643:                 
644:                     uart1Obj.wrContext = context;
645:                 }
646:                 
647:                 UART_ERROR UART1_ErrorGet( void )
648:                 {
649:                     UART_ERROR errors = uart1Obj.errors;
650:                 
651:                     uart1Obj.errors = UART_ERROR_NONE;
652:                 
653:                     /* All errors are cleared, but send the previous error state */
654:                     return errors;
655:                 }
656:                 
657:                 bool UART1_AutoBaudQuery( void )
658:                 {
659:                     if(U1MODE & _U1MODE_ABAUD_MASK)
660:                         return true;
661:                     else
662:                         return false;
663:                 }
664:                 
665:                 void UART1_AutoBaudSet( bool enable )
666:                 {
667:                     if( enable == true )
668:                     {
669:                         U1MODESET = _U1MODE_ABAUD_MASK;
670:                     }
671:                 
672:                     /* Turning off ABAUD if it was on can lead to unpredictable behavior, so that
673:                        direction of control is not allowed in this function.                      */
674:                 }
675:                 
676:                 static void UART1_FAULT_InterruptHandler (void)
677:                 {
678:                     /* Save the error to be reported later */
679:                     uart1Obj.errors = (UART_ERROR)(U1STA & (_U1STA_OERR_MASK | _U1STA_FERR_MASK | _U1STA_PERR_MASK));
680:                 
681:                     UART1_ErrorClear();
682:                 
683:                     /* Client must call UARTx_ErrorGet() function to clear the errors */
684:                     if( uart1Obj.rdCallback != NULL )
685:                     {
686:                         uart1Obj.rdCallback(UART_EVENT_READ_ERROR, uart1Obj.rdContext);
687:                     }
688:                 }
689:                 
690:                 static void UART1_RX_InterruptHandler (void)
691:                 {
692:                     /* Keep reading until there is a character availabe in the RX FIFO */
693:                     while((U1STA & _U1STA_URXDA_MASK) == _U1STA_URXDA_MASK)
694:                     {
695:                         if (UART1_RxPushByte(  (uint16_t )(U1RXREG) ) == true)
696:                         {
697:                             UART1_ReadNotificationSend();
698:                         }
699:                         else
700:                         {
701:                             /* UART RX buffer is full */
702:                         }
703:                     }
704:                 
705:                     /* Clear UART1 RX Interrupt flag */
706:                     IFS1CLR = _IFS1_U1RXIF_MASK;
707:                 }
708:                 
709:                 static void UART1_TX_InterruptHandler (void)
710:                 {
711:                     uint16_t wrByte;
712:                 
713:                     /* Check if any data is pending for transmission */
714:                     if (UART1_WritePendingBytesGet() > 0)
715:                     {
716:                         /* Keep writing to the TX FIFO as long as there is space */
717:                         while(!(U1STA & _U1STA_UTXBF_MASK))
718:                         {
719:                             if (UART1_TxPullByte(&wrByte) == true)
720:                             {
721:                                 if (UART1_IS_9BIT_MODE_ENABLED())
722:                                 {
723:                                     U1TXREG = wrByte;
724:                                 }
725:                                 else
726:                                 {
727:                                     U1TXREG = (uint8_t)wrByte;
728:                                 }
729:                 
730:                                 /* Send notification */
731:                                 UART1_WriteNotificationSend();
732:                             }
733:                             else
734:                             {
735:                                 /* Nothing to transmit. Disable the data register empty interrupt. */
736:                                 UART1_TX_INT_DISABLE();
737:                                 break;
738:                             }
739:                         }
740:                 
741:                         /* Clear UART1TX Interrupt flag */
742:                         IFS1CLR = _IFS1_U1TXIF_MASK;
743:                 
744:                     }
745:                     else
746:                     {
747:                         /* Nothing to transmit. Disable the data register empty interrupt. */
748:                         UART1_TX_INT_DISABLE();
749:                     }
750:                 }
751:                 
752:                 void UART_1_InterruptHandler (void)
753:                 {
754:                     /* Call Error handler if Error interrupt flag is set */
755:                     if ((IFS1 & _IFS1_U1EIF_MASK) && (IEC1 & _IEC1_U1EIE_MASK))
756:                     {
757:                         UART1_FAULT_InterruptHandler();
758:                     }
759:                     /* Call RX handler if RX interrupt flag is set */
760:                     if ((IFS1 & _IFS1_U1RXIF_MASK) && (IEC1 & _IEC1_U1RXIE_MASK))
761:                     {
762:                         UART1_RX_InterruptHandler();
763:                     }
764:                     /* Call TX handler if TX interrupt flag is set */
765:                     if ((IFS1 & _IFS1_U1TXIF_MASK) && (IEC1 & _IEC1_U1TXIE_MASK))
766:                     {
767:                         UART1_TX_InterruptHandler();
768:                     }
769:                 
770:                 }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
00000024  00000000   NOP
00000028  00000000   NOP
0000002C  00000000   NOP
00000030  00000000   NOP
00000034  00000000   NOP
00000038  00000000   NOP
00000040  00000000   NOP
00000044  00000000   NOP
00000048  00000000   NOP
0000004C  00000000   NOP
00000058  00000000   NOP
0000005C  00000000   NOP
00000060  00000000   NOP
00000064  00000000   NOP
00000068  00000000   NOP
0000006C  00000000   NOP
00000074  00000000   NOP
00000078  00000000   NOP
0000007C  00000000   NOP
00000080  00000000   NOP
00000084  00000000   NOP
00000088  00000000   NOP
0000008C  00000000   NOP
00000090  00000000   NOP
00000094  00000000   NOP
00000098  00000000   NOP
0000009C  00000000   NOP
000000A0  00000000   NOP
000000A4  00000000   NOP
000000AC  00000000   NOP
000000B4  00000000   NOP
000000C0  00000000   NOP
000000C4  00000000   NOP
000000CC  00000000   NOP
000000D0  00000000   NOP
000000D4  00000000   NOP
000000DC  00000000   NOP
000000E4  00000000   NOP
000000EC  00000000   NOP
000000F0  00000000   NOP
000000F4  00000000   NOP
00000100  00000000   NOP
00000110  00000000   NOP
9D000228  3C03A000   LUI V1, -24576
9D00022C  24630508   ADDIU V1, V1, 1288
9D000230  8C62003C   LW V0, 60(V1)
9D000234  AC60003C   SW ZERO, 60(V1)
9D000238  03E00008   JR RA
9D00023C  00000000   NOP
9D00271C  27BDFFD0   ADDIU SP, SP, -48
9D002720  AFB2001C   SW S2, 28(SP)
9D002724  3C12BF88   LUI S2, -16504
9D002728  8E421040   LW V0, 4160(S2)
9D00272C  AFBF002C   SW RA, 44(SP)
9D002730  AFB50028   SW S5, 40(SP)
9D002734  30420080   ANDI V0, V0, 128
9D002738  AFB40024   SW S4, 36(SP)
9D00273C  AFB30020   SW S3, 32(SP)
9D002740  AFB10018   SW S1, 24(SP)
9D002744  10400005   BEQ V0, ZERO, 0x9D00275C
9D002748  AFB00014   SW S0, 20(SP)
9D00274C  8E421070   LW V0, 4208(S2)
9D002750  30420080   ANDI V0, V0, 128
9D002754  1440005C   BNE V0, ZERO, UART_1_InterruptHandler::UART1_FAULT_InterruptHandler
9D002758  3C11BF80   LUI S1, -16512
9D00275C  8E421040   LW V0, 4160(S2)
9D002760  30420100   ANDI V0, V0, 256
9D002764  10400005   BEQ V0, ZERO, 0x9D00277C
9D002768  00000000   NOP
9D00276C  8E421070   LW V0, 4208(S2)
9D002770  30420100   ANDI V0, V0, 256
9D002774  54400074   BNEL V0, ZERO, UART_1_InterruptHandler::UART1_RX_InterruptHandler
9D002778  3C10A000   LUI S0, -24576
9D00277C  8E421040   LW V0, 4160(S2)
9D002780  30420200   ANDI V0, V0, 512
9D002784  10400005   BEQ V0, ZERO, 0x9D00279C
9D002788  8FBF002C   LW RA, 44(SP)
9D00278C  8E421070   LW V0, 4208(S2)
9D002790  30420200   ANDI V0, V0, 512
9D002794  14400009   BNE V0, ZERO, UART_1_InterruptHandler::UART1_TX_InterruptHandler
9D002798  3C14A000   LUI S4, -24576
9D00279C  8FB50028   LW S5, 40(SP)
9D0027A0  8FB40024   LW S4, 36(SP)
9D0027A4  8FB30020   LW S3, 32(SP)
9D0027A8  8FB2001C   LW S2, 28(SP)
9D0027AC  8FB10018   LW S1, 24(SP)
9D0027B0  8FB00014   LW S0, 20(SP)
9D0027B4  03E00008   JR RA
9D0027B8  27BD0030   ADDIU SP, SP, 48
9D0027BC  26900508   ADDIU S0, S4, 1288
9D0027C4  8E030008   LW V1, 8(S0)
9D0027C8  0062202B   SLTU A0, V1, V0
9D0027D4  8E040018   LW A0, 24(S0)
9D0027DC  00621023   SUBU V0, V1, V0
9D0027E0  104000AC   BEQ V0, ZERO, UART_1_InterruptHandler::UART1_TX_InterruptHandler
9D0027E4  24020200   ADDIU V0, ZERO, 512
9D0027E8  3C15A000   LUI S5, -24576
9D0027EC  3C11BF80   LUI S1, -16512
9D0027F0  24130006   ADDIU S3, ZERO, 6
9D0027F4  26B50374   ADDIU S5, S5, 884
9D0027F8  8E226010   LW V0, 24592(S1)
9D0027FC  30420200   ANDI V0, V0, 512
9D002800  1440002E   BNE V0, ZERO, 0x9D0028BC
9D002804  24020200   ADDIU V0, ZERO, 512
9D002808  8E02000C   LW V0, 12(S0)
9D00280C  8E030008   LW V1, 8(S0)
9D002810  50430090   BEQL V0, V1, UART_1_InterruptHandler::UART1_TX_InterruptHandler
9D002814  24020200   ADDIU V0, ZERO, 512
9D002818  8E246000   LW A0, 24576(S1)
9D00281C  30840006   ANDI A0, A0, 6
9D002820  10930094   BEQ A0, S3, UART_1_InterruptHandler::UART1_TX_InterruptHandler
9D002824  24430001   ADDIU V1, V0, 1
9D002828  00551021   ADDU V0, V0, S5
9D00282C  90440000   LBU A0, 0(V0)
9D002830  8E020018   LW V0, 24(S0)
9D002834  0062282B   SLTU A1, V1, V0
9D002838  0005180A   MOVZ V1, ZERO, A1
9D00283C  AE03000C   SW V1, 12(S0)
9D002840  8E236000   LW V1, 24576(S1)
9D002844  30630006   ANDI V1, V1, 6
9D002848  54730001   BNEL V1, S3, UART1_WriteNotificationSend
9D00284C  308400FF   ANDI A0, A0, 255
9D002850  92030014   LBU V1, 20(S0)
9D002854  AE246020   SW A0, 24608(S1)
9D002858  1060FFE7   BEQ V1, ZERO, 0x9D0027F8
9D00285C  00000000   NOP
9D002860  8E03000C   LW V1, 12(S0)
9D002864  8E040008   LW A0, 8(S0)
9D002868  0083282B   SLTU A1, A0, V1
9D00286C  54A00001   BNEL A1, ZERO, 0x9D002874
9D002870  00442021   ADDU A0, V0, A0
9D002874  8E860508   LW A2, 1288(S4)
9D002878  10C0FFDF   BEQ A2, ZERO, 0x9D0027F8
9D00287C  00831823   SUBU V1, A0, V1
9D002880  92040015   LBU A0, 21(S0)
9D002884  2442FFFF   ADDIU V0, V0, -1
9D002888  00431023   SUBU V0, V0, V1
9D00288C  1080007D   BEQ A0, ZERO, UART_1_InterruptHandler::UART1_TX_InterruptHandler
9D002890  8E030010   LW V1, 16(S0)
9D002894  0043102B   SLTU V0, V0, V1
9D002898  1440FFD7   BNE V0, ZERO, 0x9D0027F8
9D00289C  00000000   NOP
9D0028A0  8E050004   LW A1, 4(S0)
9D0028A4  00C0F809   JALR A2
9D0028A8  24040003   ADDIU A0, ZERO, 3
9D0028AC  8E226010   LW V0, 24592(S1)
9D0028B0  30420200   ANDI V0, V0, 512
9D0028B4  1040FFD4   BEQ V0, ZERO, UART1_TxPullByte
9D0028B8  24020200   ADDIU V0, ZERO, 512
9D0028BC  AE421044   SW V0, 4164(S2)
9D0028C0  1000FFB6   BEQ ZERO, ZERO, 0x9D00279C
9D0028C4  8FBF002C   LW RA, 44(SP)
9D0028C8  8E226010   LW V0, 24592(S1)
9D0028CC  3C14A000   LUI S4, -24576
9D0028D4  3042000E   ANDI V0, V0, 14
9D0028D8  AE02003C   SW V0, 60(S0)
9D0028DC  8E226010   LW V0, 24592(S1)
9D0028E0  3042000E   ANDI V0, V0, 14
9D0028E4  50400011   BEQL V0, ZERO, 0x9D00292C
9D0028EC  8E226010   LW V0, 24592(S1)
9D0028F0  30420002   ANDI V0, V0, 2
9D0028F4  10400005   BEQ V0, ZERO, 0x9D00290C
9D0028FC  AE226014   SW V0, 24596(S1)
9D002908  8E226030   LW V0, 24624(S1)
9D00290C  8E226010   LW V0, 24592(S1)
9D002914  1440FFFC   BNE V0, ZERO, 0x9D002908
9D00291C  AE421044   SW V0, 4164(S2)
9D002920  24020100   ADDIU V0, ZERO, 256
9D002928  8E02001C   LW V0, 28(S0)
9D00292C  1040FF8B   BEQ V0, ZERO, 0x9D00275C
9D002934  8E050020   LW A1, 32(S0)
9D002948  3C14A000   LUI S4, -24576
9D00294C  3C11BF80   LUI S1, -16512
9D002950  26100508   ADDIU S0, S0, 1288
9D002954  26942D4C   ADDIU S4, S4, 11596
9D002958  8E226010   LW V0, 24592(S1)
9D00295C  30420001   ANDI V0, V0, 1
9D002960  10400041   BEQ V0, ZERO, UART_1_InterruptHandler::UART1_RX_InterruptHandler
9D002964  24020100   ADDIU V0, ZERO, 256
9D002968  8E336030   LW S3, 24624(S1)
9D00296C  8E020024   LW V0, 36(S0)
9D002970  8E03002C   LW V1, 44(S0)
9D002974  8E040028   LW A0, 40(S0)
9D002978  24420001   ADDIU V0, V0, 1
9D00297C  0043182B   SLTU V1, V0, V1
9D002980  0003100A   MOVZ V0, ZERO, V1
9D002984  50820023   BEQL A0, V0, UART_1_InterruptHandler::UART1_RX_InterruptHandler::UART1_RxPushByte
9D002988  8E03001C   LW V1, 28(S0)
9D00298C  8E030028   LW V1, 40(S0)
9D002990  1062FFF1   BEQ V1, V0, 0x9D002958
9D002994  00000000   NOP
9D002998  8E236000   LW V1, 24576(S1)
9D00299C  24040006   ADDIU A0, ZERO, 6
9D0029A0  30630006   ANDI V1, V1, 6
9D0029A4  10640026   BEQ V1, A0, UART_1_InterruptHandler::UART1_RX_InterruptHandler
9D0029A8  00000000   NOP
9D0029AC  8E030024   LW V1, 36(S0)
9D0029B0  00741821   ADDU V1, V1, S4
9D0029B4  A0730000   SB S3, 0(V1)
9D0029B8  92030030   LBU V1, 48(S0)
9D0029BC  AE020024   SW V0, 36(S0)
9D0029C0  1060FFE5   BEQ V1, ZERO, 0x9D002958
9D0029C4  00000000   NOP
9D0029C8  8E030024   LW V1, 36(S0)
9D0029CC  8E020028   LW V0, 40(S0)
9D0029D0  0062202B   SLTU A0, V1, V0
9D0029D4  54800032   BNEL A0, ZERO, 0x9D002AA0
9D0029D8  8E04002C   LW A0, 44(S0)
9D0029DC  00621023   SUBU V0, V1, V0
9D0029E0  8E03001C   LW V1, 28(S0)
9D0029E4  1060FFDC   BEQ V1, ZERO, 0x9D002958
9D0029E8  00000000   NOP
9D0029EC  92050038   LBU A1, 56(S0)
9D0029F0  14A0002D   BNE A1, ZERO, UART_1_InterruptHandler::UART1_RX_InterruptHandler
9D0029F4  8E040034   LW A0, 52(S0)
9D0029F8  1444FFD7   BNE V0, A0, 0x9D002958
9D0029FC  00000000   NOP
9D002A00  8E050020   LW A1, 32(S0)
9D002A04  0060F809   JALR V1
9D002A08  00002025   OR A0, ZERO, ZERO
9D002A0C  1000FFD2   BEQ ZERO, ZERO, 0x9D002958
9D002A10  00000000   NOP
9D002A14  1060FFDD   BEQ V1, ZERO, 0x9D00298C
9D002A18  00000000   NOP
9D002A1C  8E050020   LW A1, 32(S0)
9D002A20  0060F809   JALR V1
9D002A24  24040001   ADDIU A0, ZERO, 1
9D002A28  8E020024   LW V0, 36(S0)
9D002A2C  8E03002C   LW V1, 44(S0)
9D002A30  24420001   ADDIU V0, V0, 1
9D002A34  0043182B   SLTU V1, V0, V1
9D002A38  1000FFD4   BEQ ZERO, ZERO, 0x9D00298C
9D002A3C  0003100A   MOVZ V0, ZERO, V1
9D002A40  8E030024   LW V1, 36(S0)
9D002A44  00031840   SLL V1, V1, 1
9D002A48  02831821   ADDU V1, S4, V1
9D002A4C  1000FFDA   BEQ ZERO, ZERO, UART_1_InterruptHandler::UART1_RX_InterruptHandler::UART1_ReadNotificationSend
9D002A50  A4730000   SH S3, 0(V1)
9D002A54  AE421074   SW V0, 4212(S2)
9D002A58  24020200   ADDIU V0, ZERO, 512
9D002A5C  AE421044   SW V0, 4164(S2)
9D002A60  1000FF4E   BEQ ZERO, ZERO, 0x9D00279C
9D002A64  8FBF002C   LW RA, 44(SP)
9D002A68  AE421044   SW V0, 4164(S2)
9D002A6C  1000FF43   BEQ ZERO, ZERO, 0x9D00277C
9D002A70  00000000   NOP
9D002A74  00021040   SLL V0, V0, 1
9D002A78  02A21021   ADDU V0, S5, V0
9D002A7C  1000FF6C   BEQ ZERO, ZERO, 0x9D002830
9D002A80  94440000   LHU A0, 0(V0)
9D002A84  1462FF5C   BNE V1, V0, 0x9D0027F8
9D002A88  00000000   NOP
9D002A8C  1000FF85   BEQ ZERO, ZERO, 0x9D0028A4
9D002A90  8E050004   LW A1, 4(S0)
9D002A94  AE421074   SW V0, 4212(S2)
9D002A98  1000FF40   BEQ ZERO, ZERO, 0x9D00279C
9D002A9C  8FBF002C   LW RA, 44(SP)
9D002AA0  1000FFCE   BEQ ZERO, ZERO, 0x9D0029DC
9D002AA4  00641821   ADDU V1, V1, A0
9D002AA8  0044102B   SLTU V0, V0, A0
9D002AAC  1440FFAA   BNE V0, ZERO, 0x9D002958
9D002AB0  00000000   NOP
9D002AB4  1000FFD3   BEQ ZERO, ZERO, 0x9D002A04
9D002AB8  8E050020   LW A1, 32(S0)
9D005C00  10A0003E   BEQ A1, ZERO, 0x9D005CFC
9D005C04  3C03A000   LUI V1, -24576
9D005C08  24630508   ADDIU V1, V1, 1288
9D005C0C  8C6C0018   LW T4, 24(V1)
9D005C10  3C0AA000   LUI T2, -24576
9D005C14  00001025   OR V0, ZERO, ZERO
9D005C18  3C09BF80   LUI T1, -16512
9D005C1C  24080006   ADDIU T0, ZERO, 6
9D005C20  254A0374   ADDIU T2, T2, 884
9D005C24  8D266000   LW A2, 24576(T1)
9D005C28  8C6B000C   LW T3, 12(V1)
9D005C2C  8C670008   LW A3, 8(V1)
9D005C30  30C60006   ANDI A2, A2, 6
9D005C34  10C8001D   BEQ A2, T0, UART1_Write::UART1_TxPushByte
9D005C38  24E60001   ADDIU A2, A3, 1
9D005C3C  00CC682B   SLTU T5, A2, T4
9D005C40  000D300A   MOVZ A2, ZERO, T5
9D005C44  1166000D   BEQ T3, A2, UART1_Write::UART1_WritePendingBytesGet
9D005C48  00000000   NOP
9D005C4C  8D2B6000   LW T3, 24576(T1)
9D005C50  00826821   ADDU T5, A0, V0
9D005C54  316B0006   ANDI T3, T3, 6
9D005C58  1168001E   BEQ T3, T0, UART1_Write::UART1_TxPushByte
9D005C5C  91AD0000   LBU T5, 0(T5)
9D005C60  00EA3821   ADDU A3, A3, T2
9D005C64  A0ED0000   SB T5, 0(A3)
9D005C68  24420001   ADDIU V0, V0, 1
9D005C6C  AC660008   SW A2, 8(V1)
9D005C70  0045302B   SLTU A2, V0, A1
9D005C74  14C0FFEB   BNE A2, ZERO, 0x9D005C24
9D005C78  00000000   NOP
9D005C7C  8C64000C   LW A0, 12(V1)
9D005C80  8C650008   LW A1, 8(V1)
9D005C84  00A4302B   SLTU A2, A1, A0
9D005C88  54C00016   BNEL A2, ZERO, UART1_Write::UART1_WritePendingBytesGet
9D005C8C  8C630018   LW V1, 24(V1)
9D005C90  00A42023   SUBU A0, A1, A0
9D005C94  10800003   BEQ A0, ZERO, 0x9D005CA4
9D005C98  3C03BF88   LUI V1, -16504
9D005C9C  24040200   ADDIU A0, ZERO, 512
9D005CA0  AC641078   SW A0, 4216(V1)
9D005CA4  03E00008   JR RA
9D005CA8  00000000   NOP
9D005CAC  00CC682B   SLTU T5, A2, T4
9D005CB0  000D300A   MOVZ A2, ZERO, T5
9D005CB4  1166FFF1   BEQ T3, A2, UART1_Write::UART1_WritePendingBytesGet
9D005CB8  00000000   NOP
9D005CBC  8D2B6000   LW T3, 24576(T1)
9D005CC0  00026840   SLL T5, V0, 1
9D005CC4  008D6821   ADDU T5, A0, T5
9D005CC8  316B0006   ANDI T3, T3, 6
9D005CCC  1568FFE4   BNE T3, T0, 0x9D005C60
9D005CD0  95AD0000   LHU T5, 0(T5)
9D005CD4  00073840   SLL A3, A3, 1
9D005CD8  01473821   ADDU A3, T2, A3
9D005CDC  1000FFE2   BEQ ZERO, ZERO, 0x9D005C68
9D005CE0  A4ED0000   SH T5, 0(A3)
9D005CE4  00A32821   ADDU A1, A1, V1
9D005CE8  00A42023   SUBU A0, A1, A0
9D005CEC  1080FFED   BEQ A0, ZERO, 0x9D005CA4
9D005CF0  3C03BF88   LUI V1, -16504
9D005CF4  1000FFEA   BEQ ZERO, ZERO, 0x9D005CA0
9D005CF8  24040200   ADDIU A0, ZERO, 512
9D005CFC  00001025   OR V0, ZERO, ZERO
9D005D00  1000FFDE   BEQ ZERO, ZERO, UART1_Write::UART1_WritePendingBytesGet
9D005D04  24630508   ADDIU V1, V1, 1288
9D006354  3C09A000   LUI T1, -24576
9D006358  25290508   ADDIU T1, T1, 1288
9D00635C  00A01025   OR V0, A1, ZERO
9D006360  8D230028   LW V1, 40(T1)
9D006364  8D250024   LW A1, 36(T1)
9D006368  50400025   BEQL V0, ZERO, 0x9D006400
9D00636C  00602825   OR A1, V1, ZERO
9D006370  50650023   BEQL V1, A1, 0x9D006400
9D006374  00001025   OR V0, ZERO, ZERO
9D006378  3C0CA000   LUI T4, -24576
9D00637C  00003025   OR A2, ZERO, ZERO
9D006380  3C0EBF80   LUI T6, -16512
9D006384  258C2D4C   ADDIU T4, T4, 11596
9D006388  1000000A   BEQ ZERO, ZERO, 0x9D0063B4
9D00638C  240D0006   ADDIU T5, ZERO, 6
9D006390  91630000   LBU V1, 0(T3)
9D006394  A143FFFF   SB V1, -1(T2)
9D006398  8D23002C   LW V1, 44(T1)
9D00639C  0103182B   SLTU V1, T0, V1
9D0063A0  0003400A   MOVZ T0, ZERO, V1
9D0063A4  10C20015   BEQ A2, V0, 0x9D0063FC
9D0063A8  01001825   OR V1, T0, ZERO
9D0063AC  50650017   BEQL V1, A1, 0x9D00640C
9D0063B0  00C01025   OR V0, A2, ZERO
9D0063B4  8DC76000   LW A3, 24576(T6)
9D0063B8  24C60001   ADDIU A2, A2, 1
9D0063BC  01835821   ADDU T3, T4, V1
9D0063C0  30E70006   ANDI A3, A3, 6
9D0063C4  00865021   ADDU T2, A0, A2
9D0063C8  14EDFFF1   BNE A3, T5, 0x9D006390
9D0063CC  24680001   ADDIU T0, V1, 1
9D0063D0  00031840   SLL V1, V1, 1
9D0063D4  01831821   ADDU V1, T4, V1
9D0063D8  94670000   LHU A3, 0(V1)
9D0063DC  00061840   SLL V1, A2, 1
9D0063E0  00831821   ADDU V1, A0, V1
9D0063E4  A467FFFE   SH A3, -2(V1)
9D0063E8  8D23002C   LW V1, 44(T1)
9D0063EC  0103182B   SLTU V1, T0, V1
9D0063F0  0003400A   MOVZ T0, ZERO, V1
9D0063F4  14C2FFED   BNE A2, V0, 0x9D0063AC
9D0063F8  01001825   OR V1, T0, ZERO
9D0063FC  01002825   OR A1, T0, ZERO
9D006400  AD250028   SW A1, 40(T1)
9D006404  03E00008   JR RA
9D006408  00000000   NOP
9D00640C  AD250028   SW A1, 40(T1)
9D006410  03E00008   JR RA
9D006414  00000000   NOP
9D006418  1000FFF9   BEQ ZERO, ZERO, 0x9D006400
9D00641C  00001025   OR V0, ZERO, ZERO
9D0065B8  3C03BF80   LUI V1, -16512
9D0065BC  24050008   ADDIU A1, ZERO, 8
9D0065C0  AC656000   SW A1, 24576(V1)
9D0065C4  34059400   ORI A1, ZERO, -27648
9D0065C8  AC656018   SW A1, 24600(V1)
9D0065CC  3C06A000   LUI A2, -24576
9D0065D0  2405009B   ADDIU A1, ZERO, 155
9D0065D4  24C20508   ADDIU V0, A2, 1288
9D0065D8  AC656040   SW A1, 24640(V1)
9D0065DC  3C04BF88   LUI A0, -16504
9D0065E0  24050200   ADDIU A1, ZERO, 512
9D0065E4  AC851074   SW A1, 4212(A0)
9D0065E8  AC400024   SW ZERO, 36(V0)
9D0065EC  AC400028   SW ZERO, 40(V0)
9D0065F0  AC400008   SW ZERO, 8(V0)
9D0065F4  AC40000C   SW ZERO, 12(V0)
9D0065F8  AC40003C   SW ZERO, 60(V0)
9D0065FC  8C656000   LW A1, 24576(V1)
9D006600  24070006   ADDIU A3, ZERO, 6
9D006604  AC40001C   SW ZERO, 28(V0)
9D006608  30A50006   ANDI A1, A1, 6
9D00660C  A0400030   SB ZERO, 48(V0)
9D006610  A0400038   SB ZERO, 56(V0)
9D006614  AC400034   SW ZERO, 52(V0)
9D006618  ACC00508   SW ZERO, 1288(A2)
9D00661C  AC400010   SW ZERO, 16(V0)
9D006620  10A7000C   BEQ A1, A3, 0x9D006654
9D006624  A4400014   SH ZERO, 20(V0)
9D006628  24050080   ADDIU A1, ZERO, 128
9D00662C  AC45002C   SW A1, 44(V0)
9D006630  AC450018   SW A1, 24(V0)
9D006634  34028000   ORI V0, ZERO, -32768
9D006638  AC626008   SW V0, 24584(V1)
9D00663C  24020080   ADDIU V0, ZERO, 128
9D006640  AC821078   SW V0, 4216(A0)
9D006644  24020100   ADDIU V0, ZERO, 256
9D006648  AC821078   SW V0, 4216(A0)
9D00664C  03E00008   JR RA
9D006650  00000000   NOP
9D006654  24050040   ADDIU A1, ZERO, 64
9D006658  AC45002C   SW A1, 44(V0)
9D00665C  AC450018   SW A1, 24(V0)
9D006660  34028000   ORI V0, ZERO, -32768
9D006664  AC626008   SW V0, 24584(V1)
9D006668  24020080   ADDIU V0, ZERO, 128
9D00666C  AC821078   SW V0, 4216(A0)
9D006670  24020100   ADDIU V0, ZERO, 256
9D006674  AC821078   SW V0, 4216(A0)
9D006678  03E00008   JR RA
9D00667C  00000000   NOP
9D00804C  3C03A000   LUI V1, -24576
9D008050  24630508   ADDIU V1, V1, 1288
9D008054  8C62000C   LW V0, 12(V1)
9D008058  8C640008   LW A0, 8(V1)
9D00805C  0082282B   SLTU A1, A0, V0
9D008068  00642021   ADDU A0, V1, A0
9D00806C  00821023   SUBU V0, A0, V0
9D008070  2463FFFF   ADDIU V1, V1, -1
9D008074  03E00008   JR RA
9D008078  00621023   SUBU V0, V1, V0
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/peripheral/spi/spi_master/plib_spi1_master.c
1:                   /*******************************************************************************
2:                     SPI PLIB
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_spi1_master.c
9:                   
10:                    Summary:
11:                      SPI1 Master Source File
12:                  
13:                    Description:
14:                      This file has implementation of all the interfaces provided for particular
15:                      SPI peripheral.
16:                  
17:                  *******************************************************************************/
18:                  
19:                  /*******************************************************************************
20:                  * Copyright (C) 2018-2019 Microchip Technology Inc. and its subsidiaries.
21:                  *
22:                  * Subject to your compliance with these terms, you may use Microchip software
23:                  * and any derivatives exclusively with Microchip products. It is your
24:                  * responsibility to comply with third party license terms applicable to your
25:                  * use of third party software (including open source software) that may
26:                  * accompany Microchip software.
27:                  *
28:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                  * PARTICULAR PURPOSE.
32:                  *
33:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                  *******************************************************************************/
41:                  
42:                  #include "plib_spi1_master.h"
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Section: SPI1 Implementation
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  
50:                  
51:                  #define SPI1_CON_MSTEN                      (1 << _SPI1CON_MSTEN_POSITION)
52:                  #define SPI1_CON_CKP                        (1 << _SPI1CON_CKP_POSITION)
53:                  #define SPI1_CON_CKE                        (0 << _SPI1CON_CKE_POSITION)
54:                  #define SPI1_CON_MODE_32_MODE_16            (0 << _SPI1CON_MODE16_POSITION)
55:                  #define SPI1_CON_ENHBUF                     (1 << _SPI1CON_ENHBUF_POSITION)
56:                  #define SPI1_CON_MCLKSEL                    (0 << _SPI1CON_MCLKSEL_POSITION)
57:                  #define SPI1_CON_MSSEN                      (0 << _SPI1CON_MSSEN_POSITION)
58:                  #define SPI1_CON_SMP                        (0 << _SPI1CON_SMP_POSITION)
59:                  
60:                  void SPI1_Initialize ( void )
61:                  {
62:                      uint32_t rdata = 0U;
63:                  
64:                      /* Disable SPI1 Interrupts */
65:                      IEC1CLR = 0x10;
66:                      IEC1CLR = 0x20;
67:                      IEC1CLR = 0x40;
68:                  
69:                      /* STOP and Reset the SPI */
70:                      SPI1CON = 0;
71:                  
72:                      /* Clear the Receiver buffer */
73:                      rdata = SPI1BUF;
74:                      rdata = rdata;
75:                  
76:                      /* Clear SPI1 Interrupt flags */
77:                      IFS1CLR = 0x10;
78:                      IFS1CLR = 0x20;
79:                      IFS1CLR = 0x40;
80:                  
81:                      /* BAUD Rate register Setup */
82:                      SPI1BRG = 3;
83:                  
84:                      /* CLear the Overflow */
85:                      SPI1STATCLR = _SPI1STAT_SPIROV_MASK;
86:                  
87:                      /*
88:                      MSTEN = 1
89:                      CKP = 1
90:                      CKE = 0
91:                      MODE<32,16> = 0
92:                      ENHBUF = 1
93:                      MSSEN = 0
94:                      MCLKSEL = 0
95:                      */
96:                      SPI1CONSET = (SPI1_CON_MSSEN | SPI1_CON_MCLKSEL | SPI1_CON_ENHBUF | SPI1_CON_MODE_32_MODE_16 | SPI1_CON_CKE | SPI1_CON_CKP | SPI1_CON_MSTEN | SPI1_CON_SMP);
97:                  
98:                      /* Enable transmit interrupt when transmit buffer is completely empty (STXISEL = '01') */
99:                      /* Enable receive interrupt when the receive buffer is not empty (SRXISEL = '01') */
100:                     SPI1CONSET = 0x00000005;
101:                 
102:                 
103:                     /* Enable SPI1 */
104:                     SPI1CONSET = _SPI1CON_ON_MASK;
105:                 }
106:                 
107:                 bool SPI1_TransferSetup (SPI_TRANSFER_SETUP* setup, uint32_t spiSourceClock )
108:                 {
109:                     uint32_t t_brg;
110:                     uint32_t baudHigh;
111:                     uint32_t baudLow;
112:                     uint32_t errorHigh;
113:                     uint32_t errorLow;
114:                 
115:                     if ((setup == NULL) || (setup->clockFrequency == 0))
116:                     {
117:                         return false;
118:                     }
119:                 
120:                     if(spiSourceClock == 0)
121:                     {
122:                         // Use Master Clock Frequency set in GUI
123:                         spiSourceClock = 72000000;
124:                     }
125:                 
126:                     t_brg = (((spiSourceClock / (setup->clockFrequency)) / 2u) - 1u);
127:                     baudHigh = spiSourceClock / (2u * (t_brg + 1u));
128:                     baudLow = spiSourceClock / (2u * (t_brg + 2u));
129:                     errorHigh = baudHigh - setup->clockFrequency;
130:                     errorLow = setup->clockFrequency - baudLow;
131:                 
132:                     if (errorHigh > errorLow)
133:                     {
134:                         t_brg++;
135:                     }
136:                 
137:                     if(t_brg > 8191)
138:                     {
139:                         return false;
140:                     }
141:                 
142:                     SPI1BRG = t_brg;
143:                     SPI1CON = (SPI1CON & (~(_SPI1CON_MODE16_MASK | _SPI1CON_MODE32_MASK | _SPI1CON_CKP_MASK | _SPI1CON_CKE_MASK))) |
144:                                             (setup->clockPolarity | setup->clockPhase | setup->dataBits);
145:                 
146:                     return true;
147:                 }
148:                 
149:                 bool SPI1_Write(void* pTransmitData, size_t txSize)
150:                 {
151:                     return(SPI1_WriteRead(pTransmitData, txSize, NULL, 0));
152:                 }
153:                 
154:                 bool SPI1_Read(void* pReceiveData, size_t rxSize)
155:                 {
156:                     return(SPI1_WriteRead(NULL, 0, pReceiveData, rxSize));
157:                 }
158:                 
159:                 bool SPI1_IsTransmitterBusy (void)
160:                 {
161:                     return ((SPI1STAT & _SPI1STAT_SRMT_MASK) == 0)? true : false;
162:                 }
163:                 
164:                 bool SPI1_WriteRead(void* pTransmitData, size_t txSize, void* pReceiveData, size_t rxSize)
165:                 {
166:                     size_t txCount = 0;
167:                     size_t rxCount = 0;
168:                     size_t dummySize = 0;
169:                     size_t dummyRxCntr = 0;
170:                     size_t receivedData;
171:                     bool isSuccess = false;
172:                 
173:                     /* Verify the request */
174:                     if (((txSize > 0) && (pTransmitData != NULL)) || ((rxSize > 0) && (pReceiveData != NULL)))
175:                     {
176:                         if (pTransmitData == NULL)
177:                         {
178:                             txSize = 0;
179:                         }
180:                         if (pReceiveData == NULL)
181:                         {
182:                             rxSize = 0;
183:                         }
184:                 
185:                         /* Clear the receive overflow error if any */
186:                         SPI1STATCLR = _SPI1STAT_SPIROV_MASK;
187:                 
188:                         /* Flush out any unread data in SPI read buffer from the previous transfer */
189:                         while ((bool)(SPI1STAT & _SPI1STAT_SPIRBE_MASK) == false)
190:                         {
191:                             receivedData = SPI1BUF;
192:                         }
193:                 
194:                         if (rxSize > txSize)
195:                         {
196:                             dummySize = rxSize - txSize;
197:                         }
198:                 
199:                         /* If dataBit size is 32 bits */
200:                         if (_SPI1CON_MODE32_MASK == (SPI1CON & _SPI1CON_MODE32_MASK))
201:                         {
202:                             rxSize >>= 2;
203:                             txSize >>= 2;
204:                             dummySize >>= 2;
205:                         }
206:                         /* If dataBit size is 16 bits */
207:                         else if (_SPI1CON_MODE16_MASK == (SPI1CON & _SPI1CON_MODE16_MASK))
208:                         {
209:                             rxSize >>= 1;
210:                             txSize >>= 1;
211:                             dummySize >>= 1;
212:                         }
213:                 
214:                         /* Make sure transmit buffer is empty */
215:                         while((bool)(SPI1STAT & _SPI1STAT_SPITBE_MASK) == false);
216:                 
217:                         while ((txCount != txSize) || (dummySize != 0))
218:                         {
219:                             if (txCount != txSize)
220:                             {
221:                                 if((_SPI1CON_MODE32_MASK) == (SPI1CON & (_SPI1CON_MODE32_MASK)))
222:                                 {
223:                                     SPI1BUF = ((uint32_t*)pTransmitData)[txCount++];
224:                                 }
225:                                 else if((_SPI1CON_MODE16_MASK) == (SPI1CON & (_SPI1CON_MODE16_MASK)))
226:                                 {
227:                                     SPI1BUF = ((uint16_t*)pTransmitData)[txCount++];
228:                                 }
229:                                 else
230:                                 {
231:                                     SPI1BUF = ((uint8_t*)pTransmitData)[txCount++];
232:                                 }
233:                             }
234:                             else if (dummySize > 0)
235:                             {
236:                                 SPI1BUF = 0xff;
237:                                 dummySize--;
238:                             }
239:                 
240:                             if (rxCount == rxSize)
241:                             {
242:                                 /* If inside this if condition, then it means that txSize > rxSize and all RX bytes are received */
243:                 
244:                                 /* For transmit only request, wait for buffer to become empty */
245:                                 while((bool)(SPI1STAT & _SPI1STAT_SPITBE_MASK) == false);
246:                 
247:                                 /* Read until the receive buffer is not empty */
248:                                 while ((bool)(SPI1STAT & _SPI1STAT_SPIRBE_MASK) == false)
249:                                 {
250:                                     receivedData = SPI1BUF;
251:                                     dummyRxCntr++;
252:                                 }
253:                             }
254:                             else
255:                             {
256:                                 /* If data is read, wait for the Receiver Data the data to become available */
257:                                 while((SPI1STAT & _SPI1STAT_SPIRBE_MASK) == _SPI1STAT_SPIRBE_MASK);
258:                 
259:                                 /* We have data waiting in the SPI buffer */
260:                                 receivedData = SPI1BUF;
261:                 
262:                                 if (rxCount < rxSize)
263:                                 {
264:                                     if((_SPI1CON_MODE32_MASK) == (SPI1CON & (_SPI1CON_MODE32_MASK)))
265:                                     {
266:                                         ((uint32_t*)pReceiveData)[rxCount++]  = receivedData;
267:                                     }
268:                                     else if((_SPI1CON_MODE16_MASK) == (SPI1CON & (_SPI1CON_MODE16_MASK)))
269:                                     {
270:                                         ((uint16_t*)pReceiveData)[rxCount++]  = receivedData;
271:                                     }
272:                                     else
273:                                     {
274:                                         ((uint8_t*)pReceiveData)[rxCount++]  = receivedData;
275:                                     }
276:                                 }
277:                             }
278:                         }
279:                 
280:                         /* Make sure no data is pending in the shift register */
281:                         while ((bool)((SPI1STAT & _SPI1STAT_SRMT_MASK) == false));
282:                 
283:                         /* Make sure for every character transmitted a character is also received back.
284:                          * If this is not done, we may prematurely exit this routine with the last bit still being
285:                          * transmitted out. As a result, the application may prematurely deselect the CS line and also
286:                          * the next request can receive last character of previous request as its first character.
287:                          */
288:                         if (txSize > rxSize)
289:                         {
290:                             while (dummyRxCntr != (txSize - rxSize))
291:                             {
292:                                 /* Wait for all the RX bytes to be received. */
293:                                 while ((bool)(SPI1STAT & _SPI1STAT_SPIRBE_MASK) == false)
294:                                 {
295:                                     receivedData = SPI1BUF;
296:                                     dummyRxCntr++;
297:                                 }
298:                             }
299:                         }
300:                 
301:                         isSuccess = true;
302:                     }
303:                 
304:                     return isSuccess;
305:                 }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
00000024  00000000   NOP
00000028  00000000   NOP
0000002C  00000000   NOP
00000030  00000000   NOP
00000034  00000000   NOP
00000038  00000000   NOP
0000003C  00000000   NOP
00000040  00000000   NOP
00000048  00000000   NOP
0000004C  00000000   NOP
00000050  00000000   NOP
00000058  00000000   NOP
0000005C  00000000   NOP
00000060  00000000   NOP
00000064  00000000   NOP
0000006C  00000000   NOP
00000074  00000000   NOP
00000078  00000000   NOP
0000007C  00000000   NOP
00000080  00000000   NOP
00000084  00000000   NOP
00000088  00000000   NOP
0000008C  00000000   NOP
00000090  00000000   NOP
00000098  00000000   NOP
000000A0  00000000   NOP
000000A4  00000000   NOP
000000A8  00000000   NOP
000000AC  00000000   NOP
000000B4  00000000   NOP
000000BC  00000000   NOP
000000C4  00000000   NOP
000000C8  00000000   NOP
000000D0  00000000   NOP
000000D8  00000000   NOP
000000E0  00000000   NOP
000000EC  00000000   NOP
000000F4  00000000   NOP
000000FC  00000000   NOP
00000100  00000000   NOP
00000108  00000000   NOP
00000110  00000000   NOP
00000118  00000000   NOP
00000120  00000000   NOP
00000128  00000000   NOP
0000012C  00000000   NOP
00000130  00000000   NOP
00000134  00000000   NOP
00000144  00000000   NOP
0000014C  00000000   NOP
00000154  00000000   NOP
0000015C  00000000   NOP
00000164  00000000   NOP
0000016C  00000000   NOP
00000174  00000000   NOP
00000178  00000000   NOP
0000017C  00000000   NOP
00000180  00000000   NOP
00000188  00000000   NOP
00000190  00000000   NOP
00000198  00000000   NOP
000001A0  00000000   NOP
000001A8  00000000   NOP
000001AC  00000000   NOP
000001B4  00000000   NOP
000001B8  00000000   NOP
000001C4  00000000   NOP
000001CC  00000000   NOP
000001D4  00000000   NOP
000001E0  00000000   NOP
000001E8  00000000   NOP
000001EC  00000000   NOP
000001F0  00000000   NOP
000001FC  00000000   NOP
00000200  00000000   NOP
00000208  00000000   NOP
00000210  00000000   NOP
00000218  00000000   NOP
0000021C  00000000   NOP
00000220  00000000   NOP
00000224  00000000   NOP
00000228  00000000   NOP
00000230  00000000   NOP
00000238  00000000   NOP
00000240  00000000   NOP
00000248  00000000   NOP
9D007654  3C02BF80   LUI V0, -16512
9D007658  3C03BF88   LUI V1, -16504
9D00765C  24040040   ADDIU A0, ZERO, 64
9D007660  24060010   ADDIU A2, ZERO, 16
9D007664  24050020   ADDIU A1, ZERO, 32
9D007668  AC661074   SW A2, 4212(V1)
9D00766C  AC651074   SW A1, 4212(V1)
9D007670  AC641074   SW A0, 4212(V1)
9D007674  AC405800   SW ZERO, 22528(V0)
9D007678  8C475820   LW A3, 22560(V0)
9D00767C  AC661044   SW A2, 4164(V1)
9D007680  AC651044   SW A1, 4164(V1)
9D007684  AC641044   SW A0, 4164(V1)
9D007688  24030003   ADDIU V1, ZERO, 3
9D00768C  AC435830   SW V1, 22576(V0)
9D007690  3C030001   LUI V1, 1
9D007694  24630060   ADDIU V1, V1, 96
9D007698  AC445814   SW A0, 22548(V0)
9D00769C  AC435808   SW V1, 22536(V0)
9D0076A0  24030005   ADDIU V1, ZERO, 5
9D0076A4  AC435808   SW V1, 22536(V0)
9D0076A8  34038000   ORI V1, ZERO, -32768
9D0076AC  AC435808   SW V1, 22536(V0)
9D0076B0  03E00008   JR RA
9D0076B4  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/peripheral/nvm/plib_nvm.c  -----------------
1:                   /*******************************************************************************
2:                     Non-Volatile Memory Controller(NVM) PLIB.
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_nvm.c
9:                   
10:                    Summary:
11:                      Interface definition of NVM Plib.
12:                  
13:                    Description:
14:                      This file defines the interface for the NVM Plib.
15:                      It allows user to Program, Erase and lock the on-chip Non Volatile Flash
16:                      Memory.
17:                  *******************************************************************************/
18:                  
19:                  // DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
22:                  *
23:                  * Subject to your compliance with these terms, you may use Microchip software
24:                  * and any derivatives exclusively with Microchip products. It is your
25:                  * responsibility to comply with third party license terms applicable to your
26:                  * use of third party software (including open source software) that may
27:                  * accompany Microchip software.
28:                  *
29:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
31:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
32:                  * PARTICULAR PURPOSE.
33:                  *
34:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                  *******************************************************************************/
42:                  // DOM-IGNORE-END
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Section: Included Files
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  
50:                  #include <string.h>
51:                  #include "sys/kmem.h"
52:                  #include "plib_nvm.h"
53:                  
54:                  /* ************************************************************************** */
55:                  /* ************************************************************************** */
56:                  /* Section: File Scope or Global Data                                         */
57:                  /* ************************************************************************** */
58:                  /* ************************************************************************** */
59:                  // *****************************************************************************
60:                  
61:                  /*******************************************
62:                   * Internal operation type
63:                   ******************************************/
64:                  typedef enum
65:                  {
66:                      PROGRAM_ERASE_OPERATION         = 0x5,
67:                      PAGE_ERASE_OPERATION            = 0x4,
68:                      ROW_PROGRAM_OPERATION           = 0x3,
69:                      WORD_PROGRAM_OPERATION          = 0x1,
70:                      NO_OPERATION                    = 0x0,
71:                  } NVM_OPERATION_MODE;
72:                  
73:                  /*******************************************
74:                   * Internal Flash Programming Unlock Keys
75:                   ******************************************/
76:                  typedef enum
77:                  {
78:                      NVM_UNLOCK_KEY1 = 0xAA996655,
79:                      NVM_UNLOCK_KEY2 = 0x556699AA
80:                  } NVM_UNLOCK_KEYS;
81:                  
82:                  #define NVM_INTERRUPT_ENABLE_MASK   0x80000000L
83:                  #define NVM_INTERRUPT_FLAG_MASK     0x80000000L
84:                  
85:                  /* ************************************************************************** */
86:                  /* ************************************************************************** */
87:                  // Section: Local Functions                                                   */
88:                  /* ************************************************************************** */
89:                  /* ************************************************************************** */
90:                  
91:                  // *****************************************************************************
92:                  // *****************************************************************************
93:                  // Section: NVM Implementation
94:                  // *****************************************************************************
95:                  // *****************************************************************************
96:                  
97:                  NVM_CALLBACK nvmCallbackFunc;
98:                  
99:                  uintptr_t nvmContext;
100:                 
101:                 void NVM_CallbackRegister( NVM_CALLBACK callback, uintptr_t context )
102:                 {
103:                     /* Register callback function */
104:                     nvmCallbackFunc    = callback;
105:                     nvmContext         = context;
106:                 }
107:                 
108:                 void NVM_InterruptHandler( void )
109:                 {
110:                     IFS0CLR = NVM_INTERRUPT_FLAG_MASK;
111:                 
112:                     if(nvmCallbackFunc != NULL)
113:                     {
114:                         nvmCallbackFunc(nvmContext);
115:                     }
116:                 }
117:                 
118:                 static void NVM_StartOperationAtAddress( uint32_t address,  NVM_OPERATION_MODE operation )
119:                 {
120:                     volatile uint32_t processorStatus;
121:                 
122:                     processorStatus = __builtin_disable_interrupts();
123:                 
124:                     // Set the target Flash address to be operated on (destination).
125:                     NVMADDR = KVA_TO_PA(address);
126:                 
127:                     // NVMOP can be written only when WREN is zero. So, clear WREN.
128:                     NVMCONCLR = _NVMCON_WREN_MASK;
129:                 
130:                     NVMCONCLR = _NVMCON_NVMOP_MASK;
131:                     NVMCONSET = ( _NVMCON_NVMOP_MASK & (((uint32_t)operation) << _NVMCON_NVMOP_POSITION) );
132:                 
133:                     // Set WREN to enable writes to the WR bit and to prevent NVMOP modification
134:                     NVMCONSET = _NVMCON_WREN_MASK;
135:                 
136:                     // Write the unlock key sequence
137:                     NVMKEY = 0x0;
138:                     NVMKEY = NVM_UNLOCK_KEY1;
139:                     NVMKEY = NVM_UNLOCK_KEY2;
140:                 
141:                     // Start the operation
142:                     NVMCONSET = _NVMCON_WR_MASK;
143:                 
144:                     __builtin_mtc0(12, 0, processorStatus);
145:                 
146:                     IEC0SET   = NVM_INTERRUPT_ENABLE_MASK;
147:                 }
148:                 
149:                 /* ************************************************************************** */
150:                 /* ************************************************************************** */
151:                 // Section: Interface Functions                                               */
152:                 /* ************************************************************************** */
153:                 /* ************************************************************************** */
154:                 
155:                 void NVM_Initialize( void )
156:                 {
157:                     NVM_StartOperationAtAddress( NVMADDR,  NO_OPERATION );
158:                 }
159:                 
160:                 bool NVM_Read( uint32_t *data, uint32_t length, const uint32_t address )
161:                 {
162:                     memcpy((void *)data, (void *)KVA0_TO_KVA1(address), length);
163:                 
164:                     return true;
165:                 }
166:                 
167:                 bool NVM_WordWrite( uint32_t data, uint32_t address )
168:                 {
169:                     NVMDATA = (uint32_t )data;
170:                 
171:                     NVM_StartOperationAtAddress( address,  WORD_PROGRAM_OPERATION);
172:                 
173:                     return true;
174:                 }
175:                 
176:                 bool NVM_RowWrite( uint32_t *data, uint32_t address )
177:                 {
178:                    NVMSRCADDR = (uint32_t )KVA_TO_PA(data);
179:                 
180:                    NVM_StartOperationAtAddress( address,  ROW_PROGRAM_OPERATION);
181:                 
182:                    return true;
183:                 }
184:                 
185:                 bool NVM_PageErase( uint32_t address )
186:                 {
187:                    NVM_StartOperationAtAddress(address,  PAGE_ERASE_OPERATION);
188:                 
189:                    return true;
190:                 }
191:                 
192:                 NVM_ERROR NVM_ErrorGet( void )
193:                 {
194:                     // mask for WRERR and LVDERR bits
195:                     return (NVMCON & (_NVMCON_LVDERR_MASK | _NVMCON_WRERR_MASK));
196:                 }
197:                 
198:                 bool NVM_IsBusy( void )
199:                 {
200:                     return (bool)NVMCONbits.WR;
201:                 }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
00000024  00000000   NOP
00000028  00000000   NOP
0000002C  00000000   NOP
00000030  00000000   NOP
00000034  00000000   NOP
00000038  00000000   NOP
0000003C  00000000   NOP
00000040  00000000   NOP
00000044  00000000   NOP
00000048  00000000   NOP
0000004C  00000000   NOP
00000050  00000000   NOP
00000054  00000000   NOP
00000058  00000000   NOP
0000005C  00000000   NOP
00000060  00000000   NOP
00000064  00000000   NOP
00000068  00000000   NOP
0000006C  00000000   NOP
00000070  00000000   NOP
00000074  00000000   NOP
00000078  00000000   NOP
0000007C  00000000   NOP
00000080  00000000   NOP
00000084  00000000   NOP
9D0070D4  3C02BF81   LUI V0, -16511
9D0070D8  8C43F420   LW V1, -3040(V0)
9D0070DC  27BDFFF0   ADDIU SP, SP, -16
9D0070E0  AFBF000C   SW RA, 12(SP)
9D0070E4  41656000   DI A1
9D0070E8  000000C0   EHB
9D0070EC  7C63E000   EXT V1, V1, 0, 29
9D0070F0  AFA50000   SW A1, 0(SP)
9D0070F4  24044000   ADDIU A0, ZERO, 16384
9D0070F8  AC43F420   SW V1, -3040(V0)
9D0070FC  2403000F   ADDIU V1, ZERO, 15
9D007100  AC44F404   SW A0, -3068(V0)
9D007104  AC43F404   SW V1, -3068(V0)
9D007108  3C03AA99   LUI V1, -21863
9D00710C  24636655   ADDIU V1, V1, 26197
9D007110  AC40F408   SW ZERO, -3064(V0)
9D007114  AC44F408   SW A0, -3064(V0)
9D007118  AC40F410   SW ZERO, -3056(V0)
9D00711C  AC43F410   SW V1, -3056(V0)
9D007120  3C035566   LUI V1, 21862
9D007124  346399AA   ORI V1, V1, -26198
9D007128  AC43F410   SW V1, -3056(V0)
9D00712C  34038000   ORI V1, ZERO, -32768
9D007130  AC43F408   SW V1, -3064(V0)
9D007134  8FA20000   LW V0, 0(SP)
9D007138  40826000   MTC0 V0, Status
9D00713C  000000C0   EHB
9D007140  8FBF000C   LW RA, 12(SP)
9D007144  3C02BF88   LUI V0, -16504
9D007148  3C038000   LUI V1, -32768
9D00714C  AC431068   SW V1, 4200(V0)
9D007150  03E00008   JR RA
9D007154  27BD0010   ADDIU SP, SP, 16
9D0082D0  8F99802C   LW T9, -32724(GP)
9D0082D4  3C02BF88   LUI V0, -16504
9D0082D8  3C038000   LUI V1, -32768
9D0082DC  AC431034   SW V1, 4148(V0)
9D0082E0  13200003   BEQ T9, ZERO, 0x9D0082F0
9D0082E4  00000000   NOP
9D0082E8  03200008   JR T9
9D0082EC  8F848030   LW A0, -32720(GP)
9D0082F0  03E00008   JR RA
9D0082F4  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/peripheral/gpio/plib_gpio.c  ---------------
1:                   /*******************************************************************************
2:                     SYS PORTS Static Functions for PORTS System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_gpio.c
9:                   
10:                    Summary:
11:                      GPIO function implementations for the GPIO PLIB.
12:                  
13:                    Description:
14:                      The GPIO PLIB provides a simple interface to manage peripheral
15:                      input-output controller.
16:                  
17:                  *******************************************************************************/
18:                  
19:                  //DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
22:                  *
23:                  * Subject to your compliance with these terms, you may use Microchip software
24:                  * and any derivatives exclusively with Microchip products. It is your
25:                  * responsibility to comply with third party license terms applicable to your
26:                  * use of third party software (including open source software) that may
27:                  * accompany Microchip software.
28:                  *
29:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
31:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
32:                  * PARTICULAR PURPOSE.
33:                  *
34:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                  *******************************************************************************/
42:                  //DOM-IGNORE-END
43:                  
44:                  #include "plib_gpio.h"
45:                  
46:                  
47:                  
48:                  /******************************************************************************
49:                    Function:
50:                      GPIO_Initialize ( void )
51:                  
52:                    Summary:
53:                      Initialize the GPIO library.
54:                  
55:                    Remarks:
56:                      See plib_gpio.h for more details.
57:                  */
58:                  void GPIO_Initialize ( void )
59:                  {
60:                      /* PORTA Initialization */
61:                      LATA = 0x400; /* Initial Latch Value */
62:                      TRISACLR = 0x410; /* Direction Control */
63:                      CNPUASET = 0x80; /* Pull-Up Enable */
64:                      CNPDASET = 0x200; /* Pull-Down Enable */
65:                  
66:                      /* PORTB Initialization */
67:                      ANSELBCLR = 0x4000; /* Digital Mode Enable */
68:                  
69:                      /* PORTC Initialization */
70:                      LATC = 0x60; /* Initial Latch Value */
71:                      TRISCCLR = 0x74; /* Direction Control */
72:                      ANSELCCLR = 0xd; /* Digital Mode Enable */
73:                  
74:                  
75:                  
76:                      /* PPS Input Remapping */
77:                      SDI1R = 7;
78:                      U1CTSR = 5;
79:                      U1RXR = 2;
80:                      U2RXR = 6;
81:                  
82:                      /* PPS Output Remapping */
83:                      RPA3R = 1;
84:                      RPC0R = 1;
85:                      RPC3R = 3;
86:                      RPB9R = 2;
87:                  
88:                  
89:                  }
90:                  
91:                  // *****************************************************************************
92:                  // *****************************************************************************
93:                  // Section: GPIO APIs which operates on multiple pins of a port
94:                  // *****************************************************************************
95:                  // *****************************************************************************
96:                  
97:                  // *****************************************************************************
98:                  /* Function:
99:                      uint32_t GPIO_PortRead ( GPIO_PORT port )
100:                 
101:                   Summary:
102:                     Read all the I/O lines of the selected port.
103:                 
104:                   Description:
105:                     This function reads the live data values on all the I/O lines of the
106:                     selected port.  Bit values returned in each position indicate corresponding
107:                     pin levels.
108:                     1 = Pin is high.
109:                     0 = Pin is low.
110:                 
111:                     This function reads the value regardless of pin configuration, whether it is
112:                     set as as an input, driven by the GPIO Controller, or driven by a peripheral.
113:                 
114:                   Remarks:
115:                     If the port has less than 32-bits, unimplemented pins will read as
116:                     low (0).
117:                     Implemented pins are Right aligned in the 32-bit return value.
118:                 */
119:                 uint32_t GPIO_PortRead(GPIO_PORT port)
120:                 {
121:                     return (*(volatile uint32_t *)(&PORTA + (port * 0x40)));
122:                 }
123:                 
124:                 // *****************************************************************************
125:                 /* Function:
126:                     void GPIO_PortWrite (GPIO_PORT port, uint32_t mask, uint32_t value);
127:                 
128:                   Summary:
129:                     Write the value on the masked I/O lines of the selected port.
130:                 
131:                   Remarks:
132:                     See plib_gpio.h for more details.
133:                 */
134:                 void GPIO_PortWrite(GPIO_PORT port, uint32_t mask, uint32_t value)
135:                 {
136:                     *(volatile uint32_t *)(&LATA + (port * 0x40)) = (*(volatile uint32_t *)(&LATA + (port * 0x40)) & (~mask)) | (mask & value);
137:                 }
138:                 
139:                 // *****************************************************************************
140:                 /* Function:
141:                     uint32_t GPIO_PortLatchRead ( GPIO_PORT port )
142:                 
143:                   Summary:
144:                     Read the latched value on all the I/O lines of the selected port.
145:                 
146:                   Remarks:
147:                     See plib_gpio.h for more details.
148:                 */
149:                 uint32_t GPIO_PortLatchRead(GPIO_PORT port)
150:                 {
151:                     return (*(volatile uint32_t *)(&LATA + (port * 0x40)));
152:                 }
153:                 
154:                 // *****************************************************************************
155:                 /* Function:
156:                     void GPIO_PortSet ( GPIO_PORT port, uint32_t mask )
157:                 
158:                   Summary:
159:                     Set the selected IO pins of a port.
160:                 
161:                   Remarks:
162:                     See plib_gpio.h for more details.
163:                 */
164:                 void GPIO_PortSet(GPIO_PORT port, uint32_t mask)
165:                 {
166:                     *(volatile uint32_t *)(&LATASET + (port * 0x40)) = mask;
167:                 }
168:                 
169:                 // *****************************************************************************
170:                 /* Function:
171:                     void GPIO_PortClear ( GPIO_PORT port, uint32_t mask )
172:                 
173:                   Summary:
174:                     Clear the selected IO pins of a port.
175:                 
176:                   Remarks:
177:                     See plib_gpio.h for more details.
178:                 */
179:                 void GPIO_PortClear(GPIO_PORT port, uint32_t mask)
180:                 {
181:                     *(volatile uint32_t *)(&LATACLR + (port * 0x40)) = mask;
182:                 }
183:                 
184:                 // *****************************************************************************
185:                 /* Function:
186:                     void GPIO_PortToggle ( GPIO_PORT port, uint32_t mask )
187:                 
188:                   Summary:
189:                     Toggles the selected IO pins of a port.
190:                 
191:                   Remarks:
192:                     See plib_gpio.h for more details.
193:                 */
194:                 void GPIO_PortToggle(GPIO_PORT port, uint32_t mask)
195:                 {
196:                     *(volatile uint32_t *)(&LATAINV + (port * 0x40))= mask;
197:                 }
198:                 
199:                 // *****************************************************************************
200:                 /* Function:
201:                     void GPIO_PortInputEnable ( GPIO_PORT port, uint32_t mask )
202:                 
203:                   Summary:
204:                     Enables selected IO pins of a port as input.
205:                 
206:                   Remarks:
207:                     See plib_gpio.h for more details.
208:                 */
209:                 void GPIO_PortInputEnable(GPIO_PORT port, uint32_t mask)
210:                 {
211:                     *(volatile uint32_t *)(&TRISASET + (port * 0x40)) = mask;
212:                 }
213:                 
214:                 // *****************************************************************************
215:                 /* Function:
216:                     void GPIO_PortOutputEnable ( GPIO_PORT port, uint32_t mask )
217:                 
218:                   Summary:
219:                     Enables selected IO pins of a port as output(s).
220:                 
221:                   Remarks:
222:                     See plib_gpio.h for more details.
223:                 */
224:                 void GPIO_PortOutputEnable(GPIO_PORT port, uint32_t mask)
225:                 {
226:                     *(volatile uint32_t *)(&TRISACLR + (port * 0x40)) = mask;
227:                 }
228:                 
229:                 
230:                 
231:                 
232:                 /*******************************************************************************
233:                  End of File
234:                 */
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
00000024  00000000   NOP
9D00704C  3C03BF88   LUI V1, -16504
9D007050  24060400   ADDIU A2, ZERO, 1024
9D007054  AC666030   SW A2, 24624(V1)
9D007058  24060410   ADDIU A2, ZERO, 1040
9D00705C  AC666014   SW A2, 24596(V1)
9D007060  24060080   ADDIU A2, ZERO, 128
9D007064  AC666058   SW A2, 24664(V1)
9D007068  24060200   ADDIU A2, ZERO, 512
9D00706C  AC666068   SW A2, 24680(V1)
9D007070  24064000   ADDIU A2, ZERO, 16384
9D007074  AC666104   SW A2, 24836(V1)
9D007078  24060060   ADDIU A2, ZERO, 96
9D00707C  AC666230   SW A2, 25136(V1)
9D007080  24060074   ADDIU A2, ZERO, 116
9D007084  AC666214   SW A2, 25108(V1)
9D007088  2406000D   ADDIU A2, ZERO, 13
9D00708C  AC666204   SW A2, 25092(V1)
9D007090  3C02BF81   LUI V0, -16511
9D007094  24030007   ADDIU V1, ZERO, 7
9D007098  AC43FA84   SW V1, -1404(V0)
9D00709C  24030005   ADDIU V1, ZERO, 5
9D0070A0  AC43FA54   SW V1, -1452(V0)
9D0070A4  24040002   ADDIU A0, ZERO, 2
9D0070A8  24030006   ADDIU V1, ZERO, 6
9D0070AC  AC44FA50   SW A0, -1456(V0)
9D0070B0  24050001   ADDIU A1, ZERO, 1
9D0070B4  AC43FA58   SW V1, -1448(V0)
9D0070B8  24030003   ADDIU V1, ZERO, 3
9D0070BC  AC45FB0C   SW A1, -1268(V0)
9D0070C0  AC45FB6C   SW A1, -1172(V0)
9D0070C4  AC43FB78   SW V1, -1160(V0)
9D0070C8  AC44FB50   SW A0, -1200(V0)
9D0070CC  03E00008   JR RA
9D0070D0  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/peripheral/evic/plib_evic.c  ---------------
1:                   /*******************************************************************************
2:                     EVIC PLIB Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_evic.c
9:                   
10:                    Summary:
11:                      EVIC PLIB Source File
12:                  
13:                    Description:
14:                      None
15:                  
16:                  *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
21:                  *
22:                  * Subject to your compliance with these terms, you may use Microchip software
23:                  * and any derivatives exclusively with Microchip products. It is your
24:                  * responsibility to comply with third party license terms applicable to your
25:                  * use of third party software (including open source software) that may
26:                  * accompany Microchip software.
27:                  *
28:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                  * PARTICULAR PURPOSE.
32:                  *
33:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                  *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  #include "device.h"
44:                  #include "plib_evic.h"
45:                  
46:                  
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  // Section: IRQ Implementation
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  
53:                  void EVIC_Initialize( void )
54:                  {
55:                      INTCONSET = _INTCON_MVEC_MASK;
56:                  
57:                      /* Set up priority and subpriority of enabled interrupts */
58:                      IPC0SET = 0x4 | 0x0;  /* CORE_TIMER:  Priority 1 / Subpriority 0 */
59:                      IPC3SET = 0x4 | 0x0;  /* TIMER_3:  Priority 1 / Subpriority 0 */
60:                      IPC6SET = 0x40000 | 0x0;  /* FCE:  Priority 1 / Subpriority 0 */
61:                      IPC7SET = 0x40000 | 0x0;  /* USB_1:  Priority 1 / Subpriority 0 */
62:                      IPC8SET = 0x4 | 0x0;  /* UART_1:  Priority 1 / Subpriority 0 */
63:                      IPC9SET = 0x400 | 0x0;  /* UART_2:  Priority 1 / Subpriority 0 */
64:                  
65:                  
66:                  }
67:                  
68:                  void EVIC_SourceEnable( INT_SOURCE source )
69:                  {
70:                      volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
71:                      volatile uint32_t *IECxSET = (volatile uint32_t *)(IECx + 2);
72:                  
73:                      *IECxSET = 1 << (source & 0x1f);
74:                  }
75:                  
76:                  void EVIC_SourceDisable( INT_SOURCE source )
77:                  {
78:                      volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
79:                      volatile uint32_t *IECxCLR = (volatile uint32_t *)(IECx + 1);
80:                  
81:                      *IECxCLR = 1 << (source & 0x1f);
82:                  }
83:                  
84:                  bool EVIC_SourceIsEnabled( INT_SOURCE source )
85:                  {
86:                      volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
87:                  
88:                      return (bool)((*IECx >> (source & 0x1f)) & 0x01);
89:                  }
90:                  
91:                  bool EVIC_SourceStatusGet( INT_SOURCE source )
92:                  {
93:                      volatile uint32_t *IFSx = (volatile uint32_t *)(&IFS0 + ((0x10 * (source / 32)) / 4));
94:                  
95:                      return (bool)((*IFSx >> (source & 0x1f)) & 0x1);
96:                  }
97:                  
98:                  void EVIC_SourceStatusSet( INT_SOURCE source )
99:                  {
100:                     volatile uint32_t *IFSx = (volatile uint32_t *) (&IFS0 + ((0x10 * (source / 32)) / 4));
101:                     volatile uint32_t *IFSxSET = (volatile uint32_t *)(IFSx + 2);
102:                 
103:                     *IFSxSET = 1 << (source & 0x1f);
104:                 }
105:                 
106:                 void EVIC_SourceStatusClear( INT_SOURCE source )
107:                 {
108:                     volatile uint32_t *IFSx = (volatile uint32_t *) (&IFS0 + ((0x10 * (source / 32)) / 4));
109:                     volatile uint32_t *IFSxCLR = (volatile uint32_t *)(IFSx + 1);
110:                 
111:                     *IFSxCLR = 1 << (source & 0x1f);
112:                 }
113:                 
114:                 void EVIC_INT_Enable( void )
115:                 {
116:                     __builtin_enable_interrupts();
117:                 }
118:                 
119:                 bool EVIC_INT_Disable( void )
120:                 {
121:                     uint32_t processorStatus;
122:                 
123:                     /* Save the processor status and then Disable the global interrupt */
124:                     processorStatus = ( uint32_t )__builtin_disable_interrupts();
125:                 
126:                     /* return the interrupt status */
127:                     return (bool)(processorStatus & 0x01);
128:                 }
129:                 
130:                 void EVIC_INT_Restore( bool state )
131:                 {
132:                     if (state)
133:                     {
134:                         /* restore the state of CP0 Status register before the disable occurred */
135:                         __builtin_enable_interrupts();
136:                     }
137:                 }
138:                 
139:                 
140:                 /* End of file */
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
9D007E04  3C02BF88   LUI V0, -16504
9D007E08  24030004   ADDIU V1, ZERO, 4
9D007E0C  3C040004   LUI A0, 4
9D007E10  24051000   ADDIU A1, ZERO, 4096
9D007E14  AC451008   SW A1, 4104(V0)
9D007E18  AC431098   SW V1, 4248(V0)
9D007E1C  AC4310C8   SW V1, 4296(V0)
9D007E20  AC4410F8   SW A0, 4344(V0)
9D007E24  AC441108   SW A0, 4360(V0)
9D007E28  AC431118   SW V1, 4376(V0)
9D007E2C  24030400   ADDIU V1, ZERO, 1024
9D007E30  AC431128   SW V1, 4392(V0)
9D007E34  03E00008   JR RA
9D007E38  00000000   NOP
9D008230  00041142   SRL V0, A0, 5
9D008234  00022900   SLL A1, V0, 4
9D008238  3C02BF88   LUI V0, -16504
9D00823C  24421060   ADDIU V0, V0, 4192
9D008240  24030001   ADDIU V1, ZERO, 1
9D008244  00451021   ADDU V0, V0, A1
9D008248  00831804   SLLV V1, V1, A0
9D00824C  AC430008   SW V1, 8(V0)
9D008250  03E00008   JR RA
9D008254  00000000   NOP
9D008258  00041142   SRL V0, A0, 5
9D00825C  00022900   SLL A1, V0, 4
9D008260  3C02BF88   LUI V0, -16504
9D008264  24421060   ADDIU V0, V0, 4192
9D008268  24030001   ADDIU V1, ZERO, 1
9D00826C  00451021   ADDU V0, V0, A1
9D008270  00831804   SLLV V1, V1, A0
9D008274  AC430004   SW V1, 4(V0)
9D008278  03E00008   JR RA
9D00827C  00000000   NOP
9D008280  00041142   SRL V0, A0, 5
9D008284  00022900   SLL A1, V0, 4
9D008288  3C02BF88   LUI V0, -16504
9D00828C  24421030   ADDIU V0, V0, 4144
9D008290  24030001   ADDIU V1, ZERO, 1
9D008294  00451021   ADDU V0, V0, A1
9D008298  00831804   SLLV V1, V1, A0
9D00829C  AC430004   SW V1, 4(V0)
9D0082A0  03E00008   JR RA
9D0082A4  00000000   NOP
9D0082A8  10800007   BEQ A0, ZERO, 0x9D0082C8
9D0082AC  00000000   NOP
9D0082B0  27BDFFF8   ADDIU SP, SP, -8
9D0082B4  AFBF0004   SW RA, 4(SP)
9D0082B8  41626020   EI V0
9D0082BC  8FBF0004   LW RA, 4(SP)
9D0082C0  03E00008   JR RA
9D0082C4  27BD0008   ADDIU SP, SP, 8
9D0082C8  03E00008   JR RA
9D0082CC  00000000   NOP
9D008370  00041942   SRL V1, A0, 5
9D008374  00032900   SLL A1, V1, 4
9D008378  3C03BF88   LUI V1, -16504
9D00837C  24631060   ADDIU V1, V1, 4192
9D008380  00651821   ADDU V1, V1, A1
9D008384  8C620000   LW V0, 0(V1)
9D008388  00821006   SRLV V0, V0, A0
9D00838C  03E00008   JR RA
9D008390  30420001   ANDI V0, V0, 1
9D008394  27BDFFF8   ADDIU SP, SP, -8
9D008398  AFBF0004   SW RA, 4(SP)
9D00839C  41626000   DI V0
9D0083A0  000000C0   EHB
9D0083A4  8FBF0004   LW RA, 4(SP)
9D0083A8  30420001   ANDI V0, V0, 1
9D0083AC  03E00008   JR RA
9D0083B0  27BD0008   ADDIU SP, SP, 8
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/peripheral/coretimer/plib_coretimer.c  -----
1:                   /*******************************************************************************
2:                     Core Timer Peripheral Library
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_coretimer.c
9:                   
10:                    Summary:
11:                      Core timer Source File
12:                  
13:                    Description:
14:                      None
15:                  
16:                  *******************************************************************************/
17:                  
18:                  /*******************************************************************************
19:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
20:                  *
21:                  * Subject to your compliance with these terms, you may use Microchip software
22:                  * and any derivatives exclusively with Microchip products. It is your
23:                  * responsibility to comply with third party license terms applicable to your
24:                  * use of third party software (including open source software) that may
25:                  * accompany Microchip software.
26:                  *
27:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                  * PARTICULAR PURPOSE.
31:                  *
32:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
33:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
34:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
35:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
36:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
37:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
38:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
39:                  *******************************************************************************/
40:                  
41:                  #include "device.h"
42:                  #include "peripheral/coretimer/plib_coretimer.h"
43:                  
44:                  CORETIMER_OBJECT coreTmr;
45:                  void CORETIMER_Initialize()
46:                  {
47:                      // Disable Timer by setting Disable Count (DC) bit
48:                      _CP0_SET_CAUSE(_CP0_GET_CAUSE() | _CP0_CAUSE_DC_MASK);
49:                      coreTmr.period=CORE_TIMER_INTERRUPT_PERIOD_VALUE;
50:                      coreTmr.tickCounter = 0;
51:                      coreTmr.callback = NULL;
52:                  }
53:                  void CORETIMER_CallbackSet ( CORETIMER_CALLBACK callback, uintptr_t context )
54:                  {
55:                      coreTmr.callback = callback;
56:                      coreTmr.context = context;
57:                  }
58:                  void CORETIMER_PeriodSet ( uint32_t period )
59:                  {
60:                      coreTmr.period=period;
61:                  }
62:                  void CORETIMER_Start()
63:                  {
64:                      // Disable Timer by setting Disable Count (DC) bit
65:                      _CP0_SET_CAUSE(_CP0_GET_CAUSE() | _CP0_CAUSE_DC_MASK);
66:                      // Disable Interrupt
67:                      IEC0CLR=0x1;
68:                      // Clear Core Timer
69:                      _CP0_SET_COUNT(0);
70:                      _CP0_SET_COMPARE(coreTmr.period);
71:                      // Enable Timer by clearing Disable Count (DC) bit
72:                      _CP0_SET_CAUSE(_CP0_GET_CAUSE() & (~_CP0_CAUSE_DC_MASK));
73:                      // Enable Interrupt
74:                      IEC0SET=0x1;
75:                  }
76:                  void CORETIMER_Stop()
77:                  {
78:                      // Disable Timer by setting Disable Count (DC) bit
79:                      _CP0_SET_CAUSE(_CP0_GET_CAUSE() | _CP0_CAUSE_DC_MASK);
80:                      // Disable Interrupt
81:                      IEC0CLR=0x1;
82:                  }
83:                  uint32_t CORETIMER_FrequencyGet ( void )
84:                  {
85:                      return (CORE_TIMER_FREQUENCY);
86:                  }
87:                  void CORE_TIMER_InterruptHandler (void)
88:                  {
89:                      uint32_t count, newCompare;
90:                      uint32_t status = IFS0bits.CTIF;
91:                      IFS0CLR = 0x1;
92:                      // Start Critical Section
93:                      __builtin_disable_interrupts();
94:                      count=_CP0_GET_COUNT();
95:                      newCompare=_CP0_GET_COMPARE() + coreTmr.period;
96:                      if (count<newCompare-50)
97:                          _CP0_SET_COMPARE(newCompare);
98:                      else
99:                          _CP0_SET_COMPARE(count+50);
100:                     // End Critical Section
101:                     __builtin_enable_interrupts();
102:                     coreTmr.tickCounter++;
103:                     if(coreTmr.callback != NULL)
104:                     {
105:                         coreTmr.callback(status, coreTmr.context);
106:                     }
107:                 }
108:                 
109:                 
110:                 
111:                 void CORETIMER_DelayMs ( uint32_t delay_ms)
112:                 {
113:                     uint32_t startCount, endCount;
114:                 
115:                     /* Calculate the end count for the given delay */
116:                     endCount=(CORE_TIMER_FREQUENCY/1000)*delay_ms;
117:                 
118:                     startCount=_CP0_GET_COUNT();
119:                     while((_CP0_GET_COUNT()-startCount)<endCount);
120:                 
121:                 }
122:                 
123:                 void CORETIMER_DelayUs ( uint32_t delay_us)
124:                 {
125:                     uint32_t startCount, endCount;
126:                 
127:                     /* Calculate the end count for the given delay */
128:                     endCount=(CORE_TIMER_FREQUENCY/1000000)*delay_us;
129:                 
130:                     startCount=_CP0_GET_COUNT();
131:                     while((_CP0_GET_COUNT()-startCount)<endCount);
132:                 
133:                 }
134:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
0000002C  00000000   NOP
9D006960  3C02BF88   LUI V0, -16504
9D006964  8C441030   LW A0, 4144(V0)
9D006968  27BDFFF8   ADDIU SP, SP, -8
9D00696C  24030001   ADDIU V1, ZERO, 1
9D006970  30840001   ANDI A0, A0, 1
9D006974  AFBF0004   SW RA, 4(SP)
9D006978  AC431034   SW V1, 4148(V0)
9D00697C  41626000   DI V0
9D006980  000000C0   EHB
9D006984  40064800   MFC0 A2, Count
9D006988  40035800   MFC0 V1, Compare
9D00698C  3C07A000   LUI A3, -24576
9D006990  24E204F8   ADDIU V0, A3, 1272
9D006994  8C45000C   LW A1, 12(V0)
9D006998  00651821   ADDU V1, V1, A1
9D00699C  2465FFCE   ADDIU A1, V1, -50
9D0069A0  00C5282B   SLTU A1, A2, A1
9D0069A4  50A0000D   BEQL A1, ZERO, 0x9D0069DC
9D0069A8  24C60032   ADDIU A2, A2, 50
9D0069AC  40835800   MTC0 V1, Compare
9D0069B0  000000C0   EHB
9D0069B4  41636020   EI V1
9D0069B8  8C430008   LW V1, 8(V0)
9D0069BC  8CF904F8   LW T9, 1272(A3)
9D0069C0  24630001   ADDIU V1, V1, 1
9D0069C4  AC430008   SW V1, 8(V0)
9D0069C8  1320000D   BEQ T9, ZERO, 0x9D006A00
9D0069CC  8FBF0004   LW RA, 4(SP)
9D0069D0  8C450004   LW A1, 4(V0)
9D0069D4  03200008   JR T9
9D0069D8  27BD0008   ADDIU SP, SP, 8
9D0069DC  40865800   MTC0 A2, Compare
9D0069E0  000000C0   EHB
9D0069E4  41636020   EI V1
9D0069E8  8C430008   LW V1, 8(V0)
9D0069EC  8CF904F8   LW T9, 1272(A3)
9D0069F0  24630001   ADDIU V1, V1, 1
9D0069F4  AC430008   SW V1, 8(V0)
9D0069F8  1720FFF5   BNE T9, ZERO, 0x9D0069D0
9D0069FC  8FBF0004   LW RA, 4(SP)
9D006A00  03E00008   JR RA
9D006A04  27BD0008   ADDIU SP, SP, 8
9D0075F0  27BDFFF8   ADDIU SP, SP, -8
9D0075F4  AFBF0004   SW RA, 4(SP)
9D0075F8  40026800   MFC0 V0, Cause
9D0075FC  3C030800   LUI V1, 2048
9D007600  00431025   OR V0, V0, V1
9D007604  40826800   MTC0 V0, Cause
9D007608  000000C0   EHB
9D00760C  3C03BF88   LUI V1, -16504
9D007610  24040001   ADDIU A0, ZERO, 1
9D007614  AC641064   SW A0, 4196(V1)
9D007618  00001025   OR V0, ZERO, ZERO
9D00761C  40824800   MTC0 V0, Count
9D007620  000000C0   EHB
9D007624  3C02A000   LUI V0, -24576
9D007628  8C420504   LW V0, 1284(V0)
9D00762C  40825800   MTC0 V0, Compare
9D007630  000000C0   EHB
9D007634  40026800   MFC0 V0, Cause
9D007638  7C02DEC4   INS V0, ZERO, 27, 1
9D00763C  40826800   MTC0 V0, Cause
9D007640  000000C0   EHB
9D007644  8FBF0004   LW RA, 4(SP)
9D007648  AC641068   SW A0, 4200(V1)
9D00764C  03E00008   JR RA
9D007650  27BD0008   ADDIU SP, SP, 8
9D007BF4  00041880   SLL V1, A0, 2
9D007BF8  00642021   ADDU A0, V1, A0
9D007BFC  00041900   SLL V1, A0, 4
9D007C00  00642023   SUBU A0, V1, A0
9D007C04  00041900   SLL V1, A0, 4
9D007C08  00641823   SUBU V1, V1, A0
9D007C0C  27BDFFF8   ADDIU SP, SP, -8
9D007C10  00031940   SLL V1, V1, 5
9D007C14  AFBF0004   SW RA, 4(SP)
9D007C18  40044800   MFC0 A0, Count
9D007C1C  40024800   MFC0 V0, Count
9D007C20  00441023   SUBU V0, V0, A0
9D007C24  0043102B   SLTU V0, V0, V1
9D007C28  1440FFFC   BNE V0, ZERO, 0x9D007C1C
9D007C2C  8FBF0004   LW RA, 4(SP)
9D007C30  03E00008   JR RA
9D007C34  27BD0008   ADDIU SP, SP, 8
9D007D04  27BDFFF8   ADDIU SP, SP, -8
9D007D08  AFBF0004   SW RA, 4(SP)
9D007D0C  40026800   MFC0 V0, Cause
9D007D10  3C030800   LUI V1, 2048
9D007D14  00431025   OR V0, V0, V1
9D007D18  40826800   MTC0 V0, Cause
9D007D1C  000000C0   EHB
9D007D20  8FBF0004   LW RA, 4(SP)
9D007D24  3C02A000   LUI V0, -24576
9D007D28  244304F8   ADDIU V1, V0, 1272
9D007D2C  34048CA0   ORI A0, ZERO, -29536
9D007D30  AC64000C   SW A0, 12(V1)
9D007D34  AC600008   SW ZERO, 8(V1)
9D007D38  AC4004F8   SW ZERO, 1272(V0)
9D007D3C  03E00008   JR RA
9D007D40  27BD0008   ADDIU SP, SP, 8
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/peripheral/clk/plib_clk.c  -----------------
1:                   /*******************************************************************************
2:                     SYS CLK Static Functions for Clock System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_clk.c
9:                   
10:                    Summary:
11:                      SYS CLK static function implementations for the Clock System Service.
12:                  
13:                    Description:
14:                      The Clock System Service provides a simple interface to manage the
15:                      oscillators on Microchip microcontrollers. This file defines the static
16:                      implementation for the Clock System Service.
17:                  
18:                    Remarks:
19:                      Static functions incorporate all system clock configuration settings as
20:                      determined by the user via the Microchip Harmony Configurator GUI.
21:                      It provides static version of the routines, eliminating the need for an
22:                      object ID or object handle.
23:                  
24:                      Static single-open interfaces also eliminate the need for the open handle.
25:                  
26:                  *******************************************************************************/
27:                  
28:                  /*******************************************************************************
29:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
30:                  *
31:                  * Subject to your compliance with these terms, you may use Microchip software
32:                  * and any derivatives exclusively with Microchip products. It is your
33:                  * responsibility to comply with third party license terms applicable to your
34:                  * use of third party software (including open source software) that may
35:                  * accompany Microchip software.
36:                  *
37:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
38:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
39:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
40:                  * PARTICULAR PURPOSE.
41:                  *
42:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
43:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
44:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
45:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
46:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
47:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
48:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
49:                  *******************************************************************************/
50:                  
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  // Section: Include Files
54:                  // *****************************************************************************
55:                  // *****************************************************************************
56:                  
57:                  #include "device.h"
58:                  #include "plib_clk.h"
59:                  
60:                  // *****************************************************************************
61:                  // *****************************************************************************
62:                  // Section: File Scope Functions
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  
66:                  // *****************************************************************************
67:                  /* Function:
68:                      void CLK_Initialize( void )
69:                  
70:                    Summary:
71:                      Initializes hardware and internal data structure of the System Clock.
72:                  
73:                    Description:
74:                      This function initializes the hardware and internal data structure of System
75:                      Clock Service.
76:                  
77:                    Remarks:
78:                      This is configuration values for the static version of the Clock System
79:                      Service module is determined by the user via the MHC GUI.
80:                  
81:                      The objective is to eliminate the user's need to be knowledgeable in the
82:                      function of the 'configuration bits' to configure the system oscillators.
83:                  */
84:                  
85:                  void CLK_Initialize( void )
86:                  {
87:                  
88:                      /* Code for fuse settings can be found in "initialization.c" */
89:                      
90:                  
91:                  
92:                      /* Peripheral Module Disable Configuration */
93:                      PMD1 = 0x101100;
94:                      PMD2 = 0x7;
95:                      PMD3 = 0x1f001f;
96:                      PMD4 = 0x19;
97:                      PMD5 = 0x30200;
98:                      PMD6 = 0x10001;
99:                  }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D007B18  3C030010   LUI V1, 16
9D007B1C  3C02BF81   LUI V0, -16511
9D007B20  24631100   ADDIU V1, V1, 4352
9D007B24  AC43F240   SW V1, -3520(V0)
9D007B28  24030007   ADDIU V1, ZERO, 7
9D007B2C  AC43F250   SW V1, -3504(V0)
9D007B30  3C03001F   LUI V1, 31
9D007B34  2463001F   ADDIU V1, V1, 31
9D007B38  AC43F260   SW V1, -3488(V0)
9D007B3C  24030019   ADDIU V1, ZERO, 25
9D007B40  AC43F270   SW V1, -3472(V0)
9D007B44  3C030003   LUI V1, 3
9D007B48  24630200   ADDIU V1, V1, 512
9D007B4C  AC43F280   SW V1, -3456(V0)
9D007B50  3C030001   LUI V1, 1
9D007B54  24630001   ADDIU V1, V1, 1
9D007B58  AC43F290   SW V1, -3440(V0)
9D007B5C  03E00008   JR RA
9D007B60  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/osal/osal_impl_basic.h  --------------------
1:                   /*******************************************************************************
2:                     Operating System Abstraction Layer Basic Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       osal_impl_basic.h
9:                   
10:                    Summary:
11:                      Header file for the OSAL Basic implementation.
12:                  
13:                    Description:
14:                      This file defines the additions or variations to the OSAL base implementation.
15:                   Where it is logical or possible to implement an OSAL function in a simple form
16:                   without an RTOS being present then the function has been defined here and
17:                   implemented either here as an inline or #define. Longer functions that are part
18:                   of the basic implementation may also be found in the file osal.c
19:                   The best way to consider this file is detailing any deviations from the osal.h
20:                   definitions OR as the complete implementation of those functions when pretending
21:                   to support BASIC operations.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
27:                  *
28:                  * Subject to your compliance with these terms, you may use Microchip software
29:                  * and any derivatives exclusively with Microchip products. It is your
30:                  * responsibility to comply with third party license terms applicable to your
31:                  * use of third party software (including open source software) that may
32:                  * accompany Microchip software.
33:                  *
34:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
35:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
36:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
37:                  * PARTICULAR PURPOSE.
38:                  *
39:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
40:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
41:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
42:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
43:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
44:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
45:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  #ifndef OSAL_IMPL_BASIC_H
50:                  #define OSAL_IMPL_BASIC_H
51:                  
52:                  #ifdef __cplusplus
53:                  extern "C" {
54:                  #endif
55:                  
56:                  // *****************************************************************************
57:                  // *****************************************************************************
58:                  // Section: Included Files
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  #include <stdint.h>
62:                  #include <stdbool.h>
63:                  #include <stdlib.h>
64:                  #include "system/int/sys_int.h"
65:                  #include "device.h"
66:                  
67:                  
68:                  typedef uint8_t                     OSAL_SEM_HANDLE_TYPE;
69:                  typedef uint8_t                     OSAL_MUTEX_HANDLE_TYPE;
70:                  typedef uint32_t                    OSAL_CRITSECT_DATA_TYPE;
71:                  #define OSAL_WAIT_FOREVER           (uint16_t) 0xFFFF
72:                  
73:                  #define OSAL_SEM_DECLARE(semID)         uint8_t    semID
74:                  #define OSAL_MUTEX_DECLARE(mutexID)     uint8_t    mutexID
75:                  
76:                  // *****************************************************************************
77:                  /* Macro: OSAL_ASSERT
78:                   */
79:                  
80:                  #define OSAL_ASSERT(test, message)      test
81:                  
82:                  // *****************************************************************************
83:                  /* OSAL Result type
84:                  
85:                    Summary:
86:                      Enumerated type representing the general return value from OSAL functions.
87:                  
88:                    Description:
89:                      This enum represents possible return types from OSAL functions.
90:                  
91:                    Remarks:
92:                      These enum values are the possible return values from OSAL functions
93:                      where a standard success/fail type response is required. The majority
94:                      of OSAL functions will return this type with a few exceptions.
95:                  */
96:                  
97:                  typedef enum OSAL_SEM_TYPE
98:                  {
99:                    OSAL_SEM_TYPE_BINARY,
100:                   OSAL_SEM_TYPE_COUNTING
101:                 } OSAL_SEM_TYPE;
102:                 
103:                 typedef enum OSAL_CRIT_TYPE
104:                 {
105:                   OSAL_CRIT_TYPE_LOW,
106:                   OSAL_CRIT_TYPE_HIGH
107:                 } OSAL_CRIT_TYPE;
108:                 
109:                 typedef enum OSAL_RESULT
110:                 {
111:                   OSAL_RESULT_NOT_IMPLEMENTED = -1,
112:                   OSAL_RESULT_FALSE = 0,
113:                   OSAL_RESULT_TRUE = 1
114:                 } OSAL_RESULT;
115:                 
116:                 // *****************************************************************************
117:                 // *****************************************************************************
118:                 // Section: Section: Interface Routines Group Declarations
119:                 // *****************************************************************************
120:                 // *****************************************************************************
121:                 __STATIC_INLINE OSAL_RESULT OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE* semID, OSAL_SEM_TYPE type, uint8_t maxCount, uint8_t initialCount);
122:                 __STATIC_INLINE OSAL_RESULT OSAL_SEM_Delete(OSAL_SEM_HANDLE_TYPE* semID);
123:                 __STATIC_INLINE OSAL_RESULT OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE* semID, uint16_t waitMS);
124:                 __STATIC_INLINE OSAL_RESULT OSAL_SEM_Post(OSAL_SEM_HANDLE_TYPE* semID);
125:                 __STATIC_INLINE OSAL_RESULT OSAL_SEM_PostISR(OSAL_SEM_HANDLE_TYPE* semID);
126:                 __STATIC_INLINE uint8_t OSAL_SEM_GetCount(OSAL_SEM_HANDLE_TYPE* semID);
127:                 
128:                 __STATIC_INLINE OSAL_CRITSECT_DATA_TYPE OSAL_CRIT_Enter(OSAL_CRIT_TYPE severity);
129:                 __STATIC_INLINE void OSAL_CRIT_Leave(OSAL_CRIT_TYPE severity, OSAL_CRITSECT_DATA_TYPE status);
130:                 
131:                 __STATIC_INLINE OSAL_RESULT OSAL_MUTEX_Create(OSAL_MUTEX_HANDLE_TYPE* mutexID);
132:                 __STATIC_INLINE OSAL_RESULT OSAL_MUTEX_Delete(OSAL_MUTEX_HANDLE_TYPE* mutexID);
133:                 __STATIC_INLINE OSAL_RESULT OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE* mutexID, uint16_t waitMS);
134:                 __STATIC_INLINE OSAL_RESULT OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE* mutexID);
135:                 
136:                 __STATIC_INLINE void* OSAL_Malloc(size_t size);
137:                 __STATIC_INLINE void OSAL_Free(void* pData);
138:                 
139:                 OSAL_RESULT OSAL_Initialize(void);
140:                 
141:                 __STATIC_INLINE const char* OSAL_Name(void);
142:                 
143:                 // *****************************************************************************
144:                 // *****************************************************************************
145:                 // Section: Interface Routines Group Defintions
146:                 // *****************************************************************************
147:                 // *****************************************************************************
148:                 
149:                 /* Critical Section group */
150:                 // *****************************************************************************
151:                 /* Function: OSAL_CRITSECT_DATA_TYPE OSAL_CRIT_Enter(OSAL_CRIT_TYPE severity)
152:                  */
153:                 static OSAL_CRITSECT_DATA_TYPE OSAL_CRIT_Enter(OSAL_CRIT_TYPE severity)
154:                 {
155:                   if(severity == OSAL_CRIT_TYPE_LOW)
156:                     return (0);
157:                   /*if priority is set to HIGH the user wants interrupts disabled*/
158:                   return (SYS_INT_Disable());
159:                 }
160:                 
161:                 // *****************************************************************************
162:                 /* Function: void OSAL_CRIT_Leave(OSAL_CRIT_TYPE severity, OSAL_CRITSECT_DATA_TYPE status)
163:                  */
164:                 static void OSAL_CRIT_Leave(OSAL_CRIT_TYPE severity, OSAL_CRITSECT_DATA_TYPE status)
165:                 {
166:                   if(severity == OSAL_CRIT_TYPE_LOW)
167:                     return;
168:                   /*if priority is set to HIGH the user wants interrupts re-enabled to the state
169:                   they were before disabling.*/
170:                   SYS_INT_Restore(status);
171:                 }
172:                 
173:                 // *****************************************************************************
174:                 /* Function: OSAL_RESULT OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE semID, OSAL_SEM_TYPE type,
175:                                                 uint8_t maxCount, uint8_t initialCount)
176:                  */
177:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE* semID, OSAL_SEM_TYPE type,
178:                                                 uint8_t maxCount, uint8_t initialCount)
179:                 {
180:                   OSAL_CRITSECT_DATA_TYPE IntState;
181:                 
182:                   IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
183:                 
184:                   if (type == OSAL_SEM_TYPE_COUNTING)
185:                     *semID = initialCount;
186:                   else
187:                     *semID = 1;
188:                 
189:                   OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
190:                 
191:                   return OSAL_RESULT_TRUE;
192:                 }
193:                 
194:                 // *****************************************************************************
195:                 /* Function: OSAL_RESULT OSAL_SEM_Delete(OSAL_SEM_HANDLE_TYPE semID)
196:                  */
197:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Delete(OSAL_SEM_HANDLE_TYPE* mutexID)
198:                 {
199:                    return (OSAL_RESULT_TRUE);
200:                 }
201:                 
202:                 // *****************************************************************************
203:                 /* Function: OSAL_RESULT OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE semID, uint16_t waitMS)
204:                  */
205:                 static  OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE* semID, uint16_t waitMS)
206:                 {
207:                   OSAL_CRITSECT_DATA_TYPE IntState;
208:                 
209:                   IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
210:                 
211:                   if (*semID > 0)
212:                   {
213:                     (*semID)--;
214:                     OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
215:                 
216:                     return OSAL_RESULT_TRUE;
217:                   }
218:                 
219:                   OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
220:                 
221:                   return OSAL_RESULT_FALSE;
222:                 }
223:                 
224:                 // *****************************************************************************
225:                 /* Function: OSAL_RESULT OSAL_SEM_Post(OSAL_SEM_HANDLE_TYPE semID)
226:                  */
227:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Post(OSAL_SEM_HANDLE_TYPE* semID)
228:                 {
229:                   OSAL_CRITSECT_DATA_TYPE IntState;
230:                 
231:                   IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
232:                   (*semID)++;
233:                   OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
234:                 
235:                   return OSAL_RESULT_TRUE;
236:                 }
237:                 
238:                 // *****************************************************************************
239:                 /* Function: OSAL_RESULT OSAL_SEM_PostISR(OSAL_SEM_HANDLE_TYPE semID)
240:                  */
241:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_PostISR(OSAL_SEM_HANDLE_TYPE* semID)
242:                 {
243:                   (*semID)++;
244:                   return OSAL_RESULT_TRUE;
245:                 }
246:                 
247:                 // *****************************************************************************
248:                 /* Function: uint8_t OSAL_SEM_GetCount(OSAL_SEM_HANDLE_TYPE semID)
249:                  */
250:                 static uint8_t __attribute__((always_inline)) OSAL_SEM_GetCount(OSAL_SEM_HANDLE_TYPE* semID)
251:                 {
252:                   return *semID;
253:                 }
254:                 
255:                 // *****************************************************************************
256:                 /* Function: OSAL_RESULT OSAL_MUTEX_Create(OSAL_MUTEX_HANDLE_TYPE mutexID)
257:                  */
258:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Create(OSAL_MUTEX_HANDLE_TYPE* mutexID)
259:                 {
260:                   *mutexID = 1;
261:                   return OSAL_RESULT_TRUE;
262:                 }
263:                 
264:                 // *****************************************************************************
265:                 /* Function: OSAL_RESULT OSAL_MUTEX_Delete(OSAL_MUTEX_HANDLE_TYPE mutexID)
266:                  */
267:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Delete(OSAL_MUTEX_HANDLE_TYPE* mutexID)
268:                 {
269:                   return (OSAL_RESULT_TRUE);
270:                 }
271:                 // *****************************************************************************
272:                 /* Function: OSAL_RESULT OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE mutexID, uint16_t waitMS)
273:                  */
274:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE* mutexID, uint16_t waitMS)
275:                 {
276:                   if (*mutexID == 1)
277:                   {
278:                     *mutexID = 0;
279:                     return OSAL_RESULT_TRUE;
280:                   }
281:                   return OSAL_RESULT_FALSE;
282:                 }
283:                 
284:                 // *****************************************************************************
285:                 /* Function: OSAL_RESULT OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE mutexID)
286:                  */
287:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE* mutexID)
288:                 {
289:                   *mutexID = 1;
290:                   return OSAL_RESULT_TRUE;
291:                 }
292:                 
293:                 // *****************************************************************************
294:                 /* Function: void* OSAL_Malloc(size_t size)
295:                  */
296:                 static void* __attribute__((always_inline)) OSAL_Malloc(size_t size)
297:                 {
298:                     return malloc(size);
299:                 }
300:                 
301:                 // *****************************************************************************
302:                 /* Function: void OSAL_Free(void* pData)
303:                  */
304:                 static void __attribute__((always_inline)) OSAL_Free(void* pData)
305:                 {
306:                     free(pData);
307:                 }
308:                 
309:                 // Initialization and Diagnostics
310:                 // *****************************************************************************
311:                 /* Function: OSAL_RESULT OSAL_Initialize()
312:                  */
313:                 #define OSAL_Initialize()
314:                 
315:                 
316:                 // *****************************************************************************
317:                 /* Function: const char* OSAL_Name()
318:                  */
319:                 static const char* __attribute__((always_inline)) OSAL_Name(void)
320:                 {
321:                   return((const char*) "BASIC");
322:                 }
323:                 
324:                 
325:                 #ifdef __cplusplus
326:                 }
327:                 #endif
328:                 
329:                 #endif // _OSAL_IMPL_BASIC_H
330:                 
331:                 /*******************************************************************************
332:                  End of File
333:                  */
334:                 
335:                 
336:                 
337:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
0000000C  00000000   NOP
00000040  00000000   NOP
00000090  00000000   NOP
0000009C  00000000   NOP
000000BC  00000000   NOP
000000C8  00000000   NOP
000000F4  00000000   NOP
0000010C  00000000   NOP
00000110  00000000   NOP
0000014C  00000000   NOP
00000154  00000000   NOP
00000158  00000000   NOP
00000164  00000000   NOP
0000016C  00000000   NOP
00000188  00000000   NOP
0000018C  00000000   NOP
00000194  00000000   NOP
0000019C  00000000   NOP
000001A0  00000000   NOP
000001AC  00000000   NOP
000001B4  00000000   NOP
000001BC  00000000   NOP
000001C0  00000000   NOP
9D0033B0  24020001   ADDIU V0, ZERO, 1
9D0033B4  A2220030   SB V0, 48(S1)
9D0033B8  8FBF0034   LW RA, 52(SP)
9D0033BC  00001025   OR V0, ZERO, ZERO
9D0033F4  92230030   LBU V1, 48(S1)
9D0033F8  24020001   ADDIU V0, ZERO, 1
9D0033FC  50620012   BEQL V1, V0, DRV_USBFS_DEVICE_IRPSubmit::OSAL_MUTEX_Lock
9D003400  8E240028   LW A0, 40(S1)
9D003404  2402FF81   ADDIU V0, ZERO, -127
9D003440  1000FFDC   BEQ ZERO, ZERO, 0x9D0033B4
9D003444  24020001   ADDIU V0, ZERO, 1
9D003448  A2200030   SB ZERO, 48(S1)
9D00344C  0F401E8B   JAL SYS_INT_SourceDisable
9D003450  AFA60010   SW A2, 16(SP)
9D0034BC  90830030   LBU V1, 48(A0)
9D0034C0  24020001   ADDIU V0, ZERO, 1
9D0034C4  5462FFD0   BNEL V1, V0, 0x9D003408
9D0034C8  2402FF81   ADDIU V0, ZERO, -127
9D0034CC  8E240028   LW A0, 40(S1)
9D0034D0  A2200030   SB ZERO, 48(S1)
9D0034D4  0F401E8B   JAL SYS_INT_SourceDisable
9D003634  24020001   ADDIU V0, ZERO, 1
9D00363C  8FBF002C   LW RA, 44(SP)
9D003640  00001025   OR V0, ZERO, ZERO
9D003660  90840030   LBU A0, 48(A0)
9D003664  24030001   ADDIU V1, ZERO, 1
9D003668  1083002F   BEQ A0, V1, 0x9D003728
9D00366C  2402FF81   ADDIU V0, ZERO, -127
9D003670  8FBF002C   LW RA, 44(SP)
9D003720  1000FFC5   BEQ ZERO, ZERO, 0x9D003638
9D003724  24020001   ADDIU V0, ZERO, 1
9D003728  8E240028   LW A0, 40(S1)
9D00372C  A2200030   SB ZERO, 48(S1)
9D003730  0F401E8B   JAL SYS_INT_SourceDisable
9D003BF0  24050001   ADDIU A1, ZERO, 1
9D003BF4  10450012   BEQ V0, A1, 0x9D003C40
9D003BF8  2411FFA0   ADDIU S1, ZERO, -96
9D003BFC  8FBF0024   LW RA, 36(SP)
9D003C40  3C05A000   LUI A1, -24576
9D003C44  24A50554   ADDIU A1, A1, 1364
9D003C4C  29080002   SLTI T0, T0, 2
9D003C78  2411FF80   ADDIU S1, ZERO, -128
9D003C7C  A3828035   SB V0, -32715(GP)
9D003C80  8FB30020   LW S3, 32(SP)
9D003C84  02201025   OR V0, S1, ZERO
9D003C88  8FB2001C   LW S2, 28(SP)
9D003CC8  0F4000D6   JAL SYS_INT_Disable
9D003CD0  8E030034   LW V1, 52(S0)
9D003CD4  00402025   OR A0, V0, ZERO
9D003CE0  0F4000E2   JAL SYS_INT_Restore
9D003CE4  00000000   NOP
9D003CE8  AE510000   SW S1, 0(S2)
9D003D04  24020001   ADDIU V0, ZERO, 1
9D003D08  1000FFBC   BEQ ZERO, ZERO, 0x9D003BFC
9D003D0C  A3828035   SB V0, -32715(GP)
9D003D10  0F4000D6   JAL SYS_INT_Disable
9D003D18  8E030034   LW V1, 52(S0)
9D003D1C  00402025   OR A0, V0, ZERO
9D003D28  0F4000E2   JAL SYS_INT_Restore
9D003D30  2402FFFF   ADDIU V0, ZERO, -1
9D003D38  24020001   ADDIU V0, ZERO, 1
9D003D3C  1000FFAF   BEQ ZERO, ZERO, 0x9D003BFC
9D003E2C  90840030   LBU A0, 48(A0)
9D003E30  24030001   ADDIU V1, ZERO, 1
9D003E34  1083003C   BEQ A0, V1, 0x9D003F28
9D003E38  2402FF81   ADDIU V0, ZERO, -127
9D003E3C  8FBF002C   LW RA, 44(SP)
9D003E40  8FB40028   LW S4, 40(SP)
9D003E44  8FB30024   LW S3, 36(SP)
9D003E48  8FB20020   LW S2, 32(SP)
9D003E4C  8FB1001C   LW S1, 28(SP)
9D003EDC  24020001   ADDIU V0, ZERO, 1
9D003EE4  8FBF002C   LW RA, 44(SP)
9D003EE8  00001025   OR V0, ZERO, ZERO
9D003F20  1000FFEF   BEQ ZERO, ZERO, 0x9D003EE0
9D003F24  24020001   ADDIU V0, ZERO, 1
9D003F28  8E240028   LW A0, 40(S1)
9D003F2C  A2200030   SB ZERO, 48(S1)
9D003F30  0F401E8B   JAL SYS_INT_SourceDisable
9D004198  24030001   ADDIU V1, ZERO, 1
9D00419C  10430009   BEQ V0, V1, 0x9D0041C4
9D0041A0  2411FFA0   ADDIU S1, ZERO, -96
9D0041A4  8FBF0024   LW RA, 36(SP)
9D0041A8  02201025   OR V0, S1, ZERO
9D0041AC  8FB30020   LW S3, 32(SP)
9D0041B0  8FB2001C   LW S2, 28(SP)
9D0041B4  8FB10018   LW S1, 24(SP)
9D0041B8  8FB00014   LW S0, 20(SP)
9D0041BC  03E00008   JR RA
9D0041C0  27BD0028   ADDIU SP, SP, 40
9D0041C4  3C03A000   LUI V1, -24576
9D0041D0  29080002   SLTI T0, T0, 2
9D0041FC  2411FF80   ADDIU S1, ZERO, -128
9D004200  A3828035   SB V0, -32715(GP)
9D004204  8FB30020   LW S3, 32(SP)
9D004254  0F4000D6   JAL SYS_INT_Disable
9D00425C  8E030038   LW V1, 56(S0)
9D004260  00402025   OR A0, V0, ZERO
9D00426C  0F4000E2   JAL SYS_INT_Restore
9D004270  00000000   NOP
9D004274  AE710000   SW S1, 0(S3)
9D004290  24020001   ADDIU V0, ZERO, 1
9D004294  1000FFC3   BEQ ZERO, ZERO, 0x9D0041A4
9D004298  A3828035   SB V0, -32715(GP)
9D00429C  0F4000D6   JAL SYS_INT_Disable
9D0042A4  8E030038   LW V1, 56(S0)
9D0042A8  00402025   OR A0, V0, ZERO
9D0042B4  0F4000E2   JAL SYS_INT_Restore
9D0042B8  00000000   NOP
9D0042BC  2402FFFF   ADDIU V0, ZERO, -1
9D0042C4  24020001   ADDIU V0, ZERO, 1
9D0042C8  1000FFB6   BEQ ZERO, ZERO, 0x9D0041A4
9D0042CC  A3828035   SB V0, -32715(GP)
9D0045BC  24020001   ADDIU V0, ZERO, 1
9D0045C4  8FBF002C   LW RA, 44(SP)
9D0045C8  00001025   OR V0, ZERO, ZERO
9D0045E8  90840030   LBU A0, 48(A0)
9D0045EC  24030001   ADDIU V1, ZERO, 1
9D0045F0  10830010   BEQ A0, V1, 0x9D004634
9D0045F4  2402FF81   ADDIU V0, ZERO, -127
9D0045F8  8FBF002C   LW RA, 44(SP)
9D004620  1000FFE7   BEQ ZERO, ZERO, 0x9D0045C0
9D004624  24020001   ADDIU V0, ZERO, 1
9D004634  8E240028   LW A0, 40(S1)
9D004638  A2200030   SB ZERO, 48(S1)
9D00463C  0F401E8B   JAL SYS_INT_SourceDisable
9D004FB8  24900400   ADDIU S0, A0, 1024
9D004FBC  A2020030   SB V0, 48(S0)
9D004FDC  3C02A000   LUI V0, -24576
9D005B88  24020001   ADDIU V0, ZERO, 1
9D005B8C  A2220030   SB V0, 48(S1)
9D005B90  8FBF0024   LW RA, 36(SP)
9D005B94  00001025   OR V0, ZERO, ZERO
9D005BA8  90840030   LBU A0, 48(A0)
9D005BAC  24030001   ADDIU V1, ZERO, 1
9D005BB0  1083000A   BEQ A0, V1, 0x9D005BDC
9D005BB4  2402FF81   ADDIU V0, ZERO, -127
9D005BB8  8FBF0024   LW RA, 36(SP)
9D005BBC  8FB20020   LW S2, 32(SP)
9D005BC0  8FB1001C   LW S1, 28(SP)
9D005BD4  1000FFED   BEQ ZERO, ZERO, 0x9D005B8C
9D005BD8  24020001   ADDIU V0, ZERO, 1
9D005BDC  8E240028   LW A0, 40(S1)
9D005BE0  A2200030   SB ZERO, 48(S1)
9D005BE4  0F401E8B   JAL SYS_INT_SourceDisable
9D008400  A3828035   SB V0, -32715(GP)
9D008404  A3828034   SB V0, -32716(GP)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/exceptions.c  ------------------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Exceptions Source File
3:                   
4:                     File Name:
5:                       exceptions.c
6:                   
7:                     Summary:
8:                       This file contains a function which overrides the default _weak_ exception
9:                       handler provided by the XC32 compiler.
10:                  
11:                    Description:
12:                      This file redefines the default _weak_  exception handler with a more debug
13:                      friendly one. If an unexpected exception occurs the code will stop in a
14:                      while(1) loop.  The debugger can be halted and two variables _excep_code and
15:                      _except_addr can be examined to determine the cause and address where the
16:                      exception occurred.
17:                   *******************************************************************************/
18:                  
19:                  // DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
22:                  *
23:                  * Subject to your compliance with these terms, you may use Microchip software
24:                  * and any derivatives exclusively with Microchip products. It is your
25:                  * responsibility to comply with third party license terms applicable to your
26:                  * use of third party software (including open source software) that may
27:                  * accompany Microchip software.
28:                  *
29:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
31:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
32:                  * PARTICULAR PURPOSE.
33:                  *
34:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                  *******************************************************************************/
42:                  // DOM-IGNORE-END
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Section: Included Files
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  #include "configuration.h"
50:                  #include "device.h"
51:                  #include "definitions.h"
52:                  #include <stdio.h>
53:                  
54:                  
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  // Section: Global Data Definitions
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  
61:                  /*******************************************************************************
62:                    Exception Reason Data
63:                  
64:                    <editor-fold defaultstate="expanded" desc="Exception Reason Data">
65:                  
66:                    Remarks:
67:                      These global static items are used instead of local variables in the
68:                      _general_exception_handler function because the stack may not be available
69:                      if an exception has occured.
70:                  */
71:                  
72:                  /* Address of instruction that caused the exception. */
73:                  static unsigned int _excep_addr;
74:                  
75:                  /* Enum identifying the cause */
76:                  typedef enum {
77:                      EXCEP_IRQ      =  0, // interrupt
78:                      EXCEP_AdEL     =  4, // address error exception (load or ifetch)
79:                      EXCEP_AdES     =  5, // address error exception (store)
80:                      EXCEP_IBE      =  6, // bus error (ifetch)
81:                      EXCEP_DBE      =  7, // bus error (load/store)
82:                      EXCEP_Sys      =  8, // syscall
83:                      EXCEP_Bp       =  9, // breakpoint
84:                      EXCEP_RI       = 10, // reserved instruction
85:                      EXCEP_CpU      = 11, // coprocessor unusable
86:                      EXCEP_Overflow = 12, // arithmetic overflow
87:                      EXCEP_Trap     = 13, // trap (possible divide by zero)
88:                      EXCEP_IS1      = 16, // implementation specfic 1
89:                      EXCEP_CEU      = 17, // CorExtend Unuseable
90:                      EXCEP_C2E      = 18, // coprocessor 2
91:                  } excep_code;
92:                  
93:                  /* Code identifying the cause of the exception (CP0 Cause register). */
94:                  static excep_code _excep_code;
95:                  
96:                  // </editor-fold>
97:                  
98:                  /*******************************************************************************
99:                    Function:
100:                     void _general_exception_handler ( void )
101:                 
102:                   Description:
103:                     A general exception is any non-interrupt exception which occurs during program
104:                     execution outside of bootstrap code.
105:                 
106:                   Remarks:
107:                     Refer to the XC32 User's Guide for additional information.
108:                  */
109:                 
110:                 void __attribute__((noreturn)) _general_exception_handler ( void )
111:                 {
112:                     /* Mask off the ExcCode Field from the Cause Register
113:                     Refer to the MIPs Software User's manual */
114:                     _excep_code = (_CP0_GET_CAUSE() & 0x0000007C) >> 2;
115:                     _excep_addr = _CP0_GET_EPC();
116:                 
117:                     while (1)
118:                     {
119:                         #if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
120:                             __builtin_software_breakpoint();
121:                         #endif
122:                     }
123:                 }
124:                 
125:                 /*******************************************************************************
126:                   Function:
127:                     void _bootstrap_exception_handler ( void )
128:                 
129:                   Description:
130:                     A bootstrap exception is any exception which occurs while bootstrap code is
131:                     running (STATUS.BEV bit is 1).
132:                 
133:                   Remarks:
134:                     Refer to the XC32 User's Guide for additional information.
135:                  */
136:                 
137:                 void __attribute__((noreturn)) _bootstrap_exception_handler(void)
138:                 {
139:                     /* Mask off the ExcCode Field from the Cause Register
140:                     Refer to the MIPs Software User's manual */
141:                     _excep_code = (_CP0_GET_CAUSE() & 0x0000007C) >> 2;
142:                     _excep_addr = _CP0_GET_EPC();
143:                 
144:                     while (1)
145:                     {
146:                         #if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
147:                             __builtin_software_breakpoint();
148:                         #endif
149:                     }
150:                 }
151:                 /*******************************************************************************
152:                  End of File
153:                 */
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0083B4  27BDFFF8   ADDIU SP, SP, -8
9D0083B8  AFBF0004   SW RA, 4(SP)
9D0083BC  40026800   MFC0 V0, Cause
9D0083C0  40027000   MFC0 V0, EPC
9D0083C4  7000003F   SDBBP 0
9D0083C8  7000003F   SDBBP 0
9D0083CC  1000FFFD   BEQ ZERO, ZERO, 0x9D0083C4
9D0083D0  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_stopinidle_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_StopInIdle_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : StopInIdle
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_StopInIdleEnable
16:                          PLIB_USB_StopInIdleDisable
17:                          PLIB_USB_ExistsStopInIdle
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_STOPINIDLE_DEFAULT_H
48:                  #define _USB_STOPINIDLE_DEFAULT_H
49:                  
50:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
51:                  //******************************************************************************
52:                  /* Function :  USB_StopInIdleEnable_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_USB_StopInIdleEnable 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_USB_StopInIdleEnable function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void USB_StopInIdleEnable_Default( USB_MODULE_ID index )
62:                  {
63:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
64:                      usb->UxCNFG1.USBSIDL = 1;
65:                     
66:                  }
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USB_StopInIdleDisable_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_USB_StopInIdleDisable 
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_USB_StopInIdleDisable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void USB_StopInIdleDisable_Default( USB_MODULE_ID index )
79:                  {
80:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
81:                      usb->UxCNFG1.USBSIDL = 0;
82:                  }
83:                  
84:                  //******************************************************************************
85:                  /* Function :  USB_ExistsStopInIdle_Default
86:                  
87:                    Summary:
88:                      Implements Default variant of PLIB_USB_ExistsStopInIdle
89:                  
90:                    Description:
91:                      This template implements the Default variant of the PLIB_USB_ExistsStopInIdle function.
92:                  */
93:                  
94:                  #define PLIB_USB_ExistsStopInIdle PLIB_USB_ExistsStopInIdle
95:                  PLIB_TEMPLATE bool USB_ExistsStopInIdle_Default( USB_MODULE_ID index )
96:                  {
97:                      return true;
98:                  }
99:                  
100:                 
101:                 #endif /*_USB_STOPINIDLE_DEFAULT_H*/
102:                 
103:                 /******************************************************************************
104:                  End of File
105:                 */
106:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00500C  922202A0   LBU V0, 672(S1)
9D005018  7C622104   INS V0, V1, 4, 1
9D005020  90A20009   LBU V0, 9(A1)
9D00508C  A22202A0   SB V0, 672(S1)
9D005090  90A20009   LBU V0, 9(A1)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_resumesignaling_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_ResumeSignaling_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ResumeSignaling
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_ResumeSignalingEnable
16:                          PLIB_USB_ResumeSignalingDisable
17:                          PLIB_USB_ExistsResumeSignaling
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_RESUMESIGNALING_DEFAULT_H
48:                  #define _USB_RESUMESIGNALING_DEFAULT_H
49:                  
50:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_ResumeSignalingEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_ResumeSignalingEnable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_ResumeSignalingEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void USB_ResumeSignalingEnable_Default( USB_MODULE_ID index )
64:                  {
65:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
66:                  	usb->UxCON.w |=  UxCON_RESUME_MASK ;
67:                     
68:                  }
69:                  
70:                  //******************************************************************************
71:                  /* Function :  USB_ResumeSignalingDisable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_USB_ResumeSignalingDisable 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_USB_ResumeSignalingDisable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void USB_ResumeSignalingDisable_Default( USB_MODULE_ID index )
81:                  {
82:                  
83:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
84:                  	usb->UxCON.w &= ( ~ UxCON_RESUME_MASK);
85:                    
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  USB_ExistsResumeSignaling_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_USB_ExistsResumeSignaling
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_USB_ExistsResumeSignaling function.
97:                  */
98:                  
99:                  #define PLIB_USB_ExistsResumeSignaling PLIB_USB_ExistsResumeSignaling
100:                 PLIB_TEMPLATE bool USB_ExistsResumeSignaling_Default( USB_MODULE_ID index )
101:                 {
102:                     return true;
103:                 }
104:                 
105:                 
106:                 #endif /*_USB_RESUMESIGNALING_DEFAULT_H*/
107:                 
108:                 /******************************************************************************
109:                  End of File
110:                 */
111:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0081C8  8C830020   LW V1, 32(A0)
9D0081CC  8C620210   LW V0, 528(V1)
9D0081D8  03E00008   JR RA
9D0081F0  8C830020   LW V1, 32(A0)
9D0081F4  8C620210   LW V0, 528(V1)
9D008200  03E00008   JR RA
9D008204  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_packettransfer_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_PacketTransfer_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PacketTransfer
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_PacketTransferIsDisabled
16:                          PLIB_USB_PacketTransferEnable
17:                          PLIB_USB_ExistsPacketTransfer
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_PACKETTRANSFER_DEFAULT_H
48:                  #define _USB_PACKETTRANSFER_DEFAULT_H
49:                  
50:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_PacketTransferIsDisabled_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_PacketTransferIsDisabled 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_PacketTransferIsDisabled function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE bool USB_PacketTransferIsDisabled_Default( USB_MODULE_ID index )
64:                  {
65:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
66:                      return ( usb->UxCON.UxCONbits.PKTDIS_TOKBUSY );
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_PacketTransferEnable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_PacketTransferEnable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USB_PacketTransferEnable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USB_PacketTransferEnable_Default( USB_MODULE_ID index )
80:                  {
81:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
82:                      usb->UxCON.UxCONbits.TOKBUSY = 0;
83:                      
84:                  }
85:                  
86:                  //******************************************************************************
87:                  /* Function :  USB_PacketTransferDisable_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_USB_PacketTransferDisable 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_USB_PacketTransferDisable function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE void USB_PacketTransferDisable_Default( USB_MODULE_ID index )
97:                  {
98:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
99:                      usb->UxCON.UxCONbits.TOKBUSY = 1;
100:                    
101:                 }
102:                 
103:                 //******************************************************************************
104:                 /* Function :  USB_ExistsPacketTransfer_Default
105:                 
106:                   Summary:
107:                     Implements Default variant of PLIB_USB_ExistsPacketTransfer
108:                 
109:                   Description:
110:                     This template implements the Default variant of the PLIB_USB_ExistsPacketTransfer function.
111:                 */
112:                 
113:                 #define PLIB_USB_ExistsPacketTransfer PLIB_USB_ExistsPacketTransfer
114:                 PLIB_TEMPLATE bool USB_ExistsPacketTransfer_Default( USB_MODULE_ID index )
115:                 {
116:                     return true;
117:                 }
118:                 
119:                 
120:                 #endif /*_USB_PACKETTRANSFER_DEFAULT_H*/
121:                 
122:                 /******************************************************************************
123:                  End of File
124:                 */
125:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0016A0  92040210   LBU A0, 528(S0)
9D0016AC  7C042944   INS A0, ZERO, 5, 1
9D0016B8  A2040210   SB A0, 528(S0)
9D0016BC  A3C00000   SB ZERO, 0(FP)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_otg_sessionvalid_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_OTG_SessionValid_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OTG_SessionValid
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_OTG_SessionValid
16:                          PLIB_USB_ExistsOTG_SessionValid
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_OTG_SESSIONVALID_DEFAULT_H
47:                  #define _USB_OTG_SESSIONVALID_DEFAULT_H
48:                  
49:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
50:                  
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USB_OTG_SessionValid_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USB_OTG_SessionValid 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USB_OTG_SessionValid function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE bool USB_OTG_SessionValid_Default( USB_MODULE_ID index )
63:                  {
64:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
65:                  	return ( usb->UxOTGSTAT.SESVD );
66:                  }
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USB_ExistsOTG_SessionValid_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_USB_ExistsOTG_SessionValid
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_USB_ExistsOTG_SessionValid function.
76:                  */
77:                  
78:                  #define PLIB_USB_ExistsOTG_SessionValid PLIB_USB_ExistsOTG_SessionValid
79:                  PLIB_TEMPLATE bool USB_ExistsOTG_SessionValid_Default( USB_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  #endif /*_USB_OTG_SESSIONVALID_DEFAULT_H*/
86:                  
87:                  /******************************************************************************
88:                   End of File
89:                  */
90:                  
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D001590  8E020020   LW V0, 32(S0)
9D001598  14400024   BNE V0, ZERO, 0x9D00162C
9D00159C  8C820010   LW V0, 16(A0)
9D0015A0  A0800002   SB ZERO, 2(A0)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_otg_interruptstatus_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_OTG_InterruptStatus_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OTG_InterruptStatus
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_OTG_InterruptFlagSet
16:                          PLIB_USB_OTG_InterruptFlagClear
17:                          PLIB_USB_OTG_InterruptFlagGet
18:                          PLIB_USB_ExistsOTG_InterruptStatus
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USB_OTG_INTERRUPTSTATUS_DEFAULT_H
49:                  #define _USB_OTG_INTERRUPTSTATUS_DEFAULT_H
50:                  
51:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_OTG_InterruptFlagSet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_OTG_InterruptFlagSet 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptFlagSet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void USB_OTG_InterruptFlagSet_Default( USB_MODULE_ID index , USB_OTG_INTERRUPTS     interruptFlag )
64:                  {
65:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
66:                  	usb->UxOTGIR.w  |= interruptFlag ;
67:                      
68:                  }
69:                  
70:                  //******************************************************************************
71:                  /* Function :  USB_OTG_InterruptFlagClear_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_USB_OTG_InterruptFlagClear 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptFlagClear function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void USB_OTG_InterruptFlagClear_Default( USB_MODULE_ID index , USB_OTG_INTERRUPTS     interruptFlag )
81:                  {
82:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
83:                  	usb->UxOTGIR.w = interruptFlag ;
84:                  
85:                  }
86:                  
87:                  //******************************************************************************
88:                  /* Function :  USB_OTG_InterruptFlagGet_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_USB_OTG_InterruptFlagGet 
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptFlagGet function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE bool USB_OTG_InterruptFlagGet_Default( USB_MODULE_ID index , USB_OTG_INTERRUPTS     interruptFlag )
98:                  {
99:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
100:                     return (  ( ( ( usb->UxOTGIR.w  ) & ( interruptFlag) )) ? 1 : 0 );
101:                 }
102:                 
103:                 
104:                 //******************************************************************************
105:                 /* Function :  USB_ExistsOTG_InterruptStatus_Default
106:                 
107:                   Summary:
108:                     Implements Default variant of PLIB_USB_ExistsOTG_InterruptStatus
109:                 
110:                   Description:
111:                     This template implements the Default variant of the PLIB_USB_ExistsOTG_InterruptStatus function.
112:                 */
113:                 
114:                 #define PLIB_USB_ExistsOTG_InterruptStatus PLIB_USB_ExistsOTG_InterruptStatus
115:                 PLIB_TEMPLATE bool USB_ExistsOTG_InterruptStatus_Default( USB_MODULE_ID index )
116:                 {
117:                     return true;
118:                 }
119:                 
120:                 
121:                 #endif /*_USB_OTG_INTERRUPTSTATUS_DEFAULT_H*/
122:                 
123:                 /******************************************************************************
124:                  End of File
125:                 */
126:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D001180  8C900020   LW S0, 32(A0)
9D00118C  8E020000   LW V0, 0(S0)
9D001198  30420008   ANDI V0, V0, 8
9D0011B0  10400005   BEQ V0, ZERO, 0x9D0011C8
9D0011E8  240200F5   ADDIU V0, ZERO, 245
9D0011F0  8FBF004C   LW RA, 76(SP)
9D0011F4  8FBE0048   LW FP, 72(SP)
9D0011F8  8FB70044   LW S7, 68(SP)
9D0011FC  8FB60040   LW S6, 64(SP)
9D001200  8FB5003C   LW S5, 60(SP)
9D001204  8FB40038   LW S4, 56(SP)
9D001208  8FB30034   LW S3, 52(SP)
9D00120C  8FB20030   LW S2, 48(SP)
9D001220  8E020000   LW V0, 0(S0)
9D001224  30420010   ANDI V0, V0, 16
9D001240  AE020000   SW V0, 0(S0)
9D001244  8E020010   LW V0, 16(S0)
9D0015B8  24030008   ADDIU V1, ZERO, 8
9D0015BC  92420002   LBU V0, 2(S2)
9D0015C0  AE030000   SW V1, 0(S0)
9D0015C4  1000FF01   BEQ ZERO, ZERO, 0x9D0011CC
9D0015C8  00000000   NOP
9D0015CC  8E45001C   LW A1, 28(S2)
9D0015D0  00A31824   AND V1, A1, V1
9D00163C  AE050000   SW A1, 0(S0)
9D001640  1000FEE5   BEQ ZERO, ZERO, 0x9D0011D8
9D0017B8  24020008   ADDIU V0, ZERO, 8
9D0017BC  AE020000   SW V0, 0(S0)
9D0017C0  1000FE87   BEQ ZERO, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_ErrorInterruptFlagClear
9D007318  240300F5   ADDIU V1, ZERO, 245
9D007320  8C430010   LW V1, 16(V0)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_otg_interrupt_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_OTG_Interrupt_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OTG_Interrupt
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_OTG_InterruptEnable
16:                          PLIB_USB_OTG_InterruptDisable
17:                          PLIB_USB_OTG_InterruptIsEnabled
18:                          PLIB_USB_ExistsOTG_Interrupt
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USB_OTG_INTERRUPT_DEFAULT_H
49:                  #define _USB_OTG_INTERRUPT_DEFAULT_H
50:                  
51:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_OTG_InterruptEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_OTG_InterruptEnable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void USB_OTG_InterruptEnable_Default( USB_MODULE_ID index , USB_OTG_INTERRUPTS     interruptFlag )
64:                  {
65:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
66:                  	usb->UxOTGIE.w   |= interruptFlag;
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_OTG_InterruptDisable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_OTG_InterruptDisable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptDisable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USB_OTG_InterruptDisable_Default( USB_MODULE_ID index , USB_OTG_INTERRUPTS     interruptFlag )
80:                  {
81:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
82:                      usb->UxOTGIE.w   &= (~interruptFlag);
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  USB_OTG_InterruptIsEnabled_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_USB_OTG_InterruptIsEnabled 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptIsEnabled function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE bool USB_OTG_InterruptIsEnabled_Default( USB_MODULE_ID index , USB_INTERRUPTS interruptFlag )
97:                  {   
98:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
99:                      return ( ( usb->UxOTGIE.w ) & interruptFlag ? 1 : 0 );
100:                 }
101:                 
102:                 
103:                 //******************************************************************************
104:                 /* Function :  USB_ExistsOTG_Interrupt_Default
105:                 
106:                   Summary:
107:                     Implements Default variant of PLIB_USB_ExistsOTG_Interrupt
108:                 
109:                   Description:
110:                     This template implements the Default variant of the PLIB_USB_ExistsOTG_Interrupt function.
111:                 */
112:                 
113:                 #define PLIB_USB_ExistsOTG_Interrupt PLIB_USB_ExistsOTG_Interrupt
114:                 PLIB_TEMPLATE bool USB_ExistsOTG_Interrupt_Default( USB_MODULE_ID index )
115:                 {
116:                     return true;
117:                 }
118:                 
119:                 
120:                 #endif /*_USB_OTG_INTERRUPT_DEFAULT_H*/
121:                 
122:                 /******************************************************************************
123:                  End of File
124:                 */
125:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0011B8  8E020010   LW V0, 16(S0)
9D0011BC  30420008   ANDI V0, V0, 8
9D001230  8E020010   LW V0, 16(S0)
9D001234  30420010   ANDI V0, V0, 16
9D001244  8E020010   LW V0, 16(S0)
9D00124C  7C022104   INS V0, ZERO, 4, 1
9D001250  AE020010   SW V0, 16(S0)
9D001254  10600005   BEQ V1, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00139C  8E020010   LW V0, 16(S0)
9D0013A0  34420010   ORI V0, V0, 16
9D0013A4  AE020010   SW V0, 16(S0)
9D0013A8  8E0201D0   LW V0, 464(S0)
9D0072FC  2404FF0A   ADDIU A0, ZERO, -246
9D007300  7C033804   INS V1, ZERO, 0, 8
9D007304  AC4301D0   SW V1, 464(V0)
9D007320  8C430010   LW V1, 16(V0)
9D007324  00641824   AND V1, V1, A0
9D007328  AC430010   SW V1, 16(V0)
9D00732C  90430210   LBU V1, 528(V0)
9D00791C  8C830020   LW V1, 32(A0)
9D007920  8C840028   LW A0, 40(A0)
9D007924  8C620010   LW V0, 16(V1)
9D007928  34420008   ORI V0, V0, 8
9D00792C  AC620010   SW V0, 16(V1)
9D007930  0B40208C   J EVIC_SourceEnable
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_opmodeselect_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_OpModeSelect_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OpModeSelect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_OperatingModeSelect
16:                          PLIB_USB_ExistsOpModeSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_OPMODESELECT_DEFAULT_H
47:                  #define _USB_OPMODESELECT_DEFAULT_H
48:                  
49:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
50:                  
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USB_OperatingModeSelect_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USB_OperatingModeSelect
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USB_OperatingModeSelect function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void USB_OperatingModeSelect_Default( USB_MODULE_ID index , USB_OPMODES opMode )
63:                  {
64:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
65:                      usb->UxCON.UxCONbits.USBEN_SOFEN = 0;
66:                      usb->UxCON.UxCONbits.HOSTEN = 0 ;
67:                  	usb->UxOTGCON.OTGEN = 0;
68:                      switch ( opMode )
69:                      {
70:                          case USB_OPMODE_NONE:
71:                               break;
72:                  			
73:                          case USB_OPMODE_DEVICE:
74:                               usb->UxCON.UxCONbits.USBEN_SOFEN = 1; 
75:                              break;
76:                  
77:                          case USB_OPMODE_HOST:
78:                              usb->UxCON.UxCONbits.HOSTEN = 1 ;
79:                              break;
80:                  
81:                          case USB_OPMODE_OTG:
82:                              usb->UxOTGCON.OTGEN = 1;
83:                              break;
84:                  
85:                          default:
86:                              PLIB_ASSERT( 0, "In USB_OperatingModeSelect, unknown operating mode!" );
87:                              break;
88:                      }
89:                  }
90:                  
91:                  //******************************************************************************
92:                  /* Function :  USB_ExistsOpModeSelect_Default
93:                  
94:                    Summary:
95:                      Implements Default variant of PLIB_USB_ExistsOpModeSelect
96:                  
97:                    Description:
98:                      This template implements the Default variant of the PLIB_USB_ExistsOpModeSelect function.
99:                  */
100:                 
101:                 #define PLIB_USB_ExistsOpModeSelect PLIB_USB_ExistsOpModeSelect
102:                 PLIB_TEMPLATE bool USB_ExistsOpModeSelect_Default( USB_MODULE_ID index )
103:                 {
104:                     return true;
105:                 }
106:                 
107:                 
108:                 #endif /*_USB_OPMODESELECT_DEFAULT_H*/
109:                 
110:                 /******************************************************************************
111:                  End of File
112:                 */
113:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00732C  90430210   LBU V1, 528(V0)
9D007338  90430210   LBU V1, 528(V0)
9D007344  90430030   LBU V1, 48(V0)
9D007350  03E00008   JR RA
9D007458  8C820020   LW V0, 32(A0)
9D007460  90430210   LBU V1, 528(V0)
9D007464  24040001   ADDIU A0, ZERO, 1
9D007468  7C030004   INS V1, ZERO, 0, 1
9D00746C  A0430210   SB V1, 528(V0)
9D007470  90430210   LBU V1, 528(V0)
9D007474  7C0318C4   INS V1, ZERO, 3, 1
9D007478  A0430210   SB V1, 528(V0)
9D00747C  90430030   LBU V1, 48(V0)
9D007480  7C031084   INS V1, ZERO, 2, 1
9D007484  A0430030   SB V1, 48(V0)
9D007488  90430210   LBU V1, 528(V0)
9D00748C  7C830004   INS V1, A0, 0, 1
9D007490  A0430210   SB V1, 528(V0)
9D007494  240300DF   ADDIU V1, ZERO, 223
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_modulepower_32bit16bit.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_ModulePower_32Bit16Bit.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ModulePower
13:                      and its Variant : 32Bit16Bit
14:                      For following APIs :
15:                          PLIB_USB_Enable
16:                          PLIB_USB_Disable
17:                          PLIB_USB_ExistsModulePower
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_MODULEPOWER_32BIT16BIT_H
48:                  #define _USB_MODULEPOWER_32BIT16BIT_H
49:                  
50:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_Enable_32Bit16Bit
55:                  
56:                    Summary:
57:                      Implements 32Bit16Bit variant of PLIB_USB_Enable 
58:                  
59:                    Description:
60:                      This template implements the 32Bit16Bit variant of the PLIB_USB_Enable function.
61:                  */
62:                  
63:                      
64:                  PLIB_TEMPLATE void USB_Enable_32Bit16Bit( USB_MODULE_ID index )
65:                  {
66:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
67:                  	usb->UxPWRC.USBPWR = 1;
68:                      
69:                  }
70:                  
71:                  //******************************************************************************
72:                  /* Function :  USB_Disable_32Bit16Bit
73:                  
74:                    Summary:
75:                      Implements 32Bit16Bit variant of PLIB_USB_Disable 
76:                  
77:                    Description:
78:                      This template implements the 32Bit16Bit variant of the PLIB_USB_Disable function.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void USB_Disable_32Bit16Bit( USB_MODULE_ID index )
82:                  {
83:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
84:                  	usb->UxPWRC.USBPWR = 0 ;
85:                   
86:                  }
87:                  
88:                  //******************************************************************************
89:                  /* Function :  USB_ExistsModulePower_32Bit16Bit
90:                  
91:                    Summary:
92:                      Implements 32Bit16Bit variant of PLIB_USB_ExistsModulePower
93:                  
94:                    Description:
95:                      This template implements the 32Bit16Bit variant of the PLIB_USB_ExistsModulePower function.
96:                  */
97:                  
98:                  #define PLIB_USB_ExistsModulePower PLIB_USB_ExistsModulePower
99:                  PLIB_TEMPLATE bool USB_ExistsModulePower_32Bit16Bit( USB_MODULE_ID index )
100:                 {
101:                     return true;
102:                 }
103:                 
104:                 
105:                 #endif /*_USB_MODULEPOWER_32BIT16BIT_H*/
106:                 
107:                 /******************************************************************************
108:                  End of File
109:                 */
110:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000050  00000000   NOP
00000054  00000000   NOP
0000005C  00000000   NOP
00000064  00000000   NOP
0000006C  00000000   NOP
9D004FB4  92270040   LBU A3, 64(S1)
9D004FD4  7C670004   INS A3, V1, 0, 1
9D004FE8  A2270040   SB A3, 64(S1)
9D00500C  922202A0   LBU V0, 672(S1)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_lasttransactiondetails_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_LastTransactionDetails_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : LastTransactionDetails
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_LastTransactionDetailsGet
16:                          PLIB_USB_ExistsLastTransactionDetails
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_LASTTRANSACTIONDETAILS_DEFAULT_H
47:                  #define _USB_LASTTRANSACTIONDETAILS_DEFAULT_H
48:                  
49:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USB_LastTransactionDetailsGet_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_USB_LastTransactionDetailsGet 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_USB_LastTransactionDetailsGet function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void USB_LastTransactionDetailsGet_Default( USB_MODULE_ID index , USB_BUFFER_DIRECTION * direction , USB_PING_PONG_STATE * pingpong , uint8_t * endpoint )
62:                  {
63:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
64:                      *direction = ( USB_BUFFER_DIRECTION ) usb->UxSTAT.DIR;
65:                      *pingpong =  ( USB_PING_PONG_STATE )usb->UxSTAT.PPBI;
66:                      *endpoint = usb->UxSTAT.ENDPT;
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_ExistsLastTransactionDetails_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_ExistsLastTransactionDetails
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USB_ExistsLastTransactionDetails function.
77:                  */
78:                  
79:                  #define PLIB_USB_ExistsLastTransactionDetails PLIB_USB_ExistsLastTransactionDetails
80:                  PLIB_TEMPLATE bool USB_ExistsLastTransactionDetails_Default( USB_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  #endif /*_USB_LASTTRANSACTIONDETAILS_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0014E8  8E110200   LW S1, 512(S0)
9D0014EC  8E040200   LW A0, 512(S0)
9D0014F0  8E020200   LW V0, 512(S0)
9D0014F4  7E3100C0   EXT S1, S1, 3, 1
9D0014F8  7C840080   EXT A0, A0, 2, 1
9D0014FC  7C421900   EXT V0, V0, 4, 4
9D001500  AE1401C0   SW S4, 448(S0)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_gen_interruptstatus_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_GEN_InterruptStatus_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : GEN_InterruptStatus
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_InterruptFlagSet
16:                          PLIB_USB_InterruptFlagClear
17:                          PLIB_USB_InterruptFlagGet
18:                          PLIB_USB_ExistsGEN_InterruptStatus
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USB_GEN_INTERRUPTSTATUS_DEFAULT_H
49:                  #define _USB_GEN_INTERRUPTSTATUS_DEFAULT_H
50:                  
51:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_InterruptFlagSet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_InterruptFlagSet 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_InterruptFlagSet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void USB_InterruptFlagSet_Default( USB_MODULE_ID index , USB_INTERRUPTS interruptFlag )
64:                  {
65:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
66:                      usb->UxIR.w  |= interruptFlag;
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_InterruptFlagClear_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_InterruptFlagClear 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USB_InterruptFlagClear function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USB_InterruptFlagClear_Default( USB_MODULE_ID index , USB_INTERRUPTS interruptFlag )
80:                  {
81:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
82:                  	usb->UxIR.w  = interruptFlag;
83:                  }
84:                  
85:                  //******************************************************************************
86:                  /* Function :  USB_InterruptFlagGet_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_USB_InterruptFlagGet 
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_USB_InterruptFlagGet function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE bool USB_InterruptFlagGet_Default( USB_MODULE_ID index , USB_INTERRUPTS interruptFlag )
96:                  {
97:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
98:                      return ( (( usb->UxIR.w ) & interruptFlag) ? 1 : 0 );
99:                  }
100:                 
101:                 //******************************************************************************
102:                 /* Function :  USB_InterruptFlagGet_Default
103:                 
104:                   Summary:
105:                     Implements Default variant of PLIB_USB_InterruptFlagAllGet 
106:                 
107:                   Description:
108:                     This template implements the Default variant of the PLIB_USB_InterruptFlagAllGet function.
109:                 */
110:                 
111:                 PLIB_TEMPLATE USB_INTERRUPTS USB_InterruptFlagAllGet_Default( USB_MODULE_ID index )
112:                 {
113:                 	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
114:                 	return (USB_INTERRUPTS) (  usb->UxIR.w ) ;
115:                 }
116:                 
117:                 //******************************************************************************
118:                 /* Function :  USB_ExistsGEN_InterruptStatus_Default
119:                 
120:                   Summary:
121:                     Implements Default variant of PLIB_USB_ExistsGEN_InterruptStatus
122:                 
123:                   Description:
124:                     This template implements the Default variant of the PLIB_USB_ExistsGEN_InterruptStatus function.
125:                 */
126:                 
127:                 #define PLIB_USB_ExistsGEN_InterruptStatus PLIB_USB_ExistsGEN_InterruptStatus
128:                 PLIB_TEMPLATE bool USB_ExistsGEN_InterruptStatus_Default( USB_MODULE_ID index )
129:                 {
130:                     return true;
131:                 }
132:                 
133:                 
134:                 #endif /*_USB_GEN_INTERRUPTSTATUS_DEFAULT_H*/
135:                 
136:                 /******************************************************************************
137:                  End of File
138:                 */
139:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0011E4  AE0201C0   SW V0, 448(S0)
9D0011E8  240200F5   ADDIU V0, ZERO, 245
9D00126C  8E0201C0   LW V0, 448(S0)
9D001270  30420020   ANDI V0, V0, 32
9D0012A8  24020020   ADDIU V0, ZERO, 32
9D0012B0  8E0201D0   LW V0, 464(S0)
9D0012BC  8E0201C0   LW V0, 448(S0)
9D0012C0  30420001   ANDI V0, V0, 1
9D0012E4  AE0401C0   SW A0, 448(S0)
9D0012E8  24040010   ADDIU A0, ZERO, 16
9D0012F4  AC400000   SW ZERO, 0(V0)
9D001354  24020001   ADDIU V0, ZERO, 1
9D001358  AE0201C0   SW V0, 448(S0)
9D00135C  8E0201C0   LW V0, 448(S0)
9D001360  30420010   ANDI V0, V0, 16
9D001394  24020010   ADDIU V0, ZERO, 16
9D00139C  8E020010   LW V0, 16(S0)
9D0013BC  8E0201C0   LW V0, 448(S0)
9D0013C0  30420004   ANDI V0, V0, 4
9D0013F4  24020004   ADDIU V0, ZERO, 4
9D0013FC  8E0201C0   LW V0, 448(S0)
9D001400  30420080   ANDI V0, V0, 128
9D001468  24020080   ADDIU V0, ZERO, 128
9D001470  8E0201C0   LW V0, 448(S0)
9D001474  30420002   ANDI V0, V0, 2
9D001484  24140008   ADDIU S4, ZERO, 8
9D0014D8  8E0201C0   LW V0, 448(S0)
9D0014DC  30420008   ANDI V0, V0, 8
9D001500  AE1401C0   SW S4, 448(S0)
9D001504  1080FFE3   BEQ A0, ZERO, 0x9D001494
9D001608  24020002   ADDIU V0, ZERO, 2
9D001610  1060FF9B   BEQ V1, ZERO, 0x9D001480
9D001614  27A60010   ADDIU A2, SP, 16
9D0072EC  8C820020   LW V0, 32(A0)
9D0072F4  AC4501C0   SW A1, 448(V0)
9D0072F8  8C4301D0   LW V1, 464(V0)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_gen_interrupt_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_GEN_Interrupt_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : GEN_Interrupt
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_InterruptEnable
16:                          PLIB_USB_InterruptDisable
17:                          PLIB_USB_InterruptIsEnabled
18:                          PLIB_USB_ExistsGEN_Interrupt
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USB_GEN_INTERRUPT_DEFAULT_H
49:                  #define _USB_GEN_INTERRUPT_DEFAULT_H
50:                  
51:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_InterruptEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_InterruptEnable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_InterruptEnable
61:                      function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void USB_InterruptEnable_Default
65:                  ( 
66:                      USB_MODULE_ID index , 
67:                      USB_INTERRUPTS interruptFlag 
68:                  )
69:                  {
70:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
71:                  	usb->UxIE.w  |= interruptFlag ;
72:                  }
73:                  
74:                  //******************************************************************************
75:                  /* Function :  USB_InterruptDisable_Default
76:                  
77:                    Summary:
78:                      Implements Default variant of PLIB_USB_InterruptDisable 
79:                  
80:                    Description:
81:                      This template implements the Default variant of the
82:                      PLIB_USB_InterruptDisable function.
83:                  */
84:                  
85:                  PLIB_TEMPLATE void USB_InterruptDisable_Default
86:                  ( 
87:                      USB_MODULE_ID index , 
88:                      USB_INTERRUPTS interruptFlag 
89:                  )
90:                  {
91:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
92:                  	usb->UxIE.w &= (~interruptFlag);
93:                  }
94:                  
95:                  //******************************************************************************
96:                  /* Function :  USB_InterruptIsEnabled_Default
97:                  
98:                    Summary:
99:                      Implements Default variant of PLIB_USB_InterruptIsEnabled 
100:                 
101:                   Description:
102:                     This template implements the Default variant of the
103:                     PLIB_USB_InterruptIsEnabled function.
104:                 */
105:                 
106:                 PLIB_TEMPLATE bool USB_InterruptIsEnabled_Default
107:                 ( 
108:                     USB_MODULE_ID index , 
109:                     USB_INTERRUPTS interruptFlag 
110:                 )
111:                 {
112:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
113:                     return ( (usb->UxIE.w )  & interruptFlag ? 1 : 0 );
114:                 }
115:                 
116:                 //******************************************************************************
117:                 /* Function :  USB_ExistsGEN_Interrupt_Default
118:                 
119:                   Summary:
120:                     Implements Default variant of PLIB_USB_ExistsGEN_Interrupt
121:                 
122:                   Description:
123:                     This template implements the Default variant of the
124:                     PLIB_USB_ExistsGEN_Interrupt function.
125:                 */
126:                 
127:                 #define PLIB_USB_ExistsGEN_Interrupt PLIB_USB_ExistsGEN_Interrupt
128:                 PLIB_TEMPLATE bool USB_ExistsGEN_Interrupt_Default( USB_MODULE_ID index )
129:                 {
130:                     return true;
131:                 }
132:                 
133:                 #endif /*_USB_GEN_INTERRUPT_DEFAULT_H*/
134:                 
135:                 /******************************************************************************
136:                  End of File
137:                 */
138:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00127C  8E0201D0   LW V0, 464(S0)
9D001280  30420020   ANDI V0, V0, 32
9D0012B0  8E0201D0   LW V0, 464(S0)
9D0012B4  7C022944   INS V0, ZERO, 5, 1
9D0012B8  AE0201D0   SW V0, 464(S0)
9D0012BC  8E0201C0   LW V0, 448(S0)
9D0012CC  8E0201D0   LW V0, 464(S0)
9D0012D0  30420001   ANDI V0, V0, 1
9D00136C  8E0201D0   LW V0, 464(S0)
9D001370  30420010   ANDI V0, V0, 16
9D0013A8  8E0201D0   LW V0, 464(S0)
9D0013B4  24020001   ADDIU V0, ZERO, 1
9D0013CC  8E0201D0   LW V0, 464(S0)
9D0013D0  30420004   ANDI V0, V0, 4
9D00140C  8E0201D0   LW V0, 464(S0)
9D001410  30420080   ANDI V0, V0, 128
9D0015E8  8E0201D0   LW V0, 464(S0)
9D0015EC  30420002   ANDI V0, V0, 2
9D0072F8  8C4301D0   LW V1, 464(V0)
9D007300  7C033804   INS V1, ZERO, 0, 8
9D007308  AC4501E0   SW A1, 480(V0)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_framenumber_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_FrameNumber_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : FrameNumber
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_FrameNumberGet
16:                          PLIB_USB_ExistsFrameNumber
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_FRAMENUMBER_DEFAULT_H
47:                  #define _USB_FRAMENUMBER_DEFAULT_H
48:                  
49:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
50:                  
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USB_FrameNumberGet_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USB_FrameNumberGet 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USB_FrameNumberGet
60:                      function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE uint16_t USB_FrameNumberGet_Default( USB_MODULE_ID index )
64:                  {
65:                      uint16_t retval;
66:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
67:                  	retval =  (( usb->UxFRML.FRML ) |   ( usb->UxFRMH.FRMH << 8 ) );
68:                      return retval;
69:                  }
70:                  
71:                  //******************************************************************************
72:                  /* Function :  USB_ExistsFrameNumber_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_USB_ExistsFrameNumber
76:                  
77:                    Description:
78:                      This template implements the Default variant of the
79:                      PLIB_USB_ExistsFrameNumber function.
80:                  */
81:                  
82:                  #define PLIB_USB_ExistsFrameNumber PLIB_USB_ExistsFrameNumber
83:                  PLIB_TEMPLATE bool USB_ExistsFrameNumber_Default( USB_MODULE_ID index )
84:                  {
85:                      return true;
86:                  }
87:                  
88:                  #endif /*_USB_FRAMENUMBER_DEFAULT_H*/
89:                  
90:                  /******************************************************************************
91:                   End of File
92:                  */
93:                  
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00802C  8C830020   LW V1, 32(A0)
9D008030  90640240   LBU A0, 576(V1)
9D008034  8C620250   LW V0, 592(V1)
9D00803C  00021200   SLL V0, V0, 8
9D008040  00441025   OR V0, V0, A0
9D008044  03E00008   JR RA
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_err_interruptstatus_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_ERR_InterruptStatus_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ERR_InterruptStatus
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_ErrorInterruptFlagSet
16:                          PLIB_USB_ErrorInterruptFlagClear
17:                          PLIB_USB_ErrorInterruptFlagGet
18:                          PLIB_USB_ExistsERR_InterruptStatus
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USB_ERR_INTERRUPTSTATUS_DEFAULT_H
49:                  #define _USB_ERR_INTERRUPTSTATUS_DEFAULT_H
50:                  
51:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_ErrorInterruptFlagSet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_ErrorInterruptFlagSet 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the
61:                      PLIB_USB_ErrorInterruptFlagSet function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void USB_ErrorInterruptFlagSet_Default
65:                  ( 
66:                      USB_MODULE_ID index , 
67:                      USB_ERROR_INTERRUPTS   interruptFlag 
68:                  )
69:                  {
70:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
71:                  	usb->UxEIR.w |=  interruptFlag ;
72:                     
73:                  }
74:                  
75:                  //******************************************************************************
76:                  /* Function :  USB_ErrorInterruptFlagClear_Default
77:                  
78:                    Summary:
79:                      Implements Default variant of PLIB_USB_ErrorInterruptFlagClear 
80:                  
81:                    Description:
82:                      This template implements the Default variant of the
83:                      PLIB_USB_ErrorInterruptFlagClear function.
84:                  */
85:                  
86:                  PLIB_TEMPLATE void USB_ErrorInterruptFlagClear_Default
87:                  ( 
88:                      USB_MODULE_ID index , 
89:                      USB_ERROR_INTERRUPTS interruptFlag 
90:                  )
91:                  {
92:                   	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
93:                  	usb->UxEIR.w = interruptFlag ;
94:                  }
95:                  
96:                  //******************************************************************************
97:                  /* Function :  USB_ErrorInterruptFlagGet_Default
98:                  
99:                    Summary:
100:                     Implements Default variant of PLIB_USB_ErrorInterruptFlagGet 
101:                 
102:                   Description:
103:                     This template implements the Default variant of the
104:                     PLIB_USB_ErrorInterruptFlagGet function.
105:                 */
106:                 
107:                 PLIB_TEMPLATE bool USB_ErrorInterruptFlagGet_Default
108:                 ( 
109:                     USB_MODULE_ID index , 
110:                     USB_ERROR_INTERRUPTS interruptFlag 
111:                 )
112:                 {
113:                 	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
114:                     return ( ( usb->UxEIR.w) & interruptFlag ? 1 : 0 );
115:                 }
116:                 
117:                 //******************************************************************************
118:                 /* Function :  USB_ErrorInterruptFlagAllGet_Default
119:                 
120:                   Summary:
121:                     Implements Default variant of PLIB_USB_ErrorInterruptFlagAllGet 
122:                 
123:                   Description:
124:                     This template implements the Default variant of the
125:                     PLIB_USB_ErrorInterruptFlagAllGet function.
126:                 */
127:                 
128:                 PLIB_TEMPLATE USB_ERROR_INTERRUPTS USB_ErrorInterruptFlagAllGet_Default( USB_MODULE_ID index )
129:                 {
130:                 	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
131:                     return (USB_ERROR_INTERRUPTS)( usb->UxEIR.w);
132:                 
133:                 }
134:                 
135:                 //******************************************************************************
136:                 /* Function :  USB_ExistsERR_InterruptStatus_Default
137:                 
138:                   Summary:
139:                     Implements Default variant of PLIB_USB_ExistsERR_InterruptStatus
140:                 
141:                   Description:
142:                     This template implements the Default variant of the
143:                     PLIB_USB_ExistsERR_InterruptStatus function.
144:                 */
145:                 
146:                 #define PLIB_USB_ExistsERR_InterruptStatus PLIB_USB_ExistsERR_InterruptStatus
147:                 PLIB_TEMPLATE bool USB_ExistsERR_InterruptStatus_Default( USB_MODULE_ID index )
148:                 {
149:                     return true;
150:                 }
151:                 
152:                 
153:                 #endif /*_USB_ERR_INTERRUPTSTATUS_DEFAULT_H*/
154:                 
155:                 /******************************************************************************
156:                  End of File
157:                 */
158:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0011E0  AE0201E0   SW V0, 480(S0)
9D0011E4  AE0201C0   SW V0, 448(S0)
9D0015F8  8E0201E0   LW V0, 480(S0)
9D0015FC  8E430010   LW V1, 16(S2)
9D001604  AE0201E0   SW V0, 480(S0)
9D001608  24020002   ADDIU V0, ZERO, 2
9D0017C0  1000FE87   BEQ ZERO, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_ErrorInterruptFlagClear
9D0017C4  240200FF   ADDIU V0, ZERO, 255
9D007308  AC4501E0   SW A1, 480(V0)
9D00730C  8C4301F0   LW V1, 496(V0)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_err_interrupt_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_ERR_Interrupt_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ERR_Interrupt
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_ErrorInterruptEnable
16:                          PLIB_USB_ErrorInterruptDisable
17:                          PLIB_USB_ErrorInterruptIsEnabled
18:                          PLIB_USB_ExistsERR_Interrupt
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USB_ERR_INTERRUPT_DEFAULT_H
49:                  #define _USB_ERR_INTERRUPT_DEFAULT_H
50:                  
51:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
52:                  
53:                  
54:                  //******************************************************************************
55:                  /* Function :  USB_ErrorInterruptEnable_Default
56:                  
57:                    Summary:
58:                      Implements Default variant of PLIB_USB_ErrorInterruptEnable 
59:                  
60:                    Description:
61:                      This template implements the Default variant of the
62:                      PLIB_USB_ErrorInterruptEnable function.
63:                  */
64:                  
65:                  PLIB_TEMPLATE void USB_ErrorInterruptEnable_Default
66:                  ( 
67:                      USB_MODULE_ID index , 
68:                      USB_ERROR_INTERRUPTS interruptFlag 
69:                  )
70:                  {
71:                       volatile usb_registers_t * usb = ((usb_registers_t *)(index));
72:                       usb->UxEIE.w |= interruptFlag ;
73:                   
74:                  }
75:                  //******************************************************************************
76:                  /* Function :  USB_ErrorInterruptDisable_Default
77:                  
78:                    Summary:
79:                      Implements Default variant of PLIB_USB_ErrorInterruptDisable 
80:                  
81:                    Description:
82:                      This template implements the Default variant of the
83:                      PLIB_USB_ErrorInterruptDisable function.
84:                  */
85:                  
86:                  PLIB_TEMPLATE void USB_ErrorInterruptDisable_Default
87:                  ( 
88:                      USB_MODULE_ID index , 
89:                      USB_ERROR_INTERRUPTS interruptFlag 
90:                  )
91:                  {
92:                  	volatile usb_registers_t * usb = ((usb_registers_t *)(index));
93:                  	usb->UxEIE.w &= (~ interruptFlag );
94:                  }
95:                  
96:                  //******************************************************************************
97:                  /* Function :  USB_ErrorInterruptIsEnabled_Default
98:                  
99:                    Summary:
100:                     Implements Default variant of PLIB_USB_ErrorInterruptIsEnabled 
101:                 
102:                   Description:
103:                     This template implements the Default variant of the
104:                     PLIB_USB_ErrorInterruptIsEnabled function.
105:                 */
106:                 
107:                 PLIB_TEMPLATE bool USB_ErrorInterruptIsEnabled_Default
108:                 ( 
109:                     USB_MODULE_ID index , 
110:                     USB_INTERRUPTS interruptFlag 
111:                 )
112:                 {
113:                 	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
114:                 	return ( ( usb->UxEIE.w) & interruptFlag ? 1 : 0 );
115:                 }
116:                 
117:                 //******************************************************************************
118:                 /* Function :  USB_ExistsERR_Interrupt_Default
119:                 
120:                   Summary:
121:                     Implements Default variant of PLIB_USB_ExistsERR_Interrupt
122:                 
123:                   Description:
124:                     This template implements the Default variant of the
125:                     PLIB_USB_ExistsERR_Interrupt function.
126:                 */
127:                 
128:                 #define PLIB_USB_ExistsERR_Interrupt PLIB_USB_ExistsERR_Interrupt
129:                 PLIB_TEMPLATE bool USB_ExistsERR_Interrupt_Default( USB_MODULE_ID index )
130:                 {
131:                     return true;
132:                 }
133:                 
134:                 
135:                 #endif /*_USB_ERR_INTERRUPT_DEFAULT_H*/
136:                 
137:                 /******************************************************************************
138:                  End of File
139:                 */
140:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00730C  8C4301F0   LW V1, 496(V0)
9D007318  240300F5   ADDIU V1, ZERO, 245
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_epnrxenableenhanced_pic32.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_EPnRxEnableEnhanced_PIC32.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EPnRxEnableEnhanced
13:                      and its Variant : PIC32
14:                      For following APIs :
15:                          PLIB_USB_EPnRxEnable
16:                          PLIB_USB_ExistsEPnRxEnable
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_EPNRXENABLEENHANCED_PIC32_H
47:                  #define _USB_EPNRXENABLEENHANCED_PIC32_H
48:                  
49:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USB_EPnRxEnable_PIC32
53:                  
54:                    Summary:
55:                      Implements PIC32 variant of PLIB_USB_EPnRxEnable 
56:                  
57:                    Description:
58:                      This template implements the PIC32 variant of the PLIB_USB_EPnRxEnable
59:                      function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void USB_EPnRxEnable_PIC32
63:                  ( 
64:                      USB_MODULE_ID index , 
65:                      uint8_t endpoint 
66:                  )
67:                  {
68:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
69:                      usb->UxEP[endpoint].UxEPbits.EPRXEN = 1;
70:                  }
71:                  
72:                  //******************************************************************************
73:                  /* Function :  USB_EPnRxDisable_PIC32
74:                  
75:                    Summary:
76:                      Implements PIC32 variant of PLIB_USB_EPnRxDisable 
77:                  
78:                    Description:
79:                      This template implements the PIC32 variant of the PLIB_USB_EPnRxDisable
80:                      function.
81:                  */
82:                  
83:                  PLIB_TEMPLATE void USB_EPnRxDisable_PIC32
84:                  ( 
85:                      USB_MODULE_ID index , 
86:                      uint8_t endpoint 
87:                  )
88:                  {
89:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
90:                      usb->UxEP[endpoint].UxEPbits.EPRXEN = 0;
91:                  }
92:                  
93:                  //******************************************************************************
94:                  /* Function :  USB_EPnTxEnable_PIC32
95:                  
96:                    Summary:
97:                      Implements PIC32 variant of PLIB_USB_EPnTxEnable 
98:                  
99:                    Description:
100:                     This template implements the PIC32 variant of the PLIB_USB_EPnTxEnable
101:                     function.
102:                 */
103:                 
104:                 PLIB_TEMPLATE void USB_EPnTxEnable_PIC32
105:                 ( 
106:                     USB_MODULE_ID index , 
107:                     uint8_t endpoint 
108:                 )
109:                 {
110:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
111:                     usb->UxEP[endpoint].UxEPbits.EPTXEN = 1;
112:                 }
113:                 
114:                 //******************************************************************************
115:                 /* Function :  USB_EPnTxDisable_PIC32
116:                 
117:                   Summary:
118:                     Implements PIC32 variant of PLIB_USB_EPnTxDisable 
119:                 
120:                   Description:
121:                     This template implements the PIC32 variant of the PLIB_USB_EPnTxDisable
122:                     function.
123:                 */
124:                 
125:                 PLIB_TEMPLATE void USB_EPnTxDisable_PIC32
126:                 ( 
127:                     USB_MODULE_ID index , 
128:                     uint8_t endpoint 
129:                 )
130:                 {
131:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
132:                     usb->UxEP[endpoint].UxEPbits.EPTXEN = 0;
133:                 }
134:                 
135:                 //******************************************************************************
136:                 /* Function :  USB_EPnHandshakeEnable_PIC32
137:                 
138:                   Summary:
139:                     Implements PIC32 variant of PLIB_USB_EPnTxEnable 
140:                 
141:                   Description:
142:                     This template implements the PIC32 variant of the PLIB_USB_EPnTxEnable
143:                     function.
144:                 */
145:                 
146:                 PLIB_TEMPLATE void USB_EPnHandshakeEnable_PIC32
147:                 ( 
148:                     USB_MODULE_ID index , 
149:                     uint8_t endpoint 
150:                 )
151:                 {
152:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
153:                     usb->UxEP[endpoint].UxEPbits.EPHSHK = 1;
154:                    
155:                 }
156:                 
157:                 //******************************************************************************
158:                 /* Function :  USB_EPnTxDisable_PIC32
159:                 
160:                   Summary:
161:                     Implements PIC32 variant of PLIB_USB_EPnTxDisable 
162:                 
163:                   Description:
164:                     This template implements the PIC32 variant of the PLIB_USB_EPnTxDisable
165:                     function.
166:                 */
167:                 
168:                 PLIB_TEMPLATE void USB_EPnHandshakeDisable_PIC32
169:                 ( 
170:                     USB_MODULE_ID index , 
171:                     uint8_t endpoint 
172:                 )
173:                 {
174:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
175:                     usb->UxEP[endpoint].UxEPbits.EPHSHK = 0;
176:                 }
177:                 
178:                 //******************************************************************************
179:                 /* Function :  USB_EPnControlTransferEnable_PIC32
180:                 
181:                   Summary:
182:                     Implements PIC32 variant of PLIB_USB_EPnControlTransferEnable 
183:                 
184:                   Description:
185:                     This template implements the PIC32 variant of the
186:                     PLIB_USB_EPnControlTransferEnable function.
187:                 */
188:                 
189:                 PLIB_TEMPLATE void USB_EPnControlTransferEnable_PIC32
190:                 ( 
191:                     USB_MODULE_ID index , 
192:                     uint8_t endpoint 
193:                 )
194:                 {
195:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
196:                     usb->UxEP[endpoint].w &= (~UxEP_EPCONDIS_MASK);
197:                     usb->UxEP[endpoint].w |= (UxEP_EPTXEN_MASK|UxEP_EPRXEN_MASK);
198:                 }
199:                 
200:                 PLIB_TEMPLATE void USB_EPnAttributesSet_PIC32
201:                 (
202:                     USB_MODULE_ID index, 
203:                     uint8_t endpoint, 
204:                     int direction, 
205:                     bool isControl, 
206:                     bool handshake
207:                 )
208:                 {
209:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
210:                 
211:                     if(isControl)
212:                     {
213:                         usb->UxEP[endpoint].w &= (~UxEP_EPCONDIS_MASK);
214:                         usb->UxEP[endpoint].w |= (UxEP_EPTXEN_MASK|UxEP_EPRXEN_MASK|UxEP_EPHSHK_MASK);
215:                     }
216:                     else 
217:                 	{  
218:                 		/* Set the direction and handshake */
219:                         usb->UxEP[endpoint].w |= ((UxEP_EPRXEN_MASK >> direction)|handshake);
220:                 	}
221:                 }
222:                 
223:                 PLIB_TEMPLATE void USB_EPnAttributesClear_PIC32
224:                 (
225:                     USB_MODULE_ID index, 
226:                     uint8_t endpoint
227:                 )
228:                 {
229:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
230:                     
231:                     usb->UxEP[endpoint].w |= UxEP_EPCONDIS_MASK;
232:                     usb->UxEP[endpoint].w &= (~(UxEP_EPTXEN_MASK|UxEP_EPRXEN_MASK|UxEP_EPHSHK_MASK));
233:                 }
234:                 
235:                 PLIB_TEMPLATE void USB_EPnDirectionDisable_PIC32
236:                 (
237:                     USB_MODULE_ID index, 
238:                     uint8_t endpoint, 
239:                     int direction
240:                 )
241:                 {
242:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
243:                     usb->UxEP[endpoint].w &= (~(UxEP_EPRXEN_MASK >> direction));
244:                 }
245:                 
246:                 //******************************************************************************
247:                 /* Function :  USB_EPnControlTransferDisable_PIC32
248:                 
249:                   Summary:
250:                     Implements PIC32 variant of PLIB_USB_EPnControlTransferDisable 
251:                 
252:                   Description:
253:                     This template implements the PIC32 variant of the
254:                     PLIB_USB_EPnControlTransferDisable function.
255:                 */
256:                 
257:                 PLIB_TEMPLATE void USB_EPnControlTransferDisable_PIC32
258:                 ( 
259:                     USB_MODULE_ID index , 
260:                     uint8_t endpoint 
261:                 )
262:                 {
263:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
264:                     usb->UxEP[endpoint].UxEPbits.EPCONDIS = 1;
265:                 }
266:                 
267:                 //******************************************************************************
268:                 /* Function :  USB_EPnIsStalled_PIC32
269:                 
270:                   Summary:
271:                     Implements PIC32 variant of PLIB_USB_EPnIsStalled 
272:                 
273:                   Description:
274:                     This template implements the PIC32 variant of the PLIB_USB_EPnIsStalled 
275:                     function.
276:                 */
277:                 
278:                 PLIB_TEMPLATE bool USB_EPnIsStalled_PIC32
279:                 ( 
280:                     USB_MODULE_ID index , 
281:                     uint8_t endpoint 
282:                 )
283:                 {
284:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
285:                 	return ( usb->UxEP[endpoint].UxEPbits.EPSTALL );
286:                 }
287:                 
288:                 //******************************************************************************
289:                 /* Function :  USB_EPnStallClear_PIC32
290:                 
291:                   Summary:
292:                     Implements PIC32 variant of PLIB_USB_EPnStallClear 
293:                 
294:                   Description:
295:                     This template implements the PIC32 variant of the PLIB_USB_EPnStallClear 
296:                     function.
297:                 */
298:                 
299:                 PLIB_TEMPLATE void USB_EPnStallClear_PIC32
300:                 (
301:                     USB_MODULE_ID index , 
302:                     uint8_t endpoint 
303:                 )
304:                 {
305:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
306:                     usb->UxEP[endpoint].UxEPbits.EPSTALL = 0;
307:                 }
308:                 
309:                 
310:                 PLIB_TEMPLATE void USB_EP0HostSetup_PIC32(USB_MODULE_ID index)
311:                 {
312:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
313:                 	
314:                 	usb->UxEP[0].w = 0x00 ;
315:                 	
316:                     /* Set up endpoint 0 for typical host operation.
317:                      * Enable Transmit, Receive, Control Transfers, Handshake
318:                      * Disable NAK Retry and Low speed connect */
319:                     
320:                     usb->UxEP[0].w |= (UxEP0_RETRYDIS_MASK|UxEP_EPHSHK_MASK|UxEP_EPTXEN_MASK|UxEP_EPRXEN_MASK);
321:                 }
322:                 
323:                 //******************************************************************************
324:                 /* Function :  USB_ExistsEPnRxEnable_PIC32
325:                 
326:                   Summary:
327:                     Implements PIC32 variant of PLIB_USB_ExistsEPnRxEnable
328:                 
329:                   Description:
330:                     This template implements the PIC32 variant of the PLIB_USB_ExistsEPnRxEnable
331:                     function.
332:                 */
333:                 
334:                 #define PLIB_USB_ExistsEPnRxEnable PLIB_USB_ExistsEPnRxEnable
335:                 PLIB_TEMPLATE bool USB_ExistsEPnRxEnable_PIC32( USB_MODULE_ID index )
336:                 {
337:                     return true;
338:                 }
339:                 
340:                 
341:                 #endif /*_USB_EPNRXENABLEENHANCED_PIC32_H*/
342:                 
343:                 /******************************************************************************
344:                  End of File
345:                 */
346:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D001420  2462002C   ADDIU V0, V1, 44
9D001430  7C840040   EXT A0, A0, 1, 1
9D001434  10800004   BEQ A0, ZERO, 0x9D001448
9D00143C  90440000   LBU A0, 0(V0)
9D001440  7C040844   INS A0, ZERO, 1, 1
9D001444  A0440000   SB A0, 0(V0)
9D001448  1465FFF6   BNE V1, A1, 0x9D001424
9D00144C  2462002C   ADDIU V0, V1, 44
9D003E5C  2442002C   ADDIU V0, V0, 44
9D003E80  7C070844   INS A3, ZERO, 1, 1
9D003E8C  2414FFFC   ADDIU S4, ZERO, -4
9D003E90  A0470000   SB A3, 0(V0)
9D003E94  AE60000C   SW ZERO, 12(S3)
9D004358  8D0D02C0   LW T5, 704(T0)
9D004364  24090008   ADDIU T1, ZERO, 8
9D00436C  01C94807   SRAV T1, T1, T6
9D004378  012C4825   OR T1, T1, T4
9D004380  012D4825   OR T1, T1, T5
9D004394  AD0902C0   SW T1, 704(T0)
9D004398  04A20037   BLTZL A1, 0x9D004478
9D0043F8  00084100   SLL T0, T0, 4
9D0043FC  01284021   ADDU T0, T1, T0
9D004400  8D0602C0   LW A2, 704(T0)
9D004404  8C82001C   LW V0, 28(A0)
9D00440C  7C062104   INS A2, ZERO, 4, 1
9D004410  AD0602C0   SW A2, 704(T0)
9D004414  8D0B02C0   LW T3, 704(T0)
9D00442C  3562000D   ORI V0, T3, 13
9D00443C  AD0202C0   SW V0, 704(T0)
9D004440  00001025   OR V0, ZERO, ZERO
9D005914  8C8202C0   LW V0, 704(A0)
9D00591C  2408FFF2   ADDIU T0, ZERO, -14
9D005920  34420010   ORI V0, V0, 16
9D005924  AC8202C0   SW V0, 704(A0)
9D005928  8C8702C0   LW A3, 704(A0)
9D005934  00E83824   AND A3, A3, T0
9D005938  AC8702C0   SW A3, 704(A0)
9D00593C  AC660014   SW A2, 20(V1)
9D005948  8C8702C0   LW A3, 704(A0)
9D00594C  24020008   ADDIU V0, ZERO, 8
9D005954  00052827   NOR A1, ZERO, A1
9D005958  00A72824   AND A1, A1, A3
9D005960  00001025   OR V0, ZERO, ZERO
9D005970  240AFFF2   ADDIU T2, ZERO, -14
9D005978  00041900   SLL V1, A0, 4
9D005980  8C6702C0   LW A3, 704(V1)
9D00598C  34E70010   ORI A3, A3, 16
9D005990  AC6702C0   SW A3, 704(V1)
9D005994  8C6702C0   LW A3, 704(V1)
9D005998  24420030   ADDIU V0, V0, 48
9D00599C  7C060004   INS A2, ZERO, 0, 1
9D0059A4  00EA3824   AND A3, A3, T2
9D0059AC  AC6702C0   SW A3, 704(V1)
9D0059B0  AC46FFE4   SW A2, -28(V0)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_deviceaddress_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_DeviceAddress_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : DeviceAddress
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_DeviceAddressSet
16:                          PLIB_USB_DeviceAddressGet
17:                          PLIB_USB_ExistsDeviceAddress
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_DEVICEADDRESS_DEFAULT_H
48:                  #define _USB_DEVICEADDRESS_DEFAULT_H
49:                  
50:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_DeviceAddressSet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_DeviceAddressSet 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the
61:                      PLIB_USB_DeviceAddressSet function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void USB_DeviceAddressSet_Default
65:                  ( 
66:                      USB_MODULE_ID index , 
67:                      uint8_t address 
68:                  )
69:                  {
70:                      volatile usb_registers_t  * usb = ((usb_registers_t *)(index));
71:                  	usb->UxADDR.DEVADDR = ( address & 0x7F ) ;
72:                  }
73:                  
74:                  //******************************************************************************
75:                  /* Function :  USB_DeviceAddressGet_Default
76:                  
77:                    Summary:
78:                      Implements Default variant of PLIB_USB_DeviceAddressGet 
79:                  
80:                    Description:
81:                      This template implements the Default variant of the
82:                      PLIB_USB_DeviceAddressGet function.
83:                  */
84:                  
85:                  PLIB_TEMPLATE uint8_t USB_DeviceAddressGet_Default( USB_MODULE_ID index )
86:                  {
87:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
88:                      return ( usb->UxADDR.DEVADDR );
89:                  }
90:                  
91:                  
92:                  //******************************************************************************
93:                  /* Function :  USB_ExistsDeviceAddress_Default
94:                  
95:                    Summary:
96:                      Implements Default variant of PLIB_USB_ExistsDeviceAddress
97:                  
98:                    Description:
99:                      This template implements the Default variant of the
100:                     PLIB_USB_ExistsDeviceAddress function.
101:                 */
102:                 
103:                 #define PLIB_USB_ExistsDeviceAddress PLIB_USB_ExistsDeviceAddress
104:                 PLIB_TEMPLATE bool USB_ExistsDeviceAddress_Default( USB_MODULE_ID index )
105:                 {
106:                     return true;
107:                 }
108:                 
109:                 
110:                 #endif /*_USB_DEVICEADDRESS_DEFAULT_H*/
111:                 
112:                 /******************************************************************************
113:                  End of File
114:                 */
115:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00132C  92020220   LBU V0, 544(S0)
9D001338  7C023004   INS V0, ZERO, 0, 7
9D001340  10600004   BEQ V1, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagClear
9D001344  00003025   OR A2, ZERO, ZERO
9D0081A0  8C820020   LW V0, 32(A0)
9D0081A4  90430220   LBU V1, 544(V0)
9D0081B0  03E00008   JR RA
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_bufferfreeze_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_BufferFreeze_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BufferFreeze
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_PingPongFreeze
16:                          PLIB_USB_PingPongUnfreeze
17:                          PLIB_USB_ExistsBufferFreeze
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_BUFFERFREEZE_DEFAULT_H
48:                  #define _USB_BUFFERFREEZE_DEFAULT_H
49:                  
50:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_PingPongFreeze_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_PingPongFreeze 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_PingPongFreeze
61:                      function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void USB_PingPongFreeze_Default( USB_MODULE_ID index )
65:                  {
66:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
67:                  	usb->UxCON.w |=  UxCON_PPBRST_MASK ;
68:                    
69:                  }
70:                  
71:                  //******************************************************************************
72:                  /* Function :  USB_PingPongUnfreeze_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_USB_PingPongUnfreeze 
76:                  
77:                    Description:
78:                      This template implements the Default variant of the
79:                      PLIB_USB_PingPongUnfreeze function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void USB_PingPongUnfreeze_Default( USB_MODULE_ID index )
83:                  {
84:                  
85:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
86:                  	usb->UxCON.w &= ( ~ UxCON_PPBRST_MASK);
87:                      
88:                  }
89:                  
90:                  //******************************************************************************
91:                  /* Function :  USB_PingPongReset_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_USB_PingPongReset 
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_USB_PingPongReset
98:                      function.
99:                  */
100:                 
101:                 PLIB_TEMPLATE void USB_PingPongReset_Default( USB_MODULE_ID index )
102:                 {
103:                 
104:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
105:                     usb->UxCON.w |= UxCON_PPBRST_MASK;
106:                 	usb->UxCON.w &= ( ~ UxCON_PPBRST_MASK);
107:                 }
108:                 
109:                 
110:                 //******************************************************************************
111:                 /* Function :  USB_ExistsBufferFreeze_Default
112:                 
113:                   Summary:
114:                     Implements Default variant of PLIB_USB_ExistsBufferFreeze
115:                 
116:                   Description:
117:                     This template implements the Default variant of the
118:                     PLIB_USB_ExistsBufferFreeze function.
119:                 */
120:                 
121:                 #define PLIB_USB_ExistsBufferFreeze PLIB_USB_ExistsBufferFreeze
122:                 PLIB_TEMPLATE bool USB_ExistsBufferFreeze_Default( USB_MODULE_ID index )
123:                 {
124:                     return true;
125:                 }
126:                 
127:                 
128:                 #endif /*_USB_BUFFERFREEZE_DEFAULT_H*/
129:                 
130:                 /******************************************************************************
131:                  End of File
132:                 */
133:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D001310  8E020210   LW V0, 528(S0)
9D001314  8E430010   LW V1, 16(S2)
9D001318  34420002   ORI V0, V0, 2
9D00131C  AE020210   SW V0, 528(S0)
9D001320  8E020210   LW V0, 528(S0)
9D001324  7C020844   INS V0, ZERO, 1, 1
9D001328  AE020210   SW V0, 528(S0)
9D00132C  92020220   LBU V0, 544(S0)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_bdtbaseaddress_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_BDTBaseAddress_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BDTBaseAddress
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_BDTBaseAddressGet
16:                          PLIB_USB_BDTBaseAddressSet
17:                          PLIB_USB_ExistsBDTBaseAddress
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_BDTBASEADDRESS_DEFAULT_H
48:                  #define _USB_BDTBASEADDRESS_DEFAULT_H
49:                  
50:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USB_BDTBaseAddressGet_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USB_BDTBaseAddressGet 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the
60:                      PLIB_USB_BDTBaseAddressGet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void* USB_BDTBaseAddressGet_Default( USB_MODULE_ID index )
64:                  {
65:                      uint32_t retval;
66:                  	volatile usb_registers_t * usb = ((usb_registers_t *)(index));
67:                  	
68:                      retval = ( ( usb->UxBDTP3.BDTPTRU << 24 ) | ( usb->UxBDTP2.BDTPTRH << 16 ) | ( usb->UxBDTP1.BDTPTRL << 9 ) );
69:                  	
70:                  	return ( void * )retval;
71:                  }
72:                  
73:                  //******************************************************************************
74:                  /* Function :  USB_BDTBaseAddressSet_Default
75:                  
76:                    Summary:
77:                      Implements Default variant of PLIB_USB_BDTBaseAddressSet 
78:                  
79:                    Description:
80:                      This template implements the Default variant of the
81:                      PLIB_USB_BDTBaseAddressSet function.
82:                  */
83:                  
84:                  PLIB_TEMPLATE void USB_BDTBaseAddressSet_Default( USB_MODULE_ID index , void* address )
85:                  {
86:                      volatile usb_registers_t * usb = ((usb_registers_t *)(index));
87:                  	uint32_t value = (uint32_t) address;
88:                  	usb->UxBDTP3.BDTPTRU = ( value >> 24 ) & 0xFF ;
89:                  	usb->UxBDTP2.BDTPTRH = ( value >> 16 ) & 0xFF ;
90:                  	usb->UxBDTP1.BDTPTRL = ( value >> 9 ) & 0x7F;
91:                  }
92:                  
93:                  //******************************************************************************
94:                  /* Function :  USB_ExistsBDTBaseAddress_Default
95:                  
96:                    Summary:
97:                      Implements Default variant of PLIB_USB_ExistsBDTBaseAddress
98:                  
99:                    Description:
100:                     This template implements the Default variant of the
101:                     PLIB_USB_ExistsBDTBaseAddress function.
102:                 */
103:                 
104:                 #define PLIB_USB_ExistsBDTBaseAddress PLIB_USB_ExistsBDTBaseAddress
105:                 PLIB_TEMPLATE bool USB_ExistsBDTBaseAddress_Default( USB_MODULE_ID index )
106:                 {
107:                     return true;
108:                 }
109:                 
110:                 
111:                 #endif /*_USB_BDTBASEADDRESS_DEFAULT_H*/
112:                 
113:                 /******************************************************************************
114:                  End of File
115:                 */
116:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00504C  00022602   SRL A0, V0, 24
9D005050  7C433C00   EXT V1, V0, 16, 8
9D005054  A2240290   SB A0, 656(S1)
9D005058  A2230280   SB V1, 640(S1)
9D00505C  92240230   LBU A0, 560(S1)
9D005064  7C433240   EXT V1, V0, 9, 7
9D005068  7C643844   INS A0, V1, 1, 7
9D005070  A2240230   SB A0, 560(S1)
9D005074  8FB00014   LW S0, 20(SP)
9D005078  8FB10018   LW S1, 24(SP)
9D00507C  03E00008   JR RA
9D005080  27BD0020   ADDIU SP, SP, 32
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_automaticsuspend_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_AutomaticSuspend_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : AutomaticSuspend
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_AutoSuspendDisable
16:                          PLIB_USB_AutoSuspendEnable
17:                          PLIB_USB_ExistsAutomaticSuspend
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_AUTOMATICSUSPEND_DEFAULT_H
48:                  #define _USB_AUTOMATICSUSPEND_DEFAULT_H
49:                  
50:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USB_AutoSuspendDisable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USB_AutoSuspendDisable 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the
60:                      PLIB_USB_AutoSuspendDisable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void USB_AutoSuspendDisable_Default( USB_MODULE_ID index )
64:                  {
65:                  	volatile usb_registers_t * usb = ((usb_registers_t *)(index));
66:                  	usb->UxCNFG1CLR =  UxCNFG1_UASUSPND_MASK ;
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_AutoSuspendEnable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_AutoSuspendEnable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the
77:                      PLIB_USB_AutoSuspendEnable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void USB_AutoSuspendEnable_Default( USB_MODULE_ID index )
81:                  {
82:                      volatile usb_registers_t * usb = ((usb_registers_t *)(index));
83:                  	usb->UxCNFG1SET =  UxCNFG1_UASUSPND_MASK ;
84:                  }
85:                  
86:                  //******************************************************************************
87:                  /* Function :  USB_ExistsAutomaticSuspend_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_USB_ExistsAutomaticSuspend
91:                  
92:                    Description:
93:                      This template implements the Default variant of the
94:                      PLIB_USB_ExistsAutomaticSuspend function.
95:                  */
96:                  
97:                  #define PLIB_USB_ExistsAutomaticSuspend PLIB_USB_ExistsAutomaticSuspend
98:                  PLIB_TEMPLATE bool USB_ExistsAutomaticSuspend_Default( USB_MODULE_ID index )
99:                  {
100:                     return true;
101:                 }
102:                 
103:                 
104:                 #endif /*_USB_AUTOMATICSUSPEND_DEFAULT_H*/
105:                 
106:                 /******************************************************************************
107:                  End of File
108:                 */
109:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D005020  90A20009   LBU V0, 9(A1)
9D00502C  AE2202A8   SW V0, 680(S1)
9D005030  24020001   ADDIU V0, ZERO, 1
9D005034  10C2001C   BEQ A2, V0, 0x9D0050A8
9D005038  00002825   OR A1, ZERO, ZERO
9D005090  90A20009   LBU V0, 9(A1)
9D00509C  AE2202A4   SW V0, 676(S1)
9D0050A0  1000FFE4   BEQ ZERO, ZERO, 0x9D005034
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_all_interrupt_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_ALL_Interrupt_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ALL_Interrupt
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_AllInterruptEnable
16:                          PLIB_USB_ExistsALL_Interrupt
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_ALL_INTERRUPT_DEFAULT_H
47:                  #define _USB_ALL_INTERRUPT_DEFAULT_H
48:                  
49:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USB_AllInterruptEnable_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_USB_AllInterruptEnable 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the
59:                      PLIB_USB_AllInterruptEnable function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void USB_AllInterruptEnable_Default
63:                  ( 
64:                      USB_MODULE_ID index , 
65:                      USB_INTERRUPTS usbInterruptsFlag , 
66:                      USB_ERROR_INTERRUPTS usbErrorInterruptsFlag , 
67:                      USB_OTG_INTERRUPTS otgInterruptFlag 
68:                  )
69:                  {
70:                      volatile usb_registers_t * usb = ((usb_registers_t *)(index));
71:                  	usb->UxIE.w = usbInterruptsFlag;
72:                      usb->UxEIE.w = usbErrorInterruptsFlag;
73:                  	usb->UxOTGIE.w = otgInterruptFlag;
74:                  }
75:                  
76:                  //******************************************************************************
77:                  /* Function :  USB_InterruptEnableGet_Default
78:                  
79:                    Summary:
80:                      Implements Default variant of PLIB_USB_InterruptEnableGet 
81:                  
82:                    Description:
83:                      This template implements the Default variant of the
84:                      PLIB_USB_InterruptEnableGet function.
85:                  */
86:                  
87:                  PLIB_TEMPLATE USB_INTERRUPTS USB_InterruptEnableGet_Default 
88:                  (
89:                      USB_MODULE_ID index
90:                  )
91:                  {
92:                      volatile usb_registers_t * usb = ((usb_registers_t *)(index));
93:                      return (USB_INTERRUPTS)( usb->UxIE.w );
94:                  }
95:                  
96:                  //******************************************************************************
97:                  /* Function :  USB_ExistsALL_Interrupt_Default
98:                  
99:                    Summary:
100:                     Implements Default variant of PLIB_USB_ExistsALL_Interrupt
101:                 
102:                   Description:
103:                     This template implements the Default variant of the
104:                     PLIB_USB_ExistsALL_Interrupt function.
105:                 */
106:                 
107:                 #define PLIB_USB_ExistsALL_Interrupt PLIB_USB_ExistsALL_Interrupt
108:                 PLIB_TEMPLATE bool USB_ExistsALL_Interrupt_Default( USB_MODULE_ID index )
109:                 {
110:                     return true;
111:                 }
112:                 
113:                 
114:                 #endif /*_USB_ALL_INTERRUPT_DEFAULT_H*/
115:                 
116:                 /******************************************************************************
117:                  End of File
118:                 */
119:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D007494  240300DF   ADDIU V1, ZERO, 223
9D00749C  240300FF   ADDIU V1, ZERO, 255
9D0074A4  2403FF1A   ADDIU V1, ZERO, -230
9D0074AC  03E00008   JR RA
9D008208  8C820020   LW V0, 32(A0)
9D00820C  2403FF00   ADDIU V1, ZERO, -256
9D008218  AC4301D0   SW V1, 464(V0)
9D00821C  AC4301F0   SW V1, 496(V0)
9D008220  2403FF02   ADDIU V1, ZERO, -254
9D008224  AC430010   SW V1, 16(V0)
9D008228  03E00008   JR RA
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/plib_usbfs_header.h  --
1:                   /*******************************************************************************
2:                   * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
3:                   *
4:                   * Subject to your compliance with these terms, you may use Microchip software
5:                   * and any derivatives exclusively with Microchip products. It is your
6:                   * responsibility to comply with third party license terms applicable to your
7:                   * use of third party software (including open source software) that may
8:                   * accompany Microchip software.
9:                   *
10:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
11:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
12:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
13:                  * PARTICULAR PURPOSE.
14:                  *
15:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
16:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
17:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
18:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
19:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
20:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
21:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
22:                  *******************************************************************************/
23:                  
24:                  /* Created by plibgen $Revision: 1.31 $ */
25:                  
26:                  
27:                  #ifndef _PLIB_USBFS_H
28:                  #define _PLIB_USBFS_H
29:                  
30:                  /* Section 1 - Enumerate instances, define constants, VREGs */
31:                  
32:                  #include <xc.h>
33:                  #include <stdbool.h>
34:                  
35:                  
36:                  
37:                  /* Default definition used for all API dispatch functions */
38:                  #ifndef PLIB_INLINE_API
39:                       #define PLIB_INLINE_API static inline 
40:                  #endif
41:                  
42:                  /* Default definition used for all other functions */
43:                  #ifndef PLIB_INLINE
44:                       #define PLIB_INLINE static inline 
45:                  #endif
46:                  
47:                  #ifndef _PLIB_UNSUPPORTED
48:                      #define _PLIB_UNSUPPORTED 
49:                  #endif
50:                  
51:                  #ifndef PLIB_ASSERT
52:                      #define PLIB_ASSERT(a,b)  
53:                  #endif 
54:                  
55:                  #if defined(__32MX420F032H__) || defined(__32MX440F128H__) ||  defined(__32MX440F256H__) || defined(__32MX440F512H__) || defined(__32MX440F128L__) || defined(__32MX460F256L__) || defined(__32MX460F512L__)
56:                  
57:                      #define USB_BUSY_FLAG_DOES_NOT_EXIST   
58:                  #endif
59:                  
60:                  typedef enum {
61:                  
62:                      USB_ID_1 = _USB_BASE_ADDRESS,
63:                      USB_NUMBER_OF_MODULES = 1
64:                  	
65:                  } USB_MODULE_ID;
66:                  
67:                  typedef enum {
68:                  
69:                      USB_INT_DEVICE_RESET = 0x01,
70:                      USB_INT_ERROR = 0x02,
71:                      USB_INT_TOKEN_DONE = 0x08,
72:                      USB_INT_IDLE_DETECT = 0x10,
73:                      USB_INT_STALL = 0x80,
74:                      USB_INT_SOF = 0x04,
75:                      USB_INT_HOST_DETACH = 0x01,
76:                      USB_INT_RESUME = 0x20,
77:                      USB_INT_ATTACH = 0x40,
78:                      USB_INT_ANY = 0xFF,
79:                      USB_INT_ALL = 0xFF
80:                  
81:                  } USB_INTERRUPTS;
82:                  
83:                  typedef enum {
84:                  
85:                      USB_ERR_INT_PID_CHECK_FAILURE = 0x01,
86:                      USB_ERR_INT_BAD_CRC5 = 0x02,
87:                      USB_ERR_INT_BAD_CRC16 = 0x04,
88:                      USB_ERR_INT_BAD_DATA_FIELD_SIZE = 0x08,
89:                      USB_ERR_INT_BUS_TURNAROUND_TIMEOUT = 0x10,
90:                      USB_ERR_INT_BIT_STUFF_ERROR = 0x80,
91:                      USB_ERR_INT_HOST_EOF_ERROR = 0x02,
92:                      USB_ERR_INT_DMA_ERROR = 0x20,
93:                      USB_ERR_INT_BUS_MATRIX_ERROR = 0x40,
94:                      USB_ERR_INT_ANY = 0xFF,
95:                      USB_ERR_INT_ALL = 0xFF
96:                  
97:                  } USB_ERROR_INTERRUPTS;
98:                  
99:                  /* Section 2 - Feature variant inclusion */
100:                 
101:                 #define PLIB_TEMPLATE PLIB_INLINE
102:                 #include "driver/usb/usbfs/src/templates/usb_OTG_InterruptStatus_Default.h"
103:                 #include "driver/usb/usbfs/src/templates/usb_OTG_Interrupt_Default.h"
104:                 #include "driver/usb/usbfs/src/templates/usb_OTG_IDPinState_Default.h"
105:                 #include "driver/usb/usbfs/src/templates/usb_OTG_LineState_Default.h"
106:                 #include "driver/usb/usbfs/src/templates/usb_OTG_SessionValid_Default.h"
107:                 #include "driver/usb/usbfs/src/templates/usb_OTG_BSessionEnd_Default.h"
108:                 #include "driver/usb/usbfs/src/templates/usb_OTG_ASessionValid_Default.h"
109:                 #include "driver/usb/usbfs/src/templates/usb_OTG_PullUpPullDown_Default.h"
110:                 #include "driver/usb/usbfs/src/templates/usb_OTG_VbusPowerOnOff_Default.h"
111:                 #include "driver/usb/usbfs/src/templates/usb_OTG_VbusCharge_Default.h"
112:                 #include "driver/usb/usbfs/src/templates/usb_OTG_VbusDischarge_Default.h"
113:                 #include "driver/usb/usbfs/src/templates/usb_ActivityPending_Default.h"
114:                 #include "driver/usb/usbfs/src/templates/usb_SleepEntryGuard_Default.h"
115:                 #include "driver/usb/usbfs/src/templates/usb_Suspend_Default.h"
116:                 #include "driver/usb/usbfs/src/templates/usb_ModulePower_32Bit16Bit.h"
117:                 #include "driver/usb/usbfs/src/templates/usb_GEN_InterruptStatus_Default.h"
118:                 #include "driver/usb/usbfs/src/templates/usb_GEN_Interrupt_Default.h"
119:                 #include "driver/usb/usbfs/src/templates/usb_ALL_Interrupt_Default.h"
120:                 #include "driver/usb/usbfs/src/templates/usb_ERR_InterruptStatus_Default.h"
121:                 #include "driver/usb/usbfs/src/templates/usb_ERR_Interrupt_Default.h"
122:                 #include "driver/usb/usbfs/src/templates/usb_LastEndpoint_Default.h"
123:                 #include "driver/usb/usbfs/src/templates/usb_LastDirection_Default.h"
124:                 #include "driver/usb/usbfs/src/templates/usb_LastPingPong_Default.h"
125:                 #include "driver/usb/usbfs/src/templates/usb_LastTransactionDetails_Default.h"
126:                 #include "driver/usb/usbfs/src/templates/usb_LiveJState_Default.h"
127:                 #include "driver/usb/usbfs/src/templates/usb_LiveSingleEndedZero_Default.h"
128:                 #include "driver/usb/usbfs/src/templates/usb_PacketTransfer_Default.h"
129:                 #include "driver/usb/usbfs/src/templates/usb_HostBusyWithToken_Default.h"
130:                 #include "driver/usb/usbfs/src/templates/usb_HostGeneratesReset_Default.h"
131:                 #include "driver/usb/usbfs/src/templates/usb_OpModeSelect_Default.h"
132:                 #include "driver/usb/usbfs/src/templates/usb_ResumeSignaling_Default.h"
133:                 #include "driver/usb/usbfs/src/templates/usb_BufferFreeze_Default.h"
134:                 #include "driver/usb/usbfs/src/templates/usb_StartOfFrames_Default.h"
135:                 #include "driver/usb/usbfs/src/templates/usb_NextTokenSpeed_Default.h"
136:                 #include "driver/usb/usbfs/src/templates/usb_DeviceAddress_Default.h"
137:                 #include "driver/usb/usbfs/src/templates/usb_FrameNumber_Default.h"
138:                 #include "driver/usb/usbfs/src/templates/usb_TokenPID_Default.h"
139:                 #include "driver/usb/usbfs/src/templates/usb_TokenEP_Default.h"
140:                 #include "driver/usb/usbfs/src/templates/usb_SOFThreshold_Default.h"
141:                 #include "driver/usb/usbfs/src/templates/usb_BDTBaseAddress_Default.h"
142:                 #include "driver/usb/usbfs/src/templates/usb_EyePattern_Default.h"
143:                 #include "driver/usb/usbfs/src/templates/usb_StopInIdle_Default.h"
144:                 #include "driver/usb/usbfs/src/templates/usb_PingPongMode_Unsupported.h"
145:                 #include "driver/usb/usbfs/src/templates/usb_UOEMonitor_Unsupported.h"
146:                 #include "driver/usb/usbfs/src/templates/usb_OnChipPullup_Unsupported.h"
147:                 #include "driver/usb/usbfs/src/templates/usb_OnChipTransceiver_Unsupported.h"
148:                 #include "driver/usb/usbfs/src/templates/usb_SpeedControl_Unsupported.h"
149:                 #include "driver/usb/usbfs/src/templates/usb_EP0LowSpeedConnect_Default.h"
150:                 #include "driver/usb/usbfs/src/templates/usb_EP0NAKRetry_Default.h"
151:                 #include "driver/usb/usbfs/src/templates/usb_EPnTxRx_Default.h"
152:                 #include "driver/usb/usbfs/src/templates/usb_EPnRxEnableEnhanced_PIC32.h"
153:                 #include "driver/usb/usbfs/src/templates/usb_BDTFunctions_PIC32.h"
154:                 #ifndef  USB_BUSY_FLAG_DOES_NOT_EXIST
155:                     #include "driver/usb/usbfs/src/templates/usb_ModuleBusy_Default.h"
156:                     #include "driver/usb/usbfs/src/templates/usb_AutomaticSuspend_Default.h"
157:                 #endif
158:                 
159:                 
160:                 /* Section 3 - PLIB dispatch function definitions */
161:                 
162:                 PLIB_INLINE_API void PLIB_USB_OTG_InterruptFlagSet(USB_MODULE_ID index, USB_OTG_INTERRUPTS interruptFlag)
163:                 {
164:                      USB_OTG_InterruptFlagSet_Default(index, interruptFlag);
165:                 }
166:                 
167:                 PLIB_INLINE_API void PLIB_USB_OTG_InterruptFlagClear(USB_MODULE_ID index, USB_OTG_INTERRUPTS interruptFlag)
168:                 {
169:                      USB_OTG_InterruptFlagClear_Default(index, interruptFlag);
170:                 }
171:                 
172:                 PLIB_INLINE_API bool PLIB_USB_OTG_InterruptFlagGet(USB_MODULE_ID index, USB_OTG_INTERRUPTS interruptFlag)
173:                 {
174:                      return USB_OTG_InterruptFlagGet_Default(index, interruptFlag);
175:                 }
176:                 
177:                 PLIB_INLINE_API bool PLIB_USB_ExistsOTG_InterruptStatus(USB_MODULE_ID index)
178:                 {
179:                      return USB_ExistsOTG_InterruptStatus_Default(index);
180:                 }
181:                 
182:                 PLIB_INLINE_API void PLIB_USB_OTG_InterruptEnable(USB_MODULE_ID index, USB_OTG_INTERRUPTS interruptFlag)
183:                 {
184:                      USB_OTG_InterruptEnable_Default(index, interruptFlag);
185:                 }
186:                 
187:                 PLIB_INLINE_API void PLIB_USB_OTG_InterruptDisable(USB_MODULE_ID index, USB_OTG_INTERRUPTS interruptFlag)
188:                 {
189:                      USB_OTG_InterruptDisable_Default(index, interruptFlag);
190:                 }
191:                 
192:                 PLIB_INLINE_API bool PLIB_USB_OTG_InterruptIsEnabled(USB_MODULE_ID index, USB_INTERRUPTS interruptFlag)
193:                 {
194:                      return USB_OTG_InterruptIsEnabled_Default(index, interruptFlag);
195:                 }
196:                 
197:                 PLIB_INLINE_API bool PLIB_USB_ExistsOTG_Interrupt(USB_MODULE_ID index)
198:                 {
199:                      return USB_ExistsOTG_Interrupt_Default(index);
200:                 }
201:                 
202:                 PLIB_INLINE_API bool PLIB_USB_OTG_IDPinStateIsTypeA(USB_MODULE_ID index)
203:                 {
204:                      return USB_OTG_IDPinStateIsTypeA_Default(index);
205:                 }
206:                 
207:                 PLIB_INLINE_API bool PLIB_USB_ExistsOTG_IDPinState(USB_MODULE_ID index)
208:                 {
209:                      return USB_ExistsOTG_IDPinState_Default(index);
210:                 }
211:                 
212:                 PLIB_INLINE_API bool PLIB_USB_OTG_LineStateIsStable(USB_MODULE_ID index)
213:                 {
214:                      return USB_OTG_LineStateIsStable_Default(index);
215:                 }
216:                 
217:                 PLIB_INLINE_API bool PLIB_USB_ExistsOTG_LineState(USB_MODULE_ID index)
218:                 {
219:                      return USB_ExistsOTG_LineState_Default(index);
220:                 }
221:                 
222:                 PLIB_INLINE_API bool PLIB_USB_OTG_SessionValid(USB_MODULE_ID index)
223:                 {
224:                      return USB_OTG_SessionValid_Default(index);
225:                 }
226:                 
227:                 PLIB_INLINE_API bool PLIB_USB_ExistsOTG_SessionValid(USB_MODULE_ID index)
228:                 {
229:                      return USB_ExistsOTG_SessionValid_Default(index);
230:                 }
231:                 
232:                 PLIB_INLINE_API bool PLIB_USB_OTG_BSessionHasEnded(USB_MODULE_ID index)
233:                 {
234:                      return USB_OTG_BSessionHasEnded_Default(index);
235:                 }
236:                 
237:                 PLIB_INLINE_API bool PLIB_USB_ExistsOTG_BSessionEnd(USB_MODULE_ID index)
238:                 {
239:                      return USB_ExistsOTG_BSessionEnd_Default(index);
240:                 }
241:                 
242:                 PLIB_INLINE_API bool PLIB_USB_OTG_VBusValid(USB_MODULE_ID index)
243:                 {
244:                      return USB_OTG_VBusValid_Default(index);
245:                 }
246:                 
247:                 PLIB_INLINE_API bool PLIB_USB_ExistsOTG_ASessionValid(USB_MODULE_ID index)
248:                 {
249:                      return USB_ExistsOTG_ASessionValid_Default(index);
250:                 }
251:                 
252:                 PLIB_INLINE_API void PLIB_USB_OTG_PullUpPullDownSetup(USB_MODULE_ID index, USB_OTG_PULL_UP_PULL_DOWN resistor, bool enableResistor)
253:                 {
254:                      USB_OTG_PullUpPullDownSetup_Default(index, resistor, enableResistor);
255:                 }
256:                 
257:                 PLIB_INLINE_API bool PLIB_USB_ExistsOTG_PullUpPullDown(USB_MODULE_ID index)
258:                 {
259:                      return USB_ExistsOTG_PullUpPullDown_Default(index);
260:                 }
261:                 
262:                 PLIB_INLINE_API void PLIB_USB_OTG_VBusPowerOff(USB_MODULE_ID index)
263:                 {
264:                      USB_OTG_VBusPowerOff_Default(index);
265:                 }
266:                 
267:                 PLIB_INLINE_API void PLIB_USB_OTG_VBusPowerOn(USB_MODULE_ID index)
268:                 {
269:                      USB_OTG_VBusPowerOn_Default(index);
270:                 }
271:                 
272:                 PLIB_INLINE_API bool PLIB_USB_ExistsOTG_VbusPowerOnOff(USB_MODULE_ID index)
273:                 {
274:                      return USB_ExistsOTG_VbusPowerOnOff_Default(index);
275:                 }
276:                 
277:                 PLIB_INLINE_API void PLIB_USB_OTG_VBusChargeEnable(USB_MODULE_ID index)
278:                 {
279:                      USB_OTG_VBusChargeEnable_Default(index);
280:                 }
281:                 
282:                 PLIB_INLINE_API void PLIB_USB_OTG_VBusChargeDisable(USB_MODULE_ID index)
283:                 {
284:                      USB_OTG_VBusChargeDisable_Default(index);
285:                 }
286:                 
287:                 PLIB_INLINE_API bool PLIB_USB_ExistsOTG_VbusCharge(USB_MODULE_ID index)
288:                 {
289:                      return USB_ExistsOTG_VbusCharge_Default(index);
290:                 }
291:                 
292:                 PLIB_INLINE_API void PLIB_USB_OTG_VBusDischargeEnable(USB_MODULE_ID index)
293:                 {
294:                      USB_OTG_VBusDischargeEnable_Default(index);
295:                 }
296:                 
297:                 PLIB_INLINE_API void PLIB_USB_OTG_VBusDischargeDisable(USB_MODULE_ID index)
298:                 {
299:                      USB_OTG_VBusDischargeDisable_Default(index);
300:                 }
301:                 
302:                 PLIB_INLINE_API bool PLIB_USB_ExistsOTG_VbusDischarge(USB_MODULE_ID index)
303:                 {
304:                      return USB_ExistsOTG_VbusDischarge_Default(index);
305:                 }
306:                 
307:                 PLIB_INLINE_API bool PLIB_USB_ActivityPending(USB_MODULE_ID index)
308:                 {
309:                      return USB_ActivityPending_Default(index);
310:                 }
311:                 
312:                 PLIB_INLINE_API bool PLIB_USB_ExistsActivityPending(USB_MODULE_ID index)
313:                 {
314:                      return USB_ExistsActivityPending_Default(index);
315:                 }
316:                 
317:                 PLIB_INLINE_API void PLIB_USB_SleepGuardEnable(USB_MODULE_ID index)
318:                 {
319:                      USB_SleepGuardEnable_Default(index);
320:                 }
321:                 
322:                 PLIB_INLINE_API void PLIB_USB_SleepGuardDisable(USB_MODULE_ID index)
323:                 {
324:                      USB_SleepGuardDisable_Default(index);
325:                 }
326:                 
327:                 PLIB_INLINE_API bool PLIB_USB_ExistsSleepEntryGuard(USB_MODULE_ID index)
328:                 {
329:                      return USB_ExistsSleepEntryGuard_Default(index);
330:                 }
331:                 #ifndef  USB_BUSY_FLAG_DOES_NOT_EXIST
332:                     PLIB_INLINE_API bool PLIB_USB_ModuleIsBusy(USB_MODULE_ID index)
333:                     {
334:                          return USB_ModuleIsBusy_Default(index);
335:                     }
336:                 
337:                     PLIB_INLINE_API bool PLIB_USB_ExistsModuleBusy(USB_MODULE_ID index)
338:                     {
339:                          return USB_ExistsModuleBusy_Default(index);
340:                     }
341:                 
342:                     PLIB_INLINE_API void PLIB_USB_AutoSuspendDisable(USB_MODULE_ID index)
343:                     {
344:                          USB_AutoSuspendDisable_Default(index);
345:                     }
346:                 
347:                     PLIB_INLINE_API void PLIB_USB_AutoSuspendEnable(USB_MODULE_ID index)
348:                     {
349:                          USB_AutoSuspendEnable_Default(index);
350:                     }
351:                 
352:                     PLIB_INLINE_API bool PLIB_USB_ExistsAutomaticSuspend(USB_MODULE_ID index)
353:                     {
354:                          return USB_ExistsAutomaticSuspend_Default(index);
355:                     }
356:                 #endif
357:                 
358:                 PLIB_INLINE_API void PLIB_USB_SuspendEnable(USB_MODULE_ID index)
359:                 {
360:                      USB_SuspendEnable_Default(index);
361:                 }
362:                 
363:                 PLIB_INLINE_API void PLIB_USB_SuspendDisable(USB_MODULE_ID index)
364:                 {
365:                      USB_SuspendDisable_Default(index);
366:                 }
367:                 
368:                 PLIB_INLINE_API bool PLIB_USB_ExistsSuspend(USB_MODULE_ID index)
369:                 {
370:                      return USB_ExistsSuspend_Default(index);
371:                 }
372:                 
373:                 PLIB_INLINE_API void PLIB_USB_Enable(USB_MODULE_ID index)
374:                 {
375:                      USB_Enable_32Bit16Bit(index);
376:                 }
377:                 
378:                 PLIB_INLINE_API void PLIB_USB_Disable(USB_MODULE_ID index)
379:                 {
380:                      USB_Disable_32Bit16Bit(index);
381:                 }
382:                 
383:                 PLIB_INLINE_API bool PLIB_USB_ExistsModulePower(USB_MODULE_ID index)
384:                 {
385:                      return USB_ExistsModulePower_32Bit16Bit(index);
386:                 }
387:                 
388:                 PLIB_INLINE_API void PLIB_USB_InterruptFlagSet(USB_MODULE_ID index, USB_INTERRUPTS interruptFlag)
389:                 {
390:                      USB_InterruptFlagSet_Default(index, interruptFlag);
391:                 }
392:                 
393:                 PLIB_INLINE_API void PLIB_USB_InterruptFlagClear(USB_MODULE_ID index, USB_INTERRUPTS interruptFlag)
394:                 {
395:                      USB_InterruptFlagClear_Default(index, interruptFlag);
396:                 }
397:                 
398:                 PLIB_INLINE_API bool PLIB_USB_InterruptFlagGet(USB_MODULE_ID index, USB_INTERRUPTS interruptFlag)
399:                 {
400:                      return USB_InterruptFlagGet_Default(index, interruptFlag);
401:                 }
402:                 
403:                 PLIB_INLINE_API USB_INTERRUPTS PLIB_USB_InterruptFlagAllGet(USB_MODULE_ID index)
404:                 {
405:                      return USB_InterruptFlagAllGet_Default(index);
406:                 }
407:                 
408:                 PLIB_INLINE_API bool PLIB_USB_ExistsGEN_InterruptStatus(USB_MODULE_ID index)
409:                 {
410:                      return USB_ExistsGEN_InterruptStatus_Default(index);
411:                 }
412:                 
413:                 PLIB_INLINE_API void PLIB_USB_InterruptEnable(USB_MODULE_ID index, USB_INTERRUPTS interruptFlag)
414:                 {
415:                      USB_InterruptEnable_Default(index, interruptFlag);
416:                 }
417:                 
418:                 PLIB_INLINE_API void PLIB_USB_InterruptDisable(USB_MODULE_ID index, USB_INTERRUPTS interruptFlag)
419:                 {
420:                      USB_InterruptDisable_Default(index, interruptFlag);
421:                 }
422:                 
423:                 PLIB_INLINE_API bool PLIB_USB_InterruptIsEnabled(USB_MODULE_ID index, USB_INTERRUPTS interruptFlag)
424:                 {
425:                      return USB_InterruptIsEnabled_Default(index, interruptFlag);
426:                 }
427:                 
428:                 PLIB_INLINE_API bool PLIB_USB_ExistsGEN_Interrupt(USB_MODULE_ID index)
429:                 {
430:                      return USB_ExistsGEN_Interrupt_Default(index);
431:                 }
432:                 
433:                 PLIB_INLINE_API void PLIB_USB_AllInterruptEnable(USB_MODULE_ID index, USB_INTERRUPTS usbInterruptsFlag, USB_ERROR_INTERRUPTS usbErrorInterruptsFlag, USB_OTG_INTERRUPTS otgInterruptFlag)
434:                 {
435:                      USB_AllInterruptEnable_Default(index, usbInterruptsFlag, usbErrorInterruptsFlag, otgInterruptFlag);
436:                 }
437:                 
438:                 PLIB_INLINE_API USB_INTERRUPTS PLIB_USB_InterruptEnableGet(USB_MODULE_ID index)
439:                 {
440:                      return USB_InterruptEnableGet_Default(index);
441:                 }
442:                 
443:                 PLIB_INLINE_API bool PLIB_USB_ExistsALL_Interrupt(USB_MODULE_ID index)
444:                 {
445:                      return USB_ExistsALL_Interrupt_Default(index);
446:                 }
447:                 
448:                 PLIB_INLINE_API void PLIB_USB_ErrorInterruptFlagSet(USB_MODULE_ID index, USB_ERROR_INTERRUPTS interruptFlag)
449:                 {
450:                      USB_ErrorInterruptFlagSet_Default(index, interruptFlag);
451:                 }
452:                 
453:                 PLIB_INLINE_API void PLIB_USB_ErrorInterruptFlagClear(USB_MODULE_ID index, USB_ERROR_INTERRUPTS interruptFlag)
454:                 {
455:                      USB_ErrorInterruptFlagClear_Default(index, interruptFlag);
456:                 }
457:                 
458:                 PLIB_INLINE_API bool PLIB_USB_ErrorInterruptFlagGet(USB_MODULE_ID index, USB_ERROR_INTERRUPTS interruptFlag)
459:                 {
460:                      return USB_ErrorInterruptFlagGet_Default(index, interruptFlag);
461:                 }
462:                 
463:                 PLIB_INLINE_API USB_ERROR_INTERRUPTS PLIB_USB_ErrorInterruptFlagAllGet(USB_MODULE_ID index)
464:                 {
465:                      return USB_ErrorInterruptFlagAllGet_Default(index);
466:                 }
467:                 
468:                 PLIB_INLINE_API bool PLIB_USB_ExistsERR_InterruptStatus(USB_MODULE_ID index)
469:                 {
470:                      return USB_ExistsERR_InterruptStatus_Default(index);
471:                 }
472:                 
473:                 PLIB_INLINE_API void PLIB_USB_ErrorInterruptEnable(USB_MODULE_ID index, USB_ERROR_INTERRUPTS interruptFlag)
474:                 {
475:                      USB_ErrorInterruptEnable_Default(index, interruptFlag);
476:                 }
477:                 
478:                 PLIB_INLINE_API void PLIB_USB_ErrorInterruptDisable(USB_MODULE_ID index, USB_ERROR_INTERRUPTS interruptFlag)
479:                 {
480:                      USB_ErrorInterruptDisable_Default(index, interruptFlag);
481:                 }
482:                 
483:                 PLIB_INLINE_API bool PLIB_USB_ErrorInterruptIsEnabled(USB_MODULE_ID index, USB_INTERRUPTS interruptFlag)
484:                 {
485:                      return USB_ErrorInterruptIsEnabled_Default(index, interruptFlag);
486:                 }
487:                 
488:                 PLIB_INLINE_API bool PLIB_USB_ExistsERR_Interrupt(USB_MODULE_ID index)
489:                 {
490:                      return USB_ExistsERR_Interrupt_Default(index);
491:                 }
492:                 
493:                 PLIB_INLINE_API uint8_t PLIB_USB_LastTransactionEndPtGet(USB_MODULE_ID index)
494:                 {
495:                      return USB_LastTransactionEndPtGet_Default(index);
496:                 }
497:                 
498:                 PLIB_INLINE_API bool PLIB_USB_ExistsLastEndpoint(USB_MODULE_ID index)
499:                 {
500:                      return USB_ExistsLastEndpoint_Default(index);
501:                 }
502:                 
503:                 PLIB_INLINE_API USB_BUFFER_DIRECTION PLIB_USB_LastTransactionDirectionGet(USB_MODULE_ID index)
504:                 {
505:                      return USB_LastTransactionDirectionGet_Default(index);
506:                 }
507:                 
508:                 PLIB_INLINE_API bool PLIB_USB_ExistsLastDirection(USB_MODULE_ID index)
509:                 {
510:                      return USB_ExistsLastDirection_Default(index);
511:                 }
512:                 
513:                 PLIB_INLINE_API USB_PING_PONG_STATE PLIB_USB_LastTransactionPingPongStateGet(USB_MODULE_ID index)
514:                 {
515:                      return USB_LastTransactionPingPongStateGet_Default(index);
516:                 }
517:                 
518:                 PLIB_INLINE_API bool PLIB_USB_ExistsLastPingPong(USB_MODULE_ID index)
519:                 {
520:                      return USB_ExistsLastPingPong_Default(index);
521:                 }
522:                 
523:                 PLIB_INLINE_API void PLIB_USB_LastTransactionDetailsGet(USB_MODULE_ID index, USB_BUFFER_DIRECTION* direction, USB_PING_PONG_STATE* pingpong, uint8_t* endpoint)
524:                 {
525:                      USB_LastTransactionDetailsGet_Default(index, direction, pingpong, endpoint);
526:                 }
527:                 
528:                 PLIB_INLINE_API bool PLIB_USB_ExistsLastTransactionDetails(USB_MODULE_ID index)
529:                 {
530:                      return USB_ExistsLastTransactionDetails_Default(index);
531:                 }
532:                 
533:                 PLIB_INLINE_API bool PLIB_USB_JStateIsActive(USB_MODULE_ID index)
534:                 {
535:                      return USB_JStateIsActive_Default(index);
536:                 }
537:                 
538:                 PLIB_INLINE_API bool PLIB_USB_ExistsLiveJState(USB_MODULE_ID index)
539:                 {
540:                      return USB_ExistsLiveJState_Default(index);
541:                 }
542:                 
543:                 PLIB_INLINE_API bool PLIB_USB_SE0InProgress(USB_MODULE_ID index)
544:                 {
545:                      return USB_SE0InProgress_Default(index);
546:                 }
547:                 
548:                 PLIB_INLINE_API bool PLIB_USB_ExistsLiveSingleEndedZero(USB_MODULE_ID index)
549:                 {
550:                      return USB_ExistsLiveSingleEndedZero_Default(index);
551:                 }
552:                 
553:                 PLIB_INLINE_API bool PLIB_USB_PacketTransferIsDisabled(USB_MODULE_ID index)
554:                 {
555:                      return USB_PacketTransferIsDisabled_Default(index);
556:                 }
557:                 
558:                 PLIB_INLINE_API void PLIB_USB_PacketTransferEnable(USB_MODULE_ID index)
559:                 {
560:                      USB_PacketTransferEnable_Default(index);
561:                 }
562:                 
563:                 PLIB_INLINE_API void PLIB_USB_PacketTransferDisable(USB_MODULE_ID index)
564:                 {
565:                      USB_PacketTransferDisable_Default(index);
566:                 }
567:                 
568:                 PLIB_INLINE_API bool PLIB_USB_ExistsPacketTransfer(USB_MODULE_ID index)
569:                 {
570:                      return USB_ExistsPacketTransfer_Default(index);
571:                 }
572:                 
573:                 PLIB_INLINE_API bool PLIB_USB_IsBusyWithToken(USB_MODULE_ID index)
574:                 {
575:                      return USB_IsBusyWithToken_Default(index);
576:                 }
577:                 
578:                 PLIB_INLINE_API bool PLIB_USB_ExistsHostBusyWithToken(USB_MODULE_ID index)
579:                 {
580:                      return USB_ExistsHostBusyWithToken_Default(index);
581:                 }
582:                 
583:                 PLIB_INLINE_API void PLIB_USB_ResetSignalEnable(USB_MODULE_ID index)
584:                 {
585:                      USB_ResetSignalEnable_Default(index);
586:                 }
587:                 
588:                 PLIB_INLINE_API void PLIB_USB_ResetSignalDisable(USB_MODULE_ID index)
589:                 {
590:                      USB_ResetSignalDisable_Default(index);
591:                 }
592:                 
593:                 PLIB_INLINE_API bool PLIB_USB_ExistsHostGeneratesReset(USB_MODULE_ID index)
594:                 {
595:                      return USB_ExistsHostGeneratesReset_Default(index);
596:                 }
597:                 
598:                 PLIB_INLINE_API void PLIB_USB_OperatingModeSelect(USB_MODULE_ID index, USB_OPMODES opMode)
599:                 {
600:                      USB_OperatingModeSelect_Default(index, opMode);
601:                 }
602:                 
603:                 PLIB_INLINE_API bool PLIB_USB_ExistsOpModeSelect(USB_MODULE_ID index)
604:                 {
605:                      return USB_ExistsOpModeSelect_Default(index);
606:                 }
607:                 
608:                 PLIB_INLINE_API void PLIB_USB_ResumeSignalingEnable(USB_MODULE_ID index)
609:                 {
610:                      USB_ResumeSignalingEnable_Default(index);
611:                 }
612:                 
613:                 PLIB_INLINE_API void PLIB_USB_ResumeSignalingDisable(USB_MODULE_ID index)
614:                 {
615:                      USB_ResumeSignalingDisable_Default(index);
616:                 }
617:                 
618:                 PLIB_INLINE_API bool PLIB_USB_ExistsResumeSignaling(USB_MODULE_ID index)
619:                 {
620:                      return USB_ExistsResumeSignaling_Default(index);
621:                 }
622:                 
623:                 PLIB_INLINE_API void PLIB_USB_PingPongFreeze(USB_MODULE_ID index)
624:                 {
625:                      USB_PingPongFreeze_Default(index);
626:                 }
627:                 
628:                 PLIB_INLINE_API void PLIB_USB_PingPongUnfreeze(USB_MODULE_ID index)
629:                 {
630:                      USB_PingPongUnfreeze_Default(index);
631:                 }
632:                 
633:                 PLIB_INLINE_API void PLIB_USB_PingPongReset(USB_MODULE_ID index)
634:                 {
635:                      USB_PingPongReset_Default(index);
636:                 }
637:                 
638:                 PLIB_INLINE_API bool PLIB_USB_ExistsBufferFreeze(USB_MODULE_ID index)
639:                 {
640:                      return USB_ExistsBufferFreeze_Default(index);
641:                 }
642:                 
643:                 PLIB_INLINE_API void PLIB_USB_SOFEnable(USB_MODULE_ID index)
644:                 {
645:                      USB_SOFEnable_Default(index);
646:                 }
647:                 
648:                 PLIB_INLINE_API void PLIB_USB_SOFDisable(USB_MODULE_ID index)
649:                 {
650:                      USB_SOFDisable_Default(index);
651:                 }
652:                 
653:                 PLIB_INLINE_API bool PLIB_USB_ExistsStartOfFrames(USB_MODULE_ID index)
654:                 {
655:                      return USB_ExistsStartOfFrames_Default(index);
656:                 }
657:                 
658:                 PLIB_INLINE_API void PLIB_USB_TokenSpeedSelect(USB_MODULE_ID index, USB_TOKEN_SPEED tokenSpeed)
659:                 {
660:                      USB_TokenSpeedSelect_Default(index, tokenSpeed);
661:                 }
662:                 
663:                 PLIB_INLINE_API bool PLIB_USB_ExistsNextTokenSpeed(USB_MODULE_ID index)
664:                 {
665:                      return USB_ExistsNextTokenSpeed_Default(index);
666:                 }
667:                 
668:                 PLIB_INLINE_API void PLIB_USB_DeviceAddressSet(USB_MODULE_ID index, uint8_t address)
669:                 {
670:                      USB_DeviceAddressSet_Default(index, address);
671:                 }
672:                 
673:                 PLIB_INLINE_API uint8_t PLIB_USB_DeviceAddressGet(USB_MODULE_ID index)
674:                 {
675:                      return USB_DeviceAddressGet_Default(index);
676:                 }
677:                 
678:                 PLIB_INLINE_API bool PLIB_USB_ExistsDeviceAddress(USB_MODULE_ID index)
679:                 {
680:                      return USB_ExistsDeviceAddress_Default(index);
681:                 }
682:                 
683:                 PLIB_INLINE_API uint16_t PLIB_USB_FrameNumberGet(USB_MODULE_ID index)
684:                 {
685:                      return USB_FrameNumberGet_Default(index);
686:                 }
687:                 
688:                 PLIB_INLINE_API bool PLIB_USB_ExistsFrameNumber(USB_MODULE_ID index)
689:                 {
690:                      return USB_ExistsFrameNumber_Default(index);
691:                 }
692:                 
693:                 PLIB_INLINE_API USB_PID PLIB_USB_TokenPIDGet(USB_MODULE_ID index)
694:                 {
695:                      return USB_TokenPIDGet_Default(index);
696:                 }
697:                 
698:                 PLIB_INLINE_API void PLIB_USB_TokenPIDSet(USB_MODULE_ID index, USB_PID pidValue)
699:                 {
700:                      USB_TokenPIDSet_Default(index, pidValue);
701:                 }
702:                 
703:                 PLIB_INLINE_API void PLIB_USB_TokenSend(USB_MODULE_ID index, USB_PID pidValue, uint8_t endpoint, uint8_t deviceAddress, bool isLowSpeed)
704:                 {
705:                      USB_TokenSend_Default(index, pidValue, endpoint, deviceAddress, isLowSpeed);
706:                 }
707:                 
708:                 PLIB_INLINE_API bool PLIB_USB_ExistsTokenPID(USB_MODULE_ID index)
709:                 {
710:                      return USB_ExistsTokenPID_Default(index);
711:                 }
712:                 
713:                 PLIB_INLINE_API uint8_t PLIB_USB_TokenEPGet(USB_MODULE_ID index)
714:                 {
715:                      return USB_TokenEPGet_Default(index);
716:                 }
717:                 
718:                 PLIB_INLINE_API void PLIB_USB_TokenEPSet(USB_MODULE_ID index, uint8_t epValue)
719:                 {
720:                      USB_TokenEPSet_Default(index, epValue);
721:                 }
722:                 
723:                 PLIB_INLINE_API bool PLIB_USB_ExistsTokenEP(USB_MODULE_ID index)
724:                 {
725:                      return USB_ExistsTokenEP_Default(index);
726:                 }
727:                 
728:                 PLIB_INLINE_API uint8_t PLIB_USB_SOFThresholdGet(USB_MODULE_ID index)
729:                 {
730:                      return USB_SOFThresholdGet_Default(index);
731:                 }
732:                 
733:                 PLIB_INLINE_API void PLIB_USB_SOFThresholdSet(USB_MODULE_ID index, uint8_t threshold)
734:                 {
735:                      USB_SOFThresholdSet_Default(index, threshold);
736:                 }
737:                 
738:                 PLIB_INLINE_API bool PLIB_USB_ExistsSOFThreshold(USB_MODULE_ID index)
739:                 {
740:                      return USB_ExistsSOFThreshold_Default(index);
741:                 }
742:                 
743:                 PLIB_INLINE_API void* PLIB_USB_BDTBaseAddressGet(USB_MODULE_ID index)
744:                 {
745:                      return USB_BDTBaseAddressGet_Default(index);
746:                 }
747:                 
748:                 PLIB_INLINE_API void PLIB_USB_BDTBaseAddressSet(USB_MODULE_ID index, void* address)
749:                 {
750:                      USB_BDTBaseAddressSet_Default(index, address);
751:                 }
752:                 
753:                 PLIB_INLINE_API bool PLIB_USB_ExistsBDTBaseAddress(USB_MODULE_ID index)
754:                 {
755:                      return USB_ExistsBDTBaseAddress_Default(index);
756:                 }
757:                 
758:                 PLIB_INLINE_API void PLIB_USB_EyePatternDisable(USB_MODULE_ID index)
759:                 {
760:                      USB_EyePatternDisable_Default(index);
761:                 }
762:                 
763:                 PLIB_INLINE_API void PLIB_USB_EyePatternEnable(USB_MODULE_ID index)
764:                 {
765:                      USB_EyePatternEnable_Default(index);
766:                 }
767:                 
768:                 PLIB_INLINE_API bool PLIB_USB_ExistsEyePattern(USB_MODULE_ID index)
769:                 {
770:                      return USB_ExistsEyePattern_Default(index);
771:                 }
772:                 
773:                 PLIB_INLINE_API void PLIB_USB_StopInIdleEnable(USB_MODULE_ID index)
774:                 {
775:                      USB_StopInIdleEnable_Default(index);
776:                 }
777:                 
778:                 PLIB_INLINE_API void PLIB_USB_StopInIdleDisable(USB_MODULE_ID index)
779:                 {
780:                      USB_StopInIdleDisable_Default(index);
781:                 }
782:                 
783:                 PLIB_INLINE_API bool PLIB_USB_ExistsStopInIdle(USB_MODULE_ID index)
784:                 {
785:                      return USB_ExistsStopInIdle_Default(index);
786:                 }
787:                 
788:                 
789:                 
790:                 PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USB_PingPongModeSelect(USB_MODULE_ID index, USB_PING_PONG_MODE ppConfig)
791:                 {
792:                      USB_PingPongModeSelect_Unsupported(index, ppConfig);
793:                 }
794:                 
795:                 PLIB_INLINE_API USB_PING_PONG_MODE _PLIB_UNSUPPORTED PLIB_USB_PingPongModeGet(USB_MODULE_ID index)
796:                 {
797:                      return USB_PingPongModeGet_Unsupported(index);
798:                 }
799:                 
800:                 PLIB_INLINE_API bool PLIB_USB_ExistsPingPongMode(USB_MODULE_ID index)
801:                 {
802:                      return USB_ExistsPingPongMode_Unsupported(index);
803:                 }
804:                 
805:                 PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USB_UOEMonitorEnable(USB_MODULE_ID index)
806:                 {
807:                      USB_UOEMonitorEnable_Unsupported(index);
808:                 }
809:                 
810:                 PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USB_UOEMonitorDisable(USB_MODULE_ID index)
811:                 {
812:                      USB_UOEMonitorDisable_Unsupported(index);
813:                 }
814:                 
815:                 PLIB_INLINE_API bool PLIB_USB_ExistsUOEMonitor(USB_MODULE_ID index)
816:                 {
817:                      return USB_ExistsUOEMonitor_Unsupported(index);
818:                 }
819:                 
820:                 PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USB_OnChipPullUpEnable(USB_MODULE_ID index)
821:                 {
822:                      USB_OnChipPullUpEnable_Unsupported(index);
823:                 }
824:                 
825:                 PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USB_OnChipPullUpDisable(USB_MODULE_ID index)
826:                 {
827:                      USB_OnChipPullUpDisable_Unsupported(index);
828:                 }
829:                 
830:                 PLIB_INLINE_API bool PLIB_USB_ExistsOnChipPullup(USB_MODULE_ID index)
831:                 {
832:                      return USB_ExistsOnChipPullup_Unsupported(index);
833:                 }
834:                 
835:                 PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USB_TransceiverEnable(USB_MODULE_ID index)
836:                 {
837:                      USB_TransceiverEnable_Unsupported(index);
838:                 }
839:                 
840:                 PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USB_TransceiverDisable(USB_MODULE_ID index)
841:                 {
842:                      USB_TransceiverDisable_Unsupported(index);
843:                 }
844:                 
845:                 PLIB_INLINE_API bool PLIB_USB_ExistsOnChipTransceiver(USB_MODULE_ID index)
846:                 {
847:                      return USB_ExistsOnChipTransceiver_Unsupported(index);
848:                 }
849:                 
850:                 PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USB_FullSpeedEnable(USB_MODULE_ID index)
851:                 {
852:                      USB_FullSpeedEnable_Unsupported(index);
853:                 }
854:                 
855:                 PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USB_FullSpeedDisable(USB_MODULE_ID index)
856:                 {
857:                      USB_FullSpeedDisable_Unsupported(index);
858:                 }
859:                 
860:                 PLIB_INLINE_API bool PLIB_USB_ExistsSpeedControl(USB_MODULE_ID index)
861:                 {
862:                      return USB_ExistsSpeedControl_Unsupported(index);
863:                 }
864:                 
865:                 PLIB_INLINE_API void PLIB_USB_EP0LSDirectConnectEnable(USB_MODULE_ID index)
866:                 {
867:                      USB_EP0LSDirectConnectEnable_Default(index);
868:                 }
869:                 
870:                 PLIB_INLINE_API void PLIB_USB_EP0LSDirectConnectDisable(USB_MODULE_ID index)
871:                 {
872:                      USB_EP0LSDirectConnectDisable_Default(index);
873:                 }
874:                 
875:                 PLIB_INLINE_API bool PLIB_USB_ExistsEP0LowSpeedConnect(USB_MODULE_ID index)
876:                 {
877:                      return USB_ExistsEP0LowSpeedConnect_Default(index);
878:                 }
879:                 
880:                 PLIB_INLINE_API void PLIB_USB_EP0NakRetryEnable(USB_MODULE_ID index)
881:                 {
882:                      USB_EP0NakRetryEnable_Default(index);
883:                 }
884:                 
885:                 PLIB_INLINE_API void PLIB_USB_EP0NakRetryDisable(USB_MODULE_ID index)
886:                 {
887:                      USB_EP0NakRetryDisable_Default(index);
888:                 }
889:                 
890:                 PLIB_INLINE_API bool PLIB_USB_ExistsEP0NAKRetry(USB_MODULE_ID index)
891:                 {
892:                      return USB_ExistsEP0NAKRetry_Default(index);
893:                 }
894:                 
895:                 PLIB_INLINE_API void PLIB_USB_EPnTxSelect(USB_MODULE_ID index, uint8_t epValue, USB_EP_TXRX epTxRx)
896:                 {
897:                      USB_EPnTxSelect_Default(index, epValue, epTxRx);
898:                 }
899:                 
900:                 PLIB_INLINE_API void PLIB_USB_EPnRxSelect(USB_MODULE_ID index, uint8_t epValue, USB_EP_TXRX epTxRx)
901:                 {
902:                      USB_EPnRxSelect_Default(index, epValue, epTxRx);
903:                 }
904:                 
905:                 PLIB_INLINE_API void PLIB_USB_EPnTxRxSelect(USB_MODULE_ID index, uint8_t epValue, USB_EP_TXRX epTxRx)
906:                 {
907:                      USB_EPnTxRxSelect_Default(index, epValue, epTxRx);
908:                 }
909:                 
910:                 PLIB_INLINE_API bool PLIB_USB_ExistsEPnTxRx(USB_MODULE_ID index)
911:                 {
912:                      return USB_ExistsEPnTxRx_Default(index);
913:                 }
914:                 
915:                 PLIB_INLINE_API void PLIB_USB_EPnRxEnable(USB_MODULE_ID index, uint8_t endpoint)
916:                 {
917:                      USB_EPnRxEnable_PIC32(index, endpoint);
918:                 }
919:                 
920:                 PLIB_INLINE_API void PLIB_USB_EPnRxDisable(USB_MODULE_ID index, uint8_t endpoint)
921:                 {
922:                      USB_EPnRxDisable_PIC32(index, endpoint);
923:                 }
924:                 
925:                 PLIB_INLINE_API void PLIB_USB_EPnTxEnable(USB_MODULE_ID index, uint8_t endpoint)
926:                 {
927:                      USB_EPnTxEnable_PIC32(index, endpoint);
928:                 }
929:                 
930:                 PLIB_INLINE_API void PLIB_USB_EPnTxDisable(USB_MODULE_ID index, uint8_t endpoint)
931:                 {
932:                      USB_EPnTxDisable_PIC32(index, endpoint);
933:                 }
934:                 
935:                 PLIB_INLINE_API void PLIB_USB_EPnHandshakeEnable(USB_MODULE_ID index, uint8_t epValue)
936:                 {
937:                      USB_EPnHandshakeEnable_PIC32(index, epValue);
938:                 }
939:                 
940:                 PLIB_INLINE_API void PLIB_USB_EPnHandshakeDisable(USB_MODULE_ID index, uint8_t epValue)
941:                 {
942:                      USB_EPnHandshakeDisable_PIC32(index, epValue);
943:                 }
944:                 
945:                 PLIB_INLINE_API void PLIB_USB_EPnControlTransferEnable(USB_MODULE_ID index, uint8_t epValue)
946:                 {
947:                      USB_EPnControlTransferEnable_PIC32(index, epValue);
948:                 }
949:                 
950:                 PLIB_INLINE_API void PLIB_USB_EPnControlTransferDisable(USB_MODULE_ID index, uint8_t epValue)
951:                 {
952:                      USB_EPnControlTransferDisable_PIC32(index, epValue);
953:                 }
954:                 
955:                 PLIB_INLINE_API void PLIB_USB_EPnAttributesSet(USB_MODULE_ID index, uint8_t epValue, int direction, bool isControl, bool handshake)
956:                 {
957:                      USB_EPnAttributesSet_PIC32(index, epValue, direction, isControl, handshake);
958:                 }
959:                 
960:                 PLIB_INLINE_API void PLIB_USB_EPnDirectionDisable(USB_MODULE_ID index, uint8_t epValue, int direction)
961:                 {
962:                      USB_EPnDirectionDisable_PIC32(index, epValue, direction);
963:                 }
964:                 
965:                 PLIB_INLINE_API void PLIB_USB_EPnAttributesClear(USB_MODULE_ID index, uint8_t epValue)
966:                 {
967:                      USB_EPnAttributesClear_PIC32(index, epValue);
968:                 }
969:                 
970:                 PLIB_INLINE_API bool PLIB_USB_EPnIsStalled(USB_MODULE_ID index, uint8_t epValue)
971:                 {
972:                      return USB_EPnIsStalled_PIC32(index, epValue);
973:                 }
974:                 
975:                 PLIB_INLINE_API void PLIB_USB_EPnStallClear(USB_MODULE_ID index, uint8_t epValue)
976:                 {
977:                      USB_EPnStallClear_PIC32(index, epValue);
978:                 }
979:                 
980:                 PLIB_INLINE_API void PLIB_USB_EP0HostSetup(USB_MODULE_ID index)
981:                 {
982:                      USB_EP0HostSetup_PIC32(index);
983:                 }
984:                 
985:                 PLIB_INLINE_API bool PLIB_USB_ExistsEPnRxEnable(USB_MODULE_ID index)
986:                 {
987:                      return USB_ExistsEPnRxEnable_PIC32(index);
988:                 }
989:                 
990:                 PLIB_INLINE_API void* PLIB_USB_BufferAddressGet(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
991:                 {
992:                      return USB_BufferAddressGet_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
993:                 }
994:                 
995:                 PLIB_INLINE_API void PLIB_USB_BufferAddressSet(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong, void* bufferAddress)
996:                 {
997:                      USB_BufferAddressSet_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong, bufferAddress);
998:                 }
999:                 
1000:                PLIB_INLINE_API uint16_t PLIB_USB_BufferByteCountGet(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1001:                {
1002:                     return USB_BufferByteCountGet_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1003:                }
1004:                
1005:                PLIB_INLINE_API void PLIB_USB_BufferByteCountSet(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong, uint16_t bufferByteCount)
1006:                {
1007:                     USB_BufferByteCountSet_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong, bufferByteCount);
1008:                }
1009:                
1010:                PLIB_INLINE_API void PLIB_USB_BufferCancelReleaseToUSB(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1011:                {
1012:                     USB_BufferCancelReleaseToUSB_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1013:                }
1014:                
1015:                PLIB_INLINE_API void PLIB_USB_BufferAllCancelReleaseToUSB(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, int nEndpoints)
1016:                {
1017:                     USB_BufferAllCancelReleaseToUSB_PIC32(index, pBDT, ppMode, nEndpoints);
1018:                }
1019:                
1020:                PLIB_INLINE_API void PLIB_USB_BufferClearAll(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1021:                {
1022:                     USB_BufferClearAll_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1023:                }
1024:                
1025:                PLIB_INLINE_API USB_BUFFER_DATA01 PLIB_USB_BufferDataToggleGet(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1026:                {
1027:                     return USB_BufferDataToggleGet_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1028:                }
1029:                
1030:                PLIB_INLINE_API void PLIB_USB_BufferDataToggleSelect(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong, USB_BUFFER_DATA01 bufferData01)
1031:                {
1032:                     USB_BufferDataToggleSelect_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong, bufferData01);
1033:                }
1034:                
1035:                PLIB_INLINE_API void PLIB_USB_BufferDataToggleSyncEnable(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1036:                {
1037:                     USB_BufferDataToggleSyncEnable_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1038:                }
1039:                
1040:                PLIB_INLINE_API void PLIB_USB_BufferDataToggleSyncDisable(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1041:                {
1042:                     USB_BufferDataToggleSyncDisable_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1043:                }
1044:                
1045:                PLIB_INLINE_API uint8_t PLIB_USB_BufferIndexGet(USB_MODULE_ID index, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1046:                {
1047:                     return USB_BufferIndexGet_PIC32(index, ppMode, epValue, bufferDirection, bufferPingPong);
1048:                }
1049:                
1050:                PLIB_INLINE_API void PLIB_USB_BufferPIDBitsClear(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1051:                {
1052:                     USB_BufferPIDBitsClear_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1053:                }
1054:                
1055:                PLIB_INLINE_API uint8_t PLIB_USB_BufferPIDGet(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1056:                {
1057:                     return USB_BufferPIDGet_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1058:                }
1059:                
1060:                PLIB_INLINE_API bool PLIB_USB_BufferReleasedToSW(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1061:                {
1062:                     return USB_BufferReleasedToSW_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1063:                }
1064:                
1065:                PLIB_INLINE_API void PLIB_USB_BufferReleaseToUSB(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1066:                {
1067:                     USB_BufferReleaseToUSB_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1068:                }
1069:                
1070:                PLIB_INLINE_API void PLIB_USB_BufferSchedule(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong, void* bufferAddress, int16_t bufferByteCount, USB_BUFFER_SCHEDULE_DATA01 bufferData01)
1071:                {
1072:                     USB_BufferSchedule_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong, bufferAddress, bufferByteCount, bufferData01);
1073:                }
1074:                
1075:                PLIB_INLINE_API void PLIB_USB_BufferStallDisable(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1076:                {
1077:                     USB_BufferStallDisable_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1078:                }
1079:                
1080:                PLIB_INLINE_API void PLIB_USB_BufferStallEnable(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1081:                {
1082:                     USB_BufferStallEnable_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1083:                }
1084:                
1085:                PLIB_INLINE_API bool PLIB_USB_BufferStallGet(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1086:                {
1087:                     return USB_BufferStallGet_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1088:                }
1089:                
1090:                PLIB_INLINE_API void PLIB_USB_BufferEP0RxStatusInitialize(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, USB_BUFFER_PING_PONG pingpong, uint16_t bufferByteCount)
1091:                {
1092:                     USB_BufferEP0RxStatusInitialize_PIC32(index, pBDT, ppMode, pingpong, bufferByteCount);
1093:                }
1094:                
1095:                PLIB_INLINE_API void PLIB_USB_BufferClearAllDTSEnable(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection)
1096:                {
1097:                     USB_BufferClearAllDTSEnable_PIC32(index, pBDT, ppMode, epValue, bufferDirection);
1098:                }
1099:                
1100:                PLIB_INLINE_API bool PLIB_USB_ExistsBDTFunctions(USB_MODULE_ID index)
1101:                {
1102:                     return USB_ExistsBDTFunctions_PIC32(index);
1103:                }
1104:                
1105:                #endif
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000050  00000000   NOP
9D0011B0  10400005   BEQ V0, ZERO, 0x9D0011C8
9D0011B8  8E020010   LW V0, 16(S0)
9D0011E0  AE0201E0   SW V0, 480(S0)
9D0011E4  AE0201C0   SW V0, 448(S0)
9D0011E8  240200F5   ADDIU V0, ZERO, 245
9D001220  8E020000   LW V0, 0(S0)
9D001230  8E020010   LW V0, 16(S0)
9D001240  AE020000   SW V0, 0(S0)
9D001244  8E020010   LW V0, 16(S0)
9D00126C  8E0201C0   LW V0, 448(S0)
9D00127C  8E0201D0   LW V0, 464(S0)
9D0012A8  24020020   ADDIU V0, ZERO, 32
9D0012B0  8E0201D0   LW V0, 464(S0)
9D0012BC  8E0201C0   LW V0, 448(S0)
9D0012CC  8E0201D0   LW V0, 464(S0)
9D0012E4  AE0401C0   SW A0, 448(S0)
9D0012E8  24040010   ADDIU A0, ZERO, 16
9D001310  8E020210   LW V0, 528(S0)
9D001338  7C023004   INS V0, ZERO, 0, 7
9D001354  24020001   ADDIU V0, ZERO, 1
9D00135C  8E0201C0   LW V0, 448(S0)
9D00136C  8E0201D0   LW V0, 464(S0)
9D001394  24020010   ADDIU V0, ZERO, 16
9D001398  AE0201C0   SW V0, 448(S0)
9D00139C  8E020010   LW V0, 16(S0)
9D0013A8  8E0201D0   LW V0, 464(S0)
9D0013BC  8E0201C0   LW V0, 448(S0)
9D0013CC  8E0201D0   LW V0, 464(S0)
9D0013F4  24020004   ADDIU V0, ZERO, 4
9D0013F8  AE0201C0   SW V0, 448(S0)
9D0013FC  8E0201C0   LW V0, 448(S0)
9D00140C  8E0201D0   LW V0, 464(S0)
9D001420  2462002C   ADDIU V0, V1, 44
9D001424  00021100   SLL V0, V0, 4
9D001428  02021021   ADDU V0, S0, V0
9D00142C  8C440000   LW A0, 0(V0)
9D001468  24020080   ADDIU V0, ZERO, 128
9D001470  8E0201C0   LW V0, 448(S0)
9D0014D8  8E0201C0   LW V0, 448(S0)
9D0014E8  8E110200   LW S1, 512(S0)
9D001500  AE1401C0   SW S4, 448(S0)
9D001590  8E020020   LW V0, 32(S0)
9D0015C0  AE030000   SW V1, 0(S0)
9D0015E8  8E0201D0   LW V0, 464(S0)
9D0015F8  8E0201E0   LW V0, 480(S0)
9D001608  24020002   ADDIU V0, ZERO, 2
9D00163C  AE050000   SW A1, 0(S0)
9D0016B8  A2040210   SB A0, 528(S0)
9D0017B8  24020008   ADDIU V0, ZERO, 8
9D003E8C  2414FFFC   ADDIU S4, ZERO, -4
9D004394  AD0902C0   SW T1, 704(T0)
9D0043F8  00084100   SLL T0, T0, 4
9D00500C  922202A0   LBU V0, 672(S1)
9D005018  7C622104   INS V0, V1, 4, 1
9D005020  90A20009   LBU V0, 9(A1)
9D00502C  AE2202A8   SW V0, 680(S1)
9D00504C  00022602   SRL A0, V0, 24
9D00508C  A22202A0   SB V0, 672(S1)
9D005090  90A20009   LBU V0, 9(A1)
9D005094  1440FFE5   BNE V0, ZERO, DRV_USBFS_Initialize::PLIB_USB_AutoSuspendEnable
9D005098  24020001   ADDIU V0, ZERO, 1
9D00509C  AE2202A4   SW V0, 676(S1)
9D005914  8C8202C0   LW V0, 704(A0)
9D005948  8C8702C0   LW A3, 704(A0)
9D005978  00041900   SLL V1, A0, 4
9D00597C  01031821   ADDU V1, T0, V1
9D0072F4  AC4501C0   SW A1, 448(V0)
9D0072F8  8C4301D0   LW V1, 464(V0)
9D007308  AC4501E0   SW A1, 480(V0)
9D00730C  8C4301F0   LW V1, 496(V0)
9D007318  240300F5   ADDIU V1, ZERO, 245
9D007320  8C430010   LW V1, 16(V0)
9D00732C  90430210   LBU V1, 528(V0)
9D007460  90430210   LBU V1, 528(V0)
9D007494  240300DF   ADDIU V1, ZERO, 223
9D00791C  8C830020   LW V1, 32(A0)
9D00802C  8C830020   LW V1, 32(A0)
9D0081A0  8C820020   LW V0, 32(A0)
9D0081C8  8C830020   LW V1, 32(A0)
9D0081F0  8C830020   LW V1, 32(A0)
9D008218  AC4301D0   SW V1, 464(V0)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/drv_usbfs_device.c  ---
1:                   /*******************************************************************************
2:                     USB Device Driver Implementation of device mode operation routines
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_usbfs_device.c
9:                   
10:                    Summary:
11:                      USB Device Driver Dynamic Implementation of device mode operation routines
12:                  
13:                    Description:
14:                      The USB device driver provides a simple interface to manage the USB modules
15:                      on Microchip microcontrollers.  This file implements the interface routines
16:                      for the USB driver when operating in device mode.
17:                  
18:                      While building the driver from source, ALWAYS use this file in the build if
19:                      device mode operation is required.
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip  Technology  Inc.   All  rights  reserved.
25:                  
26:                  Microchip licenses to  you  the  right  to  use,  modify,  copy  and  distribute
27:                  Software only when embedded on a Microchip  microcontroller  or  digital  signal
28:                  controller  that  is  integrated  into  your  product  or  third  party  product
29:                  (pursuant to the  sublicense  terms  in  the  accompanying  license  agreement).
30:                  
31:                  You should refer  to  the  license  agreement  accompanying  this  Software  for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS  WITHOUT  WARRANTY  OF  ANY  KIND,
35:                  EITHER EXPRESS  OR  IMPLIED,  INCLUDING  WITHOUT  LIMITATION,  ANY  WARRANTY  OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A  PARTICULAR  PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR  ITS  LICENSORS  BE  LIABLE  OR  OBLIGATED  UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,  BREACH  OF  WARRANTY,  OR
39:                  OTHER LEGAL  EQUITABLE  THEORY  ANY  DIRECT  OR  INDIRECT  DAMAGES  OR  EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY  INCIDENTAL,  SPECIAL,  INDIRECT,  PUNITIVE  OR
41:                  CONSEQUENTIAL DAMAGES, LOST  PROFITS  OR  LOST  DATA,  COST  OF  PROCUREMENT  OF
42:                  SUBSTITUTE  GOODS,  TECHNOLOGY,  SERVICES,  OR  ANY  CLAIMS  BY  THIRD   PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  THEREOF),  OR  OTHER  SIMILAR  COSTS.
44:                  *******************************************************************************/
45:                  //DOM-IGNORE-END
46:                  
47:                  #include "configuration.h"
48:                  #include "driver/usb/usbfs/drv_usbfs.h"
49:                  #include "driver/usb/usbfs/src/drv_usbfs_local.h"
50:                  
51:                  /*****************************************************
52:                   * This structure is a pointer to a set of USB Driver
53:                   * Device mode functions. This set is exported to the
54:                   * device layer when the device layer must use the
55:                   * PIC32MX USB Controller.
56:                   ******************************************************/
57:                  
58:                  DRV_USB_DEVICE_INTERFACE gDrvUSBFSDeviceInterface =
59:                  {
60:                      .open = DRV_USBFS_Open,
61:                      .close = DRV_USBFS_Close,
62:                      .eventHandlerSet = DRV_USBFS_ClientEventCallBackSet,
63:                      .deviceAddressSet = DRV_USBFS_DEVICE_AddressSet,
64:                      .deviceCurrentSpeedGet = DRV_USBFS_DEVICE_CurrentSpeedGet,
65:                      .deviceSOFNumberGet = DRV_USBFS_DEVICE_SOFNumberGet,
66:                      .deviceAttach = DRV_USBFS_DEVICE_Attach,
67:                      .deviceDetach = DRV_USBFS_DEVICE_Detach,
68:                      .deviceEndpointEnable = DRV_USBFS_DEVICE_EndpointEnable,
69:                      .deviceEndpointDisable = DRV_USBFS_DEVICE_EndpointDisable,
70:                      .deviceEndpointStall = DRV_USBFS_DEVICE_EndpointStall,
71:                      .deviceEndpointStallClear = DRV_USBFS_DEVICE_EndpointStallClear,
72:                      .deviceEndpointIsEnabled = DRV_USBFS_DEVICE_EndpointIsEnabled,
73:                      .deviceEndpointIsStalled = DRV_USBFS_DEVICE_EndpointIsStalled,
74:                      .deviceIRPSubmit = DRV_USBFS_DEVICE_IRPSubmit,
75:                      .deviceIRPCancel = DRV_USBFS_DEVICE_IRPCancel,
76:                      .deviceIRPCancelAll = DRV_USBFS_DEVICE_IRPCancelAll,
77:                      .deviceRemoteWakeupStop = DRV_USBFS_DEVICE_RemoteWakeupStop,
78:                      .deviceRemoteWakeupStart = DRV_USBFS_DEVICE_RemoteWakeupStart,
79:                      .deviceTestModeEnter = NULL
80:                  };
81:                  
82:                  // *****************************************************************************
83:                  /* Function:
84:                      _DRV_USBFS_DEVICE_Initialize(DRV_USBFS_OBJ * drvObj, SYS_MODULE_INDEX index)
85:                  
86:                    Summary:
87:                      This function is calle when the driver is intialized for device mode
88:                      operation.
89:                  
90:                    Description:
91:                      This function is called when the driver is intialized for device mode
92:                      operation. The function enables USB_OTG_INT_SESSION_VALID interrupt to
93:                      detect VBUS session valid\invalid scenario. All the other interrupts will be
94:                      enabled after the device has been attached (DRV_USBFS_DEVICE_Attach()
95:                      function will be called)
96:                  
97:                    Remarks:
98:                      See drv_usbfs.h for usage information.
99:                  */
100:                 
101:                 void _DRV_USBFS_DEVICE_Initialize
102:                 (
103:                     DRV_USBFS_OBJ * drvObj, 
104:                     SYS_MODULE_INDEX index
105:                 )
106:                 {
107:                     /* Initialize device specific flags */
108:                     drvObj->vbusIsValid = false;
109:                     drvObj->isAttached = false;
110:                     drvObj->isSuspended = false;
111:                 
112:                     /* Disable all interrupts */
113:                     PLIB_USB_AllInterruptEnable(drvObj->usbID, ~USB_INT_ALL, ~USB_ERR_INT_ALL, ~USB_OTG_INT_ALL);
114:                 }
115:                 
116:                 // *****************************************************************************
117:                 /* Function:
118:                     void DRV_USBFS_DEVICE_AddressSet(DRV_HANDLE handle, uint8_t address)
119:                 
120:                   Summary:
121:                     This function will set the USB module address that is obtained from the Host.
122:                 
123:                   Description:
124:                     This function will set the USB module address  that  is  obtained  from  the
125:                     Host in a setup transaction. The address is obtained from  the  SET_ADDRESS
126:                     command issued by the Host. The  primary  (first)  client  of  the  driver
127:                     uses this function to set the module's USB address after decoding the  setup
128:                     transaction from the Host.
129:                 
130:                   Remarks:
131:                     See drv_usbfs.h for usage information.
132:                 */
133:                 
134:                 void DRV_USBFS_DEVICE_AddressSet(DRV_HANDLE handle, uint8_t address)
135:                 {
136:                     /* Check if the handle is valid */
137:                     if((DRV_HANDLE_INVALID != handle) && (handle != (DRV_HANDLE)(NULL)))
138:                     {
139:                         /* Set the address */
140:                         PLIB_USB_DeviceAddressSet( ((DRV_USBFS_OBJ *)handle)->usbID, address );
141:                     }
142:                     else
143:                     {
144:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
145:                     }
146:                 }
147:                 
148:                 // *****************************************************************************
149:                 /* Function:
150:                     USB_SPEED DRV_USBFS_DEVICE_CurrentSpeedGet(DRV_HANDLE handle)
151:                 
152:                   Summary:
153:                     This function returns the USB speed at which the device is operating.
154:                 
155:                   Description:
156:                     This function returns the USB speed at which the device is operating. 
157:                 
158:                   Remarks:
159:                     See drv_usbfs.h for usage information.
160:                 */
161:                 
162:                 USB_SPEED DRV_USBFS_DEVICE_CurrentSpeedGet(DRV_HANDLE handle)
163:                 {
164:                     USB_SPEED speed = USB_SPEED_ERROR;
165:                 
166:                     /* Check if the handle is valid */
167:                     if((DRV_HANDLE_INVALID != handle) && (handle != (DRV_HANDLE)(NULL)))
168:                     {
169:                         speed = USB_SPEED_FULL;
170:                     }
171:                     else
172:                     {
173:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
174:                     }
175:                     
176:                     /* Return the speed */
177:                     return speed;
178:                 }
179:                 
180:                 // *****************************************************************************
181:                 /* Function:
182:                     void DRV_USBFS_DEVICE_RemoteWakeup_Start(DRV_HANDLE handle)
183:                 
184:                   Summary:
185:                     This function causes the device to start Remote Wakeup Signalling on the
186:                     bus.
187:                     
188:                   Description:
189:                     This function causes the device to start Remote Wakeup Signalling on the
190:                     bus. This function should be called when the device, presently placed in
191:                     suspend mode by the Host, wants to be wakeup. Note that the device can do
192:                     this only when the Host has enabled the device's Remote Wakeup capability.
193:                 
194:                   Remarks:
195:                     See drv_usbfs.h for usage information.
196:                 */
197:                 
198:                 void DRV_USBFS_DEVICE_RemoteWakeupStart(DRV_HANDLE handle)
199:                 {
200:                     /* Check if the handle is valid */
201:                     if((DRV_HANDLE_INVALID != handle) && (handle != (DRV_HANDLE)(NULL)))
202:                     {
203:                         /* Enable Resume signalling */
204:                         PLIB_USB_ResumeSignalingEnable(((DRV_USBFS_OBJ *)handle)->usbID);
205:                     }
206:                     else
207:                     {
208:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
209:                     }
210:                 }
211:                 
212:                 // *****************************************************************************
213:                 /* Function:
214:                     void DRV_USBFS_DEVICE_RemoteWakeupStop(DRV_HANDLE handle)
215:                 
216:                   Summary:
217:                     This function causes the device to stop the Remote Wakeup Signalling on the
218:                     bus.
219:                     
220:                   Description:
221:                     This function causes the device to stop Remote Wakeup Signalling on the bus.
222:                     This function should be called after the DRV_USBFS_DEVICE_RemoteWakeupStart
223:                     function was called to start the Remote Wakeup signaling on the bus.
224:                 
225:                   Remarks:
226:                     See drv_usbfs.h for usage information.
227:                 */
228:                 
229:                 void DRV_USBFS_DEVICE_RemoteWakeupStop(DRV_HANDLE handle)
230:                 {
231:                     /* Check if the handle is valid */
232:                     if((DRV_HANDLE_INVALID != handle) && (handle != (DRV_HANDLE)(NULL)))
233:                     {
234:                         /* Disable Resume signalling */
235:                         PLIB_USB_ResumeSignalingDisable(((DRV_USBFS_OBJ *)handle)->usbID);
236:                     }
237:                     else
238:                     {
239:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
240:                     }
241:                 }
242:                 
243:                 // *****************************************************************************
244:                 /* Function:
245:                     void DRV_USBFS_DEVICE_Attach(DRV_HANDLE handle)
246:                 
247:                   Summary:
248:                     This function will enable the attach signaling resistors on the D+ and D-
249:                     lines thus letting the USB Host know that a device has been attached on the
250:                     bus.
251:                 
252:                   Description:
253:                     This function enables the pull-up resistors on the D+ or D- lines thus
254:                     letting the USB Host know that a device has been attached on the bus . This
255:                     function should be called when the driver client is ready  to  receive
256:                     communication  from  the  Host (typically after all initialization is
257:                     complete). The USB 2.0 specification requires VBUS to be detected before the
258:                     data line pull-ups are enabled. The application must ensure the same.
259:                 
260:                   Remarks:
261:                     See drv_usbfs.h for usage information.
262:                 */
263:                 
264:                 void DRV_USBFS_DEVICE_Attach(DRV_HANDLE handle)
265:                 {
266:                     /* Check if the handle is valid */
267:                     if((DRV_HANDLE_INVALID != handle) && (handle != (DRV_HANDLE)(NULL)))
268:                     {
269:                         /* Update the driver flag indicating attach */
270:                         ((DRV_USBFS_OBJ *)handle)->isAttached = true;
271:                 
272:                         /* Configure the peripheral for device mode operation. This function
273:                          * also enables the D+ pull up resistor.  */
274:                         PLIB_USB_OperatingModeSelect(((DRV_USBFS_OBJ *)handle)->usbID, USB_OPMODE_DEVICE);
275:                 
276:                         /* Enables all interrupts except RESUME. RESUMEIF will be enabled only
277:                          * on getting SUSPEND */
278:                         PLIB_USB_AllInterruptEnable(((DRV_USBFS_OBJ *)handle)->usbID, (USB_INT_ALL & ~USB_INT_RESUME), USB_ERR_INT_ALL, ((~USB_OTG_INT_ALL) | USB_OTG_INT_SESSION_VALID | USB_OTG_INT_ACTIVITY_DETECT));
279:                     }
280:                     else
281:                     {
282:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
283:                     }
284:                 }
285:                 
286:                 // *****************************************************************************
287:                 /* Function:
288:                       void DRV_USBFS_DEVICE_Detach(DRV_HANDLE handle)
289:                 
290:                   Summary:
291:                     This function will disable the attach signaling resistors on the D+ and D-
292:                     lines thus letting the USB Host know that the device has detached from the
293:                     bus.
294:                 
295:                   Description:
296:                     This function disables the pull-up resistors on the D+ or D- lines. This
297:                     function should be called when the application wants to disconnect the
298:                     device  from  the bus (typically to implement a soft detach or switch  to
299:                     Host  mode operation).  A self-powered device should be detached from the
300:                     bus when the VBUS is not valid.
301:                 
302:                   Remarks:
303:                     See drv_usbfs.h for usage information.
304:                 */
305:                 
306:                 void DRV_USBFS_DEVICE_Detach(DRV_HANDLE handle)
307:                 {
308:                     /* Check if the handle is valid */
309:                     if((DRV_HANDLE_INVALID != handle) && (handle != (DRV_HANDLE)(NULL)))
310:                     {
311:                         /* Update the driver flag indicating detach */
312:                         ((DRV_USBFS_OBJ *)handle)->isAttached = false;
313:                 
314:                         /* Clear all the USB interrupt flags */
315:                         PLIB_USB_InterruptFlagClear(((DRV_USBFS_OBJ *)handle)->usbID, USB_INT_ALL);
316:                         
317:                         /* Disable all the USB interrupts */
318:                         PLIB_USB_InterruptDisable(((DRV_USBFS_OBJ *)handle)->usbID, (USB_INT_ALL)); 
319:                         
320:                         /* Clear all USB Error Interrupt flags */
321:                         PLIB_USB_ErrorInterruptFlagClear(((DRV_USBFS_OBJ *)handle)->usbID, USB_ERR_INT_ALL);
322:                         
323:                         /* Disable all USB Error interrupts */
324:                         PLIB_USB_ErrorInterruptDisable(((DRV_USBFS_OBJ *)handle)->usbID, USB_ERR_INT_ALL);   
325:                         
326:                         /* Clear the interrupt flags excep Session Valid interrupt flag */
327:                         PLIB_USB_OTG_InterruptFlagClear(((DRV_USBFS_OBJ *)handle)->usbID, (USB_OTG_INT_ALL & (~ USB_OTG_INT_SESSION_VALID)));
328:                         
329:                         /* Disable all interrupts except Session Valid Interrupt Enable */
330:                         PLIB_USB_OTG_InterruptDisable(((DRV_USBFS_OBJ *)handle)->usbID, (USB_OTG_INT_ALL & (~ USB_OTG_INT_SESSION_VALID))); 
331:                         
332:                         /* Reset the operating mode */
333:                         PLIB_USB_OperatingModeSelect(((DRV_USBFS_OBJ *)handle)->usbID, USB_OPMODE_NONE);
334:                     }
335:                     else
336:                     {
337:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
338:                     }
339:                 }
340:                 
341:                 // *****************************************************************************
342:                 /* Function:
343:                     void _DRV_USBFS_DEVICE_EndpointObjectEnable
344:                     (
345:                         DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject,
346:                         uint16_t endpointSize,
347:                         USB_TRANSFER_TYPE endpointType,
348:                         USB_BUFFER_DATA01 dataToggle
349:                      )
350:                 
351:                   Summary:
352:                     This helper function populates the software endpoint object with provided
353:                     data.
354:                 
355:                   Description:
356:                     This helper function populates the software endpoint object with provided
357:                     data.
358:                 
359:                   Remarks:
360:                     This is a local function and should not be called directly by the
361:                     application.
362:                 */
363:                 
364:                 void _DRV_USBFS_DEVICE_EndpointObjectEnable
365:                 (
366:                     DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject,
367:                     uint16_t endpointSize,
368:                     USB_TRANSFER_TYPE endpointType,
369:                     USB_BUFFER_DATA01 dataToggle,
370:                     USB_PING_PONG_STATE nextPingPong
371:                 )
372:                 {
373:                     /* This is a helper function */
374:                     endpointObject->nextDataToggle  = USB_BUFFER_DATA0;
375:                     endpointObject->irpQueue        = NULL;
376:                     endpointObject->maxPacketSize   = endpointSize;
377:                     endpointObject->nextPingPong    = nextPingPong;
378:                     endpointObject->endpointType    = endpointType;
379:                     endpointObject->endpointState  |= DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED;
380:                     
381:                 }
382:                 
383:                 // *****************************************************************************
384:                 /* Function:
385:                     USB_ERROR DRV_USBFS_DEVICE_EndpointEnable
386:                     (
387:                         DRV_HANDLE handle,
388:                         USB_ENDPOINT endpointAndDirection,
389:                         USB_TRANSFER_TYPE endpointType,
390:                         uint16_t endpointSize
391:                     )
392:                 
393:                   Summary:
394:                     This function enables an endpoint for the specified direction and endpoint
395:                     size.
396:                     
397:                   Description:
398:                     This function enables an endpoint for the specified direction and endpoint
399:                     size. The function will enable the endpoint for communication in one
400:                     direction at a time. It must be called twice if the endpoint is required to
401:                     communicate in both the directions, with the exception of control endpoints.
402:                     If the endpoint type is a control endpoint, the endpoint is always
403:                     bidirectional and the function needs to be called only once.  
404:                     
405:                     The size of the endpoint must match the wMaxPacketSize reported in the
406:                     endpoint descriptor for this endpoint. A transfer that is scheduled over
407:                     this endpoint will be scheduled in wMaxPacketSize transactions. The function
408:                     does not check if the endpoint is already in use. It is the client's
409:                     responsibility to make sure that a endpoint is not accidentally reused.
410:                 
411:                   Remarks:
412:                     See drv_usbfs.h for usage information.
413:                 */
414:                 
415:                 USB_ERROR DRV_USBFS_DEVICE_EndpointEnable
416:                 (
417:                     DRV_HANDLE handle, 
418:                     USB_ENDPOINT endpointAndDirection, 
419:                     USB_TRANSFER_TYPE endpointType,
420:                     uint16_t endpointSize
421:                 )
422:                 {
423:                     /* This function can be called from from the USB ISR. Because an endpoint
424:                      * can be owned by one client only, we dont need mutex protection in this
425:                      * function */
426:                 
427:                     int direction;
428:                     int iEntry;
429:                     bool handshake;
430:                     uint8_t endpoint;
431:                     DRV_USBFS_OBJ * hDriver;
432:                     USB_MODULE_ID usbID;
433:                     DRV_USBFS_BDT_ENTRY * pBDT;
434:                     DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject;
435:                     USB_PING_PONG_STATE nextPingPong;
436:                     uint32_t mask = 1;
437:                     USB_ERROR returnValue = USB_ERROR_NONE;
438:                 
439:                     /* Enable the endpoint */
440:                 
441:                     endpoint = endpointAndDirection & 0xF;
442:                     direction = ((endpointAndDirection & 0x80) != 0);
443:                     
444:                     if(endpoint < DRV_USBFS_ENDPOINTS_NUMBER)
445:                     {
446:                         if((DRV_HANDLE_INVALID != handle) && (handle != (DRV_HANDLE)(NULL)))
447:                         {
448:                             /* Check if the handle is valid */
449:                             usbID = ((DRV_USBFS_OBJ *)handle)->usbID;
450:                             hDriver = (DRV_USBFS_OBJ *)handle;
451:                 
452:                             /* The BDT table has four entries per endpoint The following statement
453:                              * points pBDT to the first endpoint specific entry */
454:                 
455:                             pBDT = hDriver->pBDT + (endpoint * 4);
456:                 
457:                             /* Get the pointer to the endpoint object */
458:                 
459:                             endpointObject = (hDriver->endpointTable + (2 * endpoint) + 0);
460:                 
461:                             if(endpointType == USB_TRANSFER_TYPE_CONTROL)
462:                             {
463:                                 /* For a control endpoint enable both directions. Clear up the
464:                                  * BDT entries. */
465:                 
466:                                 uint32_t * pBDT32bit = (uint32_t *)pBDT;
467:                 
468:                                 for(iEntry = 0; iEntry < 7; iEntry ++)
469:                                 {
470:                                     /* A full duplex endpoint has 4 entries, 2 for each
471:                                      * direction */
472:                 
473:                                     *(pBDT32bit + iEntry) = 0;
474:                                 }
475:                 
476:                                 /* The following function enables both directions */
477:                 
478:                                 PLIB_USB_EPnAttributesSet( usbID, endpoint, 0, true, 0 );
479:                 
480:                                 /* The BDT even odd buffer descriptor entries to be used is is
481:                                  * contained in the tx/rx endpoint next ping pong indicators.
482:                                  * These indicators are updated when the hardware interrupts
483:                                  * occur */
484:                 
485:                                 mask = mask << endpoint ; 
486:                                 if ( hDriver->rxEndpointsNextPingPong & mask  )
487:                                 {
488:                                     nextPingPong = USB_PING_PONG_ODD ;
489:                                 }
490:                                 else
491:                                 {
492:                                     nextPingPong = USB_PING_PONG_EVEN;
493:                                 }
494:                 
495:                                 /* This is the RX endpoint */        
496:                                 _DRV_USBFS_DEVICE_EndpointObjectEnable(endpointObject, endpointSize, endpointType, USB_BUFFER_DATA0,nextPingPong);
497:                 
498:                                 /* This is when data moves from device to host. For control end
499:                                  * points the Data toggle always starts with DATA1. */
500:                 
501:                                 endpointObject ++;
502:                 
503:                                 if ( hDriver->txEndpointsNextPingPong & mask  )
504:                                 {
505:                                     nextPingPong = USB_PING_PONG_ODD; 
506:                                 }
507:                                 else
508:                                 {
509:                                     nextPingPong = USB_PING_PONG_EVEN;
510:                                 }
511:                 
512:                                 /* Update the TX endpoint object */
513:                                 _DRV_USBFS_DEVICE_EndpointObjectEnable(endpointObject, endpointSize, endpointType, USB_BUFFER_DATA1,nextPingPong);
514:                             }
515:                             else
516:                             {
517:                                 /* Clear up the even odd entries for this endpoint direction in
518:                                  * the BDT.  Each entry has 2 32 bit entries */
519:                 
520:                                 pBDT += (2 * direction);
521:                 
522:                                 /* Clear up the even entry */
523:                                 pBDT->word[0] = 0;
524:                                 pBDT->word[1] = 0;
525:                                 pBDT ++;
526:                 
527:                                 /* Clear up the odd entry */
528:                                 pBDT->word[0] = 0;
529:                                 pBDT->word[1] = 0;
530:                 
531:                                 handshake = (endpointType == USB_TRANSFER_TYPE_ISOCHRONOUS) ? false : true;
532:                                 PLIB_USB_EPnAttributesSet(usbID, endpoint, direction, false, handshake);
533:                                 mask = mask << endpoint ;
534:                 
535:                                 /* Update the endpoint database */
536:                                 if( direction == 0)
537:                                 {
538:                                     if ( hDriver->rxEndpointsNextPingPong & mask  )
539:                                     {
540:                                         /* This means the next ping pong entry should be ODD */
541:                                         nextPingPong = USB_PING_PONG_ODD ;
542:                                     }
543:                                     else
544:                                     {
545:                                         /* This means the next ping entry should be even */
546:                                         nextPingPong = USB_PING_PONG_EVEN;
547:                                     }
548:                                 }
549:                                 else  
550:                                 {
551:                                     if ( hDriver->txEndpointsNextPingPong & mask  )
552:                                     {
553:                                         nextPingPong = USB_PING_PONG_ODD; 
554:                                     }
555:                                     else
556:                                     {
557:                                         nextPingPong = USB_PING_PONG_EVEN;
558:                                     }
559:                                 }
560:                 
561:                                 /* Update the endpoint object */
562:                                 endpointObject += direction;
563:                                 _DRV_USBFS_DEVICE_EndpointObjectEnable(endpointObject, endpointSize, endpointType, USB_BUFFER_DATA0 ,nextPingPong);
564:                             }
565:                         }
566:                         else
567:                         {
568:                             SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
569:                             returnValue = USB_ERROR_PARAMETER_INVALID;
570:                         }
571:                     }
572:                     else
573:                     {
574:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO,"\r\nUSBFS Driver: Unsupported endpoint");
575:                         returnValue = USB_ERROR_DEVICE_ENDPOINT_INVALID;
576:                     }
577:                     
578:                     return(returnValue);
579:                 }
580:                 
581:                 // *****************************************************************************
582:                 /* Function:
583:                     USB_ERROR DRV_USBFS_DEVICE_EndpointDisable
584:                     (
585:                         DRV_HANDLE handle,
586:                         USB_ENDPOINT endpointAndDirection
587:                     )
588:                 
589:                   Summary:
590:                     This function disables an endpoint.
591:                     
592:                   Description:
593:                     This function disables an endpoint. If the endpoint type is a control
594:                     endpoint type, both directions are disabled. For non-control endpoints, the
595:                     function disables the specified direction only. The direction to be disabled 
596:                     is specified by the Most Significant Bit (MSB) of the endpointAndDirection 
597:                     parameter.
598:                 
599:                   Remarks:
600:                     See drv_usbfs.h for usage information.
601:                 */
602:                 
603:                 USB_ERROR DRV_USBFS_DEVICE_EndpointDisable
604:                 (
605:                     DRV_HANDLE handle, 
606:                     USB_ENDPOINT endpointAndDirection
607:                 )
608:                 {
609:                     /* This routine disables the specified endpoint.  It does not check if there
610:                      * is any ongoing communication on the bus through the endpoint */
611:                 
612:                     uint8_t endpoint;
613:                     int  direction, iEntry;
614:                     DRV_USBFS_OBJ * hDriver;
615:                     DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject;
616:                     USB_MODULE_ID usbID;
617:                     USB_ERROR returnValue  = USB_ERROR_NONE;
618:                 
619:                     /* Check if the handle is valid */
620:                     if((DRV_HANDLE_INVALID != handle) && (handle != (DRV_HANDLE)(NULL)))
621:                     {
622:                         /* Get the pointer to associated endpoint object table. Note that the
623:                          * default value of returnValue is USB_ERROR_NONE. This is the value
624:                          * that will returned if the function excutes all the success paths. */
625:                 
626:                         hDriver = ((DRV_USBFS_OBJ *)handle);
627:                         usbID = hDriver->usbID;
628:                         endpointObject = hDriver->endpointTable;
629:                 
630:                         /* If the endpointAndDirection is _DRV_USBFS_DEVICE_ENDPOINT_ALL then
631:                          * this means that the DRV_USBFS_DEVICE_EndpointDisableAll() function
632:                          * was called */
633:                 
634:                         if(endpointAndDirection == DRV_USBFS_DEVICE_ENDPOINT_ALL)
635:                         {
636:                             for(iEntry = 0; iEntry < DRV_USBFS_ENDPOINTS_NUMBER; iEntry ++)
637:                             {
638:                                 PLIB_USB_EPnAttributesClear(usbID, iEntry);
639:                 
640:                                 /* Update the endpoint database */
641:                 
642:                                 endpointObject->endpointState  &= ~DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED;
643:                                 endpointObject ++;
644:                                 endpointObject->endpointState  &= ~DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED;
645:                                 endpointObject ++;
646:                             }
647:                         }
648:                         else
649:                         {
650:                             /* A specific endpoint and direction needs to be disabled */
651:                 
652:                             endpoint = endpointAndDirection & 0xF;
653:                             direction = ((endpointAndDirection & 0x80) != 0);
654:                 
655:                             if(endpoint < DRV_USBFS_ENDPOINTS_NUMBER)
656:                             {
657:                                 /* Setup the endpointObj to point to the correct endpoint object */
658:                 
659:                                 endpointObject += ((2 * endpoint) + direction);
660:                 
661:                                 if(endpointObject->endpointType == USB_TRANSFER_TYPE_CONTROL)
662:                                 {
663:                                     /* Disable a control endpoint and update the endpoint
664:                                      * database. */
665:                 
666:                                     PLIB_USB_EPnAttributesClear(usbID, endpoint);
667:                                     endpointObject->endpointState  &= ~DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED;
668:                                     endpointObject += 1;
669:                                     endpointObject->endpointState  &= ~DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED;
670:                                 }
671:                                 else
672:                                 {
673:                                     /* Disable a specific endpoint direction for non control
674:                                      * endpoints */
675:                 
676:                                     PLIB_USB_EPnDirectionDisable(usbID, endpoint, direction);
677:                                     endpoint += direction;
678:                                     endpointObject->endpointState  &= ~DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED;
679:                                 }
680:                             }
681:                             else
682:                             {
683:                                 /* This means the endpoint is not valid */
684:                                 SYS_DEBUG_MESSAGE(SYS_ERROR_INFO,"\r\nUSBFS Driver: Unsupported endpoint");
685:                                 returnValue = USB_ERROR_DEVICE_ENDPOINT_INVALID;
686:                             }
687:                         }
688:                     }
689:                     else
690:                     {
691:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
692:                         returnValue = USB_ERROR_PARAMETER_INVALID;
693:                     }
694:                 
695:                     return(returnValue);
696:                 }
697:                 
698:                 // *****************************************************************************
699:                 /* Function:
700:                     bool DRV_USBFS_DEVICE_EndpointIsEnabled
701:                     (
702:                         DRV_HANDLE client,
703:                         USB_ENDPOINT endpointAndDirection
704:                     )
705:                 
706:                   Summary:
707:                     This function returns the enable/disable status of the specified endpoint
708:                     and direction.
709:                     
710:                   Description:
711:                     This function returns the enable/disable status of the specified endpoint
712:                     and direction.
713:                 
714:                   Remarks:
715:                     See drv_usbfs.h for usage information.
716:                 */
717:                 
718:                 bool DRV_USBFS_DEVICE_EndpointIsEnabled
719:                 (
720:                     DRV_HANDLE client, 
721:                     USB_ENDPOINT endpointAndDirection
722:                 )
723:                 {
724:                     DRV_USBFS_OBJ * hDriver;
725:                     DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObj;
726:                     bool isEnabled = false;
727:                 
728:                     uint8_t endpoint = endpointAndDirection & 0xF;
729:                     int direction = ((endpointAndDirection & 0x80) != 0);
730:                 
731:                     /* Check if the handle is valid */
732:                     if((DRV_HANDLE_INVALID != client) && (client != (DRV_HANDLE)(NULL)))
733:                     {
734:                         if(endpoint < DRV_USBFS_ENDPOINTS_NUMBER)
735:                         {
736:                             hDriver = ((DRV_USBFS_OBJ *)client);
737:                             endpointObj = hDriver->endpointTable + (2 * endpoint) + direction;
738:                 
739:                             /* The default value of isEnabled is false. Check the endpoint state. */
740:                             if((endpointObj->endpointState & DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED) != 0)
741:                             {
742:                                 isEnabled = true;
743:                             }
744:                         }
745:                         else
746:                         {
747:                             SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Endpoint is not invalid");
748:                         }
749:                     }
750:                     else
751:                     {
752:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
753:                     }
754:                 
755:                     return (isEnabled);
756:                 }
757:                 
758:                 // *****************************************************************************
759:                 /* Function:
760:                     bool DRV_USBFS_DEVICE_EndpointIsStalled
761:                     (
762:                         DRV_HANDLE client,
763:                         USB_ENDPOINT endpointAndDirection
764:                     )
765:                 
766:                   Summary:
767:                     This function returns the stall status of the specified endpoint and
768:                     direction.
769:                 
770:                   Description:
771:                     This function returns the stall status of the specified endpoint and
772:                     direction.
773:                 
774:                   Remarks:
775:                     See drv_usbfs.h for usage information.
776:                 */
777:                 
778:                 bool DRV_USBFS_DEVICE_EndpointIsStalled
779:                 (
780:                     DRV_HANDLE client, 
781:                     USB_ENDPOINT endpointAndDirection
782:                 )
783:                 {
784:                     DRV_USBFS_OBJ * hDriver;
785:                     DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObj;
786:                     uint8_t endpoint = endpointAndDirection & 0xF;
787:                     int direction = ((endpointAndDirection & 0x80) != 0);
788:                     bool isStalled = false;
789:                 
790:                     /* Check if the handle is valid */
791:                     if((DRV_HANDLE_INVALID != client) && (client != (DRV_HANDLE)(NULL)))
792:                     {
793:                         hDriver = ((DRV_USBFS_OBJ *)client);
794:                 
795:                         if(endpoint < DRV_USBFS_ENDPOINTS_NUMBER)
796:                         {
797:                             endpointObj = hDriver->endpointTable + (2 * endpoint) + direction;
798:                 
799:                             if((endpointObj->endpointState & DRV_USBFS_DEVICE_ENDPOINT_STATE_STALLED) != 0)
800:                             {
801:                                 isStalled = true;
802:                             }
803:                         }
804:                         else
805:                         {
806:                             SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Endpoint is invalid");
807:                         }
808:                     }
809:                     else
810:                     {
811:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
812:                     }
813:                 
814:                     return(isStalled);
815:                 }
816:                 
817:                 // *****************************************************************************
818:                 /* Function:
819:                     void _DRV_USBFS_DEVICE_EndpointBDTEntryArm
820:                     (
821:                         DRV_USBFS_BDT_ENTRY * pBDT,
822:                         DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObj,
823:                         USB_DEVICE_IRP_LOCAL * irp,
824:                         int direction
825:                     )
826:                 
827:                   Summary:
828:                     This function enables a Buffer Descriptor Table entry. 
829:                 
830:                   Description:
831:                     This function enables a Buffer Descriptor Table entry. Enabling and arming
832:                     the entry allows the endpoint to reply to the host request.
833:                 
834:                   Remarks:
835:                     This is a local function and should not be called directly by the
836:                     application.
837:                 */
838:                 
839:                 void _DRV_USBFS_DEVICE_EndpointBDTEntryArm
840:                 (
841:                     DRV_USBFS_BDT_ENTRY * pBDT, 
842:                     DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObj, 
843:                     USB_DEVICE_IRP_LOCAL * irp,
844:                     int direction
845:                 )
846:                 {
847:                     /* pBDT is the pointer to the ping pong BDT entries for the endpoint and
848:                      * direction  In this driver we dont check for the data toggle while
849:                      * receiving data from the host. The assumption here is that the host is
850:                      * correct */
851:                 
852:                     /* If the endpoint is stalled, the stall will be cleared */
853:                 
854:                     uint16_t size;
855:                     DRV_USBFS_BDT_ENTRY * currentBDTEntry;
856:                 
857:                     currentBDTEntry = pBDT + endpointObj->nextPingPong;
858:                 
859:                     /* Calculate the size of the transaction */
860:                     if(USB_DATA_DIRECTION_DEVICE_TO_HOST == direction)
861:                     {
862:                         /* If data is moving from device to host then enable data toggle
863:                          * syncronization */
864:                 
865:                         currentBDTEntry->byte[0] = 0x08;
866:                 
867:                         /* Adjust buffer address for the number of bytes sent */
868:                         currentBDTEntry->word[1] = (uint32_t) (KVA_TO_PA ((uint8_t *)irp->data + irp->size - irp->nPendingBytes));
869:                 
870:                         if(irp->nPendingBytes == 0)  
871:                         {
872:                             /* This applies when we need to send a ZLP */
873:                             size = 0;
874:                         }
875:                         else
876:                         {
877:                             /* In case this is a multi-transaction transfer, then we start with
878:                              * endpoint size of data. */
879:                             size = (irp->nPendingBytes > endpointObj->maxPacketSize) ? endpointObj->maxPacketSize: irp->nPendingBytes;
880:                         }
881:                 
882:                         /* Update the pending bytes only if the data direction is from device to
883:                          * host. The pending bytes for the other direction is updated in the ISR
884:                          * */
885:                 
886:                         irp->nPendingBytes -= size;
887:                     }
888:                     else
889:                     {
890:                         /* Data is moving from host to device */
891:                         currentBDTEntry->byte[0] = 0x0;
892:                 
893:                         /* Adjust the buffer address for the number of bytes received so far */
894:                         currentBDTEntry->word[1] = (uint32_t) (KVA_TO_PA ((uint8_t *)irp->data + irp->nPendingBytes));
895:                         size = (irp->size - irp->nPendingBytes > endpointObj->maxPacketSize) ? endpointObj->maxPacketSize : irp->size - irp->nPendingBytes;
896:                 
897:                     }
898:                 
899:                     /* We set up the data toggle. This will be active only if DTS is active.
900:                      * Clear the DATA0/1 and then set it according to the next data toggle to be
901:                      * used.*/
902:                 
903:                     currentBDTEntry->byte[0] &= 0xBF;
904:                     currentBDTEntry->byte[0] |= (endpointObj->nextDataToggle << 6);
905:                     
906:                     /* Set the size */
907:                     currentBDTEntry->shortWord[1] = size;
908:                     
909:                     /* Set the UOWN bit */
910:                     currentBDTEntry->byte[0] |= 0x80;
911:                     endpointObj->nextPingPong ^= 0x1;
912:                     endpointObj->nextDataToggle ^= 0x1;
913:                 }
914:                 
915:                 // *****************************************************************************
916:                 /* Function:
917:                     USB_ERROR DRV_USBFS_DEVICE_IRPSubmit
918:                     (
919:                         DRV_HANDLE client,
920:                         USB_ENDPOINT endpointAndDirection,
921:                         USB_DEVICE_IRP * inputIRP
922:                     )
923:                 
924:                   Summary:
925:                     This function submits an I/O Request Packet (IRP) for processing to the
926:                     Hi-Speed USB Driver.
927:                     
928:                   Description:
929:                     This function submits an I/O Request Packet (IRP) for processing to the USB
930:                     Driver. The IRP allows a client to send and receive data from the USB Host.
931:                     The data will be sent or received through the specified endpoint. The direction
932:                     of the data transfer is indicated by the direction flag in the
933:                     endpointAndDirection parameter. Submitting an IRP arms the endpoint to
934:                     either send data to or receive data from the Host.  If an IRP is already
935:                     being processed on the endpoint, the subsequent IRP submit operation
936:                     will be queued. The contents of the IRP (including the application buffers)
937:                     should not be changed until the IRP has been processed.
938:                     
939:                     Particular attention should be paid to the size parameter of IRP. The
940:                     following should be noted:
941:                     
942:                       * The size parameter while sending data to the Host can be less than,
943:                         greater than, equal to, or be an exact multiple of the maximum packet size
944:                         for the endpoint. The maximum packet size for the endpoint determines
945:                         the number of transactions required to process the IRP.
946:                       * If the size parameter, while sending data to the Host is less than the
947:                         maximum packet size, the transfer will complete in one transaction.
948:                       * If the size parameter, while sending data to the Host is greater
949:                         than the maximum packet size, the IRP will be processed in multiple
950:                         transactions.
951:                       * If the size parameter, while sending data to the Host is equal to or
952:                         an exact multiple of the maximum packet size, the client can optionally
953:                         ask the driver to send a Zero Length Packet(ZLP) by specifying the
954:                         USB_DEVICE_IRP_FLAG_DATA_COMPLETE flag as the flag parameter.
955:                       * The size parameter, while receiving data from the Host must be an
956:                         exact multiple of the maximum packet size of the endpoint. If this is
957:                         not the case, the driver will return a USB_ERROR_IRP_SIZE_INVALID
958:                         result. If while processing the IRP, the driver receives less than
959:                         maximum packet size or a ZLP from the Host, the driver considers the
960:                         IRP as processed. The size parameter at this point contains the actual
961:                         amount of data received from the Host. The IRP status is returned as
962:                         USB_DEVICE_IRP_STATUS_COMPLETED_SHORT.
963:                       * If a ZLP needs to be sent to Host, the IRP size should be specified
964:                         as 0 and the flag parameter should be set as
965:                         USB_DEVICE_IRP_FLAG_DATA_COMPLETE.
966:                       * If the IRP size is an exact multiple of the endpoint size, the client
967:                         can request the driver to not send a ZLP by setting the flag parameter
968:                         to USB_DEVICE_IRP_FLAG_DATA_PENDING. This flag indicates that there is
969:                         more data pending in this transfer.
970:                       * Specifying a size less than the endpoint size along with the
971:                         USB_DEVICE_IRP_FLAG_DATA_PENDING flag will cause the driver to return a
972:                         USB_ERROR_IRP_SIZE_INVALID.
973:                       * If the size is greater than but not a multiple of the endpoint size, and
974:                         the flag is specified as USB_DEVICE_IRP_FLAG_DATA_PENDING, the driver
975:                         will send multiple of endpoint size number of bytes. For example, if the
976:                         IRP size is 130 and the endpoint size if 64, the number of bytes sent
977:                         will 128.
978:                 
979:                   Remarks:
980:                     See drv_usbfs.h for usage information.
981:                 */
982:                 
983:                 USB_ERROR DRV_USBFS_DEVICE_IRPSubmit
984:                 (
985:                     DRV_HANDLE client,
986:                     USB_ENDPOINT endpointAndDirection, 
987:                     USB_DEVICE_IRP * inputIRP
988:                 )
989:                 {
990:                     uint8_t endpoint;
991:                     bool interruptWasEnabled = false;
992:                     int direction;
993:                     int remainder;
994:                     DRV_USBFS_OBJ * hDriver;
995:                     USB_DEVICE_IRP_LOCAL * irp = (USB_DEVICE_IRP_LOCAL *)inputIRP;
996:                     DRV_USBFS_BDT_ENTRY * pBDT;
997:                     DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObj;
998:                     USB_ERROR returnValue = USB_ERROR_NONE;
999:                 
1000:                    /* Check if the client handle is valid */
1001:                    if((client != DRV_HANDLE_INVALID) && (client != (DRV_HANDLE)(NULL)))
1002:                    {
1003:                        /* Make sure the IRP is available for use. */
1004:                        if(irp->status <= USB_DEVICE_IRP_STATUS_SETUP)
1005:                        {
1006:                            /* Check for a valid endpoint */
1007:                            endpoint = endpointAndDirection & 0xF;
1008:                            direction = ((endpointAndDirection & 0x80) != 0);
1009:                
1010:                            if(endpoint < DRV_USBFS_ENDPOINTS_NUMBER)
1011:                            {
1012:                                /* Get the driver object, the module ID and the endpoint and
1013:                                 * direction specific BDT entry and the endpoint object. */
1014:                
1015:                                hDriver = ((DRV_USBFS_OBJ *)client);
1016:                                pBDT = hDriver->pBDT + (endpoint * 4) + (2 * direction);
1017:                                endpointObj = hDriver->endpointTable + (2 * endpoint) + direction;
1018:                
1019:                                if((endpointObj->endpointState & DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED) != 0)
1020:                                {
1021:                                    /* Check the size of the IRP. If the endpoint receives data
1022:                                     * from the host, then IRP size must be multiple of
1023:                                     * maxPacketSize. If the send ZLP flag is set, then size
1024:                                     * must be multiple of endpoint size. */
1025:                
1026:                                    remainder = irp->size % endpointObj->maxPacketSize;
1027:                
1028:                                    if(remainder == 0)
1029:                                    {
1030:                                        /* The IRP size is either 0 or a exact multiple of
1031:                                         * maxPacketSize */
1032:                
1033:                                        if(USB_DATA_DIRECTION_DEVICE_TO_HOST == direction)
1034:                                        {
1035:                                            if(((irp->flags & USB_DEVICE_IRP_FLAG_DATA_COMPLETE) == USB_DEVICE_IRP_FLAG_DATA_COMPLETE) && (irp->size != 0))
1036:                                            {
1037:                                                /* This means a ZLP should be sent after the
1038:                                                 * data is sent. We will OR this flag as this
1039:                                                 * flag is temporary and must co-exist by the
1040:                                                 * driver client defined flag. */
1041:                
1042:                                                irp->flags |= USB_DEVICE_IRP_FLAG_SEND_ZLP;
1043:                                            }
1044:                                        }
1045:                                    }
1046:                                    else
1047:                                    {
1048:                                        /* Not exact multiple of maxPacketSize */
1049:                                        if(USB_DATA_DIRECTION_HOST_TO_DEVICE == direction)
1050:                                        {
1051:                                            /* For receive IRP it needs to exact multiple of
1052:                                             * maxPacketSize.  Hence this is an error condition. */
1053:                                            returnValue = USB_ERROR_PARAMETER_INVALID;
1054:                                        }
1055:                                    }
1056:                
1057:                                    if(returnValue == USB_ERROR_NONE)
1058:                                    {
1059:                                        /* So far no error. We can continue. Now we check if the
1060:                                         * interrupt context is active. If so the we dont need
1061:                                         * to get a mutex or disable interrupts. If this were
1062:                                         * being done in non interrupt context, then we would
1063:                                         * disable the interrupt. In which case we would get the
1064:                                         * mutex and then disable the interrupt. The mutex here
1065:                                         * is protecting the interrupt. */
1066:                
1067:                                        if(!(hDriver->inInterruptContext))
1068:                                        {
1069:                                            if(OSAL_MUTEX_Lock(&hDriver->mutexID, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1070:                                            {
1071:                                                /* Disable the interrupt as we will update the
1072:                                                 * endpoint IRP queue. We do not want a USB
1073:                                                 * interrupt to update this queue while we are
1074:                                                 * submitting an IRP. */
1075:                
1076:                                                interruptWasEnabled = _DRV_USBFS_InterruptSourceDisable(hDriver->interruptSource);
1077:                                            }
1078:                                            else
1079:                                            {
1080:                                                /* There was an error obtaining the mutex */
1081:                                                returnValue = USB_ERROR_OSAL_FUNCTION;
1082:                                            }
1083:                                        }
1084:                
1085:                                        if(returnValue == USB_ERROR_NONE)
1086:                                        {
1087:                                            irp->next = NULL;
1088:                
1089:                                            /* If the data is moving from device to host then
1090:                                             * pending bytes is data remaining to be sent to the
1091:                                             * host. If the data is moving from host to device,
1092:                                             * nPendingBytes tracks the amount of data received
1093:                                             * so far */
1094:                
1095:                                            if(USB_DATA_DIRECTION_DEVICE_TO_HOST == direction)
1096:                                            {
1097:                                                irp->nPendingBytes = irp->size;
1098:                                            }
1099:                                            else
1100:                                            {
1101:                                                irp->nPendingBytes = 0;
1102:                                            }
1103:                
1104:                                            /* Mark the IRP status as pending */
1105:                                            irp->status = USB_DEVICE_IRP_STATUS_PENDING;
1106:                
1107:                                            /* Get the last object in the endpoint object IRP Queue */
1108:                                            if(endpointObj->irpQueue == NULL)
1109:                                            {
1110:                                                /* Queue is empty */
1111:                                                endpointObj->irpQueue = irp;
1112:                                                irp->previous = NULL;
1113:                
1114:                                                /* Because this is the first IRP in the queue
1115:                                                 * then we we must arm the endpoint entry in the
1116:                                                 * BDT. */
1117:                
1118:                                                irp->status = USB_DEVICE_IRP_STATUS_IN_PROGRESS;
1119:                                                _DRV_USBFS_DEVICE_EndpointBDTEntryArm(pBDT,endpointObj, irp, direction);
1120:                                            }
1121:                                            else
1122:                                            {
1123:                                                /* This means we should surf the linked list to
1124:                                                 * get to the last entry .  */
1125:                
1126:                                                USB_DEVICE_IRP_LOCAL * iterator;
1127:                                                iterator = endpointObj->irpQueue;
1128:                
1129:                                                while(iterator->next != NULL)
1130:                                                {
1131:                                                    iterator = iterator->next;
1132:                                                }
1133:                
1134:                                                iterator->next = irp;
1135:                                                irp->previous = iterator;
1136:                                                irp->status = USB_DEVICE_IRP_STATUS_PENDING;
1137:                                            }
1138:                
1139:                                            if(!(hDriver->inInterruptContext))
1140:                                            {
1141:                                                if(interruptWasEnabled)
1142:                                                {
1143:                                                    /* Enable the interrupt only if it was enabled */
1144:                                                    _DRV_USBFS_InterruptSourceEnable(hDriver->interruptSource);
1145:                                                }
1146:                
1147:                                                /* Unlock the mutex */
1148:                                                OSAL_MUTEX_Unlock(&hDriver->mutexID);
1149:                                            }
1150:                                        }
1151:                                    }
1152:                                }
1153:                                else
1154:                                {
1155:                                    /* This means the endpoint is disabled */        
1156:                                    returnValue = USB_ERROR_ENDPOINT_NOT_CONFIGURED;        
1157:                                }
1158:                            }
1159:                            else
1160:                            {
1161:                                SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Endpoint is not provisioned for");
1162:                                returnValue = USB_ERROR_DEVICE_ENDPOINT_INVALID;
1163:                            }
1164:                        }
1165:                        else
1166:                        {
1167:                            /* This means that the IRP is in use */
1168:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Device IRP is already in use");
1169:                            returnValue = USB_ERROR_DEVICE_IRP_IN_USE;
1170:                        }
1171:                    }
1172:                    else
1173:                    {
1174:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Invalid handle");
1175:                        returnValue =  USB_ERROR_PARAMETER_INVALID;
1176:                    }
1177:                
1178:                    return(returnValue);
1179:                }
1180:                
1181:                // *****************************************************************************
1182:                /* Function:
1183:                    void _DRV_USBFS_DEVICE_IRPQueueFlush
1184:                    (
1185:                        DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject
1186:                        USB_DEVICE_IRP_STATUS status
1187:                    )
1188:                
1189:                  Summary:
1190:                    This function flushes all the IRPs in the queue.
1191:                
1192:                  Description:
1193:                    This function flushes all the IRPs in the queue. Function scans for all the
1194:                    IRPs on the endpoint queue and cancels them all. status indicate the abort
1195:                    status to be returned when the IRP callback is invoked.
1196:                
1197:                  Remarks:
1198:                    This is a local function and should not be called directly by the
1199:                    application.
1200:                */
1201:                
1202:                void _DRV_USBFS_DEVICE_IRPQueueFlush
1203:                (
1204:                    DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject,
1205:                    USB_DEVICE_IRP_STATUS status
1206:                )
1207:                {
1208:                    USB_DEVICE_IRP_LOCAL * iterator = NULL;
1209:                    
1210:                    if(endpointObject != NULL)
1211:                    {
1212:                        /* Check if any IRPs are assigned on this endpoint and abort them */
1213:                
1214:                        if(endpointObject->irpQueue != NULL)
1215:                        {
1216:                            /* Scan for all the IRPs on this endpoint Cancel the IRP and
1217:                             * deallocate driver IRP objects */
1218:                
1219:                            iterator = endpointObject->irpQueue;
1220:                            while(iterator != NULL)
1221:                            {
1222:                                iterator->status = status;
1223:                                if(iterator->callback != NULL)
1224:                                {
1225:                                    iterator->callback((USB_DEVICE_IRP *)iterator);
1226:                                }
1227:                                iterator = iterator->next;
1228:                            }
1229:                        }
1230:                
1231:                        /* Set the head pointer to NULL */
1232:                        endpointObject->irpQueue = NULL;
1233:                    }
1234:                }
1235:                
1236:                // *****************************************************************************
1237:                /* Function:
1238:                    USB_ERROR DRV_USBFS_DEVICE_IRPCancel
1239:                    (
1240:                        DRV_HANDLE client, 
1241:                        USB_DEVICE_IRP * irp
1242:                    )
1243:                
1244:                  Summary:
1245:                    Dynamic implementation of DRV_USBFS_DEVICE_IRPCancel client interface
1246:                    function.
1247:                
1248:                  Description:
1249:                    This is the dynamic implementation of DRV_USBFS_DEVICE_IRPCancel client
1250:                    interface function for USB device.  Function checks the validity of the
1251:                    input arguments and on success cancels  the specific IRP.  An IRP that was
1252:                    in the queue but that has been processed yet will be cancelled successfully
1253:                    and the IRP callback function will be called from this function with
1254:                    USB_DEVICE_IRP_STATUS_ABORTED status. The application can release the data
1255:                    buffer memory used by the IRP when this callback occurs.  If the IRP was in
1256:                    progress (a transaction in on the bus) when the cancel function was called,
1257:                    the IRP will be cancelled only when an ongoing or the next transaction has
1258:                    completed. The IRP callback function will then be called in an interrupt
1259:                    context. The application should not release the related data buffer unless
1260:                    the IRP callback has occurred.
1261:                
1262:                  Remarks:
1263:                    See drv_usbfs.h for usage information.
1264:                */
1265:                
1266:                USB_ERROR DRV_USBFS_DEVICE_IRPCancel
1267:                (
1268:                    DRV_HANDLE client, 
1269:                    USB_DEVICE_IRP * irp
1270:                )
1271:                {
1272:                    USB_ERROR returnValue = USB_ERROR_NONE;
1273:                    DRV_USBFS_OBJ * hDriver = NULL;
1274:                    USB_DEVICE_IRP_LOCAL * irpToCancel = (USB_DEVICE_IRP_LOCAL *)irp;
1275:                    bool interruptWasEnabled = false;
1276:                
1277:                    if((client != DRV_HANDLE_INVALID) && (client != (DRV_HANDLE)(NULL)))
1278:                    {
1279:                        if(irpToCancel != NULL)
1280:                        {
1281:                            /* Check the state of the IRP */
1282:                
1283:                            hDriver = ((DRV_USBFS_OBJ *)client);
1284:                
1285:                            if(irpToCancel->status > USB_DEVICE_IRP_STATUS_SETUP)
1286:                            {
1287:                                if(!(hDriver->inInterruptContext))
1288:                                {
1289:                                    if(OSAL_MUTEX_Lock(&hDriver->mutexID, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1290:                                    {
1291:                                        /* Disable the interrupt */
1292:                                        interruptWasEnabled = _DRV_USBFS_InterruptSourceDisable(hDriver->interruptSource);
1293:                                    }
1294:                                    else
1295:                                    {
1296:                                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Mutex lock failed");
1297:                                        returnValue = USB_ERROR_OSAL_FUNCTION;
1298:                                    }
1299:                                }
1300:                
1301:                                if(returnValue == USB_ERROR_NONE)
1302:                                {
1303:                                    /* The code will come here both when the IRP is NOT the 1st
1304:                                     * in queue as well as when it is at the HEAD. We will change
1305:                                     * the IRP status for either scenario but will give the callback
1306:                                     * only if it is NOT at the HEAD of the queue.
1307:                                     * 
1308:                                     * What it means for HEAD IRP case is it will be caught in USB
1309:                                     * ISR and will be further processed in ISR. This is done to
1310:                                     * make sure that the user cannot release the IRP buffer before
1311:                                     * ABORT callback*/
1312:                
1313:                                    /* Mark the IRP status as aborted */
1314:                                    irpToCancel->status = USB_DEVICE_IRP_STATUS_ABORTED;
1315:                
1316:                                    /* No data for this IRP was sent or received */
1317:                                    irpToCancel->size = 0;
1318:                
1319:                                    if(irpToCancel->previous != NULL)
1320:                                    {
1321:                                        /* This means this is not the HEAD IRP in the IRP queue.
1322:                                           Can be removed from the endpoint object queue safely.*/
1323:                                        irpToCancel->previous->next = irpToCancel->next;
1324:                
1325:                                        if(irpToCancel->next != NULL)
1326:                                        {
1327:                                            /* If this is not the last IRP in the queue then update
1328:                                               the previous link connection for the next IRP */
1329:                                            irpToCancel->next->previous = irpToCancel->previous;
1330:                                        }
1331:                
1332:                                        irpToCancel->previous = NULL;
1333:                                        irpToCancel->next = NULL;
1334:                
1335:                                        if(irpToCancel->callback != NULL)
1336:                                        {
1337:                                            irpToCancel->callback((USB_DEVICE_IRP *)irpToCancel);
1338:                                        }
1339:                                    }
1340:                
1341:                                    /* Restore the interrupt state if this was changed */
1342:                                    if(!(hDriver->inInterruptContext))  
1343:                                    {
1344:                                        if(interruptWasEnabled)
1345:                                        {
1346:                                            _DRV_USBFS_InterruptSourceEnable(hDriver->interruptSource);
1347:                                        }
1348:                
1349:                                        OSAL_MUTEX_Unlock(&hDriver->mutexID); 
1350:                                    }
1351:                                }
1352:                            }
1353:                            else
1354:                            {
1355:                                /* This IRP has either completed or has been aborted.*/
1356:                                SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: IRP is already completed");
1357:                                returnValue = USB_ERROR_PARAMETER_INVALID;
1358:                            }
1359:                        }
1360:                        else
1361:                        {
1362:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: IRP is invalid");
1363:                            returnValue = USB_ERROR_PARAMETER_INVALID;
1364:                        }
1365:                    }
1366:                    else
1367:                    {
1368:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
1369:                        returnValue = USB_ERROR_PARAMETER_INVALID;
1370:                    }
1371:                
1372:                    return returnValue;
1373:                }
1374:                
1375:                // *****************************************************************************
1376:                /* Function:
1377:                    USB_ERROR DRV_USBFS_DEVICE_IRPCancelAll
1378:                    (
1379:                        DRV_HANDLE client,
1380:                        USB_ENDPOINT endpointAndDirection
1381:                    )
1382:                
1383:                  Summary:
1384:                    Dynamic implementation of DRV_USBFS_DEVICE_IRPCancelAll client interface
1385:                    function.
1386:                
1387:                  Description:
1388:                    This is the dynamic implementation of DRV_USBFS_DEVICE_IRPCancelAll client
1389:                    interface function for USB device.  Function checks the validity of the
1390:                    input arguments and on success cancels all the IRPs on the specific endpoint
1391:                    object queue.
1392:                
1393:                  Remarks:
1394:                    See drv_usbfs.h for usage information.
1395:                */
1396:                
1397:                USB_ERROR DRV_USBFS_DEVICE_IRPCancelAll
1398:                (
1399:                    DRV_HANDLE client,
1400:                    USB_ENDPOINT endpointAndDirection
1401:                )
1402:                {
1403:                    uint8_t endpoint;
1404:                    bool interruptWasEnabled = false;
1405:                    int direction;
1406:                    DRV_USBFS_OBJ * hDriver;
1407:                    DRV_USBFS_BDT_ENTRY * pBDT;
1408:                    DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject;
1409:                    USB_ERROR returnValue = USB_ERROR_NONE;
1410:                
1411:                    endpoint = endpointAndDirection & 0xF;
1412:                    direction = ((endpointAndDirection & 0x80) != 0);
1413:                
1414:                    if(endpoint < DRV_USBFS_ENDPOINTS_NUMBER)
1415:                    {
1416:                        /* Endpoint is in range. */
1417:                
1418:                        if((client != DRV_HANDLE_INVALID) && (client != (DRV_HANDLE)(NULL)))
1419:                        {
1420:                            /* Driver handle is valid. */
1421:                
1422:                            hDriver = ((DRV_USBFS_OBJ *)client);
1423:                
1424:                            /* Get the endpoint object */
1425:                            endpointObject = hDriver->endpointTable + (2 * endpoint) + direction;
1426:                
1427:                            /* Get the BDT entry for this endpoint */
1428:                            pBDT = hDriver->pBDT + (4 * endpoint) + (2 * direction);
1429:                
1430:                            if(!(hDriver->inInterruptContext))
1431:                            {
1432:                                if(OSAL_MUTEX_Lock(&hDriver->mutexID, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1433:                                {
1434:                                    /* Disable the interrupt */
1435:                                    interruptWasEnabled = _DRV_USBFS_InterruptSourceDisable(hDriver->interruptSource);
1436:                                }
1437:                                else
1438:                                {
1439:                                    SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Mutex lock failed");
1440:                                    returnValue = USB_ERROR_OSAL_FUNCTION;
1441:                                }
1442:                            }
1443:                
1444:                            if(returnValue == USB_ERROR_NONE)
1445:                            {
1446:                                /* If there is a IRP in progress on the endpoint, and this
1447:                                 * endpoint is being cancelled, we must revert the nextPingPong
1448:                                 * indicator to what it what it before the transaction was
1449:                                 * scheduled on the endpoint */
1450:                
1451:                                if((endpointObject->irpQueue != NULL) && (endpointObject->irpQueue->status == USB_DEVICE_IRP_STATUS_IN_PROGRESS))
1452:                                {
1453:                                    endpointObject->nextPingPong ^= 1;
1454:                                }
1455:                                
1456:                                pBDT->byte[0] = 0x0;
1457:                                (pBDT + 1)->byte[0] = 0x0;
1458:                
1459:                                /* Flush the endpoint */
1460:                                _DRV_USBFS_DEVICE_IRPQueueFlush(endpointObject, USB_DEVICE_IRP_STATUS_ABORTED);
1461:                
1462:                                if(!(hDriver->inInterruptContext))
1463:                                {
1464:                                    if(interruptWasEnabled)
1465:                                    {
1466:                                        _DRV_USBFS_InterruptSourceEnable(hDriver->interruptSource);
1467:                                    }
1468:                
1469:                                    OSAL_MUTEX_Unlock(&hDriver->mutexID);
1470:                                }
1471:                            }
1472:                        }
1473:                        else
1474:                        {
1475:                            /* Driver Handle is not valid. */
1476:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
1477:                            returnValue = USB_ERROR_PARAMETER_INVALID;
1478:                        }
1479:                    }
1480:                    else
1481:                    {
1482:                        /* This is not a provisioned endpoint */
1483:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO,"\r\nUSBFS Driver: Unsupported endpoint");
1484:                        returnValue = USB_ERROR_DEVICE_ENDPOINT_INVALID;
1485:                    }
1486:                
1487:                    return(returnValue);
1488:                }
1489:                
1490:                // *****************************************************************************
1491:                /* Function:
1492:                    USB_ERROR DRV_USBFS_DEVICE_EndpointStall
1493:                    (
1494:                        DRV_HANDLE client,
1495:                        USB_ENDPOINT endpointAndDirection
1496:                    )
1497:                
1498:                  Summary:
1499:                    This function stalls an endpoint in the specified direction.
1500:                    
1501:                  Description:
1502:                    This function stalls an endpoint in the specified direction.
1503:                
1504:                  Remarks:
1505:                    See drv_usbfs.h for usage information.
1506:                */
1507:                
1508:                USB_ERROR DRV_USBFS_DEVICE_EndpointStall
1509:                (
1510:                    DRV_HANDLE client,
1511:                    USB_ENDPOINT endpointAndDirection
1512:                )
1513:                {
1514:                    int direction;
1515:                    bool interruptWasEnabled = false;
1516:                    uint8_t endpoint;
1517:                    DRV_USBFS_OBJ * hDriver;
1518:                    DRV_USBFS_BDT_ENTRY * pBDT;
1519:                    DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject;
1520:                    USB_ERROR returnValue = USB_ERROR_NONE;
1521:                
1522:                    endpoint = endpointAndDirection & 0xF;
1523:                    direction = ((endpointAndDirection & 0x80) != 0);
1524:                
1525:                    if(endpoint < DRV_USBFS_ENDPOINTS_NUMBER)
1526:                    {
1527:                        if((client != DRV_HANDLE_INVALID) && (client != (DRV_HANDLE)(NULL)))
1528:                        {
1529:                            hDriver = ((DRV_USBFS_OBJ *)client);
1530:                
1531:                            if(!(hDriver->inInterruptContext))
1532:                            {
1533:                                if(OSAL_MUTEX_Lock(&hDriver->mutexID, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1534:                                {
1535:                                    /* Disable the interrupt */
1536:                                    interruptWasEnabled = _DRV_USBFS_InterruptSourceDisable(hDriver->interruptSource);
1537:                                }
1538:                                else
1539:                                {
1540:                                    /* There was an error in getting the mutex */
1541:                                    SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Mutex lock failed");
1542:                                    returnValue = USB_ERROR_OSAL_FUNCTION;
1543:                                }
1544:                            }
1545:                
1546:                            if(returnValue == USB_ERROR_NONE)
1547:                            {
1548:                                /* At this time the function is thread safe and is interrupt
1549:                                 * safe. */
1550:                
1551:                                if(endpoint == 0)
1552:                                {
1553:                                    /* For zero endpoint we stall both directions */
1554:                
1555:                                    endpointObject = hDriver->endpointTable;
1556:                                    pBDT = hDriver->pBDT + (endpointObject->nextPingPong);
1557:                
1558:                                    /* This is the RX direction for EP0. Get the BDT back, stall
1559:                                     * it, flush all IRPs and then set the endpoint state */
1560:                
1561:                                    pBDT->byte[0] = 0x0;
1562:                                    pBDT->byte[0] |= (USBFS_UOWN|USBFS_STALL_SET);
1563:                                    _DRV_USBFS_DEVICE_IRPQueueFlush(endpointObject, USB_DEVICE_IRP_STATUS_ABORTED_ENDPOINT_HALT);
1564:                                    endpointObject->endpointState |= DRV_USBFS_DEVICE_ENDPOINT_STATE_STALLED;
1565:                
1566:                                    /* Now do the same for the TX direction */
1567:                
1568:                                    endpointObject = hDriver->endpointTable + 1;
1569:                                    pBDT = hDriver->pBDT + 2 + (endpointObject->nextPingPong);
1570:                
1571:                                    /* This is the TX direction for EP0. Get the BDT back, stall
1572:                                     * it, flush all IRPs and then set the endpoint state */
1573:                
1574:                                    pBDT->byte[0] = 0x0;
1575:                                    pBDT->byte[0] |= (USBFS_UOWN|USBFS_STALL_SET);
1576:                                    _DRV_USBFS_DEVICE_IRPQueueFlush(endpointObject, USB_DEVICE_IRP_STATUS_ABORTED_ENDPOINT_HALT );
1577:                                    endpointObject->endpointState |= DRV_USBFS_DEVICE_ENDPOINT_STATE_STALLED;
1578:                                } 
1579:                                else
1580:                                {
1581:                                    /* For non zero endpoints we stall the specified direction.
1582:                                     * Get the endpoint object. */
1583:                                    endpointObject = hDriver->endpointTable + (2 * endpoint) + direction;
1584:                
1585:                                    /* Get the BDT entry for this endpoint */
1586:                                    pBDT = hDriver->pBDT + (4 * endpoint) + (2 * direction) ;
1587:                
1588:                                    /* Get the endpoint BDT back. Stall the entry.  Flush the
1589:                                     * endpoint and set the object state. */
1590:                                    pBDT->byte[0] = 0x0;
1591:                                    pBDT->byte[0] |= (USBFS_UOWN|USBFS_STALL_SET);
1592:                
1593:                                    pBDT = hDriver->pBDT + (4 * endpoint) + (2 * direction) + 1;
1594:                
1595:                                    /* Get the endpoint BDT back. Stall the entry.  Flush the
1596:                                     * endpoint and set the object state. */
1597:                                    pBDT->byte[0] = 0x0;
1598:                                    pBDT->byte[0] |= (USBFS_UOWN|USBFS_STALL_SET);
1599:                
1600:                                    _DRV_USBFS_DEVICE_IRPQueueFlush(endpointObject, USB_DEVICE_IRP_STATUS_ABORTED_ENDPOINT_HALT);
1601:                                    endpointObject->endpointState |= DRV_USBFS_DEVICE_ENDPOINT_STATE_STALLED;
1602:                                }
1603:                
1604:                                /* Restore the interrupt enable status if this was modified. */
1605:                                if(!(hDriver->inInterruptContext))
1606:                                {
1607:                                    if(interruptWasEnabled)
1608:                                    {
1609:                                        /* Enable the interrupt */
1610:                                        _DRV_USBFS_InterruptSourceEnable(hDriver->interruptSource);
1611:                                    }
1612:                
1613:                                    OSAL_MUTEX_Unlock(&hDriver->mutexID);
1614:                                }
1615:                            }
1616:                        }
1617:                        else
1618:                        {
1619:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
1620:                            returnValue = USB_ERROR_PARAMETER_INVALID;
1621:                        }
1622:                    }
1623:                    else
1624:                    {
1625:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO,"\r\nUSBFS Driver: Unsupported endpoint");
1626:                        returnValue = USB_ERROR_DEVICE_ENDPOINT_INVALID;
1627:                    }
1628:                
1629:                    return(returnValue);
1630:                }
1631:                
1632:                // *****************************************************************************
1633:                /* Function:
1634:                    USB_ERROR DRV_USBFS_DEVICE_EndpointStallClear
1635:                    (
1636:                        DRV_HANDLE client,
1637:                        USB_ENDPOINT endpointAndDirection
1638:                    )
1639:                
1640:                  Summary:
1641:                    This function clears the stall on an endpoint in the specified direction.
1642:                    
1643:                  Description:
1644:                    This function clears the stall on an endpoint in the specified direction.
1645:                
1646:                  Remarks:
1647:                    See drv_usbfs.h for usage information.
1648:                */
1649:                
1650:                USB_ERROR DRV_USBFS_DEVICE_EndpointStallClear
1651:                (
1652:                    DRV_HANDLE client,
1653:                    USB_ENDPOINT endpointAndDirection
1654:                )
1655:                {
1656:                    int direction;
1657:                    uint8_t endpoint;
1658:                    DRV_USBFS_OBJ * hDriver;
1659:                    DRV_USBFS_BDT_ENTRY * pBDT;
1660:                    DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject;
1661:                    bool interruptWasEnabled = false;
1662:                    USB_MODULE_ID usbID; 
1663:                    USB_ERROR returnValue = USB_ERROR_NONE;
1664:                
1665:                    endpoint = endpointAndDirection & 0xF;
1666:                    direction = ((endpointAndDirection & 0x80) != 0);
1667:                
1668:                    if(endpoint < DRV_USBFS_ENDPOINTS_NUMBER)
1669:                    {
1670:                        if((client != DRV_HANDLE_INVALID) && (client != (DRV_HANDLE)(NULL)))
1671:                        {
1672:                            hDriver = ((DRV_USBFS_OBJ *)client);
1673:                            usbID = hDriver->usbID;
1674:                
1675:                            /* Get the endpoint object */
1676:                            endpointObject = hDriver->endpointTable + (2 * endpoint) + direction;
1677:                
1678:                            /* If the function is not being called from an interrupt context,
1679:                             * then capture the mutex. */
1680:                            if(!(hDriver->inInterruptContext))
1681:                            {
1682:                                if(OSAL_MUTEX_Lock(&hDriver->mutexID, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1683:                                {
1684:                                    /* Disable the interrupt */
1685:                                    interruptWasEnabled = _DRV_USBFS_InterruptSourceDisable(hDriver->interruptSource);
1686:                                }
1687:                                else
1688:                                {
1689:                                    SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Mutex lock failed");
1690:                                    returnValue = USB_ERROR_OSAL_FUNCTION;
1691:                                }
1692:                            }
1693:                
1694:                            if(returnValue == USB_ERROR_NONE)
1695:                            {
1696:                                if(endpoint == 0)
1697:                                {
1698:                                    /* Get the BDT entry for this endpoint */
1699:                                    pBDT = hDriver->pBDT + (4 * endpoint) + (2 * direction) + endpointObject->nextPingPong;
1700:                
1701:                                    /* Clear the stall and data toggle on the endpoint */
1702:                                    pBDT->byte[0] = 0x0;
1703:                                }
1704:                                else
1705:                                {
1706:                                    /* Get the BDT entry for this endpoint */
1707:                                    pBDT = hDriver->pBDT + (4 * endpoint) + (2 * direction);
1708:                
1709:                                    /* Clear the stall and data toggle on the endpoint */
1710:                                    pBDT->byte[0] = 0x0;
1711:                
1712:                                    /* Get the BDT entry for this endpoint */
1713:                                    pBDT = hDriver->pBDT + (4 * endpoint) + (2 * direction) + 1;
1714:                
1715:                                    /* Clear the stall and data toggle on the endpoint */
1716:                                    pBDT->byte[0] = 0x0;
1717:                
1718:                                    /* Clear Endpoint Stall status bit */ 
1719:                                    PLIB_USB_EPnStallClear(usbID,endpoint);
1720:                                }
1721:                
1722:                                if((endpoint == 0) && (direction == USB_DATA_DIRECTION_DEVICE_TO_HOST))
1723:                                {
1724:                                    /* All endpoint 0 transmit must start with data toggle DATA1 */
1725:                                    endpointObject->nextDataToggle = USB_BUFFER_DATA1;
1726:                                }
1727:                                else
1728:                                {
1729:                                    endpointObject->nextDataToggle = USB_BUFFER_DATA0;
1730:                                }
1731:                
1732:                                endpointObject->endpointState &= ~DRV_USBFS_DEVICE_ENDPOINT_STATE_STALLED;
1733:                
1734:                                if(endpoint != 0)
1735:                                {
1736:                
1737:                                    /* Clear up all the IRPs on this endpoint */
1738:                                    _DRV_USBFS_DEVICE_IRPQueueFlush(endpointObject, USB_DEVICE_IRP_STATUS_TERMINATED_BY_HOST);
1739:                                }
1740:                
1741:                                /* Enable the interrupt if it was previously enabled */
1742:                                if(!(hDriver->inInterruptContext))
1743:                                {
1744:                                    if(interruptWasEnabled)
1745:                                    {
1746:                                        /* Enable the interrupt */
1747:                                        _DRV_USBFS_InterruptSourceEnable(hDriver->interruptSource);
1748:                                    }
1749:                
1750:                                    /* Release the mutex */
1751:                                    OSAL_MUTEX_Unlock(&hDriver->mutexID);
1752:                                }
1753:                            }
1754:                        }
1755:                        else
1756:                        {
1757:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
1758:                            returnValue = USB_ERROR_PARAMETER_INVALID;
1759:                        }
1760:                    }
1761:                    else
1762:                    {
1763:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO,"\r\nUSBFS Driver: Unsupported endpoint");
1764:                        returnValue = USB_ERROR_DEVICE_ENDPOINT_INVALID;
1765:                    }
1766:                
1767:                    return(returnValue);
1768:                }
1769:                
1770:                // *****************************************************************************
1771:                /* Function:
1772:                    uint16_t DRV_USBFS_DEVICE_SOFNumberGet(DRV_HANDLE client)
1773:                
1774:                  Summary:
1775:                    This function will return the USB SOF packet number.
1776:                
1777:                  Description:
1778:                    This function will return the USB SOF packet number..
1779:                
1780:                  Remarks:
1781:                    See drv_usbfs.h for usage information.
1782:                */
1783:                
1784:                uint16_t DRV_USBFS_DEVICE_SOFNumberGet(DRV_HANDLE client)
1785:                {
1786:                    uint16_t sofNumber = 0;
1787:                    USB_MODULE_ID usbID;
1788:                
1789:                    /* Check if the handle is valid */
1790:                    if((DRV_HANDLE_INVALID != client) && (client != (DRV_HANDLE)(NULL)))
1791:                    {
1792:                        /* Get the Frame count */
1793:                        usbID = ((DRV_USBFS_OBJ *)client)->usbID;
1794:                        sofNumber = PLIB_USB_FrameNumberGet(usbID);
1795:                    }
1796:                    else
1797:                    {
1798:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
1799:                    }
1800:                
1801:                    return sofNumber;
1802:                }
1803:                
1804:                // *****************************************************************************
1805:                /* Function:
1806:                      void _DRV_USBFS_DEVICE_Tasks_ISR(DRV_USBFS_OBJ * hDriver)
1807:                
1808:                  Summary:
1809:                    Dynamic implementation of _DRV_USBFS_DEVICE_Tasks_ISR ISR handler function.
1810:                
1811:                  Description:
1812:                    This is the dynamic implementation of _DRV_USBFS_DEVICE_Tasks_ISR ISR handler
1813:                    function for USB device.  Function will get called automatically due to USB
1814:                    interrupts in interrupt mode.  In polling mode this function will be
1815:                    routinely called from USB driver DRV_USBFS_Tasks() function.  This function
1816:                    performs necessary action based on the interrupt and clears the interrupt
1817:                    after that. The USB device layer callback is called with the interrupt event
1818:                    details, if callback function is registered.
1819:                
1820:                  Remarks:
1821:                    This is a local function and should not be called directly by the
1822:                    application.
1823:                */
1824:                
1825:                void _DRV_USBFS_DEVICE_Tasks_ISR(DRV_USBFS_OBJ * hDriver)
1826:                {
1827:                    bool queueWasEmpty = false;
1828:                    bool processNextIRP;
1829:                    uint8_t lastEndpoint = 0;
1830:                    int iEntry;
1831:                    unsigned int errorType;
1832:                    USB_MODULE_ID usbID;
1833:                    DRV_USBFS_EVENT eventType = 0;
1834:                    USB_DEVICE_IRP_LOCAL * irp;
1835:                    DRV_USBFS_BDT_ENTRY * currentBDTEntry;
1836:                    DRV_USBFS_BDT_ENTRY * lastBDTEntry;
1837:                    DRV_USBFS_BDT_ENTRY * ep0TransmitBDTEntry;
1838:                    USB_PING_PONG_STATE lastPingPong = 0;
1839:                    USB_PING_PONG_STATE nextPingPong = 0;
1840:                    USB_BUFFER_DIRECTION lastDirection = 0;
1841:                    DRV_USBFS_DEVICE_ENDPOINT_OBJ * lastEndpointObj;
1842:                    uint32_t  mask;
1843:                
1844:                    usbID = hDriver->usbID;
1845:                
1846:                    /* Check is there was a change in VBUS voltage level */
1847:                    if(PLIB_USB_OTG_InterruptFlagGet(usbID, USB_OTG_INT_SESSION_VALID) && PLIB_USB_OTG_InterruptIsEnabled(usbID, USB_OTG_INT_SESSION_VALID))
1848:                    {
1849:                        /* This means there was a change in the VBUS voltage detected level. We
1850:                         * can find out if the VBUS is valid */
1851:                
1852:                        if(PLIB_USB_OTG_SessionValid(usbID))
1853:                        {
1854:                            /* This means we detected a valid VBUS voltage. */
1855:                            hDriver->vbusIsValid = true;
1856:                            eventType = DRV_USBFS_EVENT_DEVICE_SESSION_VALID; 
1857:                        }
1858:                        else
1859:                        {
1860:                            /* This means the VBUS is not valid anymore */
1861:                            hDriver->vbusIsValid = false;
1862:                            eventType = DRV_USBFS_EVENT_DEVICE_SESSION_INVALID;
1863:                        }
1864:                
1865:                        if(hDriver->pEventCallBack != NULL)
1866:                        {
1867:                            /* Send this event to the client */
1868:                            hDriver->pEventCallBack(hDriver->hClientArg, eventType,  (void *)NULL);
1869:                        }
1870:                
1871:                        /* Clear the interrupt */
1872:                        PLIB_USB_OTG_InterruptFlagClear(usbID, USB_OTG_INT_SESSION_VALID);
1873:                    }
1874:                
1875:                    /* If there is no VBUS or if the device pull up is not enabled yet, then
1876:                     * clear all the interrupt flags except VBUS session interrupt. Clear all
1877:                     * error, OTG and general interrupts. We cannot clear the session valid
1878:                     * interrupt because this may have change already by the time we have
1879:                     * reached here. After clearing the interrup we exit as we have nothing more
1880:                     * to be done in the ISR. */
1881:                
1882:                    if((!(hDriver->vbusIsValid)) || (!(hDriver->isAttached)))
1883:                    {
1884:                        PLIB_USB_ErrorInterruptFlagClear(usbID, USB_ERR_INT_ALL);
1885:                        PLIB_USB_InterruptFlagClear(usbID, USB_INT_ALL);
1886:                        PLIB_USB_OTG_InterruptFlagClear(usbID, (USB_OTG_INT_ALL & (~ USB_OTG_INT_SESSION_VALID))); 
1887:                    }
1888:                    else
1889:                    {
1890:                        /* Check if there was activity on the bus. This interrupt is enabled before
1891:                         * entering suspend mode. This interrupt must be enabled to wake up the
1892:                         * microcontroller from sleep due to USB activity. The driver wraps this
1893:                         * interrupt as resume detection. */
1894:                
1895:                        if(PLIB_USB_OTG_InterruptFlagGet(usbID, USB_OTG_INT_ACTIVITY_DETECT) && PLIB_USB_OTG_InterruptIsEnabled(usbID, USB_OTG_INT_ACTIVITY_DETECT ))
1896:                        {
1897:                            /* Clear the interrupt */
1898:                            PLIB_USB_OTG_InterruptFlagClear(usbID, USB_OTG_INT_ACTIVITY_DETECT);
1899:                
1900:                            /* Disable the interrupt */
1901:                            PLIB_USB_OTG_InterruptDisable(usbID, USB_OTG_INT_ACTIVITY_DETECT);
1902:                
1903:                            /* Device is not suspended any more */
1904:                            hDriver->isSuspended = false;
1905:                
1906:                            if(hDriver->pEventCallBack != NULL)
1907:                            {
1908:                                /* Send this event to the client */
1909:                                hDriver->pEventCallBack(hDriver->hClientArg, DRV_USBFS_EVENT_RESUME_DETECT,  (void *)NULL);
1910:                            }
1911:                        }
1912:                
1913:                        /* The RESUME event can only occur after the device has been suspended. */
1914:                        if (PLIB_USB_InterruptFlagGet(usbID, USB_INT_RESUME) && PLIB_USB_InterruptIsEnabled(usbID, USB_INT_RESUME))
1915:                        {
1916:                            /* Device is not suspended any more */
1917:                            hDriver->isSuspended = false;
1918:                
1919:                            if(hDriver->pEventCallBack != NULL)
1920:                            {
1921:                                /* Send this event to the client */
1922:                                hDriver->pEventCallBack(hDriver->hClientArg, DRV_USBFS_EVENT_RESUME_DETECT,  (void *)NULL);
1923:                            }
1924:                
1925:                            /* Clear the interrupt flag and disable it. This event will be enabled
1926:                             * the next time we enter suspend mode. */
1927:                            PLIB_USB_InterruptFlagClear(usbID, USB_INT_RESUME);
1928:                            PLIB_USB_InterruptDisable(usbID, USB_INT_RESUME);
1929:                        }
1930:                
1931:                        /* Check if RESET signalling was received */
1932:                        if ( PLIB_USB_InterruptFlagGet(usbID, USB_INT_DEVICE_RESET) && PLIB_USB_InterruptIsEnabled(usbID, USB_INT_DEVICE_RESET))
1933:                        {
1934:                            /* Device is not suspended any more */
1935:                            hDriver->isSuspended = false;
1936:                
1937:                            /* The host may have suspended the device before reset.
1938:                             * Clear the suspend flag and the resume flag */
1939:                            PLIB_USB_InterruptFlagClear( usbID, USB_INT_RESUME );
1940:                            PLIB_USB_InterruptFlagClear( usbID, USB_INT_IDLE_DETECT );
1941:                
1942:                            /* Make sure that all BDs are returned
1943:                             * back to the application */
1944:                
1945:                            for(iEntry = 0; iEntry < DRV_USBFS_ENDPOINTS_NUMBER; iEntry++)
1946:                            {
1947:                                currentBDTEntry = hDriver->pBDT + (4 * iEntry);
1948:                                (currentBDTEntry + 0)->word[0] = 0x0;
1949:                                (currentBDTEntry + 1)->word[0] = 0x0;
1950:                                (currentBDTEntry + 2)->word[0] = 0x0;
1951:                                (currentBDTEntry + 3)->word[0] = 0x0;
1952:                            }
1953:                
1954:                            /* Reset all ping pong buffers to even */
1955:                            PLIB_USB_PingPongReset(usbID);
1956:                
1957:                            /* Because we have reset the ping pong, the rx and tx
1958:                             * ping pong indicators need to set to set to all even */
1959:                            hDriver->rxEndpointsNextPingPong = 0 ;
1960:                            hDriver->txEndpointsNextPingPong = 0 ;
1961:                
1962:                            /* Reset address to default value (0) */
1963:                            PLIB_USB_DeviceAddressSet( usbID, 0 );
1964:                
1965:                            if(hDriver->pEventCallBack != NULL)
1966:                            {
1967:                                /* Send this event to the client */
1968:                                hDriver->pEventCallBack(hDriver->hClientArg, DRV_USBFS_EVENT_RESET_DETECT,  (void *)NULL);
1969:                            }
1970:                
1971:                            /* Clear the interrupt flag */
1972:                            PLIB_USB_InterruptFlagClear(usbID, USB_INT_DEVICE_RESET);
1973:                        }
1974:                
1975:                        /* Check if the host has suspended the bus. */
1976:                        if (PLIB_USB_InterruptFlagGet(usbID, USB_INT_IDLE_DETECT) && PLIB_USB_InterruptIsEnabled(usbID, USB_INT_IDLE_DETECT))
1977:                        {
1978:                            /* The bus is IDLE and is suspended. Send the event to the client. */
1979:                            if(hDriver->pEventCallBack != NULL)
1980:                            {
1981:                                /* Send this event to the client */
1982:                                hDriver->pEventCallBack(hDriver->hClientArg, DRV_USBFS_EVENT_IDLE_DETECT,  (void *)NULL);
1983:                            }
1984:                
1985:                            /* Clear the interrupt flag and disable it. This event will be enabled
1986:                             * the next time we enter suspend mode. */
1987:                            PLIB_USB_InterruptFlagClear(usbID, USB_INT_IDLE_DETECT);
1988:                
1989:                            /* Enable the actvity interrupt */
1990:                            PLIB_USB_OTG_InterruptEnable(usbID, USB_OTG_INT_ACTIVITY_DETECT);
1991:                
1992:                            /* Enable the resume interrupt */
1993:                            PLIB_USB_InterruptEnable(usbID, USB_INT_RESUME);
1994:                
1995:                            /* Set the suspended flag */
1996:                            hDriver->isSuspended = true;
1997:                        }
1998:                
1999:                        /* Check if an SOF was received */
2000:                
2001:                        if (PLIB_USB_InterruptFlagGet(usbID,USB_INT_SOF) && PLIB_USB_InterruptIsEnabled(usbID, USB_INT_SOF))
2002:                        {
2003:                            /* SOF received by Device or SOF threshold reached by Host no event data
2004:                             * to send. */
2005:                
2006:                            if(hDriver->pEventCallBack != NULL)
2007:                            {
2008:                                /* Send this event to the client */
2009:                                hDriver->pEventCallBack(hDriver->hClientArg, DRV_USBFS_EVENT_SOF_DETECT,  (void *)NULL);
2010:                            }
2011:                
2012:                            /* Clear the interrupt flag */
2013:                            PLIB_USB_InterruptFlagClear(usbID, USB_INT_SOF);
2014:                        }
2015:                
2016:                        /* The following event occurs when and endpoint has sent stall to the host.
2017:                         * If the stall was sent from endpoint 0, the device layer would know about
2018:                         * it. If it was sent from an non-zero endpoint, the host would send a clear
2019:                         * feature control request. This event therefore does not send any event
2020:                         * data to the client. */
2021:                
2022:                        if (PLIB_USB_InterruptFlagGet(usbID, USB_INT_STALL) && PLIB_USB_InterruptIsEnabled(usbID, USB_INT_STALL))
2023:                        {
2024:                            unsigned int iEndpoint;
2025:                            for ( iEndpoint = 0; iEndpoint < DRV_USBFS_ENDPOINTS_NUMBER; iEndpoint++ )
2026:                            {
2027:                                if ( PLIB_USB_EPnIsStalled(usbID,iEndpoint) )
2028:                                {
2029:                                    PLIB_USB_EPnStallClear(usbID,iEndpoint);
2030:                                }
2031:                            }
2032:                
2033:                            if(hDriver->pEventCallBack != NULL)
2034:                            {
2035:                                /* Send this event to the client */
2036:                                hDriver->pEventCallBack(hDriver->hClientArg, DRV_USBFS_EVENT_STALL,  (void *)NULL);
2037:                            }
2038:                
2039:                            /* Clear the interrupt flag */
2040:                            PLIB_USB_InterruptFlagClear(usbID, USB_INT_STALL);
2041:                        }
2042:                
2043:                        /* Check if an error has occurred */
2044:                        if ( PLIB_USB_InterruptFlagGet( usbID, USB_INT_ERROR ) && PLIB_USB_InterruptIsEnabled(usbID, USB_INT_ERROR))
2045:                        {
2046:                            /* Get the error type to send to the client */
2047:                            errorType = PLIB_USB_ErrorInterruptFlagAllGet(usbID);
2048:                
2049:                            /* Clear the base error flags and the interrupt flag */
2050:                            PLIB_USB_ErrorInterruptFlagClear( usbID, errorType );
2051:                            PLIB_USB_InterruptFlagClear( usbID, USB_INT_ERROR );
2052:                
2053:                            if(hDriver->pEventCallBack != NULL)
2054:                            {
2055:                                /* Send this event to the client */
2056:                                hDriver->pEventCallBack(hDriver->hClientArg, DRV_USBFS_EVENT_ERROR,  (void *)&errorType);
2057:                            }
2058:                        }
2059:                
2060:                        /* This while loop will empty the token received FIFO. This while will not
2061:                         * run forever because there are only that many tokens that can be received
2062:                         * in a period of 1 millisecond. */
2063:                
2064:                        while(PLIB_USB_InterruptFlagGet(usbID, USB_INT_TOKEN_DONE))
2065:                        {
2066:                            /* Get the details of the last transaction */
2067:                            PLIB_USB_LastTransactionDetailsGet(usbID, &lastDirection, &lastPingPong, &lastEndpoint); 
2068:                
2069:                            /* Now that the details of the last transaction have been obtained, we
2070:                             * need to clear the TOKEN interrupt immediately. This will give enough
2071:                             * time for the TRNIF flag to clear. This way we avoid situations where
2072:                             * the flag was cleared but the code still enters TRNIF was still set.
2073:                             * */
2074:                
2075:                            PLIB_USB_InterruptFlagClear(usbID,USB_INT_TOKEN_DONE);
2076:                
2077:                            /* Set up the next ping pong buffer descriptor. This will tell the IRP
2078:                             * processing code which buffer descriptors to use. When the host does a
2079:                             * set configuration 0, the Device Layer will disable and enable all
2080:                             * endpoints. A set configuration 0 is not the same a bus reset in which
2081:                             * case the ping pong indicators would have been reset. So the endpoint
2082:                             * enable function will ready the soft ping pong trackers to find out
2083:                             * which ping pong to use.  */
2084:                
2085:                            if ( lastPingPong == USB_PING_PONG_EVEN )
2086:                            {
2087:                                nextPingPong = USB_PING_PONG_ODD;
2088:                            }
2089:                            else
2090:                            {
2091:                                nextPingPong = USB_PING_PONG_EVEN;
2092:                            }
2093:                
2094:                            mask = 1 << lastEndpoint ;
2095:                
2096:                            /* Update the next ping pong indicator for this endpoint. Each bit in
2097:                             * the rxEndpointsNextPingPong and txEndpointsNextPingPong track the
2098:                             * ping pong value for the endpoint. */
2099:                
2100:                            if( lastDirection == USB_BUFFER_RX ) 
2101:                            {
2102:                                /* This is for the RX direction */
2103:                                if (nextPingPong == USB_PING_PONG_ODD )
2104:                                {
2105:                                    hDriver->rxEndpointsNextPingPong =   hDriver->rxEndpointsNextPingPong | mask ;
2106:                                }
2107:                                else
2108:                                {
2109:                                    hDriver->rxEndpointsNextPingPong =  ( hDriver->rxEndpointsNextPingPong & (~mask ) ) ;
2110:                                }
2111:                            }
2112:                            else    
2113:                            {
2114:                                /* This is for the TX direction */
2115:                                if (nextPingPong == USB_PING_PONG_ODD )
2116:                                {
2117:                                    hDriver->txEndpointsNextPingPong =   hDriver->txEndpointsNextPingPong | mask ;
2118:                                }
2119:                                else
2120:                                {
2121:                                    hDriver->txEndpointsNextPingPong =  ( hDriver->txEndpointsNextPingPong & (~mask ) ) ;
2122:                                }
2123:                            }
2124:                
2125:                            /* Get the associated endpoint object */
2126:                            lastEndpointObj = hDriver->endpointTable + (lastEndpoint * 2) + lastDirection;
2127:                
2128:                            /* Get the first IRP in the queue */
2129:                            irp = lastEndpointObj->irpQueue; 
2130:                
2131:                            /* Get the BDT entry for this direction. currentBDTEntry points to the
2132:                             * ping pong set. lastBDTEntry points to the specific ping or pong
2133:                             * entry. */
2134:                
2135:                            currentBDTEntry = hDriver->pBDT + (4 * lastEndpoint) + (2 * lastDirection); 
2136:                            lastBDTEntry = currentBDTEntry + lastPingPong;
2137:                
2138:                            if(irp != NULL)
2139:                            {
2140:                                /* This flag lets us know if the current IRP is done and that the next
2141:                                 * IRP should be processed */
2142:                
2143:                                processNextIRP = false;
2144:                                switch(lastBDTEntry->byte[0] & 0x3C)
2145:                                {
2146:                                    case 0x34 :
2147:                
2148:                                        /* This means a setup packet has been received */
2149:                
2150:                                        irp->status = USB_DEVICE_IRP_STATUS_SETUP;
2151:                                        irp->size   = lastBDTEntry->word[1];
2152:                
2153:                                        /* currentBDTEntry at this point will point to enpoint 0 BDT
2154:                                         * entry. We should get the transmit BDT entries and clear
2155:                                         * the stall conditions */
2156:                
2157:                                        ep0TransmitBDTEntry = currentBDTEntry + 2;
2158:                
2159:                                        /* ep0TranmitBDTEntry at this point should point to the EP0
2160:                                         * transmit even BDT entry. Clearing byte 0 will clear clear
2161:                                         * the stall */
2162:                                        ep0TransmitBDTEntry->byte[0] = 0;
2163:                
2164:                                        /* Now get the transmit BDT odd entry and do the same */
2165:                
2166:                                        ep0TransmitBDTEntry ++;
2167:                                        ep0TransmitBDTEntry->byte[0] = 0;
2168:                
2169:                                        /* Reset the data toggle on the TX endpoint to DATA1 because
2170:                                         * we received a setup packet. Any packet that the device
2171:                                         * transmit on this endpoint must start with DATA1 toggle.
2172:                                         * */
2173:                
2174:                                        (lastEndpointObj + USB_DATA_DIRECTION_DEVICE_TO_HOST)->nextDataToggle = USB_BUFFER_DATA1;
2175:                
2176:                                        PLIB_USB_PacketTransferEnable(usbID);
2177:                
2178:                                        /* We should get the next IRP in the queue . */
2179:                
2180:                                        processNextIRP = true;
2181:                                        break;
2182:                
2183:                                    case 0x4:
2184:                
2185:                                        /* We received an OUT token. Check if the size is less than
2186:                                         * maxPacketSize. This means the end of the transfer. If the
2187:                                         * pending size is 0 then again we end the transfer */
2188:                
2189:                                        irp->nPendingBytes += lastBDTEntry->shortWord[1];
2190:                
2191:                                        if(irp->status == USB_DEVICE_IRP_STATUS_ABORTED)
2192:                                        {
2193:                                            /* No need to process this aborted IRP. Enable the
2194:                                             * driver to move to the next IRP in the queue. */
2195:                                            if(irp->callback != NULL)
2196:                                            {
2197:                                                irp->callback((USB_DEVICE_IRP *)irp);
2198:                                            }
2199:                                            processNextIRP = true;
2200:                                        }
2201:                
2202:                                        else if((lastBDTEntry->shortWord[1] < lastEndpointObj->maxPacketSize) || (irp->nPendingBytes >= irp->size))
2203:                                        {
2204:                                            /* We end the transfer because we either got the amount
2205:                                             * of data that we were expecting or we got the a short
2206:                                             * packet. */
2207:                
2208:                                            /* If we got less data than we were expecting, then set
2209:                                             * the IRP status to short else say it is completed */
2210:                
2211:                                            if(irp->nPendingBytes >= irp->size)
2212:                                            {
2213:                                                irp->status = USB_DEVICE_IRP_STATUS_COMPLETED;
2214:                                            }
2215:                                            else
2216:                                            {
2217:                                                irp->status = USB_DEVICE_IRP_STATUS_COMPLETED_SHORT;
2218:                                            }
2219:                
2220:                                            /* Update the irp size with received data */
2221:                                            irp->size = irp->nPendingBytes;
2222:                
2223:                                            processNextIRP = true;
2224:                
2225:                                        }
2226:                                        else
2227:                                        {
2228:                                            /* We must continue this transfer */
2229:                                            _DRV_USBFS_DEVICE_EndpointBDTEntryArm(currentBDTEntry, lastEndpointObj, irp, lastDirection);
2230:                                        }
2231:                                        break;
2232:                
2233:                                    case 0x24:
2234:                
2235:                                        /* This means that a IN token was received from the host */
2236:                
2237:                                        if(irp->status == USB_DEVICE_IRP_STATUS_ABORTED)
2238:                                        {
2239:                                            /* No need to process this aborted IRP. Enable the
2240:                                             * driver to move to the next IRP in the queue. */
2241:                
2242:                                            if(irp->callback != NULL)
2243:                                            {
2244:                                                irp->callback((USB_DEVICE_IRP *)irp);
2245:                                            }
2246:                                            processNextIRP = true;
2247:                                        }
2248:                
2249:                                        else if(irp->nPendingBytes == 0)
2250:                                        {
2251:                                            if((irp->flags & USB_DEVICE_IRP_FLAG_SEND_ZLP) != 0)
2252:                                            {
2253:                                                /* This means a ZLP must be sent */
2254:                                                irp->flags &= ~USB_DEVICE_IRP_FLAG_SEND_ZLP;
2255:                                                _DRV_USBFS_DEVICE_EndpointBDTEntryArm(currentBDTEntry, lastEndpointObj, irp, lastDirection);
2256:                                            }
2257:                                            else
2258:                                            {
2259:                                                irp->status = USB_DEVICE_IRP_STATUS_COMPLETED;
2260:                                                processNextIRP = true;
2261:                                            }
2262:                                        }
2263:                                        else
2264:                                        {
2265:                                            /* We must continue this transfer */
2266:                                            _DRV_USBFS_DEVICE_EndpointBDTEntryArm(currentBDTEntry, lastEndpointObj, irp, lastDirection);
2267:                                        }
2268:                
2269:                                        break;
2270:                
2271:                                    default:
2272:                                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Unknown TOKEN received from host");
2273:                                        break;
2274:                                }
2275:                
2276:                                /* Reset the BDT status */
2277:                                lastBDTEntry->byte[0] = 0;
2278:                
2279:                                if(processNextIRP)
2280:                                {
2281:                                    /* Check the queue and get the next IRP */
2282:                
2283:                                    lastEndpointObj->irpQueue = irp->next;
2284:                
2285:                                    /* Check if the queue is empty. This will then allow us to track
2286:                                     * if a IRP was submitted after the  IRP callback. If so, then
2287:                                     * we should not call the
2288:                                     * _DRV_USBFS_DEVICE_EndpointBDTEntryArm(). For an IRP added in
2289:                                     * the IRP callback, the _DRV_USBFS_DEVICE_EndpointBDTEntryArm
2290:                                     * would have already been done in the IRP Submit function */
2291:                
2292:                                    if(lastEndpointObj->irpQueue == NULL)
2293:                                    {
2294:                                        /* Queue was empty before the call back */
2295:                                        queueWasEmpty = true;
2296:                                    }
2297:                
2298:                                    /* Now do the IRP callback*/
2299:                
2300:                                    if(irp->callback != NULL && irp->status != USB_DEVICE_IRP_STATUS_ABORTED)
2301:                                    {
2302:                                        /* Invoke the callback */
2303:                                        irp->callback((USB_DEVICE_IRP *)irp);
2304:                                    }
2305:                
2306:                                    if((lastEndpointObj->irpQueue != NULL) && (!(queueWasEmpty)))
2307:                                    {
2308:                                        /* This means we have something in the queue and this was not
2309:                                         * added in the IRP callback. We can arm the endpoint. */
2310:                
2311:                                        lastEndpointObj->irpQueue->status = USB_DEVICE_IRP_STATUS_IN_PROGRESS;
2312:                                        _DRV_USBFS_DEVICE_EndpointBDTEntryArm( currentBDTEntry, lastEndpointObj, lastEndpointObj->irpQueue, lastDirection);
2313:                                    }
2314:                                }
2315:                            }
2316:                            else
2317:                            {
2318:                                /* The IRP is null. This can happen if the IRP was aborted. In which
2319:                                 * case we have nothing to do. */
2320:                            }
2321:                        }
2322:                    }
2323:                }
2324:                
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
00000024  00000000   NOP
0000002C  00000000   NOP
00000030  00000000   NOP
00000034  00000000   NOP
0000003C  00000000   NOP
00000044  00000000   NOP
00000048  00000000   NOP
00000050  00000000   NOP
00000054  00000000   NOP
00000058  00000000   NOP
0000005C  00000000   NOP
00000060  00000000   NOP
0000006C  00000000   NOP
9D000308  2482FFFF   ADDIU V0, A0, -1
9D00030C  2C42FFFE   SLTIU V0, V0, -2
9D000310  03E00008   JR RA
9D000314  00021040   SLL V0, V0, 1
9D001178  27BDFFB0   ADDIU SP, SP, -80
9D00117C  AFB00028   SW S0, 40(SP)
9D001184  AFB20030   SW S2, 48(SP)
9D001188  AFBF004C   SW RA, 76(SP)
9D001190  AFBE0048   SW FP, 72(SP)
9D001194  AFB70044   SW S7, 68(SP)
9D00119C  AFB60040   SW S6, 64(SP)
9D0011A0  AFB5003C   SW S5, 60(SP)
9D0011A4  AFB40038   SW S4, 56(SP)
9D0011A8  AFB30034   SW S3, 52(SP)
9D0011AC  AFB1002C   SW S1, 44(SP)
9D0011B0  10400005   BEQ V0, ZERO, 0x9D0011C8
9D0011B4  00809025   OR S2, A0, ZERO
9D0011C0  144000F3   BNE V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_OTG_SessionValid
9D0011C4  00000000   NOP
9D0011C8  92420002   LBU V0, 2(S2)
9D0011CC  10400004   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_ErrorInterruptFlagClear
9D0011D0  240200FF   ADDIU V0, ZERO, 255
9D0011D4  92550003   LBU S5, 3(S2)
9D0011D8  16A00011   BNE S5, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_OTG_InterruptFlagGet
9D0011DC  240200FF   ADDIU V0, ZERO, 255
9D0011E0  AE0201E0   SW V0, 480(S0)
9D0011E4  AE0201C0   SW V0, 448(S0)
9D0011E8  240200F5   ADDIU V0, ZERO, 245
9D0011F0  8FBF004C   LW RA, 76(SP)
9D001210  8FB1002C   LW S1, 44(SP)
9D001214  8FB00028   LW S0, 40(SP)
9D001218  03E00008   JR RA
9D00121C  27BD0050   ADDIU SP, SP, 80
9D001220  8E020000   LW V0, 0(S0)
9D001228  10400010   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00122C  00000000   NOP
9D001238  1040000C   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00123C  24020010   ADDIU V0, ZERO, 16
9D001240  AE020000   SW V0, 0(S0)
9D001244  8E020010   LW V0, 16(S0)
9D001248  8E430010   LW V1, 16(S2)
9D001254  10600005   BEQ V1, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D001258  A2400004   SB ZERO, 4(S2)
9D00125C  8E44000C   LW A0, 12(S2)
9D001260  00003025   OR A2, ZERO, ZERO
9D001264  0060F809   JALR V1
9D001268  24050003   ADDIU A1, ZERO, 3
9D00126C  8E0201C0   LW V0, 448(S0)
9D001274  10400011   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D001278  00000000   NOP
9D001284  1040000D   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D001288  00000000   NOP
9D00128C  8E420010   LW V0, 16(S2)
9D001290  10400005   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagClear
9D001294  A2400004   SB ZERO, 4(S2)
9D001298  8E44000C   LW A0, 12(S2)
9D00129C  00003025   OR A2, ZERO, ZERO
9D0012A0  0040F809   JALR V0
9D0012A4  24050003   ADDIU A1, ZERO, 3
9D0012A8  24020020   ADDIU V0, ZERO, 32
9D0012AC  AE0201C0   SW V0, 448(S0)
9D0012B0  8E0201D0   LW V0, 464(S0)
9D0012BC  8E0201C0   LW V0, 448(S0)
9D0012C4  10400025   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D0012C8  00000000   NOP
9D0012D4  10400021   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D0012D8  24040020   ADDIU A0, ZERO, 32
9D0012DC  8E42002C   LW V0, 44(S2)
9D0012E0  A2400004   SB ZERO, 4(S2)
9D0012E4  AE0401C0   SW A0, 448(S0)
9D0012E8  24040010   ADDIU A0, ZERO, 16
9D0012EC  24430080   ADDIU V1, V0, 128
9D0012F0  AE0401C0   SW A0, 448(S0)
9D0012F4  AC400000   SW ZERO, 0(V0)
9D0012F8  AC400008   SW ZERO, 8(V0)
9D0012FC  AC400010   SW ZERO, 16(V0)
9D001300  AC400018   SW ZERO, 24(V0)
9D001304  24420020   ADDIU V0, V0, 32
9D001308  5443FFFB   BNEL V0, V1, 0x9D0012F8
9D00130C  AC400000   SW ZERO, 0(V0)
9D001310  8E020210   LW V0, 528(S0)
9D001314  8E430010   LW V1, 16(S2)
9D00132C  92020220   LBU V0, 544(S0)
9D001330  AE400018   SW ZERO, 24(S2)
9D001334  AE40001C   SW ZERO, 28(S2)
9D001338  7C023004   INS V0, ZERO, 0, 7
9D00133C  A2020220   SB V0, 544(S0)
9D001340  10600004   BEQ V1, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagClear
9D001348  8E44000C   LW A0, 12(S2)
9D00134C  0060F809   JALR V1
9D001350  24050002   ADDIU A1, ZERO, 2
9D001354  24020001   ADDIU V0, ZERO, 1
9D00135C  8E0201C0   LW V0, 448(S0)
9D001364  10400015   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D001368  00000000   NOP
9D001374  10400011   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D001378  00000000   NOP
9D00137C  8E420010   LW V0, 16(S2)
9D001380  10400004   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagClear
9D001384  00003025   OR A2, ZERO, ZERO
9D001388  8E44000C   LW A0, 12(S2)
9D00138C  0040F809   JALR V0
9D001390  24050004   ADDIU A1, ZERO, 4
9D001394  24020010   ADDIU V0, ZERO, 16
9D00139C  8E020010   LW V0, 16(S0)
9D0013A8  8E0201D0   LW V0, 464(S0)
9D0013AC  34420020   ORI V0, V0, 32
9D0013B0  AE0201D0   SW V0, 464(S0)
9D0013B4  24020001   ADDIU V0, ZERO, 1
9D0013B8  A2420004   SB V0, 4(S2)
9D0013BC  8E0201C0   LW V0, 448(S0)
9D0013C4  1040000D   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D0013C8  00000000   NOP
9D0013D4  10400009   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D0013D8  00000000   NOP
9D0013DC  8E420010   LW V0, 16(S2)
9D0013E0  10400004   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagClear
9D0013E4  00003025   OR A2, ZERO, ZERO
9D0013E8  8E44000C   LW A0, 12(S2)
9D0013EC  0040F809   JALR V0
9D0013F0  24050007   ADDIU A1, ZERO, 7
9D0013F4  24020004   ADDIU V0, ZERO, 4
9D0013FC  8E0201C0   LW V0, 448(S0)
9D001404  1040001A   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D001408  00000000   NOP
9D001414  10400016   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D001418  00001825   OR V1, ZERO, ZERO
9D00141C  24050004   ADDIU A1, ZERO, 4
9D001420  2462002C   ADDIU V0, V1, 44
9D001434  10800004   BEQ A0, ZERO, 0x9D001448
9D001438  24630001   ADDIU V1, V1, 1
9D001448  1465FFF6   BNE V1, A1, 0x9D001424
9D001450  8E420010   LW V0, 16(S2)
9D001454  10400004   BEQ V0, ZERO, PLIB_USB_InterruptFlagClear
9D001458  00003025   OR A2, ZERO, ZERO
9D00145C  8E44000C   LW A0, 12(S2)
9D001460  0040F809   JALR V0
9D001464  24050006   ADDIU A1, ZERO, 6
9D001468  24020080   ADDIU V0, ZERO, 128
9D001470  8E0201C0   LW V0, 448(S0)
9D001478  1440005B   BNE V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptIsEnabled
9D00147C  00000000   NOP
9D001480  0000B825   OR S7, ZERO, ZERO
9D001488  24130001   ADDIU S3, ZERO, 1
9D00148C  10000012   BEQ ZERO, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D001490  24160024   ADDIU S6, ZERO, 36
9D001494  56200051   BNEL S1, ZERO, 0x9D0015DC
9D001498  8E45001C   LW A1, 28(S2)
9D00149C  8E450018   LW A1, 24(S2)
9D0014A0  00A31825   OR V1, A1, V1
9D0014A4  AE430018   SW V1, 24(S2)
9D0014A8  00023840   SLL A3, V0, 1
9D0014AC  00111840   SLL V1, S1, 1
9D0014B0  00E22821   ADDU A1, A3, V0
9D0014B4  00711021   ADDU V0, V1, S1
9D0014B8  8E430034   LW V1, 52(S2)
9D0014BC  000210C0   SLL V0, V0, 3
9D0014C0  00052900   SLL A1, A1, 4
9D0014C4  00A22821   ADDU A1, A1, V0
9D0014C8  00652821   ADDU A1, V1, A1
9D0014CC  8CA20000   LW V0, 0(A1)
9D0014D0  54400020   BNEL V0, ZERO, 0x9D001554
9D0014D4  8E48002C   LW T0, 44(S2)
9D0014D8  8E0201C0   LW V0, 448(S0)
9D0014E0  1040FF44   BEQ V0, ZERO, 0x9D0011F4
9D0014E4  8FBF004C   LW RA, 76(SP)
9D0014E8  8E110200   LW S1, 512(S0)
9D001500  AE1401C0   SW S4, 448(S0)
9D001504  1080FFE3   BEQ A0, ZERO, 0x9D001494
9D001508  00531804   SLLV V1, S3, V0
9D00150C  1620002F   BNE S1, ZERO, 0x9D0015CC
9D001510  00031827   NOR V1, ZERO, V1
9D001514  8E450018   LW A1, 24(S2)
9D001518  00023840   SLL A3, V0, 1
9D00151C  00A31824   AND V1, A1, V1
9D001520  AE430018   SW V1, 24(S2)
9D001524  00111840   SLL V1, S1, 1
9D001528  00E22821   ADDU A1, A3, V0
9D00152C  00711021   ADDU V0, V1, S1
9D001530  8E430034   LW V1, 52(S2)
9D001534  000210C0   SLL V0, V0, 3
9D001538  00052900   SLL A1, A1, 4
9D00153C  00A22821   ADDU A1, A1, V0
9D001540  00652821   ADDU A1, V1, A1
9D001544  8CA20000   LW V0, 0(A1)
9D001548  1040FFE3   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00154C  00000000   NOP
9D001550  8E48002C   LW T0, 44(S2)
9D001554  00F13821   ADDU A3, A3, S1
9D001558  00073900   SLL A3, A3, 4
9D00155C  01074021   ADDU T0, T0, A3
9D001560  000420C0   SLL A0, A0, 3
9D001564  0104F021   ADDU FP, T0, A0
9D001568  93C30000   LBU V1, 0(FP)
9D00156C  3063003C   ANDI V1, V1, 60
9D001570  10760067   BEQ V1, S6, 0x9D001710
9D001574  24040034   ADDIU A0, ZERO, 52
9D001578  10640045   BEQ V1, A0, 0x9D001690
9D00157C  24040004   ADDIU A0, ZERO, 4
9D001580  50640031   BEQL V1, A0, 0x9D001648
9D001584  97C60002   LHU A2, 2(FP)
9D001588  1000FFD3   BEQ ZERO, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00158C  A3C00000   SB ZERO, 0(FP)
9D001590  8E020020   LW V0, 32(S0)
9D001594  7C4200C0   EXT V0, V0, 3, 1
9D001598  14400024   BNE V0, ZERO, 0x9D00162C
9D0015A4  10400084   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_OTG_InterruptFlagClear
9D0015A8  24050009   ADDIU A1, ZERO, 9
9D0015AC  8E44000C   LW A0, 12(S2)
9D0015B0  0040F809   JALR V0
9D0015B4  00003025   OR A2, ZERO, ZERO
9D0015C0  AE030000   SW V1, 0(S0)
9D0015CC  8E45001C   LW A1, 28(S2)
9D0015D4  1000FFB4   BEQ ZERO, ZERO, 0x9D0014A8
9D0015D8  AE43001C   SW V1, 28(S2)
9D0015DC  00A31825   OR V1, A1, V1
9D0015E0  1000FFB1   BEQ ZERO, ZERO, 0x9D0014A8
9D0015E4  AE43001C   SW V1, 28(S2)
9D0015F0  1040FFA4   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagClear
9D0015F4  0000B825   OR S7, ZERO, ZERO
9D0015F8  8E0201E0   LW V0, 480(S0)
9D0015FC  8E430010   LW V1, 16(S2)
9D001600  AFA20010   SW V0, 16(SP)
9D001608  24020002   ADDIU V0, ZERO, 2
9D00160C  AE0201C0   SW V0, 448(S0)
9D001610  1060FF9B   BEQ V1, ZERO, 0x9D001480
9D001618  8E44000C   LW A0, 12(S2)
9D00161C  0060F809   JALR V1
9D001620  24050001   ADDIU A1, ZERO, 1
9D001624  1000FF97   BEQ ZERO, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagClear
9D001628  0000B825   OR S7, ZERO, ZERO
9D00162C  24030001   ADDIU V1, ZERO, 1
9D001630  A0830002   SB V1, 2(A0)
9D001634  1440FFDD   BNE V0, ZERO, 0x9D0015AC
9D001638  24050008   ADDIU A1, ZERO, 8
9D00163C  AE050000   SW A1, 0(S0)
9D001640  1000FEE5   BEQ ZERO, ZERO, 0x9D0011D8
9D001644  92550003   LBU S5, 3(S2)
9D001648  8C430020   LW V1, 32(V0)
9D00164C  8C470008   LW A3, 8(V0)
9D001650  2404FFFE   ADDIU A0, ZERO, -2
9D001654  00C31821   ADDU V1, A2, V1
9D001658  10E40042   BEQ A3, A0, 0x9D001764
9D00165C  AC430020   SW V1, 32(V0)
9D001660  94A70004   LHU A3, 4(A1)
9D001664  8C440004   LW A0, 4(V0)
9D001668  00C7302B   SLTU A2, A2, A3
9D00166C  14C00003   BNE A2, ZERO, 0x9D00167C
9D001670  0064202B   SLTU A0, V1, A0
9D001674  14800056   BNE A0, ZERO, 0x9D0017D0
9D001678  02203825   OR A3, S1, ZERO
9D00167C  AC430004   SW V1, 4(V0)
9D001680  AC440008   SW A0, 8(V0)
9D001684  8C43000C   LW V1, 12(V0)
9D001688  1000000D   BEQ ZERO, ZERO, 0x9D0016C0
9D00168C  A3C00000   SB ZERO, 0(FP)
9D001690  8FC30004   LW V1, 4(FP)
9D001694  24040002   ADDIU A0, ZERO, 2
9D001698  AC440008   SW A0, 8(V0)
9D00169C  AC430004   SW V1, 4(V0)
9D0016A0  92040210   LBU A0, 528(S0)
9D0016A4  8C43000C   LW V1, 12(V0)
9D0016A8  A1000010   SB ZERO, 16(T0)
9D0016AC  7C042944   INS A0, ZERO, 5, 1
9D0016B0  A1000018   SB ZERO, 24(T0)
9D0016B4  ACB30024   SW S3, 36(A1)
9D0016B8  A2040210   SB A0, 528(S0)
9D0016BC  A3C00000   SB ZERO, 0(FP)
9D0016C0  8C460018   LW A2, 24(V0)
9D0016C4  10C00034   BEQ A2, ZERO, 0x9D001798
9D0016C8  ACA60000   SW A2, 0(A1)
9D0016CC  1060000C   BEQ V1, ZERO, 0x9D001700
9D0016D0  2404FFFE   ADDIU A0, ZERO, -2
9D0016D4  8C470008   LW A3, 8(V0)
9D0016D8  10E40009   BEQ A3, A0, 0x9D001700
9D0016DC  00000000   NOP
9D0016E0  00402025   OR A0, V0, ZERO
9D0016E4  AFA8001C   SW T0, 28(SP)
9D0016E8  0060F809   JALR V1
9D0016EC  AFA50018   SW A1, 24(SP)
9D0016F0  8FA50018   LW A1, 24(SP)
9D0016F4  8CA60000   LW A2, 0(A1)
9D0016F8  10C0FF77   BEQ A2, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D0016FC  8FA8001C   LW T0, 28(SP)
9D001700  12E00012   BEQ S7, ZERO, 0x9D00174C
9D001704  24020004   ADDIU V0, ZERO, 4
9D001708  1000FF73   BEQ ZERO, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00170C  02A0B825   OR S7, S5, ZERO
9D001710  8C440008   LW A0, 8(V0)
9D001714  2403FFFE   ADDIU V1, ZERO, -2
9D001718  50830013   BEQL A0, V1, 0x9D001768
9D00171C  8C43000C   LW V1, 12(V0)
9D001720  8C430020   LW V1, 32(V0)
9D001724  1460002A   BNE V1, ZERO, 0x9D0017D0
9D001728  02203825   OR A3, S1, ZERO
9D00172C  8C430010   LW V1, 16(V0)
9D001730  30640080   ANDI A0, V1, 128
9D001734  54800024   BNEL A0, ZERO, 0x9D0017C8
9D001738  7C0339C4   INS V1, ZERO, 7, 1
9D00173C  AC400008   SW ZERO, 8(V0)
9D001740  8C43000C   LW V1, 12(V0)
9D001744  1000FFDE   BEQ ZERO, ZERO, 0x9D0016C0
9D001748  A3C00000   SB ZERO, 0(FP)
9D00174C  ACC20008   SW V0, 8(A2)
9D001750  02203825   OR A3, S1, ZERO
9D001754  0F4017FB   JAL _DRV_USBFS_DEVICE_EndpointBDTEntryArm
9D001758  01002025   OR A0, T0, ZERO
9D00175C  1000FF5E   BEQ ZERO, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D001760  00000000   NOP
9D001764  8C43000C   LW V1, 12(V0)
9D001768  1060001E   BEQ V1, ZERO, 0x9D0017E4
9D00176C  00402025   OR A0, V0, ZERO
9D001770  AFA80020   SW T0, 32(SP)
9D001774  AFA5001C   SW A1, 28(SP)
9D001778  0060F809   JALR V1
9D00177C  AFA20018   SW V0, 24(SP)
9D001780  8FA20018   LW V0, 24(SP)
9D001784  8FA5001C   LW A1, 28(SP)
9D001788  8FA80020   LW T0, 32(SP)
9D00178C  8C43000C   LW V1, 12(V0)
9D001790  1000FFCB   BEQ ZERO, ZERO, 0x9D0016C0
9D001794  A3C00000   SB ZERO, 0(FP)
9D001798  1060FF4F   BEQ V1, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00179C  02A0B825   OR S7, S5, ZERO
9D0017A0  8C460008   LW A2, 8(V0)
9D0017A4  2404FFFE   ADDIU A0, ZERO, -2
9D0017A8  54C4FFCE   BNEL A2, A0, 0x9D0016E4
9D0017AC  00402025   OR A0, V0, ZERO
9D0017B0  1000FF49   BEQ ZERO, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D0017B4  00000000   NOP
9D0017B8  24020008   ADDIU V0, ZERO, 8
9D0017C0  1000FE87   BEQ ZERO, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_ErrorInterruptFlagClear
9D0017C8  AC430010   SW V1, 16(V0)
9D0017CC  02203825   OR A3, S1, ZERO
9D0017D0  00403025   OR A2, V0, ZERO
9D0017D4  0F4017FB   JAL _DRV_USBFS_DEVICE_EndpointBDTEntryArm
9D0017D8  01002025   OR A0, T0, ZERO
9D0017DC  1000FF3E   BEQ ZERO, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D0017E0  A3C00000   SB ZERO, 0(FP)
9D0017E4  8C460018   LW A2, 24(V0)
9D0017E8  A3C00000   SB ZERO, 0(FP)
9D0017EC  14C0FFC4   BNE A2, ZERO, 0x9D001700
9D0017F0  ACA60000   SW A2, 0(A1)
9D0017F4  1000FF38   BEQ ZERO, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D0017F8  02A0B825   OR S7, S5, ZERO
9D0032B0  2482FFFF   ADDIU V0, A0, -1
9D0032B4  2C42FFFE   SLTIU V0, V0, -2
9D0032B8  1040008C   BEQ V0, ZERO, 0x9D0034EC
9D0032BC  00000000   NOP
9D0032C0  8CC20008   LW V0, 8(A2)
9D0032C4  28420003   SLTI V0, V0, 3
9D0032C8  1040008C   BEQ V0, ZERO, 0x9D0034FC
9D0032CC  00000000   NOP
9D0032D0  27BDFFC8   ADDIU SP, SP, -56
9D0032D4  30A3000C   ANDI V1, A1, 12
9D0032D8  AFB20024   SW S2, 36(SP)
9D0032DC  AFBF0034   SW RA, 52(SP)
9D0032E0  AFB50030   SW S5, 48(SP)
9D0032E4  AFB4002C   SW S4, 44(SP)
9D0032E8  AFB30028   SW S3, 40(SP)
9D0032EC  AFB10020   SW S1, 32(SP)
9D0032F0  AFB0001C   SW S0, 28(SP)
9D0032F4  30A2000F   ANDI V0, A1, 15
9D0032F8  1460007E   BNE V1, ZERO, 0x9D0034F4
9D0032FC  7C059420   SEB S2, A1
9D003300  0002A040   SLL S4, V0, 1
9D003304  02821021   ADDU V0, S4, V0
9D003308  2A430000   SLTI V1, S2, 0
9D00330C  8C930034   LW S3, 52(A0)
9D003310  24050018   ADDIU A1, ZERO, 24
9D003314  00021100   SLL V0, V0, 4
9D003318  0003280A   MOVZ A1, ZERO, V1
9D00331C  00451021   ADDU V0, V0, A1
9D003320  02629821   ADDU S3, S3, V0
9D003324  8E620014   LW V0, 20(S3)
9D003328  30420001   ANDI V0, V0, 1
9D00332C  10400075   BEQ V0, ZERO, 0x9D003504
9D003330  8C95002C   LW S5, 44(A0)
9D003334  96700004   LHU S0, 4(S3)
9D003338  8CC20004   LW V0, 4(A2)
9D00333C  0050001B   DIVU V0, S0
9D003340  020001F4   TEQ S0, ZERO
9D003344  00008010   MFHI S0
9D003348  16000025   BNE S0, ZERO, 0x9D0033E0
9D00334C  00808825   OR S1, A0, ZERO
9D003350  06400047   BLTZ S2, 0x9D003470
9D003354  90830001   LBU V1, 1(A0)
9D003358  10600058   BEQ V1, ZERO, DRV_USBFS_DEVICE_IRPSubmit::OSAL_MUTEX_Lock
9D00335C  00006025   OR T4, ZERO, ZERO
9D003360  ACC00018   SW ZERO, 24(A2)
9D003364  8E670000   LW A3, 0(S3)
9D003368  24030003   ADDIU V1, ZERO, 3
9D00336C  ACD00020   SW S0, 32(A2)
9D003370  14E00003   BNE A3, ZERO, 0x9D003380
9D003374  ACC30008   SW V1, 8(A2)
9D003378  10000045   BEQ ZERO, ZERO, 0x9D003490
9D00337C  00123FC2   SRL A3, S2, 31
9D003380  8CE30018   LW V1, 24(A3)
9D003384  5460FFFE   BNEL V1, ZERO, 0x9D003380
9D003388  00603825   OR A3, V1, ZERO
9D00338C  24030003   ADDIU V1, ZERO, 3
9D003390  ACE60018   SW A2, 24(A3)
9D003394  ACC7001C   SW A3, 28(A2)
9D003398  ACC30008   SW V1, 8(A2)
9D00339C  92230001   LBU V1, 1(S1)
9D0033A0  14600019   BNE V1, ZERO, 0x9D003408
9D0033A4  00001025   OR V0, ZERO, ZERO
9D0033A8  15800023   BNE T4, ZERO, 0x9D003438
9D0033AC  00000000   NOP
9D0033B0  24020001   ADDIU V0, ZERO, 1
9D0033B8  8FBF0034   LW RA, 52(SP)
9D0033C0  8FB50030   LW S5, 48(SP)
9D0033C4  8FB4002C   LW S4, 44(SP)
9D0033C8  8FB30028   LW S3, 40(SP)
9D0033CC  8FB20024   LW S2, 36(SP)
9D0033D0  8FB10020   LW S1, 32(SP)
9D0033D4  8FB0001C   LW S0, 28(SP)
9D0033D8  03E00008   JR RA
9D0033DC  27BD0038   ADDIU SP, SP, 56
9D0033E0  06430009   BGEZL S2, 0x9D003408
9D0033E4  2402FF83   ADDIU V0, ZERO, -125
9D0033E8  90830001   LBU V1, 1(A0)
9D0033EC  5460000F   BNEL V1, ZERO, 0x9D00342C
9D0033F0  ACC00018   SW ZERO, 24(A2)
9D0033F4  92230030   LBU V1, 48(S1)
9D003404  2402FF81   ADDIU V0, ZERO, -127
9D003408  8FBF0034   LW RA, 52(SP)
9D00340C  8FB50030   LW S5, 48(SP)
9D003410  8FB4002C   LW S4, 44(SP)
9D003414  8FB30028   LW S3, 40(SP)
9D003418  8FB20024   LW S2, 36(SP)
9D00341C  8FB10020   LW S1, 32(SP)
9D003420  8FB0001C   LW S0, 28(SP)
9D003424  03E00008   JR RA
9D003428  27BD0038   ADDIU SP, SP, 56
9D00342C  00408025   OR S0, V0, ZERO
9D003430  1000FFCC   BEQ ZERO, ZERO, 0x9D003364
9D003434  00006025   OR T4, ZERO, ZERO
9D003438  0F40208C   JAL EVIC_SourceEnable
9D00343C  8E240028   LW A0, 40(S1)
9D00344C  0F401E8B   JAL SYS_INT_SourceDisable
9D003454  8FA60010   LW A2, 16(SP)
9D003458  00406025   OR T4, V0, ZERO
9D00345C  00008025   OR S0, ZERO, ZERO
9D003460  0641FFC0   BGEZ S2, 0x9D003364
9D003464  ACC00018   SW ZERO, 24(A2)
9D003468  1000FFBE   BEQ ZERO, ZERO, 0x9D003364
9D00346C  8CD00004   LW S0, 4(A2)
9D003470  8CC40010   LW A0, 16(A2)
9D003474  30850001   ANDI A1, A0, 1
9D003478  10A0FFDC   BEQ A1, ZERO, 0x9D0033EC
9D00347C  00000000   NOP
9D003480  1040FFDA   BEQ V0, ZERO, 0x9D0033EC
9D003484  34840080   ORI A0, A0, 128
9D003488  1000FFD8   BEQ ZERO, ZERO, 0x9D0033EC
9D00348C  ACC40010   SW A0, 16(A2)
9D003490  02872021   ADDU A0, S4, A3
9D003494  24020004   ADDIU V0, ZERO, 4
9D003498  00042100   SLL A0, A0, 4
9D00349C  AE660000   SW A2, 0(S3)
9D0034A0  02602825   OR A1, S3, ZERO
9D0034A4  ACC0001C   SW ZERO, 28(A2)
9D0034A8  ACC20008   SW V0, 8(A2)
9D0034AC  0F4017FB   JAL _DRV_USBFS_DEVICE_EndpointBDTEntryArm
9D0034B0  02A42021   ADDU A0, S5, A0
9D0034B4  1000FFBA   BEQ ZERO, ZERO, 0x9D0033A0
9D0034B8  92230001   LBU V1, 1(S1)
9D0034BC  90830030   LBU V1, 48(A0)
9D0034CC  8E240028   LW A0, 40(S1)
9D0034D4  0F401E8B   JAL SYS_INT_SourceDisable
9D0034D8  AFA60010   SW A2, 16(SP)
9D0034DC  8FA60010   LW A2, 16(SP)
9D0034E0  00406025   OR T4, V0, ZERO
9D0034E4  1000FF9F   BEQ ZERO, ZERO, 0x9D003364
9D0034E8  ACC00018   SW ZERO, 24(A2)
9D0034EC  03E00008   JR RA
9D0034F0  2402FF83   ADDIU V0, ZERO, -125
9D0034F4  1000FFC4   BEQ ZERO, ZERO, 0x9D003408
9D0034F8  2402FF84   ADDIU V0, ZERO, -124
9D0034FC  03E00008   JR RA
9D003500  2402FF85   ADDIU V0, ZERO, -123
9D003504  1000FFC0   BEQ ZERO, ZERO, 0x9D003408
9D003508  2402FF8A   ADDIU V0, ZERO, -118
9D00350C  30A2000C   ANDI V0, A1, 12
9D003510  1440008E   BNE V0, ZERO, 0x9D00374C
9D003514  00000000   NOP
9D003518  2482FFFF   ADDIU V0, A0, -1
9D00351C  2C42FFFE   SLTIU V0, V0, -2
9D003520  1040008C   BEQ V0, ZERO, 0x9D003754
9D003524  00000000   NOP
9D003528  90820001   LBU V0, 1(A0)
9D00352C  27BDFFD0   ADDIU SP, SP, -48
9D003530  AFB1001C   SW S1, 28(SP)
9D003534  AFBF002C   SW RA, 44(SP)
9D003538  AFB40028   SW S4, 40(SP)
9D00353C  AFB30024   SW S3, 36(SP)
9D003540  AFB20020   SW S2, 32(SP)
9D003544  AFB00018   SW S0, 24(SP)
9D003548  10400045   BEQ V0, ZERO, DRV_USBFS_DEVICE_EndpointStall::OSAL_MUTEX_Lock
9D00354C  00808825   OR S1, A0, ZERO
9D003550  00009025   OR S2, ZERO, ZERO
9D003554  30A2000F   ANDI V0, A1, 15
9D003558  8E330034   LW S3, 52(S1)
9D00355C  1440004C   BNE V0, ZERO, 0x9D003690
9D003560  8E23002C   LW V1, 44(S1)
9D003564  8E620010   LW V0, 16(S3)
9D003568  8E700000   LW S0, 0(S3)
9D00356C  2404FF84   ADDIU A0, ZERO, -124
9D003570  000210C0   SLL V0, V0, 3
9D003574  00621021   ADDU V0, V1, V0
9D003578  12000072   BEQ S0, ZERO, 0x9D003744
9D00357C  A0440000   SB A0, 0(V0)
9D003580  2414FFFD   ADDIU S4, ZERO, -3
9D003584  8E02000C   LW V0, 12(S0)
9D003588  02002025   OR A0, S0, ZERO
9D00358C  10400003   BEQ V0, ZERO, 0x9D00359C
9D003590  AE140008   SW S4, 8(S0)
9D003594  0040F809   JALR V0
9D003598  00000000   NOP
9D00359C  8E100018   LW S0, 24(S0)
9D0035A0  5600FFF9   BNEL S0, ZERO, 0x9D003588
9D0035A4  8E02000C   LW V0, 12(S0)
9D0035A8  8E340034   LW S4, 52(S1)
9D0035AC  8E23002C   LW V1, 44(S1)
9D0035B0  8E850028   LW A1, 40(S4)
9D0035B4  8E640014   LW A0, 20(S3)
9D0035B8  26820018   ADDIU V0, S4, 24
9D0035BC  24A50002   ADDIU A1, A1, 2
9D0035C0  34840002   ORI A0, A0, 2
9D0035C4  000528C0   SLL A1, A1, 3
9D0035C8  AE640014   SW A0, 20(S3)
9D0035CC  00651821   ADDU V1, V1, A1
9D0035D0  2404FF84   ADDIU A0, ZERO, -124
9D0035D4  AE600000   SW ZERO, 0(S3)
9D0035D8  1040000E   BEQ V0, ZERO, 0x9D003614
9D0035E0  8E900018   LW S0, 24(S4)
9D0035E4  1200000A   BEQ S0, ZERO, 0x9D003610
9D0035EC  8E02000C   LW V0, 12(S0)
9D0035F0  02002025   OR A0, S0, ZERO
9D0035F4  10400003   BEQ V0, ZERO, 0x9D003604
9D0035FC  0040F809   JALR V0
9D003604  8E100018   LW S0, 24(S0)
9D003608  5600FFF9   BNEL S0, ZERO, 0x9D0035F0
9D003610  AE800018   SW ZERO, 24(S4)
9D003614  8E82002C   LW V0, 44(S4)
9D003618  34420002   ORI V0, V0, 2
9D00361C  AE82002C   SW V0, 44(S4)
9D003620  92230001   LBU V1, 1(S1)
9D003624  14600012   BNE V1, ZERO, 0x9D003670
9D003628  00001025   OR V0, ZERO, ZERO
9D00362C  1640003A   BNE S2, ZERO, 0x9D003718
9D003630  00000000   NOP
9D003634  24020001   ADDIU V0, ZERO, 1
9D003638  A2220030   SB V0, 48(S1)
9D00363C  8FBF002C   LW RA, 44(SP)
9D003644  8FB40028   LW S4, 40(SP)
9D003648  8FB30024   LW S3, 36(SP)
9D00364C  8FB20020   LW S2, 32(SP)
9D003650  8FB1001C   LW S1, 28(SP)
9D003654  8FB00018   LW S0, 24(SP)
9D003658  03E00008   JR RA
9D00365C  27BD0030   ADDIU SP, SP, 48
9D003660  90840030   LBU A0, 48(A0)
9D003670  8FBF002C   LW RA, 44(SP)
9D003674  8FB40028   LW S4, 40(SP)
9D003678  8FB30024   LW S3, 36(SP)
9D00367C  8FB20020   LW S2, 32(SP)
9D003680  8FB1001C   LW S1, 28(SP)
9D003684  8FB00018   LW S0, 24(SP)
9D003688  03E00008   JR RA
9D00368C  27BD0030   ADDIU SP, SP, 48
9D003690  7C052C20   SEB A1, A1
9D003694  00023040   SLL A2, V0, 1
9D003698  28A40000   SLTI A0, A1, 0
9D00369C  00C21021   ADDU V0, A2, V0
9D0036A0  00052FC2   SRL A1, A1, 31
9D0036A4  24070018   ADDIU A3, ZERO, 24
9D0036A8  00021100   SLL V0, V0, 4
9D0036AC  0004380A   MOVZ A3, ZERO, A0
9D0036B0  00A62821   ADDU A1, A1, A2
9D0036B4  00471021   ADDU V0, V0, A3
9D0036B8  00052900   SLL A1, A1, 4
9D0036BC  00652821   ADDU A1, V1, A1
9D0036C0  02629821   ADDU S3, S3, V0
9D0036C4  2403FF84   ADDIU V1, ZERO, -124
9D0036C8  A0A30000   SB V1, 0(A1)
9D0036CC  1260000E   BEQ S3, ZERO, 0x9D003708
9D0036D4  8E700000   LW S0, 0(S3)
9D0036D8  1200000A   BEQ S0, ZERO, 0x9D003704
9D0036E0  8E02000C   LW V0, 12(S0)
9D0036E4  02002025   OR A0, S0, ZERO
9D0036E8  10400003   BEQ V0, ZERO, 0x9D0036F8
9D0036F0  0040F809   JALR V0
9D0036F8  8E100018   LW S0, 24(S0)
9D0036FC  5600FFF9   BNEL S0, ZERO, 0x9D0036E4
9D003704  AE600000   SW ZERO, 0(S3)
9D003708  8E620014   LW V0, 20(S3)
9D00370C  34420002   ORI V0, V0, 2
9D003710  1000FFC3   BEQ ZERO, ZERO, 0x9D003620
9D003714  AE620014   SW V0, 20(S3)
9D003718  0F40208C   JAL EVIC_SourceEnable
9D00371C  8E240028   LW A0, 40(S1)
9D003728  8E240028   LW A0, 40(S1)
9D003730  0F401E8B   JAL SYS_INT_SourceDisable
9D003734  AFA50010   SW A1, 16(SP)
9D003738  00409025   OR S2, V0, ZERO
9D00373C  1000FF85   BEQ ZERO, ZERO, 0x9D003554
9D003740  8FA50010   LW A1, 16(SP)
9D003744  1000FF9A   BEQ ZERO, ZERO, 0x9D0035B0
9D003748  0260A025   OR S4, S3, ZERO
9D00374C  03E00008   JR RA
9D003750  2402FF84   ADDIU V0, ZERO, -124
9D003754  03E00008   JR RA
9D003758  2402FF83   ADDIU V0, ZERO, -125
9D003D78  30A2000C   ANDI V0, A1, 12
9D003D7C  14400071   BNE V0, ZERO, 0x9D003F44
9D003D80  00000000   NOP
9D003D84  2482FFFF   ADDIU V0, A0, -1
9D003D88  2C42FFFE   SLTIU V0, V0, -2
9D003D8C  1040006F   BEQ V0, ZERO, 0x9D003F4C
9D003D90  00000000   NOP
9D003D94  90820001   LBU V0, 1(A0)
9D003D98  27BDFFD0   ADDIU SP, SP, -48
9D003D9C  AFB40028   SW S4, 40(SP)
9D003DA0  AFB1001C   SW S1, 28(SP)
9D003DA4  AFB00018   SW S0, 24(SP)
9D003DA8  AFBF002C   SW RA, 44(SP)
9D003DAC  AFB30024   SW S3, 36(SP)
9D003DB0  AFB20020   SW S2, 32(SP)
9D003DB4  00808825   OR S1, A0, ZERO
9D003DB8  8C940020   LW S4, 32(A0)
9D003DBC  1040001B   BEQ V0, ZERO, DRV_USBFS_DEVICE_EndpointStallClear::OSAL_MUTEX_Lock
9D003DC0  8C900034   LW S0, 52(A0)
9D003DC4  00009025   OR S2, ZERO, ZERO
9D003DC8  30A2000F   ANDI V0, A1, 15
9D003DCC  00022040   SLL A0, V0, 1
9D003DD0  7C052C20   SEB A1, A1
9D003DD4  28B30000   SLTI S3, A1, 0
9D003DD8  00821821   ADDU V1, A0, V0
9D003DDC  24060018   ADDIU A2, ZERO, 24
9D003DE0  0013300A   MOVZ A2, ZERO, S3
9D003DE4  00031900   SLL V1, V1, 4
9D003DE8  00661821   ADDU V1, V1, A2
9D003DEC  02039821   ADDU S3, S0, V1
9D003DF0  8E660014   LW A2, 20(S3)
9D003DF4  8E23002C   LW V1, 44(S1)
9D003DF8  14400018   BNE V0, ZERO, DRV_USBFS_DEVICE_EndpointStallClear::PLIB_USB_EPnStallClear
9D003DFC  7C060844   INS A2, ZERO, 1, 1
9D003E00  8E640010   LW A0, 16(S3)
9D003E04  00051183   SRA V0, A1, 6
9D003E08  30420002   ANDI V0, V0, 2
9D003E0C  00441021   ADDU V0, V0, A0
9D003E10  000210C0   SLL V0, V0, 3
9D003E14  00621821   ADDU V1, V1, V0
9D003E18  04A0003B   BLTZ A1, 0x9D003F08
9D003E1C  A0600000   SB ZERO, 0(V1)
9D003E20  AE60000C   SW ZERO, 12(S3)
9D003E24  10000028   BEQ ZERO, ZERO, 0x9D003EC8
9D003E28  AE660014   SW A2, 20(S3)
9D003E2C  90840030   LBU A0, 48(A0)
9D003E3C  8FBF002C   LW RA, 44(SP)
9D003E50  8FB00018   LW S0, 24(SP)
9D003E54  03E00008   JR RA
9D003E58  27BD0030   ADDIU SP, SP, 48
9D003E5C  2442002C   ADDIU V0, V0, 44
9D003E60  00021100   SLL V0, V0, 4
9D003E64  02821021   ADDU V0, S4, V0
9D003E68  90470000   LBU A3, 0(V0)
9D003E6C  00052FC2   SRL A1, A1, 31
9D003E70  8E700000   LW S0, 0(S3)
9D003E74  00A42821   ADDU A1, A1, A0
9D003E78  00052900   SLL A1, A1, 4
9D003E7C  00652821   ADDU A1, V1, A1
9D003E84  A0A00000   SB ZERO, 0(A1)
9D003E88  A0A00008   SB ZERO, 8(A1)
9D003E8C  2414FFFC   ADDIU S4, ZERO, -4
9D003E90  A0470000   SB A3, 0(V0)
9D003E94  AE60000C   SW ZERO, 12(S3)
9D003E98  1200000A   BEQ S0, ZERO, 0x9D003EC4
9D003E9C  AE660014   SW A2, 20(S3)
9D003EA0  8E02000C   LW V0, 12(S0)
9D003EA4  02002025   OR A0, S0, ZERO
9D003EA8  10400003   BEQ V0, ZERO, 0x9D003EB8
9D003EAC  AE140008   SW S4, 8(S0)
9D003EB0  0040F809   JALR V0
9D003EB4  00000000   NOP
9D003EB8  8E100018   LW S0, 24(S0)
9D003EBC  5600FFF9   BNEL S0, ZERO, 0x9D003EA4
9D003EC0  8E02000C   LW V0, 12(S0)
9D003EC4  AE600000   SW ZERO, 0(S3)
9D003EC8  92230001   LBU V1, 1(S1)
9D003ECC  1460FFDB   BNE V1, ZERO, 0x9D003E3C
9D003ED0  00001025   OR V0, ZERO, ZERO
9D003ED4  16400010   BNE S2, ZERO, 0x9D003F18
9D003ED8  00000000   NOP
9D003EDC  24020001   ADDIU V0, ZERO, 1
9D003EE0  A2220030   SB V0, 48(S1)
9D003EE4  8FBF002C   LW RA, 44(SP)
9D003EEC  8FB40028   LW S4, 40(SP)
9D003EF0  8FB30024   LW S3, 36(SP)
9D003EF4  8FB20020   LW S2, 32(SP)
9D003EF8  8FB1001C   LW S1, 28(SP)
9D003EFC  8FB00018   LW S0, 24(SP)
9D003F00  03E00008   JR RA
9D003F04  27BD0030   ADDIU SP, SP, 48
9D003F08  24020001   ADDIU V0, ZERO, 1
9D003F0C  AE62000C   SW V0, 12(S3)
9D003F10  1000FFED   BEQ ZERO, ZERO, 0x9D003EC8
9D003F14  AE660014   SW A2, 20(S3)
9D003F18  0F40208C   JAL EVIC_SourceEnable
9D003F1C  8E240028   LW A0, 40(S1)
9D003F28  8E240028   LW A0, 40(S1)
9D003F30  0F401E8B   JAL SYS_INT_SourceDisable
9D003F34  AFA50010   SW A1, 16(SP)
9D003F38  00409025   OR S2, V0, ZERO
9D003F3C  1000FFA2   BEQ ZERO, ZERO, 0x9D003DC8
9D003F40  8FA50010   LW A1, 16(SP)
9D003F44  03E00008   JR RA
9D003F48  2402FF84   ADDIU V0, ZERO, -124
9D003F4C  03E00008   JR RA
9D003F50  2402FF83   ADDIU V0, ZERO, -125
9D004304  30A2000C   ANDI V0, A1, 12
9D004308  1440006B   BNE V0, ZERO, 0x9D0044B8
9D00430C  30A8000F   ANDI T0, A1, 15
9D004310  2489FFFF   ADDIU T1, A0, -1
9D004314  2D29FFFE   SLTIU T1, T1, -2
9D004318  11200069   BEQ T1, ZERO, 0x9D0044C0
9D00431C  00084840   SLL T1, T0, 1
9D004320  8C83002C   LW V1, 44(A0)
9D004324  8C8A0034   LW T2, 52(A0)
9D004328  01284821   ADDU T1, T1, T0
9D00432C  00094900   SLL T1, T1, 4
9D004330  00081140   SLL V0, T0, 5
9D004334  00621021   ADDU V0, V1, V0
9D004338  01491821   ADDU V1, T2, T1
9D00433C  240A0001   ADDIU T2, ZERO, 1
9D004340  010A5004   SLLV T2, T2, T0
9D004344  10C00027   BEQ A2, ZERO, 0x9D0043E4
9D004348  8C890020   LW T1, 32(A0)
9D00434C  00084100   SLL T0, T0, 4
9D004350  01284021   ADDU T0, T1, T0
9D004354  7C052C20   SEB A1, A1
9D004358  8D0D02C0   LW T5, 704(T0)
9D00435C  000577C2   SRL T6, A1, 31
9D004360  38CC0001   XORI T4, A2, 1
9D004368  000558C3   SRA T3, A1, 3
9D004370  000C602B   SLTU T4, ZERO, T4
9D004374  316B0010   ANDI T3, T3, 16
9D00437C  004B1021   ADDU V0, V0, T3
9D004380  012D4825   OR T1, T1, T5
9D004384  AC400000   SW ZERO, 0(V0)
9D004388  AC400004   SW ZERO, 4(V0)
9D00438C  AC400008   SW ZERO, 8(V0)
9D004390  AC40000C   SW ZERO, 12(V0)
9D004394  AD0902C0   SW T1, 704(T0)
9D004398  04A20037   BLTZL A1, 0x9D004478
9D00439C  8C82001C   LW V0, 28(A0)
9D0043A0  8C820018   LW V0, 24(A0)
9D0043A4  24040018   ADDIU A0, ZERO, 24
9D0043A8  01425024   AND T2, T2, V0
9D0043AC  28A20000   SLTI V0, A1, 0
9D0043B0  0002200A   MOVZ A0, ZERO, V0
9D0043B4  00641821   ADDU V1, V1, A0
9D0043B8  8C620014   LW V0, 20(V1)
9D0043BC  000A502B   SLTU T2, ZERO, T2
9D0043C0  AC60000C   SW ZERO, 12(V1)
9D0043C4  34420001   ORI V0, V0, 1
9D0043C8  AC620014   SW V0, 20(V1)
9D0043CC  AC600000   SW ZERO, 0(V1)
9D0043D0  A4670004   SH A3, 4(V1)
9D0043D4  AC6A0010   SW T2, 16(V1)
9D0043D8  AC660008   SW A2, 8(V1)
9D0043DC  03E00008   JR RA
9D0043E0  00001025   OR V0, ZERO, ZERO
9D0043E4  2445001C   ADDIU A1, V0, 28
9D0043E8  AC400000   SW ZERO, 0(V0)
9D0043EC  24420004   ADDIU V0, V0, 4
9D0043F0  54A2FFFE   BNEL A1, V0, 0x9D0043EC
9D0043F4  AC400000   SW ZERO, 0(V0)
9D0043F8  00084100   SLL T0, T0, 4
9D004404  8C82001C   LW V0, 28(A0)
9D004408  8C850018   LW A1, 24(A0)
9D004418  8C690014   LW T1, 20(V1)
9D00441C  8C66002C   LW A2, 44(V1)
9D004420  01452024   AND A0, T2, A1
9D004424  01425024   AND T2, T2, V0
9D004428  0004202B   SLTU A0, ZERO, A0
9D004430  35290001   ORI T1, T1, 1
9D004434  000A502B   SLTU T2, ZERO, T2
9D004438  34C50001   ORI A1, A2, 1
9D004440  00001025   OR V0, ZERO, ZERO
9D004444  AC60000C   SW ZERO, 12(V1)
9D004448  AC600000   SW ZERO, 0(V1)
9D00444C  A4670004   SH A3, 4(V1)
9D004450  AC640010   SW A0, 16(V1)
9D004454  AC600008   SW ZERO, 8(V1)
9D004458  AC690014   SW T1, 20(V1)
9D00445C  AC600024   SW ZERO, 36(V1)
9D004460  AC600018   SW ZERO, 24(V1)
9D004464  A467001C   SH A3, 28(V1)
9D004468  AC6A0028   SW T2, 40(V1)
9D00446C  AC600020   SW ZERO, 32(V1)
9D004470  03E00008   JR RA
9D004474  AC65002C   SW A1, 44(V1)
9D004478  24040018   ADDIU A0, ZERO, 24
9D00447C  01425024   AND T2, T2, V0
9D004480  28A20000   SLTI V0, A1, 0
9D004484  0002200A   MOVZ A0, ZERO, V0
9D004488  00641821   ADDU V1, V1, A0
9D00448C  8C620014   LW V0, 20(V1)
9D004490  000A502B   SLTU T2, ZERO, T2
9D004494  AC60000C   SW ZERO, 12(V1)
9D004498  34420001   ORI V0, V0, 1
9D00449C  AC620014   SW V0, 20(V1)
9D0044A0  AC600000   SW ZERO, 0(V1)
9D0044A4  A4670004   SH A3, 4(V1)
9D0044A8  AC6A0010   SW T2, 16(V1)
9D0044AC  AC660008   SW A2, 8(V1)
9D0044B0  03E00008   JR RA
9D0044B4  00001025   OR V0, ZERO, ZERO
9D0044B8  03E00008   JR RA
9D0044BC  2402FF84   ADDIU V0, ZERO, -124
9D0044C0  03E00008   JR RA
9D0044C4  2402FF83   ADDIU V0, ZERO, -125
9D0044C8  30A2000C   ANDI V0, A1, 12
9D0044CC  14400060   BNE V0, ZERO, 0x9D004650
9D0044D0  00000000   NOP
9D0044D4  2482FFFF   ADDIU V0, A0, -1
9D0044D8  2C42FFFE   SLTIU V0, V0, -2
9D0044DC  1040005E   BEQ V0, ZERO, 0x9D004658
9D0044E0  00000000   NOP
9D0044E4  90820001   LBU V0, 1(A0)
9D0044E8  27BDFFD0   ADDIU SP, SP, -48
9D0044EC  AFB40028   SW S4, 40(SP)
9D0044F0  AFB30024   SW S3, 36(SP)
9D0044F4  AFB1001C   SW S1, 28(SP)
9D0044F8  AFBF002C   SW RA, 44(SP)
9D0044FC  AFB20020   SW S2, 32(SP)
9D004500  AFB00018   SW S0, 24(SP)
9D004504  00808825   OR S1, A0, ZERO
9D004508  8C930034   LW S3, 52(A0)
9D00450C  10400036   BEQ V0, ZERO, DRV_USBFS_DEVICE_IRPCancelAll::OSAL_MUTEX_Lock
9D004510  8C94002C   LW S4, 44(A0)
9D004514  00009025   OR S2, ZERO, ZERO
9D004518  30A2000F   ANDI V0, A1, 15
9D00451C  00022040   SLL A0, V0, 1
9D004520  7C052C20   SEB A1, A1
9D004524  28A30000   SLTI V1, A1, 0
9D004528  00821021   ADDU V0, A0, V0
9D00452C  24060018   ADDIU A2, ZERO, 24
9D004530  00021100   SLL V0, V0, 4
9D004534  0003300A   MOVZ A2, ZERO, V1
9D004538  00461021   ADDU V0, V0, A2
9D00453C  02629821   ADDU S3, S3, V0
9D004540  00052FC2   SRL A1, A1, 31
9D004544  8E700000   LW S0, 0(S3)
9D004548  00A42821   ADDU A1, A1, A0
9D00454C  00052900   SLL A1, A1, 4
9D004550  12000035   BEQ S0, ZERO, 0x9D004628
9D004554  02852821   ADDU A1, S4, A1
9D004558  8E030008   LW V1, 8(S0)
9D00455C  24020004   ADDIU V0, ZERO, 4
9D004560  54620005   BNEL V1, V0, 0x9D004578
9D004564  A0A00000   SB ZERO, 0(A1)
9D004568  8E620010   LW V0, 16(S3)
9D00456C  38420001   XORI V0, V0, 1
9D004570  AE620010   SW V0, 16(S3)
9D004574  A0A00000   SB ZERO, 0(A1)
9D004578  A0A00008   SB ZERO, 8(A1)
9D00457C  2414FFFE   ADDIU S4, ZERO, -2
9D004580  8E02000C   LW V0, 12(S0)
9D004584  02002025   OR A0, S0, ZERO
9D004588  10400003   BEQ V0, ZERO, 0x9D004598
9D00458C  AE140008   SW S4, 8(S0)
9D004590  0040F809   JALR V0
9D004594  00000000   NOP
9D004598  8E100018   LW S0, 24(S0)
9D00459C  5600FFF9   BNEL S0, ZERO, 0x9D004584
9D0045A0  8E02000C   LW V0, 12(S0)
9D0045A4  92230001   LBU V1, 1(S1)
9D0045A8  00001025   OR V0, ZERO, ZERO
9D0045AC  14600012   BNE V1, ZERO, 0x9D0045F8
9D0045B0  AE600000   SW ZERO, 0(S3)
9D0045B4  16400018   BNE S2, ZERO, 0x9D004618
9D0045B8  00000000   NOP
9D0045BC  24020001   ADDIU V0, ZERO, 1
9D0045C0  A2220030   SB V0, 48(S1)
9D0045C4  8FBF002C   LW RA, 44(SP)
9D0045CC  8FB40028   LW S4, 40(SP)
9D0045D0  8FB30024   LW S3, 36(SP)
9D0045D4  8FB20020   LW S2, 32(SP)
9D0045D8  8FB1001C   LW S1, 28(SP)
9D0045DC  8FB00018   LW S0, 24(SP)
9D0045E0  03E00008   JR RA
9D0045E4  27BD0030   ADDIU SP, SP, 48
9D0045E8  90840030   LBU A0, 48(A0)
9D0045F8  8FBF002C   LW RA, 44(SP)
9D0045FC  8FB40028   LW S4, 40(SP)
9D004600  8FB30024   LW S3, 36(SP)
9D004604  8FB20020   LW S2, 32(SP)
9D004608  8FB1001C   LW S1, 28(SP)
9D00460C  8FB00018   LW S0, 24(SP)
9D004610  03E00008   JR RA
9D004614  27BD0030   ADDIU SP, SP, 48
9D004618  0F40208C   JAL EVIC_SourceEnable
9D00461C  8E240028   LW A0, 40(S1)
9D004628  A0A00000   SB ZERO, 0(A1)
9D00462C  1000FFDD   BEQ ZERO, ZERO, 0x9D0045A4
9D004630  A0A00008   SB ZERO, 8(A1)
9D004634  8E240028   LW A0, 40(S1)
9D00463C  0F401E8B   JAL SYS_INT_SourceDisable
9D004640  AFA50010   SW A1, 16(SP)
9D004644  00409025   OR S2, V0, ZERO
9D004648  1000FFB3   BEQ ZERO, ZERO, 0x9D004518
9D00464C  8FA50010   LW A1, 16(SP)
9D004650  03E00008   JR RA
9D004654  2402FF84   ADDIU V0, ZERO, -124
9D004658  03E00008   JR RA
9D00465C  2402FF83   ADDIU V0, ZERO, -125
9D0058B8  2482FFFF   ADDIU V0, A0, -1
9D0058BC  2C42FFFE   SLTIU V0, V0, -2
9D0058C0  10400040   BEQ V0, ZERO, 0x9D0059C4
9D0058C4  24030010   ADDIU V1, ZERO, 16
9D0058C8  8C880020   LW T0, 32(A0)
9D0058CC  10A30027   BEQ A1, V1, 0x9D00596C
9D0058D0  8C820034   LW V0, 52(A0)
9D0058D4  30A3000C   ANDI V1, A1, 12
9D0058D8  30A4000F   ANDI A0, A1, 15
9D0058DC  1460003B   BNE V1, ZERO, 0x9D0059CC
9D0058E0  000529C2   SRL A1, A1, 7
9D0058E4  00041840   SLL V1, A0, 1
9D0058E8  00653021   ADDU A2, V1, A1
9D0058EC  00061840   SLL V1, A2, 1
9D0058F0  00661821   ADDU V1, V1, A2
9D0058F4  000318C0   SLL V1, V1, 3
9D0058F8  00431821   ADDU V1, V0, V1
9D0058FC  8C660014   LW A2, 20(V1)
9D005900  8C620008   LW V0, 8(V1)
9D005904  00042100   SLL A0, A0, 4
9D005908  7C060004   INS A2, ZERO, 0, 1
9D00590C  1440000E   BNE V0, ZERO, DRV_USBFS_DEVICE_EndpointDisable::PLIB_USB_EPnDirectionDisable
9D005910  01042021   ADDU A0, T0, A0
9D005914  8C8202C0   LW V0, 704(A0)
9D005918  8C65002C   LW A1, 44(V1)
9D00592C  7C050004   INS A1, ZERO, 0, 1
9D005930  00001025   OR V0, ZERO, ZERO
9D00593C  AC660014   SW A2, 20(V1)
9D005940  03E00008   JR RA
9D005944  AC65002C   SW A1, 44(V1)
9D005948  8C8702C0   LW A3, 704(A0)
9D005960  00001025   OR V0, ZERO, ZERO
9D005964  03E00008   JR RA
9D005968  AC660014   SW A2, 20(V1)
9D00596C  00002025   OR A0, ZERO, ZERO
9D005974  24090004   ADDIU T1, ZERO, 4
9D005978  00041900   SLL V1, A0, 4
9D005984  8C460014   LW A2, 20(V0)
9D005988  8C45002C   LW A1, 44(V0)
9D00599C  7C060004   INS A2, ZERO, 0, 1
9D0059A0  7C050004   INS A1, ZERO, 0, 1
9D0059A8  24840001   ADDIU A0, A0, 1
9D0059B0  AC46FFE4   SW A2, -28(V0)
9D0059B4  1489FFF0   BNE A0, T1, DRV_USBFS_DEVICE_EndpointDisable::PLIB_USB_EPnAttributesClear
9D0059B8  AC45FFFC   SW A1, -4(V0)
9D0059BC  03E00008   JR RA
9D0059C0  00001025   OR V0, ZERO, ZERO
9D0059C4  03E00008   JR RA
9D0059C8  2402FF83   ADDIU V0, ZERO, -125
9D0059CC  03E00008   JR RA
9D0059D0  2402FF84   ADDIU V0, ZERO, -124
9D005AEC  2482FFFF   ADDIU V0, A0, -1
9D005AF0  2C42FFFE   SLTIU V0, V0, -2
9D005AF4  10400040   BEQ V0, ZERO, 0x9D005BF8
9D005AF8  00000000   NOP
9D005AFC  10A0003E   BEQ A1, ZERO, 0x9D005BF8
9D005B00  00000000   NOP
9D005B04  8CA20008   LW V0, 8(A1)
9D005B08  28420003   SLTI V0, V0, 3
9D005B0C  1440003A   BNE V0, ZERO, 0x9D005BF8
9D005B10  00000000   NOP
9D005B14  90820001   LBU V0, 1(A0)
9D005B18  27BDFFD8   ADDIU SP, SP, -40
9D005B1C  AFB1001C   SW S1, 28(SP)
9D005B20  AFBF0024   SW RA, 36(SP)
9D005B24  AFB20020   SW S2, 32(SP)
9D005B28  1040001F   BEQ V0, ZERO, DRV_USBFS_DEVICE_IRPCancel::OSAL_MUTEX_Lock
9D005B2C  00808825   OR S1, A0, ZERO
9D005B30  00009025   OR S2, ZERO, ZERO
9D005B34  8CA3001C   LW V1, 28(A1)
9D005B38  2404FFFE   ADDIU A0, ZERO, -2
9D005B3C  ACA40008   SW A0, 8(A1)
9D005B40  1060000C   BEQ V1, ZERO, 0x9D005B74
9D005B44  ACA00004   SW ZERO, 4(A1)
9D005B48  8CA20018   LW V0, 24(A1)
9D005B4C  AC620018   SW V0, 24(V1)
9D005B50  8CA40018   LW A0, 24(A1)
9D005B54  54800001   BNEL A0, ZERO, 0x9D005B5C
9D005B58  AC83001C   SW V1, 28(A0)
9D005B5C  8CA3000C   LW V1, 12(A1)
9D005B60  ACA0001C   SW ZERO, 28(A1)
9D005B64  10600003   BEQ V1, ZERO, 0x9D005B74
9D005B68  ACA00018   SW ZERO, 24(A1)
9D005B6C  0060F809   JALR V1
9D005B70  00A02025   OR A0, A1, ZERO
9D005B74  92230001   LBU V1, 1(S1)
9D005B78  1460000F   BNE V1, ZERO, 0x9D005BB8
9D005B7C  00001025   OR V0, ZERO, ZERO
9D005B80  16400012   BNE S2, ZERO, 0x9D005BCC
9D005B84  00000000   NOP
9D005B88  24020001   ADDIU V0, ZERO, 1
9D005B90  8FBF0024   LW RA, 36(SP)
9D005B98  8FB20020   LW S2, 32(SP)
9D005B9C  8FB1001C   LW S1, 28(SP)
9D005BA0  03E00008   JR RA
9D005BA4  27BD0028   ADDIU SP, SP, 40
9D005BA8  90840030   LBU A0, 48(A0)
9D005BB8  8FBF0024   LW RA, 36(SP)
9D005BC4  03E00008   JR RA
9D005BC8  27BD0028   ADDIU SP, SP, 40
9D005BCC  0F40208C   JAL EVIC_SourceEnable
9D005BD0  8E240028   LW A0, 40(S1)
9D005BDC  8E240028   LW A0, 40(S1)
9D005BE4  0F401E8B   JAL SYS_INT_SourceDisable
9D005BE8  AFA50010   SW A1, 16(SP)
9D005BEC  00409025   OR S2, V0, ZERO
9D005BF0  1000FFD0   BEQ ZERO, ZERO, 0x9D005B34
9D005BF4  8FA50010   LW A1, 16(SP)
9D005BF8  03E00008   JR RA
9D005BFC  2402FF83   ADDIU V0, ZERO, -125
9D005FEC  8CA80010   LW T0, 16(A1)
9D005FF0  8CCA0020   LW T2, 32(A2)
9D005FF4  8CC30004   LW V1, 4(A2)
9D005FF8  000810C0   SLL V0, T0, 3
9D005FFC  240B0001   ADDIU T3, ZERO, 1
9D006000  00822021   ADDU A0, A0, V0
9D006004  006A4823   SUBU T1, V1, T2
9D006008  10EB0015   BEQ A3, T3, 0x9D006060
9D00600C  8CC20000   LW V0, 0(A2)
9D006010  94A60004   LHU A2, 4(A1)
9D006014  004A1021   ADDU V0, V0, T2
9D006018  7C42E000   EXT V0, V0, 0, 29
9D00601C  0126182B   SLTU V1, T1, A2
9D006020  00C3480A   MOVZ T1, A2, V1
9D006024  8CA6000C   LW A2, 12(A1)
9D006028  AC820004   SW V0, 4(A0)
9D00602C  00001025   OR V0, ZERO, ZERO
9D006030  00063980   SLL A3, A2, 6
9D006034  00471025   OR V0, V0, A3
9D006038  2407FF80   ADDIU A3, ZERO, -128
9D00603C  3123FFFF   ANDI V1, T1, -1
9D006040  39080001   XORI T0, T0, 1
9D006044  00471025   OR V0, V0, A3
9D006048  38C60001   XORI A2, A2, 1
9D00604C  A4830002   SH V1, 2(A0)
9D006050  A0820000   SB V0, 0(A0)
9D006054  ACA80010   SW T0, 16(A1)
9D006058  03E00008   JR RA
9D00605C  ACA6000C   SW A2, 12(A1)
9D006060  00491821   ADDU V1, V0, T1
9D006064  7C63E000   EXT V1, V1, 0, 29
9D006068  AC830004   SW V1, 4(A0)
9D00606C  1540000F   BNE T2, ZERO, 0x9D0060AC
9D006070  00001825   OR V1, ZERO, ZERO
9D006074  ACCA0020   SW T2, 32(A2)
9D006078  24020008   ADDIU V0, ZERO, 8
9D00607C  8CA6000C   LW A2, 12(A1)
9D006080  39080001   XORI T0, T0, 1
9D006084  A4830002   SH V1, 2(A0)
9D006088  00063980   SLL A3, A2, 6
9D00608C  00471025   OR V0, V0, A3
9D006090  2407FF80   ADDIU A3, ZERO, -128
9D006094  00471025   OR V0, V0, A3
9D006098  38C60001   XORI A2, A2, 1
9D00609C  A0820000   SB V0, 0(A0)
9D0060A0  ACA80010   SW T0, 16(A1)
9D0060A4  03E00008   JR RA
9D0060A8  ACA6000C   SW A2, 12(A1)
9D0060AC  94A30004   LHU V1, 4(A1)
9D0060B0  0143102B   SLTU V0, T2, V1
9D0060B4  0142180B   MOVN V1, T2, V0
9D0060B8  00601025   OR V0, V1, ZERO
9D0060BC  01425023   SUBU T2, T2, V0
9D0060C0  3063FFFF   ANDI V1, V1, -1
9D0060C4  ACCA0020   SW T2, 32(A2)
9D0060C8  1000FFEC   BEQ ZERO, ZERO, 0x9D00607C
9D0060CC  24020008   ADDIU V0, ZERO, 8
9D0072DC  2482FFFF   ADDIU V0, A0, -1
9D0072E0  2C42FFFE   SLTIU V0, V0, -2
9D0072E4  1040001A   BEQ V0, ZERO, DRV_USBFS_DEVICE_Detach
9D0072E8  240500FF   ADDIU A1, ZERO, 255
9D0072EC  8C820020   LW V0, 32(A0)
9D0072F0  A0800003   SB ZERO, 3(A0)
9D0072F4  AC4501C0   SW A1, 448(V0)
9D0072F8  8C4301D0   LW V1, 464(V0)
9D007308  AC4501E0   SW A1, 480(V0)
9D00730C  8C4301F0   LW V1, 496(V0)
9D007318  240300F5   ADDIU V1, ZERO, 245
9D007320  8C430010   LW V1, 16(V0)
9D00732C  90430210   LBU V1, 528(V0)
9D007350  03E00008   JR RA
9D007354  00000000   NOP
9D007448  2482FFFF   ADDIU V0, A0, -1
9D00744C  2C42FFFE   SLTIU V0, V0, -2
9D007450  10400016   BEQ V0, ZERO, DRV_USBFS_DEVICE_Attach
9D007454  24030001   ADDIU V1, ZERO, 1
9D007458  8C820020   LW V0, 32(A0)
9D00745C  A0830003   SB V1, 3(A0)
9D007460  90430210   LBU V1, 528(V0)
9D007494  240300DF   ADDIU V1, ZERO, 223
9D0074AC  03E00008   JR RA
9D0074B0  00000000   NOP
9D00798C  2483FFFF   ADDIU V1, A0, -1
9D007990  2C63FFFE   SLTIU V1, V1, -2
9D007994  1060000F   BEQ V1, ZERO, 0x9D0079D4
9D007998  00001025   OR V0, ZERO, ZERO
9D00799C  30A3000C   ANDI V1, A1, 12
9D0079A0  1460000C   BNE V1, ZERO, 0x9D0079D4
9D0079A4  30A6000F   ANDI A2, A1, 15
9D0079A8  8C820034   LW V0, 52(A0)
9D0079AC  00061840   SLL V1, A2, 1
9D0079B0  00661821   ADDU V1, V1, A2
9D0079B4  000529C2   SRL A1, A1, 7
9D0079B8  00031900   SLL V1, V1, 4
9D0079BC  24040018   ADDIU A0, ZERO, 24
9D0079C0  00431021   ADDU V0, V0, V1
9D0079C4  0005200A   MOVZ A0, ZERO, A1
9D0079C8  00442821   ADDU A1, V0, A0
9D0079CC  8CA20014   LW V0, 20(A1)
9D0079D0  30420001   ANDI V0, V0, 1
9D0079D4  03E00008   JR RA
9D0079D8  00000000   NOP
9D0079DC  2483FFFF   ADDIU V1, A0, -1
9D0079E0  2C63FFFE   SLTIU V1, V1, -2
9D0079E4  1060000F   BEQ V1, ZERO, 0x9D007A24
9D0079E8  00001025   OR V0, ZERO, ZERO
9D0079EC  30A3000C   ANDI V1, A1, 12
9D0079F0  1460000C   BNE V1, ZERO, 0x9D007A24
9D0079F4  30A6000F   ANDI A2, A1, 15
9D0079F8  8C820034   LW V0, 52(A0)
9D0079FC  00061840   SLL V1, A2, 1
9D007A00  00661821   ADDU V1, V1, A2
9D007A04  000529C2   SRL A1, A1, 7
9D007A08  00031900   SLL V1, V1, 4
9D007A0C  24040018   ADDIU A0, ZERO, 24
9D007A10  00431021   ADDU V0, V0, V1
9D007A14  0005200A   MOVZ A0, ZERO, A1
9D007A18  00442821   ADDU A1, V0, A0
9D007A1C  8CA20014   LW V0, 20(A1)
9D007A20  7C420040   EXT V0, V0, 1, 1
9D007A24  03E00008   JR RA
9D007A28  00000000   NOP
9D00801C  2483FFFF   ADDIU V1, A0, -1
9D008020  2C63FFFE   SLTIU V1, V1, -2
9D008024  10600007   BEQ V1, ZERO, DRV_USBFS_DEVICE_SOFNumberGet
9D008028  00001025   OR V0, ZERO, ZERO
9D00802C  8C830020   LW V1, 32(A0)
9D008044  03E00008   JR RA
9D008048  00000000   NOP
9D008190  2482FFFF   ADDIU V0, A0, -1
9D008194  2C42FFFE   SLTIU V0, V0, -2
9D008198  10400005   BEQ V0, ZERO, 0x9D0081B0
9D00819C  00000000   NOP
9D0081A0  8C820020   LW V0, 32(A0)
9D0081B0  03E00008   JR RA
9D0081B4  00000000   NOP
9D0081B8  2482FFFF   ADDIU V0, A0, -1
9D0081BC  2C42FFFE   SLTIU V0, V0, -2
9D0081C0  10400005   BEQ V0, ZERO, DRV_USBFS_DEVICE_RemoteWakeupStart
9D0081C4  00000000   NOP
9D0081C8  8C830020   LW V1, 32(A0)
9D0081D8  03E00008   JR RA
9D0081DC  00000000   NOP
9D0081E0  2482FFFF   ADDIU V0, A0, -1
9D0081E4  2C42FFFE   SLTIU V0, V0, -2
9D0081E8  10400005   BEQ V0, ZERO, DRV_USBFS_DEVICE_RemoteWakeupStop
9D0081EC  00000000   NOP
9D0081F0  8C830020   LW V1, 32(A0)
9D008200  03E00008   JR RA
9D008208  8C820020   LW V0, 32(A0)
9D008210  A4800002   SH ZERO, 2(A0)
9D008214  A0800004   SB ZERO, 4(A0)
9D008218  AC4301D0   SW V1, 464(V0)
9D008228  03E00008   JR RA
9D00822C  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/drv_usbfs.c  ----------
1:                   /*******************************************************************************
2:                     USB Controller Driver Core Routines.
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_usbfs.c
9:                   
10:                    Summary:
11:                      USB Controller Driver Core Routines intended for Dynamic implementation.
12:                  
13:                    Description:
14:                      The USB Controller driver provides a simple interface to manage the USB
15:                      modules on Microchip microcontrollers.  This file Implements the core
16:                      interface routines to be used both by the client(USB Host or Device layer)
17:                      and the system for communicating with USB Contoller driver.  While building
18:                      the driver from source, ALWAYS use this file in the build.
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute Software
26:                  only when embedded on a Microchip microcontroller or digital  signal  controller
27:                  that is integrated into your product or third party  product  (pursuant  to  the
28:                  sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS  WITHOUT  WARRANTY  OF  ANY  KIND,
34:                  EITHER EXPRESS  OR  IMPLIED,  INCLUDING  WITHOUT  LIMITATION,  ANY  WARRANTY  OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A  PARTICULAR  PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR  ITS  LICENSORS  BE  LIABLE  OR  OBLIGATED  UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,  BREACH  OF  WARRANTY,  OR
38:                  OTHER LEGAL  EQUITABLE  THEORY  ANY  DIRECT  OR  INDIRECT  DAMAGES  OR  EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY  INCIDENTAL,  SPECIAL,  INDIRECT,  PUNITIVE  OR
40:                  CONSEQUENTIAL DAMAGES, LOST  PROFITS  OR  LOST  DATA,  COST  OF  PROCUREMENT  OF
41:                  SUBSTITUTE  GOODS,  TECHNOLOGY,  SERVICES,  OR  ANY  CLAIMS  BY  THIRD   PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  THEREOF),  OR  OTHER  SIMILAR  COSTS.
43:                  *******************************************************************************/
44:                  //DOM-IGNORE-END
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Include Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include "configuration.h"
53:                  #include "driver/usb/usbfs/src/drv_usbfs_local.h"
54:                  
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  // Section: Global Data
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  
61:                  /******************************************************
62:                   * Hardware instance, endpoint table and client object
63:                   * lumped together as group to save memory.
64:                   ******************************************************/
65:                  DRV_USBFS_GROUP gDrvUSBGroup[DRV_USBFS_INSTANCES_NUMBER];
66:                  
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  // Section: USB Controller Driver Interface Implementations
70:                  // *****************************************************************************
71:                  // *****************************************************************************
72:                  
73:                  // *****************************************************************************
74:                  /* Function:
75:                      SYS_MODULE_OBJ DRV_USBFS_Initialize
76:                      ( 
77:                          const SYS_MODULE_INDEX index,
78:                          const SYS_MODULE_INIT * const init
79:                      )
80:                  
81:                    Summary:
82:                      Initializes the USB Driver.
83:                     
84:                    Description:
85:                      This function initializes the USB Driver, making it ready for clients to
86:                      open. The driver initialization does not complete when this function
87:                      returns. The DRV_USBFS_Tasks function must called periodically to complete
88:                      the driver initialization. The DRV_USBHS_Open function will fail if the
89:                      driver was not initialized or if initialization has not completed.
90:                    
91:                    Remarks:
92:                      See drv_usbfs.h for usage information.
93:                  */
94:                  
95:                  SYS_MODULE_OBJ DRV_USBFS_Initialize 
96:                  (
97:                      const SYS_MODULE_INDEX  drvIndex,
98:                      const SYS_MODULE_INIT * const init
99:                  )
100:                 {
101:                     DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)NULL;
102:                     USB_MODULE_ID usbID = USB_NUMBER_OF_MODULES;
103:                     DRV_USBFS_INIT * pusbInit = (DRV_USBFS_INIT *)NULL;
104:                     SYS_MODULE_OBJ returnValue = SYS_MODULE_OBJ_INVALID;
105:                 
106:                     if(drvIndex < DRV_USBFS_INSTANCES_NUMBER)
107:                     {
108:                         /* Driver index is valid */
109:                         if(gDrvUSBGroup[drvIndex].gDrvUSBObj.inUse == false)
110:                         {
111:                             /* Driver object is available. Grab the particular USB instance
112:                              * object*/
113:                             gDrvUSBGroup[drvIndex].gDrvUSBObj.inUse = true;
114:                 
115:                             /* Assign to the local pointer the init data passed */
116:                             pusbInit = (DRV_USBFS_INIT *) init;
117:                             usbID = pusbInit->usbID;
118:                             pUSBDrvObj = &gDrvUSBGroup[drvIndex].gDrvUSBObj;
119:                 
120:                             /* If this being built in an OS application, then create a mutex */
121:                             if(OSAL_MUTEX_Create(&pUSBDrvObj->mutexID) == OSAL_RESULT_TRUE)
122:                             {
123:                                 /* Populate the driver instance object with required data */
124:                                 pUSBDrvObj->status = SYS_STATUS_BUSY;
125:                                 pUSBDrvObj->usbID = usbID;
126:                                 pUSBDrvObj->operationMode = pusbInit->operationMode;
127:                                 pUSBDrvObj->pBDT = (DRV_USBFS_BDT_ENTRY *)(pusbInit->endpointTable);
128:                                 pUSBDrvObj->isOpened = false;
129:                                 pUSBDrvObj->pEventCallBack = NULL;
130:                 
131:                                 /* Assign the endpoint table */
132:                                 pUSBDrvObj->endpointTable = &gDrvUSBGroup[drvIndex].gDrvUSBEndpoints[0];
133:                                 pUSBDrvObj->interruptSource  = pusbInit->interruptSource;
134:                 
135:                                 /* Enable USB module(U1PWRC<0>). This internally does the following:
136:                                  * - Start the USB clock
137:                                  * - Allow the USB interrupt to be activated
138:                                  * - Select USB as the owner of the necessary I/O pins
139:                                  * - Enable the USB transceiver
140:                                  * - Enable the USB comparators */
141:                 
142:                                 PLIB_USB_Enable(usbID);
143:                 
144:                                 /* Setup the Hardware */
145:                                 if(pusbInit->stopInIdle)
146:                                 {
147:                                     PLIB_USB_StopInIdleEnable( usbID );
148:                                 }
149:                                 else
150:                                 {
151:                                     PLIB_USB_StopInIdleDisable( usbID );
152:                                 }
153:                 
154:                 #ifdef PLIB_USB_ExistsAutomaticSuspend
155:                                 if(PLIB_USB_ExistsAutomaticSuspend(usbID))
156:                                 {
157:                                     if(pusbInit->suspendInSleep)
158:                                     {
159:                                         PLIB_USB_AutoSuspendEnable( usbID );
160:                                     }
161:                                     else
162:                                     {
163:                                         PLIB_USB_AutoSuspendDisable( usbID );
164:                                     }
165:                                 }
166:                 #endif
167:                                 /* Setup the USB Module as per selected mode */
168:                                 switch(pusbInit->operationMode)
169:                                 {
170:                                     case DRV_USBFS_OPMODE_DEVICE:
171:                 
172:                                         /* Initialize USB Controller for Device mode */
173:                                         _DRV_USBFS_DEVICE_INIT(pUSBDrvObj, drvIndex);
174:                                         break;
175:                 
176:                                     case DRV_USBFS_OPMODE_HOST:
177:                 
178:                                         /* Initialize USB Controller for Host mode */
179:                                         _DRV_USBFS_HOST_INIT(pUSBDrvObj, drvIndex, pusbInit);
180:                                         break;
181:                 
182:                                     case DRV_USBFS_OPMODE_OTG:
183:                                         /* Not implemented at this point of time*/
184:                                         break;
185:                 
186:                                     default:
187:                                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: What mode are you trying?");
188:                                         break;
189:                                 }
190:                 
191:                                 /* Assign the BDT table base address */
192:                                 PLIB_USB_BDTBaseAddressSet(usbID , (void *)((uint32_t)KVA_TO_PA(pUSBDrvObj->pBDT)));    
193:                 
194:                                 /* Indicate that the object is ready and in use and return the driver
195:                                  * handle */
196:                 
197:                                 pUSBDrvObj->status = SYS_STATUS_READY;
198:                                 returnValue = drvIndex;
199:                             }
200:                             else
201:                             {
202:                                 /* Could not create mutex. Return the object. */
203:                                 gDrvUSBGroup[drvIndex].gDrvUSBObj.inUse = false;
204:                                 SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Mutex create failed");
205:                             } 
206:                         }
207:                         else
208:                         {
209:                             /* Cannot initialize an object that is already in use. */
210:                             SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Hardware Instance already in use");
211:                         }
212:                     }
213:                     else
214:                     {
215:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Invalid driver index");
216:                     }
217:                 
218:                     return (returnValue);
219:                 }
220:                 
221:                 // *****************************************************************************
222:                 /* Function:
223:                     void DRV_USBFS_Deinitialize( const SYS_MODULE_OBJ object )
224:                 
225:                   Summary:
226:                     This function deinitializes the USBFS driver instance. 
227:                 
228:                   Description:
229:                     This function deinitializes the USBFS driver instance. 
230:                 
231:                   Remarks:
232:                     A typicall USB application may not to called this function.
233:                 */
234:                 
235:                 void DRV_USBFS_Deinitialize
236:                 ( 
237:                     const SYS_MODULE_OBJ  object
238:                 )
239:                 {
240:                     DRV_USBFS_OBJ * pUSBDrvObj = NULL;
241:                 
242:                     if((object != SYS_MODULE_OBJ_INVALID) && (object < DRV_USBFS_INSTANCES_NUMBER))
243:                     {
244:                         /* Object is valid */
245:                         if(gDrvUSBGroup[object].gDrvUSBObj.inUse == true)
246:                         {
247:                             pUSBDrvObj = &gDrvUSBGroup[object].gDrvUSBObj;
248:                 
249:                             /* Release the USB instance object */
250:                             pUSBDrvObj->inUse = false;
251:                 
252:                             /* Reset the open flag */
253:                             pUSBDrvObj->isOpened = false;
254:                 
255:                             /* Delete the mutex */
256:                             OSAL_MUTEX_Delete(&pUSBDrvObj->mutexID);
257:                 
258:                             /* Uninitialize the status*/
259:                             pUSBDrvObj->status = SYS_STATUS_UNINITIALIZED;
260:                 
261:                             pUSBDrvObj->pEventCallBack = NULL;
262:                 
263:                             /* Clear and disable the interrupts */
264:                             _DRV_USBFS_InterruptSourceDisable(pUSBDrvObj->interruptSource);
265:                             _DRV_USBFS_InterruptSourceClear(pUSBDrvObj->interruptSource);
266:                 
267:                             /* Turn off USB module */
268:                             PLIB_USB_Disable(pUSBDrvObj->usbID);
269:                         }
270:                         else
271:                         {
272:                             /* Cannot deinitialize an object that is not in use. */
273:                             SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Instance not in use");
274:                         }
275:                     }
276:                     else
277:                     {
278:                         /* Invalid object */
279:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Invalid System Module Object");
280:                     }
281:                 } 
282:                 
283:                 // *****************************************************************************
284:                 /* Function:
285:                     SYS_STATUS DRV_USBFS_Status( const SYS_MODULE_OBJ object )
286:                 
287:                   Summary:
288:                     Provides the current status of the USB Driver module.
289:                 
290:                   Description:
291:                     This function provides the current status of the USB Driver module.
292:                 
293:                   Remarks:
294:                     See drv_usbfs.h for usage information.
295:                 */
296:                 
297:                 SYS_STATUS DRV_USBFS_Status
298:                 (
299:                     const SYS_MODULE_OBJ object
300:                 )
301:                 {
302:                     SYS_STATUS returnValue = SYS_STATUS_UNINITIALIZED;
303:                 
304:                     /* Check if USB instance object is valid */
305:                     if((object != SYS_MODULE_OBJ_INVALID) || (object < DRV_USBFS_INSTANCES_NUMBER))
306:                     {
307:                         returnValue = gDrvUSBGroup[object].gDrvUSBObj.status;
308:                     }
309:                     else
310:                     {
311:                         /* Invalid object */
312:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Invalid object");
313:                     }
314:                 
315:                     /* Return the status of the driver object */
316:                     return returnValue;
317:                 }
318:                 
319:                 // *****************************************************************************
320:                 /* Function:
321:                     DRV_HANDLE DRV_USBFS_Open
322:                     (
323:                         const SYS_MODULE_INDEX drvIndex,
324:                         const DRV_IO_INTENT ioIntent 
325:                     )
326:                 
327:                   Summary:
328:                     Opens the specified USB Driver instance and returns a handle to it.
329:                    
330:                   Description:
331:                     This function opens the specified USB Driver instance and provides a handle
332:                     that must be provided to all other client-level operations to identify the
333:                     caller and the instance of the driver. The intent flag is ignored.  Any
334:                     other setting of the intent flag will return a invalid driver handle. A
335:                     driver instance can only support one client. Trying to open a driver that
336:                     has an existing client will result in an unsuccessful function call.
337:                 
338:                   Remarks:
339:                     See drv_usbfs.h for usage information.
340:                 */
341:                 
342:                 DRV_HANDLE DRV_USBFS_Open
343:                 (
344:                     const SYS_MODULE_INDEX drvIndex,
345:                     const DRV_IO_INTENT ioIntent 
346:                 )
347:                 {
348:                     DRV_HANDLE handle = DRV_HANDLE_INVALID;
349:                 
350:                     /* Check if the specified driver index is in valid range */
351:                     if(drvIndex < DRV_USBFS_INSTANCES_NUMBER)
352:                     {
353:                         if(gDrvUSBGroup[drvIndex].gDrvUSBObj.status == SYS_STATUS_READY)
354:                         {
355:                             if(gDrvUSBGroup[drvIndex].gDrvUSBObj.isOpened == false)
356:                             {
357:                                 gDrvUSBGroup[drvIndex].gDrvUSBObj.isOpened = true;
358:                                 
359:                                 /* Handle is the pointer to the client object */
360:                                 handle = ((DRV_HANDLE)&(gDrvUSBGroup[drvIndex].gDrvUSBObj));
361:                             }
362:                             else
363:                             {
364:                                 /* Driver supports exclusive open only */
365:                                 SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver already opened once. Cannot open again");
366:                             }
367:                         }
368:                         else
369:                         {
370:                             /* The USB module should be ready */
371:                             SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Was the driver initialized?");
372:                         }
373:                     }
374:                     else
375:                     {
376:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Driver Index");
377:                     }
378:                 
379:                     /* Return invalid handle */
380:                     return handle;
381:                 }
382:                 
383:                 // *****************************************************************************
384:                 /* Function:
385:                     void DRV_USBFS_Close( DRV_HANDLE client )
386:                 
387:                   Summary:
388:                     Closes an opened-instance of the  USB Driver.
389:                 
390:                   Description:
391:                     This function closes an opened-instance of the  USB Driver, invalidating the
392:                     handle.
393:                 
394:                   Remarks:
395:                     See drv_usbfs.h for usage information.
396:                 */
397:                 
398:                 void DRV_USBFS_Close
399:                 (
400:                     DRV_HANDLE handle
401:                 )
402:                 {
403:                     DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)NULL;
404:                 
405:                     /* Check if the handle is valid */
406:                     if((handle != DRV_HANDLE_INVALID) && (handle != (DRV_HANDLE)(NULL)))
407:                     {
408:                         /* Reset the relevant parameters */
409:                         pUSBDrvObj = (DRV_USBFS_OBJ *)handle;
410:                         if(pUSBDrvObj->isOpened)
411:                         {
412:                             pUSBDrvObj->isOpened = false;
413:                             pUSBDrvObj->pEventCallBack = NULL;
414:                         }
415:                         else
416:                         {
417:                             SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Client Handle already closed");
418:                         }
419:                     }
420:                     else
421:                     {
422:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client Handle");
423:                     }
424:                 }
425:                 
426:                 // *****************************************************************************
427:                 /* Function:
428:                     DRV_HANDLE DRV_USBFS_Tasks_ISR( SYS_MODULE_OBJ object )
429:                 
430:                   Summary:
431:                     Maintains the driver's Interrupt state machine and implements its ISR.
432:                 
433:                   Description:
434:                     This function is used to maintain the driver's internal Interrupt state
435:                     machine and implement its ISR for interrupt-driven implementations.
436:                 
437:                   Remarks:
438:                     See drv_usbfs.h for usage information.
439:                 */
440:                 
441:                 void DRV_USBFS_Tasks_ISR
442:                 (
443:                     SYS_MODULE_OBJ object
444:                 )
445:                 {
446:                     DRV_USBFS_OBJ * pUSBDriver = (DRV_USBFS_OBJ *)NULL;
447:                 
448:                     pUSBDriver = &gDrvUSBGroup[object].gDrvUSBObj;
449:                 
450:                     /* We are entering an interrupt context */
451:                     pUSBDriver->inInterruptContext = true;
452:                 
453:                     /* Clear the interrupt */
454:                     _DRV_USBFS_InterruptSourceClear(pUSBDriver->interruptSource);
455:                    
456:                     switch(pUSBDriver->operationMode)
457:                     {
458:                         case DRV_USBFS_OPMODE_DEVICE:
459:                             
460:                             /* Driver is running in Device Mode */
461:                             _DRV_USBFS_DEVICE_TASKS_ISR(pUSBDriver);
462:                             break;
463:                         
464:                         case DRV_USBFS_OPMODE_HOST:
465:                 
466:                             /* Driver is running in Host Mode */
467:                             _DRV_USBFS_HOST_TASKS_ISR(pUSBDriver);
468:                             break;
469:                 
470:                         case DRV_USBFS_OPMODE_OTG:
471:                             /* OTG mode is not supported yet */
472:                             break;
473:                 
474:                         default:
475:                             SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: What mode are you trying?");
476:                             break;
477:                     }
478:                   
479:                     pUSBDriver->inInterruptContext = false;
480:                 }
481:                 
482:                 // *****************************************************************************
483:                 /* Function:
484:                     void DRV_USBFS_ClientEventCallBackSet
485:                     (
486:                         DRV_HANDLE handle,
487:                         uintptr_t hReferenceData,
488:                         DRV_USBFS_EVENT_CALLBACK eventCallBack
489:                     )
490:                 
491:                   Summary:
492:                     This function sets up the event callback function that is invoked by the USB
493:                     controller driver to notify the client of USB bus events.
494:                    
495:                   Description:
496:                     This function sets up the event callback function that is invoked by the USB
497:                     controller driver to notify the client of USB bus events. The callback is
498:                     disabled by either not calling this function after the DRV_USBFS_Open
499:                     function has been called or by setting the myEventCallBack argument as NULL.
500:                     When the callback function is called, the hReferenceData argument is
501:                     returned.
502:                 
503:                   Remarks:
504:                     See drv_usbfs.h for usage information.
505:                 */
506:                 
507:                 void DRV_USBFS_ClientEventCallBackSet
508:                 ( 
509:                     DRV_HANDLE handle,
510:                     uintptr_t hReferenceData,
511:                     DRV_USB_EVENT_CALLBACK eventCallBack 
512:                 )
513:                 {
514:                     DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)handle;
515:                     
516:                     /* Check if the handle is valid or opened */
517:                     if((handle != DRV_HANDLE_INVALID) && (handle != (DRV_HANDLE)(NULL)) && (pUSBDrvObj->isOpened == true))
518:                     {
519:                         /* Assign event call back and reference data */
520:                         pUSBDrvObj->hClientArg = hReferenceData;
521:                         pUSBDrvObj->pEventCallBack = eventCallBack;
522:                 
523:                         /* If the driver is operating in device mode, this is the time we enable
524:                          * the USB interrupt */
525:                 
526:                         if(pUSBDrvObj->operationMode == USB_OPMODE_DEVICE)
527:                         {
528:                             /* Enable the session valid interrupt */
529:                             PLIB_USB_OTG_InterruptEnable(pUSBDrvObj->usbID, USB_OTG_INT_SESSION_VALID);
530:                             
531:                             /* Enable the interrupt */
532:                             _DRV_USBFS_InterruptSourceEnable(pUSBDrvObj->interruptSource);
533:                         }
534:                     }
535:                     else
536:                     {
537:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client or client closed");
538:                     }
539:                 } 
540:                 
541:                 // *****************************************************************************
542:                 /* Function:
543:                     void DRV_USBFS_Tasks( SYS_MODULE_OBJ object )
544:                 
545:                   Summary:
546:                     Maintains the driver's state machine when the driver is configured for 
547:                     polled mode.
548:                 
549:                   Description:
550:                     Maintains the driver's state machine when the driver is configured for 
551:                     polled mode. This function should be called from the system tasks routine.
552:                 
553:                   Remarks:
554:                     Refer to drv_usbfs.h for usage information.
555:                 */
556:                 
557:                 void DRV_USBFS_Tasks(SYS_MODULE_OBJ object)
558:                 {
559:                     /* This driver does not have any non interrupt tasks. When the driver
560:                      * is configured for polled mode operation, the _DRV_USBFS_Tasks_ISR function
561:                      * will map to DRV_USBFS_Tasks_ISR function. In interrupt mode, this function
562:                      * will be mapped to nothing and hence this function will not have any
563:                      * effect. */
564:                 
565:                     _DRV_USBFS_Tasks_ISR(object);
566:                 }
567:                 
568:                 void DRV_USBFS_Tasks_ISR_USBDMA( SYS_MODULE_OBJ object )
569:                 {
570:                     /* This function is implemented to only maintain compatibility with the
571:                      * PIC32MZ High Speed USB Driver. This function does not do anything on the
572:                      * PIC32MX USB driver and is not required to be called in a PIC32MX USB
573:                      * applicaiton */
574:                 }
575:                 
576:                 // *****************************************************************************
577:                 /* Function:
578:                     void DRV_USBFS_USB_Handler(void)
579:                 
580:                   Summary:
581:                     USBFS Interrupt Handler 
582:                 	
583:                   Description:
584:                     This is USBFS Interrupt Handler 
585:                 
586:                   Remarks:
587:                 	None 
588:                 */
589:                 
590:                 void DRV_USBFS_USB_Handler(void)
591:                 {
592:                 	DRV_USBFS_Tasks_ISR(sysObj.drvUSBFSObject); 
593:                 }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000018  00000000   NOP
00000020  00000000   NOP
00000024  00000000   NOP
00000028  00000000   NOP
0000002C  00000000   NOP
00000030  00000000   NOP
00000034  00000000   NOP
00000038  00000000   NOP
0000003C  00000000   NOP
00000040  00000000   NOP
00000048  00000000   NOP
00000050  00000000   NOP
00000054  00000000   NOP
00000060  00000000   NOP
0000006C  00000000   NOP
9D000338  0B401A2C   J DRV_USBFS_Tasks_ISR
9D00033C  8F84803C   LW A0, -32708(GP)
9D004F88  1480003E   BNE A0, ZERO, 0x9D005084
9D004F8C  00000000   NOP
9D004F90  3C04A000   LUI A0, -24576
9D004F94  90820400   LBU V0, 1024(A0)
9D004F98  1440003A   BNE V0, ZERO, 0x9D005084
9D004F9C  00000000   NOP
9D004FA0  27BDFFE0   ADDIU SP, SP, -32
9D004FA4  AFB10018   SW S1, 24(SP)
9D004FA8  8CB10004   LW S1, 4(A1)
9D004FAC  24020001   ADDIU V0, ZERO, 1
9D004FB0  AFB00014   SW S0, 20(SP)
9D004FC0  8CA9000C   LW T1, 12(A1)
9D004FC4  90A80008   LBU T0, 8(A1)
9D004FC8  8CA60014   LW A2, 20(A1)
9D004FCC  8CAA0018   LW T2, 24(A1)
9D004FD0  24030001   ADDIU V1, ZERO, 1
9D004FD8  A0820400   SB V0, 1024(A0)
9D004FDC  3C02A000   LUI V0, -24576
9D004FE0  24420438   ADDIU V0, V0, 1080
9D004FE4  AFBF001C   SW RA, 28(SP)
9D004FEC  AE020034   SW V0, 52(S0)
9D004FF0  AE030014   SW V1, 20(S0)
9D004FF4  AE110020   SW S1, 32(S0)
9D004FF8  AE060024   SW A2, 36(S0)
9D004FFC  AE0A002C   SW T2, 44(S0)
9D005000  A2000005   SB ZERO, 5(S0)
9D005004  AE000010   SW ZERO, 16(S0)
9D005008  AE090028   SW T1, 40(S0)
9D00500C  922202A0   LBU V0, 672(S1)
9D005010  5100001E   BEQL T0, ZERO, DRV_USBFS_Initialize::PLIB_USB_StopInIdleDisable
9D005014  7C022104   INS V0, ZERO, 4, 1
9D005018  7C622104   INS V0, V1, 4, 1
9D00501C  A22202A0   SB V0, 672(S1)
9D005020  90A20009   LBU V0, 9(A1)
9D005024  1040001D   BEQ V0, ZERO, DRV_USBFS_Initialize::PLIB_USB_AutoSuspendDisable
9D005028  24020001   ADDIU V0, ZERO, 1
9D00502C  AE2202A8   SW V0, 680(S1)
9D005030  24020001   ADDIU V0, ZERO, 1
9D00503C  8E02002C   LW V0, 44(S0)
9D005040  24030002   ADDIU V1, ZERO, 2
9D005044  AE030014   SW V1, 20(S0)
9D005048  7C42E000   EXT V0, V0, 0, 29
9D005060  8FBF001C   LW RA, 28(SP)
9D00506C  00001025   OR V0, ZERO, ZERO
9D005074  8FB00014   LW S0, 20(SP)
9D005084  03E00008   JR RA
9D005088  2402FFFF   ADDIU V0, ZERO, -1
9D00508C  A22202A0   SB V0, 672(S1)
9D005090  90A20009   LBU V0, 9(A1)
9D00509C  AE2202A4   SW V0, 676(S1)
9D0050A0  1000FFE4   BEQ ZERO, ZERO, 0x9D005034
9D0050A4  24020001   ADDIU V0, ZERO, 1
9D0050A8  0F402082   JAL _DRV_USBFS_DEVICE_Initialize
9D0050AC  24840400   ADDIU A0, A0, 1024
9D0050B0  1000FFE3   BEQ ZERO, ZERO, 0x9D005040
9D0050B4  8E02002C   LW V0, 44(S0)
9D0068B0  27BDFFD8   ADDIU SP, SP, -40
9D0068B4  AFB2001C   SW S2, 28(SP)
9D0068B8  00049140   SLL S2, A0, 5
9D0068BC  AFB10018   SW S1, 24(SP)
9D0068C0  AFB00014   SW S0, 20(SP)
9D0068C4  3C11A000   LUI S1, -24576
9D0068C8  02448023   SUBU S0, S2, A0
9D0068CC  26310400   ADDIU S1, S1, 1024
9D0068D0  001080C0   SLL S0, S0, 3
9D0068D4  02308021   ADDU S0, S1, S0
9D0068D8  AFB30020   SW S3, 32(SP)
9D0068DC  00809825   OR S3, A0, ZERO
9D0068E0  8E040028   LW A0, 40(S0)
9D0068E4  24020001   ADDIU V0, ZERO, 1
9D0068E8  AFBF0024   SW RA, 36(SP)
9D0068EC  0F4020A0   JAL EVIC_SourceStatusClear
9D0068F0  A2020001   SB V0, 1(S0)
9D0068F4  8E030024   LW V1, 36(S0)
9D0068F8  24020001   ADDIU V0, ZERO, 1
9D0068FC  1062000B   BEQ V1, V0, 0x9D00692C
9D006900  8FBF0024   LW RA, 36(SP)
9D006904  02539023   SUBU S2, S2, S3
9D006908  001290C0   SLL S2, S2, 3
9D00690C  02328821   ADDU S1, S1, S2
9D006910  A2200001   SB ZERO, 1(S1)
9D006914  8FB30020   LW S3, 32(SP)
9D006918  8FB2001C   LW S2, 28(SP)
9D00691C  8FB10018   LW S1, 24(SP)
9D006920  8FB00014   LW S0, 20(SP)
9D006924  03E00008   JR RA
9D006928  27BD0028   ADDIU SP, SP, 40
9D00692C  0F40045E   JAL _DRV_USBFS_DEVICE_Tasks_ISR
9D006930  02002025   OR A0, S0, ZERO
9D006934  02539023   SUBU S2, S2, S3
9D006938  8FBF0024   LW RA, 36(SP)
9D00693C  001290C0   SLL S2, S2, 3
9D006940  02328821   ADDU S1, S1, S2
9D006944  A2200001   SB ZERO, 1(S1)
9D006948  8FB30020   LW S3, 32(SP)
9D00694C  8FB2001C   LW S2, 28(SP)
9D006950  8FB10018   LW S1, 24(SP)
9D006954  8FB00014   LW S0, 20(SP)
9D006958  03E00008   JR RA
9D00695C  27BD0028   ADDIU SP, SP, 40
9D0078E4  2482FFFF   ADDIU V0, A0, -1
9D0078E8  2C42FFFE   SLTIU V0, V0, -2
9D0078EC  10400009   BEQ V0, ZERO, 0x9D007914
9D0078F0  00000000   NOP
9D0078F4  90820005   LBU V0, 5(A0)
9D0078F8  10400006   BEQ V0, ZERO, 0x9D007914
9D0078FC  00000000   NOP
9D007900  8C830024   LW V1, 36(A0)
9D007904  24020001   ADDIU V0, ZERO, 1
9D007908  AC85000C   SW A1, 12(A0)
9D00790C  10620003   BEQ V1, V0, DRV_USBFS_ClientEventCallBackSet::PLIB_USB_OTG_InterruptEnable
9D007910  AC860010   SW A2, 16(A0)
9D007914  03E00008   JR RA
9D007918  00000000   NOP
9D00791C  8C830020   LW V1, 32(A0)
9D007920  8C840028   LW A0, 40(A0)
9D007930  0B40208C   J EVIC_SourceEnable
9D007934  00000000   NOP
9D007938  3C040000   LUI A0, 0
9D007ACC  14800010   BNE A0, ZERO, 0x9D007B10
9D007AD0  00000000   NOP
9D007AD4  3C03A000   LUI V1, -24576
9D007AD8  24630400   ADDIU V1, V1, 1024
9D007ADC  8C650014   LW A1, 20(V1)
9D007AE0  24040002   ADDIU A0, ZERO, 2
9D007AE4  10A40003   BEQ A1, A0, 0x9D007AF4
9D007AE8  2402FFFF   ADDIU V0, ZERO, -1
9D007AEC  03E00008   JR RA
9D007AF0  00000000   NOP
9D007AF4  90640005   LBU A0, 5(V1)
9D007AF8  1480FFFC   BNE A0, ZERO, 0x9D007AEC
9D007AFC  00000000   NOP
9D007B00  24020001   ADDIU V0, ZERO, 1
9D007B04  A0620005   SB V0, 5(V1)
9D007B08  03E00008   JR RA
9D007B0C  00601025   OR V0, V1, ZERO
9D007B10  03E00008   JR RA
9D007B14  2402FFFF   ADDIU V0, ZERO, -1
9D00810C  2482FFFF   ADDIU V0, A0, -1
9D008110  2C42FFFE   SLTIU V0, V0, -2
9D008114  10400006   BEQ V0, ZERO, 0x9D008130
9D008118  00000000   NOP
9D00811C  90820005   LBU V0, 5(A0)
9D008120  10400003   BEQ V0, ZERO, 0x9D008130
9D008124  00000000   NOP
9D008128  A0800005   SB ZERO, 5(A0)
9D00812C  AC800010   SW ZERO, 16(A0)
9D008130  03E00008   JR RA
9D008134  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/btl_tasks.c  -------------------------------
1:                   /*******************************************************************************
2:                    System Tasks File
3:                   
4:                     File Name:
5:                       tasks.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to maintain system's polled tasks.
9:                   
10:                    Description:
11:                      This file contains source code necessary to maintain system's polled tasks.
12:                      It implements the "SYS_Tasks" function that calls the individual "Tasks"
13:                      functions for all polled MPLAB Harmony modules in the system.
14:                  
15:                    Remarks:
16:                      This file requires access to the systemObjects global data structure that
17:                      contains the object handles to all MPLAB Harmony module objects executing
18:                      polled in the system.  These handles are passed into the individual module
19:                      "Tasks" functions to identify the instance of the module to maintain.
20:                   *******************************************************************************/
21:                  
22:                  // DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
25:                  *
26:                  * Subject to your compliance with these terms, you may use Microchip software
27:                  * and any derivatives exclusively with Microchip products. It is your
28:                  * responsibility to comply with third party license terms applicable to your
29:                  * use of third party software (including open source software) that may
30:                  * accompany Microchip software.
31:                  *
32:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
33:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
34:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
35:                  * PARTICULAR PURPOSE.
36:                  *
37:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
38:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
39:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
40:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
41:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
42:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
43:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
44:                   *******************************************************************************/
45:                  // DOM-IGNORE-END
46:                  
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  // Section: Included Files
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  
53:                  #include "configuration.h"
54:                  #include "definitions.h"
55:                  
56:                  //bool taskBusy = false;
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: System "Tasks" Routine
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  /*******************************************************************************
65:                    Function:
66:                      void SYS_Tasks ( void )
67:                  
68:                    Remarks:
69:                      See prototype in system/common/sys_module.h.
70:                  */
71:                  void SYS_Tasks ( void )
72:                  {
73:                  //    taskBusy = false;
74:                      
75:                      /* Maintain system services */
76:                      
77:                  
78:                      /* Maintain Device Drivers */
79:                      
80:                  
81:                      /* Maintain Middleware & Other Libraries */
82:                          /* USB Device layer tasks routine */ 
83:                      USB_DEVICE_Tasks(sysObj.usbDevObject0);
84:                  
85:                  
86:                  
87:                  
88:                      /* Maintain the application's state machine. */
89:                          /* Call Application task APP. */
90:                      APP_Tasks();
91:                  
92:                      /* Call Application task APP_USB. */
93:                      APP_USB_Tasks();
94:                  
95:                      /* Call Application task APP_BLE. */
96:                      APP_BLE_Tasks();
97:                      
98:                      /* Call Application task APP_X1TXO. */
99:                  //    APP_X1TXO_Tasks();
100:                     
101:                     /* If tasks are not busy enter idle mode */
102:                         /* Will wake up upon core timer event */
103:                         /* For now always stay in normal mode, optimize later */
104:                 //    taskBusy = true;
105:                 //    if (!taskBusy) {
106:                 //        POWER_LowPowerModeEnter(LOW_POWER_IDLE_MODE);
107:                 //    }
108:                 }
109:                 
110:                 /*******************************************************************************
111:                  End of File
112:                  */
113:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00807C  8F848038   LW A0, -32712(GP)
9D008080  27BDFFE8   ADDIU SP, SP, -24
9D008084  AFBF0014   SW RA, 20(SP)
9D008088  0F40124C   JAL USB_DEVICE_Tasks
9D00808C  00000000   NOP
9D008090  0F4005FF   JAL APP_Tasks
9D008094  00000000   NOP
9D008098  0F400B6A   JAL APP_USB_Tasks
9D00809C  00000000   NOP
9D0080A0  8FBF0014   LW RA, 20(SP)
9D0080A4  0B4012A0   J APP_BLE_Tasks
9D0080A8  27BD0018   ADDIU SP, SP, 24
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/btl_interrupts.c  --------------------------
1:                   /*******************************************************************************
2:                    System Interrupts File
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       interrupt.c
9:                   
10:                    Summary:
11:                      Interrupt vectors mapping
12:                  
13:                    Description:
14:                      This file maps all the interrupt vectors to their corresponding
15:                      implementations. If a particular module interrupt is used, then its ISR
16:                      definition can be found in corresponding PLIB source file. If a module
17:                      interrupt is not used, then its ISR implementation is mapped to dummy
18:                      handler.
19:                   *******************************************************************************/
20:                  
21:                  // DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
24:                  *
25:                  * Subject to your compliance with these terms, you may use Microchip software
26:                  * and any derivatives exclusively with Microchip products. It is your
27:                  * responsibility to comply with third party license terms applicable to your
28:                  * use of third party software (including open source software) that may
29:                  * accompany Microchip software.
30:                  *
31:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
32:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
33:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
34:                  * PARTICULAR PURPOSE.
35:                  *
36:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
37:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
38:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
39:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
40:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
41:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
42:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
43:                   *******************************************************************************/
44:                  // DOM-IGNORE-END
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Included Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include "configuration.h"
53:                  #include "interrupts.h"
54:                  #include "definitions.h"
55:                  
56:                  
57:                  // *****************************************************************************
58:                  // *****************************************************************************
59:                  // Section: System Interrupt Vector Functions
60:                  // *****************************************************************************
61:                  // *****************************************************************************
62:                  
63:                  
64:                  void CORE_TIMER_InterruptHandler( void );
65:                  //void TIMER_3_InterruptHandler( void );
66:                  void NVM_InterruptHandler( void );
67:                  void DRV_USBFS_USB_Handler( void );
68:                  void UART_1_InterruptHandler( void );
69:                  //void UART_2_InterruptHandler( void );
70:                  
71:                  
72:                  
73:                  /* All the handlers are defined here.  Each will call its PLIB-specific function. */
74:                  void __ISR(_CORE_TIMER_VECTOR, ipl1SOFT) CORE_TIMER_Handler (void)
75:                  {
76:                      CORE_TIMER_InterruptHandler();
77:                  }
78:                  
79:                  //void __ISR(_TIMER_3_VECTOR, ipl1SOFT) TIMER_3_Handler (void)
80:                  //{
81:                  //    TIMER_3_InterruptHandler();
82:                  //}
83:                  
84:                  void __ISR(_FCE_VECTOR, ipl1SOFT) FCE_Handler (void)
85:                  {
86:                      NVM_InterruptHandler();
87:                  }
88:                  
89:                  void __ISR(_USB_1_VECTOR, ipl1SOFT) USB_1_Handler (void)
90:                  {
91:                      DRV_USBFS_USB_Handler();
92:                  }
93:                  
94:                  void __ISR(_UART_1_VECTOR, ipl1SOFT) UART_1_Handler (void)
95:                  {
96:                      UART_1_InterruptHandler();
97:                  }
98:                  
99:                  //void __ISR(_UART_2_VECTOR, ipl1SOFT) UART_2_Handler (void)
100:                 //{
101:                 //    UART_2_InterruptHandler();
102:                 //}
103:                 
104:                 
105:                 
106:                 
107:                 
108:                 /*******************************************************************************
109:                  End of File
110:                 */
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D005438  415DE800   RDPGPR SP, SP
9D00543C  401A7000   MFC0 K0, EPC
9D005440  401B6000   MFC0 K1, Status
9D005444  27BDFF88   ADDIU SP, SP, -120
9D005448  AFBA0074   SW K0, 116(SP)
9D00544C  401A6002   MFC0 K0, SRSCtl
9D005450  AFBB0070   SW K1, 112(SP)
9D005454  7C1B7844   INS K1, ZERO, 1, 15
9D005458  377B0400   ORI K1, K1, 1024
9D00545C  AFBA006C   SW K0, 108(SP)
9D005460  409B6000   MTC0 K1, Status
9D005464  AFBE0058   SW FP, 88(SP)
9D005468  AFA3001C   SW V1, 28(SP)
9D00546C  AFA20018   SW V0, 24(SP)
9D005470  00001810   MFHI V1
9D005474  03A0F025   OR FP, SP, ZERO
9D005478  AFBF005C   SW RA, 92(SP)
9D00547C  00001012   MFLO V0
9D005480  AFB90054   SW T9, 84(SP)
9D005484  AFB80050   SW T8, 80(SP)
9D005488  AFAF004C   SW T7, 76(SP)
9D00548C  AFAE0048   SW T6, 72(SP)
9D005490  AFAD0044   SW T5, 68(SP)
9D005494  AFAC0040   SW T4, 64(SP)
9D005498  AFAB003C   SW T3, 60(SP)
9D00549C  AFAA0038   SW T2, 56(SP)
9D0054A0  AFA90034   SW T1, 52(SP)
9D0054A4  AFA80030   SW T0, 48(SP)
9D0054A8  AFA7002C   SW A3, 44(SP)
9D0054AC  AFA60028   SW A2, 40(SP)
9D0054B0  AFA50024   SW A1, 36(SP)
9D0054B4  AFA40020   SW A0, 32(SP)
9D0054B8  AFA10014   SW AT, 20(SP)
9D0054BC  AFA20064   SW V0, 100(SP)
9D0054C0  AFA30060   SW V1, 96(SP)
9D0054C4  0F401A58   JAL CORE_TIMER_InterruptHandler
9D0054C8  00000000   NOP
9D0054CC  03C0E825   OR SP, FP, ZERO
9D0054D0  8FA20064   LW V0, 100(SP)
9D0054D4  8FA30060   LW V1, 96(SP)
9D0054D8  8FBF005C   LW RA, 92(SP)
9D0054DC  00400013   MTLO V0
9D0054E0  8FBE0058   LW FP, 88(SP)
9D0054E4  8FB90054   LW T9, 84(SP)
9D0054E8  00600011   MTHI V1
9D0054EC  8FB80050   LW T8, 80(SP)
9D0054F0  8FAF004C   LW T7, 76(SP)
9D0054F4  8FAE0048   LW T6, 72(SP)
9D0054F8  8FAD0044   LW T5, 68(SP)
9D0054FC  8FAC0040   LW T4, 64(SP)
9D005500  8FAB003C   LW T3, 60(SP)
9D005504  8FAA0038   LW T2, 56(SP)
9D005508  8FA90034   LW T1, 52(SP)
9D00550C  8FA80030   LW T0, 48(SP)
9D005510  8FA7002C   LW A3, 44(SP)
9D005514  8FA60028   LW A2, 40(SP)
9D005518  8FA50024   LW A1, 36(SP)
9D00551C  8FA40020   LW A0, 32(SP)
9D005520  8FA3001C   LW V1, 28(SP)
9D005524  8FA20018   LW V0, 24(SP)
9D005528  8FA10014   LW AT, 20(SP)
9D00552C  41606000   DI ZERO
9D005530  000000C0   EHB
9D005534  8FBA0074   LW K0, 116(SP)
9D005538  8FBB0070   LW K1, 112(SP)
9D00553C  409A7000   MTC0 K0, EPC
9D005540  8FBA006C   LW K0, 108(SP)
9D005544  27BD0078   ADDIU SP, SP, 120
9D005548  409A6002   MTC0 K0, SRSCtl
9D00554C  41DDE800   WRPGPR SP, SP
9D005550  409B6000   MTC0 K1, Status
9D005554  42000018   ERET
9D005558  415DE800   RDPGPR SP, SP
9D00555C  401A7000   MFC0 K0, EPC
9D005560  401B6000   MFC0 K1, Status
9D005564  27BDFF88   ADDIU SP, SP, -120
9D005568  AFBA0074   SW K0, 116(SP)
9D00556C  401A6002   MFC0 K0, SRSCtl
9D005570  AFBB0070   SW K1, 112(SP)
9D005574  7C1B7844   INS K1, ZERO, 1, 15
9D005578  377B0400   ORI K1, K1, 1024
9D00557C  AFBA006C   SW K0, 108(SP)
9D005580  409B6000   MTC0 K1, Status
9D005584  AFBE0058   SW FP, 88(SP)
9D005588  AFA3001C   SW V1, 28(SP)
9D00558C  AFA20018   SW V0, 24(SP)
9D005590  00001810   MFHI V1
9D005594  03A0F025   OR FP, SP, ZERO
9D005598  AFBF005C   SW RA, 92(SP)
9D00559C  00001012   MFLO V0
9D0055A0  AFB90054   SW T9, 84(SP)
9D0055A4  AFB80050   SW T8, 80(SP)
9D0055A8  AFAF004C   SW T7, 76(SP)
9D0055AC  AFAE0048   SW T6, 72(SP)
9D0055B0  AFAD0044   SW T5, 68(SP)
9D0055B4  AFAC0040   SW T4, 64(SP)
9D0055B8  AFAB003C   SW T3, 60(SP)
9D0055BC  AFAA0038   SW T2, 56(SP)
9D0055C0  AFA90034   SW T1, 52(SP)
9D0055C4  AFA80030   SW T0, 48(SP)
9D0055C8  AFA7002C   SW A3, 44(SP)
9D0055CC  AFA60028   SW A2, 40(SP)
9D0055D0  AFA50024   SW A1, 36(SP)
9D0055D4  AFA40020   SW A0, 32(SP)
9D0055D8  AFA10014   SW AT, 20(SP)
9D0055DC  AFA20064   SW V0, 100(SP)
9D0055E0  AFA30060   SW V1, 96(SP)
9D0055E4  0F4020B4   JAL NVM_InterruptHandler
9D0055E8  00000000   NOP
9D0055EC  03C0E825   OR SP, FP, ZERO
9D0055F0  8FA20064   LW V0, 100(SP)
9D0055F4  8FA30060   LW V1, 96(SP)
9D0055F8  8FBF005C   LW RA, 92(SP)
9D0055FC  00400013   MTLO V0
9D005600  8FBE0058   LW FP, 88(SP)
9D005604  8FB90054   LW T9, 84(SP)
9D005608  00600011   MTHI V1
9D00560C  8FB80050   LW T8, 80(SP)
9D005610  8FAF004C   LW T7, 76(SP)
9D005614  8FAE0048   LW T6, 72(SP)
9D005618  8FAD0044   LW T5, 68(SP)
9D00561C  8FAC0040   LW T4, 64(SP)
9D005620  8FAB003C   LW T3, 60(SP)
9D005624  8FAA0038   LW T2, 56(SP)
9D005628  8FA90034   LW T1, 52(SP)
9D00562C  8FA80030   LW T0, 48(SP)
9D005630  8FA7002C   LW A3, 44(SP)
9D005634  8FA60028   LW A2, 40(SP)
9D005638  8FA50024   LW A1, 36(SP)
9D00563C  8FA40020   LW A0, 32(SP)
9D005640  8FA3001C   LW V1, 28(SP)
9D005644  8FA20018   LW V0, 24(SP)
9D005648  8FA10014   LW AT, 20(SP)
9D00564C  41606000   DI ZERO
9D005650  000000C0   EHB
9D005654  8FBA0074   LW K0, 116(SP)
9D005658  8FBB0070   LW K1, 112(SP)
9D00565C  409A7000   MTC0 K0, EPC
9D005660  8FBA006C   LW K0, 108(SP)
9D005664  27BD0078   ADDIU SP, SP, 120
9D005668  409A6002   MTC0 K0, SRSCtl
9D00566C  41DDE800   WRPGPR SP, SP
9D005670  409B6000   MTC0 K1, Status
9D005674  42000018   ERET
9D005678  415DE800   RDPGPR SP, SP
9D00567C  401A7000   MFC0 K0, EPC
9D005680  401B6000   MFC0 K1, Status
9D005684  27BDFF88   ADDIU SP, SP, -120
9D005688  AFBA0074   SW K0, 116(SP)
9D00568C  401A6002   MFC0 K0, SRSCtl
9D005690  AFBB0070   SW K1, 112(SP)
9D005694  7C1B7844   INS K1, ZERO, 1, 15
9D005698  377B0400   ORI K1, K1, 1024
9D00569C  AFBA006C   SW K0, 108(SP)
9D0056A0  409B6000   MTC0 K1, Status
9D0056A4  AFBE0058   SW FP, 88(SP)
9D0056A8  AFA3001C   SW V1, 28(SP)
9D0056AC  AFA20018   SW V0, 24(SP)
9D0056B0  00001810   MFHI V1
9D0056B4  03A0F025   OR FP, SP, ZERO
9D0056B8  AFBF005C   SW RA, 92(SP)
9D0056BC  00001012   MFLO V0
9D0056C0  AFB90054   SW T9, 84(SP)
9D0056C4  AFB80050   SW T8, 80(SP)
9D0056C8  AFAF004C   SW T7, 76(SP)
9D0056CC  AFAE0048   SW T6, 72(SP)
9D0056D0  AFAD0044   SW T5, 68(SP)
9D0056D4  AFAC0040   SW T4, 64(SP)
9D0056D8  AFAB003C   SW T3, 60(SP)
9D0056DC  AFAA0038   SW T2, 56(SP)
9D0056E0  AFA90034   SW T1, 52(SP)
9D0056E4  AFA80030   SW T0, 48(SP)
9D0056E8  AFA7002C   SW A3, 44(SP)
9D0056EC  AFA60028   SW A2, 40(SP)
9D0056F0  AFA50024   SW A1, 36(SP)
9D0056F4  AFA40020   SW A0, 32(SP)
9D0056F8  AFA10014   SW AT, 20(SP)
9D0056FC  AFA20064   SW V0, 100(SP)
9D005700  AFA30060   SW V1, 96(SP)
9D005704  0F4000CE   JAL DRV_USBFS_USB_Handler
9D005708  00000000   NOP
9D00570C  03C0E825   OR SP, FP, ZERO
9D005710  8FA20064   LW V0, 100(SP)
9D005714  8FA30060   LW V1, 96(SP)
9D005718  8FBF005C   LW RA, 92(SP)
9D00571C  00400013   MTLO V0
9D005720  8FBE0058   LW FP, 88(SP)
9D005724  8FB90054   LW T9, 84(SP)
9D005728  00600011   MTHI V1
9D00572C  8FB80050   LW T8, 80(SP)
9D005730  8FAF004C   LW T7, 76(SP)
9D005734  8FAE0048   LW T6, 72(SP)
9D005738  8FAD0044   LW T5, 68(SP)
9D00573C  8FAC0040   LW T4, 64(SP)
9D005740  8FAB003C   LW T3, 60(SP)
9D005744  8FAA0038   LW T2, 56(SP)
9D005748  8FA90034   LW T1, 52(SP)
9D00574C  8FA80030   LW T0, 48(SP)
9D005750  8FA7002C   LW A3, 44(SP)
9D005754  8FA60028   LW A2, 40(SP)
9D005758  8FA50024   LW A1, 36(SP)
9D00575C  8FA40020   LW A0, 32(SP)
9D005760  8FA3001C   LW V1, 28(SP)
9D005764  8FA20018   LW V0, 24(SP)
9D005768  8FA10014   LW AT, 20(SP)
9D00576C  41606000   DI ZERO
9D005770  000000C0   EHB
9D005774  8FBA0074   LW K0, 116(SP)
9D005778  8FBB0070   LW K1, 112(SP)
9D00577C  409A7000   MTC0 K0, EPC
9D005780  8FBA006C   LW K0, 108(SP)
9D005784  27BD0078   ADDIU SP, SP, 120
9D005788  409A6002   MTC0 K0, SRSCtl
9D00578C  41DDE800   WRPGPR SP, SP
9D005790  409B6000   MTC0 K1, Status
9D005794  42000018   ERET
9D005798  415DE800   RDPGPR SP, SP
9D00579C  401A7000   MFC0 K0, EPC
9D0057A0  401B6000   MFC0 K1, Status
9D0057A4  27BDFF88   ADDIU SP, SP, -120
9D0057A8  AFBA0074   SW K0, 116(SP)
9D0057AC  401A6002   MFC0 K0, SRSCtl
9D0057B0  AFBB0070   SW K1, 112(SP)
9D0057B4  7C1B7844   INS K1, ZERO, 1, 15
9D0057B8  377B0400   ORI K1, K1, 1024
9D0057BC  AFBA006C   SW K0, 108(SP)
9D0057C0  409B6000   MTC0 K1, Status
9D0057C4  AFBE0058   SW FP, 88(SP)
9D0057C8  AFA3001C   SW V1, 28(SP)
9D0057CC  AFA20018   SW V0, 24(SP)
9D0057D0  00001810   MFHI V1
9D0057D4  03A0F025   OR FP, SP, ZERO
9D0057D8  AFBF005C   SW RA, 92(SP)
9D0057DC  00001012   MFLO V0
9D0057E0  AFB90054   SW T9, 84(SP)
9D0057E4  AFB80050   SW T8, 80(SP)
9D0057E8  AFAF004C   SW T7, 76(SP)
9D0057EC  AFAE0048   SW T6, 72(SP)
9D0057F0  AFAD0044   SW T5, 68(SP)
9D0057F4  AFAC0040   SW T4, 64(SP)
9D0057F8  AFAB003C   SW T3, 60(SP)
9D0057FC  AFAA0038   SW T2, 56(SP)
9D005800  AFA90034   SW T1, 52(SP)
9D005804  AFA80030   SW T0, 48(SP)
9D005808  AFA7002C   SW A3, 44(SP)
9D00580C  AFA60028   SW A2, 40(SP)
9D005810  AFA50024   SW A1, 36(SP)
9D005814  AFA40020   SW A0, 32(SP)
9D005818  AFA10014   SW AT, 20(SP)
9D00581C  AFA20064   SW V0, 100(SP)
9D005820  AFA30060   SW V1, 96(SP)
9D005824  0F4009C7   JAL UART_1_InterruptHandler
9D005828  00000000   NOP
9D00582C  03C0E825   OR SP, FP, ZERO
9D005830  8FA20064   LW V0, 100(SP)
9D005834  8FA30060   LW V1, 96(SP)
9D005838  8FBF005C   LW RA, 92(SP)
9D00583C  00400013   MTLO V0
9D005840  8FBE0058   LW FP, 88(SP)
9D005844  8FB90054   LW T9, 84(SP)
9D005848  00600011   MTHI V1
9D00584C  8FB80050   LW T8, 80(SP)
9D005850  8FAF004C   LW T7, 76(SP)
9D005854  8FAE0048   LW T6, 72(SP)
9D005858  8FAD0044   LW T5, 68(SP)
9D00585C  8FAC0040   LW T4, 64(SP)
9D005860  8FAB003C   LW T3, 60(SP)
9D005864  8FAA0038   LW T2, 56(SP)
9D005868  8FA90034   LW T1, 52(SP)
9D00586C  8FA80030   LW T0, 48(SP)
9D005870  8FA7002C   LW A3, 44(SP)
9D005874  8FA60028   LW A2, 40(SP)
9D005878  8FA50024   LW A1, 36(SP)
9D00587C  8FA40020   LW A0, 32(SP)
9D005880  8FA3001C   LW V1, 28(SP)
9D005884  8FA20018   LW V0, 24(SP)
9D005888  8FA10014   LW AT, 20(SP)
9D00588C  41606000   DI ZERO
9D005890  000000C0   EHB
9D005894  8FBA0074   LW K0, 116(SP)
9D005898  8FBB0070   LW K1, 112(SP)
9D00589C  409A7000   MTC0 K0, EPC
9D0058A0  8FBA006C   LW K0, 108(SP)
9D0058A4  27BD0078   ADDIU SP, SP, 120
9D0058A8  409A6002   MTC0 K0, SRSCtl
9D0058AC  41DDE800   WRPGPR SP, SP
9D0058B0  409B6000   MTC0 K1, Status
9D0058B4  42000018   ERET
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/btl_initialization.c  ----------------------
1:                   /*******************************************************************************
2:                     System Initialization File
3:                   
4:                     File Name:
5:                       initialization.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to initialize the system.
9:                   
10:                    Description:
11:                      This file contains source code necessary to initialize the system.  It
12:                      implements the "SYS_Initialize" function, defines the configuration bits,
13:                      and allocates any necessary global system resources,
14:                   *******************************************************************************/
15:                  
16:                  // DOM-IGNORE-BEGIN
17:                  /*******************************************************************************
18:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
19:                  *
20:                  * Subject to your compliance with these terms, you may use Microchip software
21:                  * and any derivatives exclusively with Microchip products. It is your
22:                  * responsibility to comply with third party license terms applicable to your
23:                  * use of third party software (including open source software) that may
24:                  * accompany Microchip software.
25:                  *
26:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
27:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
28:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
29:                  * PARTICULAR PURPOSE.
30:                  *
31:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
32:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
33:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
34:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
35:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
36:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
37:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
38:                   *******************************************************************************/
39:                  // DOM-IGNORE-END
40:                  
41:                  // *****************************************************************************
42:                  // *****************************************************************************
43:                  // Section: Included Files
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  #include "configuration.h"
47:                  #include "definitions.h"
48:                  #include "device.h"
49:                  #include "bootloader/bootloader_common.h"
50:                  
51:                  
52:                  // ****************************************************************************
53:                  // ****************************************************************************
54:                  // Section: Configuration Bits
55:                  // ****************************************************************************
56:                  // ****************************************************************************
57:                  
58:                  /*** DEVCFG0 ***/
59:                  #pragma config DEBUG =      OFF
60:                  #pragma config JTAGEN =     OFF
61:                  #pragma config ICESEL =     ICS_PGx1
62:                  #pragma config PWP =        OFF
63:                  #pragma config BWP =        OFF
64:                  #pragma config CP =         OFF
65:                  #pragma config SMCLR =      MCLR_NORM
66:                  
67:                  
68:                  /*** DEVCFG1 ***/
69:                  #pragma config FNOSC =      SPLL
70:                  #pragma config FPBDIV =     DIV_1
71:                  #pragma config FSOSCEN =    OFF
72:                  #pragma config IESO =       ON
73:                  #pragma config POSCMOD =    EC
74:                  #pragma config OSCIOFNC =   OFF
75:                  #pragma config FCKSM =      CSDCMD
76:                  #pragma config WDTPS =      PS1048576
77:                  #pragma config WDTSPGM =    ON
78:                  #pragma config FWDTEN =     OFF
79:                  #pragma config WINDIS =     OFF
80:                  #pragma config FWDTWINSZ =  WINSZ_25
81:                  
82:                  
83:                  /*** DEVCFG2 ***/
84:                  #pragma config BOREN =    ON
85:                  #pragma config FPLLIDIV =   DIV_2
86:                  #pragma config FPLLICLK =   PLL_POSC
87:                  #pragma config FPLLMUL =    MUL_18
88:                  #pragma config FPLLODIV =   DIV_1
89:                  #pragma config DSBOREN =    ON
90:                  #pragma config DSWDTPS =    DSPS32
91:                  #pragma config DSWDTOSC =   LPRC
92:                  #pragma config DSWDTEN =    OFF
93:                  #pragma config FDSEN =      ON
94:                  #pragma config UPLLEN =     ON
95:                  #pragma config UPLLIDIV =   DIV_2
96:                  
97:                  /*** DEVCFG3 ***/
98:                  #pragma config AI2C1 =      OFF
99:                  #pragma config AI2C2 =      OFF
100:                 #pragma config USERID =     0xffff
101:                 #pragma config PMDL1WAY =   ON
102:                 #pragma config IOL1WAY =    ON
103:                 #pragma config FUSBIDIO =   ON
104:                 
105:                 
106:                 
107:                 
108:                 
109:                 // *****************************************************************************
110:                 // *****************************************************************************
111:                 // Section: Driver Initialization Data
112:                 // *****************************************************************************
113:                 // *****************************************************************************
114:                 
115:                 
116:                 // *****************************************************************************
117:                 // *****************************************************************************
118:                 // Section: System Data
119:                 // *****************************************************************************
120:                 // *****************************************************************************
121:                 /* Structure to hold the object handles for the modules in the system. */
122:                 SYSTEM_OBJECTS sysObj;
123:                 
124:                 // *****************************************************************************
125:                 // *****************************************************************************
126:                 // Section: Library/Stack Initialization Data
127:                 // *****************************************************************************
128:                 // *****************************************************************************
129:                 /******************************************************
130:                  * USB Driver Initialization
131:                  ******************************************************/
132:                  
133:                 uint8_t __attribute__((aligned(512))) endPointTable1[DRV_USBFS_ENDPOINTS_NUMBER * 32];
134:                 
135:                 
136:                 const DRV_USBFS_INIT drvUSBFSInit =
137:                 {
138:                 	 /* Assign the endpoint table */
139:                     .endpointTable= endPointTable1,
140:                 
141:                 
142:                 	/* Interrupt Source for USB module */
143:                 	.interruptSource = INT_SOURCE_USB,
144:                 
145:                 
146:                     
147:                     /* USB Controller to operate as USB Device */
148:                     .operationMode = DRV_USBFS_OPMODE_DEVICE,
149:                 	
150:                 	.operationSpeed = USB_SPEED_FULL,
151:                  
152:                 	/* Stop in idle */
153:                     .stopInIdle = false,
154:                 	
155:                 	    /* Suspend in sleep */
156:                     .suspendInSleep = false,
157:                  
158:                     /* Identifies peripheral (PLIB-level) ID */
159:                     .usbID = USB_ID_1,
160:                 	
161:                 
162:                 };
163:                 
164:                 
165:                 
166:                 
167:                 
168:                 
169:                 
170:                 
171:                 // *****************************************************************************
172:                 // *****************************************************************************
173:                 // Section: System Initialization
174:                 // *****************************************************************************
175:                 // *****************************************************************************
176:                 
177:                 
178:                 
179:                 // *****************************************************************************
180:                 // *****************************************************************************
181:                 // Section: Local initialization functions
182:                 // *****************************************************************************
183:                 // *****************************************************************************
184:                 
185:                 
186:                 
187:                 /*******************************************************************************
188:                   Function:
189:                     void SYS_Initialize ( void *data )
190:                 
191:                   Summary:
192:                     Initializes the board, services, drivers, application and other modules.
193:                 
194:                   Remarks:
195:                  */
196:                 
197:                 void SYS_Initialize ( void* data )
198:                 {
199:                     /* MISRAC 2012 deviation block start */
200:                     /* MISRA C-2012 Rule 2.2 deviated in this file.  Deviation record ID -  H3_MISRAC_2012_R_2_2_DR_1 */
201:                 
202:                     /* Start out with interrupts disabled before configuring any modules */
203:                     __builtin_disable_interrupts();
204:                     
205:                     CLK_Initialize();
206:                     
207:                     /* Set the SRAM wait states to One */
208:                     BMXCONbits.BMXWSDRM = 1;
209:                     
210:                     GPIO_Initialize();
211:                     
212:                     run_Application(APP_JUMP_ADDRESS);
213:                 
214:                     /* Configure KSEG0 as cacheable memory. This is needed for Prefetch Buffer */
215:                     __builtin_mtc0(16, 0,(__builtin_mfc0(16, 0) | 0x3));
216:                 
217:                     /* Configure Flash Wait States and Prefetch */
218:                     CHECONbits.PFMWS = 3;
219:                     CHECONbits.PREFEN = 3;
220:                 
221:                     /* Set the SRAM wait states to One */
222:                     BMXCONbits.BMXWSDRM = 1;
223:                 
224:                 
225:                 
226:                 
227:                 	
228:                 //	POWER_Initialize();
229:                 
230:                 
231:                 //    ADC_Initialize();
232:                 
233:                     NVM_Initialize();
234:                 
235:                     CORETIMER_Initialize();
236:                 	UART1_Initialize();
237:                 
238:                 //	UART2_Initialize();
239:                 
240:                 //    TMR2_Initialize();
241:                 
242:                 
243:                 	SPI1_Initialize();
244:                 
245:                 
246:                 
247:                 
248:                 
249:                     /* Initialize the USB device layer */
250:                     sysObj.usbDevObject0 = USB_DEVICE_Initialize (USB_DEVICE_INDEX_0 , ( SYS_MODULE_INIT* ) & usbDevInitData);
251:                 
252:                 
253:                 	/* Initialize USB Driver */ 
254:                     sysObj.drvUSBFSObject = DRV_USBFS_Initialize(DRV_USBFS_INDEX_0, (SYS_MODULE_INIT *) &drvUSBFSInit);	
255:                 
256:                 
257:                     APP_Initialize();
258:                     APP_USB_Initialize();
259:                     APP_BLE_Initialize();
260:                     //APP_X1TXO_Initialize();
261:                 
262:                 
263:                     EVIC_Initialize();
264:                 
265:                 	/* Enable global interrupts */
266:                     __builtin_enable_interrupts();
267:                 
268:                 
269:                     /* MISRAC 2012 deviation block end */
270:                 }
271:                 
272:                 
273:                 /*******************************************************************************
274:                  End of File
275:                 */
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D005E08  27BDFFE0   ADDIU SP, SP, -32
9D005E0C  AFBF001C   SW RA, 28(SP)
9D005E10  AFB10018   SW S1, 24(SP)
9D005E14  AFB00014   SW S0, 20(SP)
9D005E18  41626000   DI V0
9D005E1C  000000C0   EHB
9D005E20  0F401EC6   JAL CLK_Initialize
9D005E24  3C10BF88   LUI S0, -16504
9D005E28  8E022000   LW V0, 8192(S0)
9D005E2C  24110001   ADDIU S1, ZERO, 1
9D005E30  7E223184   INS V0, S1, 6, 1
9D005E34  AE022000   SW V0, 8192(S0)
9D005E38  0F401C13   JAL GPIO_Initialize
9D005E3C  00000000   NOP
9D005E40  3C049D00   LUI A0, -25344
9D005E44  0F401E24   JAL run_Application
9D005E48  3484A000   ORI A0, A0, -24576
9D005E4C  40028000   MFC0 V0, Config
9D005E50  34420003   ORI V0, V0, 3
9D005E54  40828000   MTC0 V0, Config
9D005E58  000000C0   EHB
9D005E5C  8E024000   LW V0, 16384(S0)
9D005E60  24030003   ADDIU V1, ZERO, 3
9D005E64  7C621004   INS V0, V1, 0, 3
9D005E68  AE024000   SW V0, 16384(S0)
9D005E6C  8E024000   LW V0, 16384(S0)
9D005E70  7C622904   INS V0, V1, 4, 2
9D005E74  AE024000   SW V0, 16384(S0)
9D005E78  8E022000   LW V0, 8192(S0)
9D005E7C  7E223184   INS V0, S1, 6, 1
9D005E80  AE022000   SW V0, 8192(S0)
9D005E84  0F401C35   JAL NVM_Initialize
9D005E88  27908038   ADDIU S0, GP, -32712
9D005E8C  0F401F41   JAL CORETIMER_Initialize
9D005E90  00000000   NOP
9D005E94  0F40196E   JAL UART1_Initialize
9D005E98  00000000   NOP
9D005E9C  0F401D95   JAL SPI1_Initialize
9D005EA0  00000000   NOP
9D005EA4  3C059D00   LUI A1, -25344
9D005EA8  24A57F80   ADDIU A1, A1, 32640
9D005EAC  0F40142E   JAL USB_DEVICE_Initialize
9D005EB0  00002025   OR A0, ZERO, ZERO
9D005EB4  3C059D01   LUI A1, -25343
9D005EB8  24A58138   ADDIU A1, A1, -32456
9D005EBC  00002025   OR A0, ZERO, ZERO
9D005EC0  0F4013E2   JAL DRV_USBFS_Initialize
9D005EC4  AE020000   SW V0, 0(S0)
9D005EC8  0F4020C8   JAL APP_Initialize
9D005ECC  AE020004   SW V0, 4(S0)
9D005ED0  0F4019A0   JAL APP_USB_Initialize
9D005ED4  00000000   NOP
9D005ED8  0F401D2D   JAL APP_BLE_Initialize
9D005EDC  00000000   NOP
9D005EE0  0F401F81   JAL EVIC_Initialize
9D005EE4  00000000   NOP
9D005EE8  41626020   EI V0
9D005EEC  8FBF001C   LW RA, 28(SP)
9D005EF0  8FB10018   LW S1, 24(SP)
9D005EF4  8FB00014   LW S0, 20(SP)
9D005EF8  03E00008   JR RA
9D005EFC  27BD0020   ADDIU SP, SP, 32
---  c:/users/db/desktop/nano_tx/firmware/src/btl_app_usb.c  --------------------------------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                     
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       app_usb.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It 
15:                      implements the logic of the application's state machine and it may call 
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
27:                  *
28:                  * Subject to your compliance with these terms, you may use Microchip software
29:                  * and any derivatives exclusively with Microchip products. It is your
30:                  * responsibility to comply with third party license terms applicable to your
31:                  * use of third party software (including open source software) that may
32:                  * accompany Microchip software.
33:                  *
34:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
35:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
36:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
37:                  * PARTICULAR PURPOSE.
38:                  *
39:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
40:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
41:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
42:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
43:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
44:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
45:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  // Section: Included Files 
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  
56:                  #include "app_usb.h"
57:                  
58:                  
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  // Section: Global Data Definitions
62:                  // *****************************************************************************
63:                  // *****************************************************************************
64:                  
65:                  //extern bool taskBusy;
66:                  uint8_t CACHE_ALIGN cdcReadBuffer[APP_USB_READ_BUFFER_SIZE];
67:                  uint8_t CACHE_ALIGN cdcWriteBuffer[APP_USB_READ_BUFFER_SIZE];
68:                  uint8_t appUsbHostOutStreamBuffer[APP_USB_STREAM_BUFFER_SIZE];
69:                  uint8_t appUsbHostInStreamBuffer[APP_USB_STREAM_BUFFER_SIZE];
70:                  RINGBUFFER* appUsbRbHostOut = NULL;
71:                  RINGBUFFER* appUsbRbHostIn = NULL;
72:                  
73:                  // *****************************************************************************
74:                  /* Application Data
75:                  
76:                    Summary:
77:                      Holds application data
78:                  
79:                    Description:
80:                      This structure holds the application's data.
81:                  
82:                    Remarks:
83:                      This structure should be initialized by the APP_Initialize function.
84:                      
85:                      Application strings and buffers are be defined outside this structure.
86:                  */
87:                  
88:                  APP_USB_DATA appUsbData;
89:                  
90:                  
91:                  // *****************************************************************************
92:                  // *****************************************************************************
93:                  // Section: Application Callback Functions
94:                  // *****************************************************************************
95:                  // *****************************************************************************
96:                  
97:                  
98:                  
99:                  /*******************************************************
100:                  * USB CDC Device Events - Application Event Handler
101:                  *******************************************************/
102:                 
103:                 USB_DEVICE_CDC_EVENT_RESPONSE APP_USBDeviceCDCEventHandler
104:                 (
105:                     USB_DEVICE_CDC_INDEX index,
106:                     USB_DEVICE_CDC_EVENT event,
107:                     void * pData,
108:                     uintptr_t userData
109:                 )
110:                 {
111:                     APP_USB_DATA * appDataObject;
112:                     USB_CDC_CONTROL_LINE_STATE * controlLineStateData;
113:                     USB_DEVICE_CDC_EVENT_DATA_READ_COMPLETE * eventDataRead;
114:                     
115:                     appDataObject = (APP_USB_DATA *)userData;
116:                 
117:                     switch(event)
118:                     {
119:                         case USB_DEVICE_CDC_EVENT_GET_LINE_CODING:
120:                 
121:                             /* This means the host wants to know the current line
122:                              * coding. This is a control transfer request. Use the
123:                              * USB_DEVICE_ControlSend() function to send the data to
124:                              * host.  */
125:                 
126:                             USB_DEVICE_ControlSend(appDataObject->deviceHandle,
127:                                     &appDataObject->getLineCodingData, sizeof(USB_CDC_LINE_CODING));
128:                 
129:                             break;
130:                 
131:                         case USB_DEVICE_CDC_EVENT_SET_LINE_CODING:
132:                 
133:                             /* This means the host wants to set the line coding.
134:                              * This is a control transfer request. Use the
135:                              * USB_DEVICE_ControlReceive() function to receive the
136:                              * data from the host */
137:                 
138:                             USB_DEVICE_ControlReceive(appDataObject->deviceHandle,
139:                                     &appDataObject->setLineCodingData, sizeof(USB_CDC_LINE_CODING));
140:                 
141:                             break;
142:                 
143:                         case USB_DEVICE_CDC_EVENT_SET_CONTROL_LINE_STATE:
144:                 
145:                             /* This means the host is setting the control line state.
146:                              * Read the control line state. We will accept this request
147:                              * for now. */
148:                 
149:                             controlLineStateData = (USB_CDC_CONTROL_LINE_STATE *)pData;
150:                             appDataObject->controlLineStateData.dtr = controlLineStateData->dtr;
151:                             appDataObject->controlLineStateData.carrier = controlLineStateData->carrier;
152:                 
153:                             USB_DEVICE_ControlStatus(appDataObject->deviceHandle, USB_DEVICE_CONTROL_STATUS_OK);
154:                 
155:                             break;
156:                 
157:                         case USB_DEVICE_CDC_EVENT_SEND_BREAK:
158:                 
159:                             /* This means that the host is requesting that a break of the
160:                              * specified duration be sent. Read the break duration */
161:                 
162:                             appDataObject->breakData = ((USB_DEVICE_CDC_EVENT_DATA_SEND_BREAK *)pData)->breakDuration;
163:                             
164:                             /* Complete the control transfer by sending a ZLP  */
165:                             USB_DEVICE_ControlStatus(appDataObject->deviceHandle, USB_DEVICE_CONTROL_STATUS_OK);
166:                             
167:                             break;
168:                 
169:                         case USB_DEVICE_CDC_EVENT_READ_COMPLETE:
170:                 
171:                             /* This means that the host has sent some data*/
172:                             eventDataRead = (USB_DEVICE_CDC_EVENT_DATA_READ_COMPLETE *)pData;
173:                             appDataObject->isReadComplete = true;
174:                             appDataObject->numBytesRead = eventDataRead->length; 
175:                             break;
176:                 
177:                         case USB_DEVICE_CDC_EVENT_CONTROL_TRANSFER_DATA_RECEIVED:
178:                 
179:                             /* The data stage of the last control transfer is
180:                              * complete. For now we accept all the data */
181:                 
182:                             USB_DEVICE_ControlStatus(appDataObject->deviceHandle, USB_DEVICE_CONTROL_STATUS_OK);
183:                             break;
184:                 
185:                         case USB_DEVICE_CDC_EVENT_CONTROL_TRANSFER_DATA_SENT:
186:                 
187:                             /* This means the GET LINE CODING function data is valid. We don't
188:                              * do much with this data in this demo. */
189:                             break;
190:                 
191:                         case USB_DEVICE_CDC_EVENT_WRITE_COMPLETE:
192:                 
193:                             /* This means that the data write got completed. We can schedule
194:                              * the next read. */
195:                 
196:                             appDataObject->isWriteComplete = true;
197:                             break;
198:                 
199:                         default:
200:                             break;
201:                     }
202:                 
203:                     return USB_DEVICE_CDC_EVENT_RESPONSE_NONE;
204:                 }
205:                 
206:                 /***********************************************
207:                  * Application USB Device Layer Event Handler.
208:                  ***********************************************/
209:                 void APP_USBDeviceEventHandler 
210:                 (
211:                     USB_DEVICE_EVENT event, 
212:                     void * eventData, 
213:                     uintptr_t context 
214:                 )
215:                 {
216:                     USB_DEVICE_EVENT_DATA_CONFIGURED *configuredEventData;
217:                 
218:                     switch(event)
219:                     {
220:                         case USB_DEVICE_EVENT_SOF:
221:                 
222:                             appUsbData.sofEventHasOccurred = true;
223:                             
224:                             break;
225:                 
226:                         case USB_DEVICE_EVENT_RESET:
227:                 
228:                             /* Update LED to show reset state */
229:                             //LED_Off();
230:                 
231:                             appUsbData.isConfigured = false;
232:                 
233:                             break;
234:                 
235:                         case USB_DEVICE_EVENT_CONFIGURED:
236:                 
237:                             /* Check the configuration. We only support configuration 1 */
238:                             configuredEventData = (USB_DEVICE_EVENT_DATA_CONFIGURED*)eventData;
239:                             
240:                             if ( configuredEventData->configurationValue == 1)
241:                             {
242:                                 /* Update LED to show configured state */
243:                                 //LED_On();
244:                                 
245:                                 /* Register the CDC Device application event handler here.
246:                                  * Note how the appData object pointer is passed as the
247:                                  * user data */
248:                 
249:                                 USB_DEVICE_CDC_EventHandlerSet(USB_DEVICE_CDC_INDEX_0, APP_USBDeviceCDCEventHandler, (uintptr_t)&appUsbData);
250:                 
251:                                 /* Mark that the device is now configured */
252:                                 appUsbData.isConfigured = true;
253:                             }
254:                             
255:                             break;
256:                 
257:                         case USB_DEVICE_EVENT_POWER_DETECTED:
258:                 
259:                             /* VBUS was detected. We can attach the device */
260:                             USB_DEVICE_Attach(appUsbData.deviceHandle);
261:                             
262:                             /* Mark that the device is now attached */
263:                             appUsbData.isAttached = true;
264:                             
265:                             break;
266:                 
267:                         case USB_DEVICE_EVENT_POWER_REMOVED:
268:                 
269:                             /* VBUS is not available any more. Detach the device. */
270:                             USB_DEVICE_Detach(appUsbData.deviceHandle);
271:                             
272:                             /* Mark that the device is now detached */
273:                             appUsbData.isAttached = false;
274:                             
275:                             //LED_Off();
276:                             
277:                             break;
278:                 
279:                         case USB_DEVICE_EVENT_SUSPENDED:
280:                 
281:                             //LED_Off();
282:                             
283:                             break;
284:                 
285:                         case USB_DEVICE_EVENT_RESUMED:
286:                         case USB_DEVICE_EVENT_ERROR:
287:                         default:
288:                             
289:                             break;
290:                     }
291:                 }
292:                 
293:                 // *****************************************************************************
294:                 // *****************************************************************************
295:                 // Section: Application Local Functions
296:                 // *****************************************************************************
297:                 // *****************************************************************************
298:                 
299:                 /*****************************************************
300:                  * This function is called in every step of the
301:                  * application state machine.
302:                  *****************************************************/
303:                 
304:                 bool APP_StateReset(void)
305:                 {
306:                     /* This function returns true if the device
307:                      * was reset  */
308:                 
309:                     bool retVal;
310:                 
311:                     if(appUsbData.isConfigured == false)
312:                     {
313:                         appUsbData.state = APP_USB_STATE_WAIT_FOR_CONFIGURATION;
314:                         appUsbData.readTransferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
315:                         appUsbData.writeTransferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
316:                         appUsbData.isReadComplete = true;
317:                         appUsbData.numBytesRead = 0;
318:                         appUsbData.isWriteComplete = true;
319:                         retVal = true;
320:                     }
321:                     else
322:                     {
323:                         retVal = false;
324:                     }
325:                 
326:                     return(retVal);
327:                 }
328:                 
329:                 // *****************************************************************************
330:                 // *****************************************************************************
331:                 // Section: Application Initialization and State Machine Functions
332:                 // *****************************************************************************
333:                 // *****************************************************************************
334:                 
335:                 /*******************************************************************************
336:                   Function:
337:                     void APP_Initialize(void)
338:                 
339:                   Remarks:
340:                     See prototype in app.h.
341:                  */
342:                 
343:                 void APP_USB_Initialize(void)
344:                 {
345:                     /* Place the App state machine in its initial state. */
346:                     appUsbData.state = APP_STATE_INIT;
347:                     
348:                     /* Device Layer Handle  */
349:                     appUsbData.deviceHandle = USB_DEVICE_HANDLE_INVALID ;
350:                 
351:                     /* Device configured status */
352:                     appUsbData.isConfigured = false;
353:                 
354:                     /* Initial get line coding state */
355:                     appUsbData.getLineCodingData.dwDTERate = 9600;
356:                     appUsbData.getLineCodingData.bParityType = 0;
357:                     appUsbData.getLineCodingData.bParityType = 0;
358:                     appUsbData.getLineCodingData.bDataBits = 8;
359:                 
360:                     /* Read Transfer Handle */
361:                     appUsbData.readTransferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
362:                 
363:                     /* Write Transfer Handle */
364:                     appUsbData.writeTransferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
365:                 
366:                     /* Initialize the read complete flag and the pending read bytes count */
367:                     appUsbData.isReadComplete = true;
368:                     appUsbData.numBytesRead = 0;
369:                 
370:                     /*Initialize the write complete flag*/
371:                     appUsbData.isWriteComplete = true;
372:                 
373:                     /* Reset other flags */
374:                     appUsbData.sofEventHasOccurred = false;
375:                 
376:                     /* Set up the USB CDC read buffer */
377:                     appUsbData.cdcReadBuffer = &cdcReadBuffer[0];
378:                 
379:                     /* Set up the USB CDC write buffer */
380:                     appUsbData.cdcWriteBuffer = &cdcWriteBuffer[0];      
381:                     
382:                     /* Set up the host output stream buffer */
383:                     RB_Init(&appUsbData.rbHostOut,
384:                             appUsbHostOutStreamBuffer,
385:                             sizeof(appUsbHostOutStreamBuffer));
386:                     appUsbRbHostOut = &appUsbData.rbHostOut;
387:                     
388:                     /* Set up the host input stream buffer */
389:                     RB_Init(&appUsbData.rbHostIn,
390:                             appUsbHostInStreamBuffer,
391:                             sizeof(appUsbHostInStreamBuffer));
392:                     appUsbRbHostIn = &appUsbData.rbHostIn;
393:                 }
394:                 
395:                 
396:                 /******************************************************************************
397:                   Function:
398:                     void APP_Tasks(void)
399:                 
400:                   Remarks:
401:                     See prototype in app.h.
402:                  */
403:                 
404:                 void APP_USB_Tasks(void)
405:                 {
406:                 //    /* Do not enter idle state while USB device is attached */
407:                 //    if (appUsbData.isAttached) {
408:                 //        taskBusy = true;
409:                 //    }
410:                     
411:                     /* Update the application state machine based
412:                      * on the current state */
413:                     //int i;
414:                     
415:                     switch(appUsbData.state)
416:                     {
417:                         case APP_STATE_INIT:
418:                 
419:                             /* Open the device layer */
420:                             appUsbData.deviceHandle = USB_DEVICE_Open( USB_DEVICE_INDEX_0, DRV_IO_INTENT_READWRITE );
421:                 
422:                             if(appUsbData.deviceHandle != USB_DEVICE_HANDLE_INVALID)
423:                             {
424:                                 /* Register a callback with device layer to get event notification (for end point 0) */
425:                                 USB_DEVICE_EventHandlerSet(appUsbData.deviceHandle, APP_USBDeviceEventHandler, 0);
426:                 
427:                                 appUsbData.state = APP_USB_STATE_WAIT_FOR_CONFIGURATION;
428:                             }
429:                             else
430:                             {
431:                                 /* The Device Layer is not ready to be opened. We should try
432:                                  * again later. */
433:                             }
434:                 
435:                             break;
436:                 
437:                         case APP_USB_STATE_WAIT_FOR_CONFIGURATION:
438:                 
439:                             /* Check if the device was configured */
440:                             if(appUsbData.isConfigured)
441:                             {
442:                                 /* If the device is configured then lets start reading */
443:                                 appUsbData.state = APP_USB_STATE_SCHEDULE_READ;
444:                             }
445:                             
446:                             break;
447:                 
448:                         case APP_USB_STATE_SCHEDULE_READ:
449:                 
450:                             if(APP_StateReset())
451:                             {
452:                                 break;
453:                             }
454:                 
455:                             /* If a read is complete, then schedule a read
456:                              * else wait for the current read to complete */
457:                 
458:                             appUsbData.state = APP_USB_STATE_WAIT_FOR_READ_COMPLETE;
459:                             if ((appUsbData.isReadComplete == true) && (appUsbData.numBytesRead == 0))
460:                             {
461:                                 appUsbData.isReadComplete = false;
462:                                 appUsbData.readTransferHandle =  USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
463:                 
464:                                 USB_DEVICE_CDC_Read (USB_DEVICE_CDC_INDEX_0,
465:                                         &appUsbData.readTransferHandle, appUsbData.cdcReadBuffer,
466:                                         APP_USB_READ_BUFFER_SIZE);
467:                                 
468:                                 if(appUsbData.readTransferHandle == USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID)
469:                                 {
470:                                     appUsbData.state = APP_USB_STATE_ERROR;
471:                                     break;
472:                                 }
473:                             }
474:                 
475:                             break;
476:                 
477:                         case APP_USB_STATE_WAIT_FOR_READ_COMPLETE:
478:                 
479:                             if (APP_StateReset())
480:                             {
481:                                 break;
482:                             }
483:                 
484:                             /* Check if a character was received the isReadComplete flag gets 
485:                              * updated in the CDC event handler. */
486:                             if (appUsbData.isReadComplete)
487:                             {
488:                                 if (appUsbData.numBytesRead < RB_GetFree(&appUsbData.rbHostOut))
489:                                 {
490:                                     RB_Write(&appUsbData.rbHostOut, 
491:                                          appUsbData.cdcReadBuffer,
492:                                          appUsbData.numBytesRead);
493:                                     appUsbData.numBytesRead = 0;
494:                                 }
495:                             }
496:                             
497:                             /* Schedule write.
498:                              * If the read is not complete yet we will wait for it as soon as
499:                              * there are no pending writes.
500:                              * See https://github.com/Microchip-MPLAB-Harmony/usb_apps_device/blob/master/apps/cdc_com_port_single/firmware/src/app.c
501:                              * for example. */
502:                             appUsbData.state = APP_USB_STATE_SCHEDULE_WRITE;
503:                             
504:                             break;
505:                 
506:                 
507:                         case APP_USB_STATE_SCHEDULE_WRITE:
508:                 
509:                             if (APP_StateReset())
510:                             {
511:                                 break;
512:                             }
513:                             
514:                 //            /* Skip write and go ahead with read if no data pending for
515:                 //             * write. */
516:                 //            if (RB_GetUsed(&appUsbData.rbHostIn) == 0)
517:                 //            {
518:                 //                appUsbData.state = APP_USB_STATE_SCHEDULE_READ;
519:                 //                break;
520:                 //            }
521:                 
522:                 
523:                 
524:                 //            /* Else echo each received character by adding 1 */
525:                 //            for(i = 0; i < appUsbData.numBytesRead; i++)
526:                 //            {
527:                 //                if((appUsbData.cdcReadBuffer[i] != 0x0A) && (appUsbData.cdcReadBuffer[i] != 0x0D))
528:                 //                {
529:                 //                    appUsbData.cdcWriteBuffer[i] = appUsbData.cdcReadBuffer[i] + 1;
530:                 //                }
531:                 //            }
532:                             
533:                             /* Read data from host input stream buffer */
534:                             uint32_t writeBytes = 0;
535:                             writeBytes = RB_Read(&appUsbData.rbHostIn,
536:                                     appUsbData.cdcWriteBuffer,
537:                                     APP_USB_READ_BUFFER_SIZE);
538:                             USB_DEVICE_CDC_TRANSFER_FLAGS txFlags
539:                                     = USB_DEVICE_CDC_TRANSFER_FLAGS_DATA_COMPLETE;
540:                             if (RB_GetUsed(&appUsbData.rbHostIn) > 0) {
541:                                 txFlags = USB_DEVICE_CDC_TRANSFER_FLAGS_MORE_DATA_PENDING;
542:                             }
543:                             
544:                             /* Skip write and go ahead with read if no data pending for
545:                              * write. */
546:                             if (writeBytes == 0)
547:                             {
548:                                 appUsbData.state = APP_USB_STATE_SCHEDULE_READ;
549:                                 break;
550:                             }
551:                                     /* Setup the write */
552:                             appUsbData.writeTransferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
553:                             appUsbData.isWriteComplete = false;
554:                             appUsbData.state = APP_USB_STATE_WAIT_FOR_WRITE_COMPLETE;            
555:                             
556:                             USB_DEVICE_CDC_Write(USB_DEVICE_CDC_INDEX_0,
557:                                     &appUsbData.writeTransferHandle,
558:                                     appUsbData.cdcWriteBuffer, writeBytes,
559:                                     txFlags);
560:                 
561:                             break;
562:                 
563:                         case APP_USB_STATE_WAIT_FOR_WRITE_COMPLETE:
564:                 
565:                             if(APP_StateReset())
566:                             {
567:                                 break;
568:                             }
569:                 
570:                             /* Check if a character was sent. The isWriteComplete
571:                              * flag gets updated in the CDC event handler */
572:                 
573:                             if(appUsbData.isWriteComplete == true)
574:                             {
575:                                 appUsbData.state = APP_USB_STATE_SCHEDULE_READ;
576:                             }
577:                 
578:                             break;
579:                 
580:                         case APP_USB_STATE_ERROR:
581:                         default:
582:                             
583:                             break;
584:                     }
585:                 }
586:                 
587:                 /*******************************************************************************
588:                  End of File
589:                  */
590:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000018  00000000   NOP
9D002DA8  27BDFFD8   ADDIU SP, SP, -40
9D002DAC  AFB1001C   SW S1, 28(SP)
9D002DB0  3C11A000   LUI S1, -24576
9D002DB4  AFB00018   SW S0, 24(SP)
9D002DB8  263008D0   ADDIU S0, S1, 2256
9D002DBC  8E020004   LW V0, 4(S0)
9D002DC0  AFBF0024   SW RA, 36(SP)
9D002DC4  2C430006   SLTIU V1, V0, 6
9D002DC8  1060001B   BEQ V1, ZERO, 0x9D002E38
9D002DCC  AFB20020   SW S2, 32(SP)
9D002DD0  00021880   SLL V1, V0, 2
9D002DD4  3C029D00   LUI V0, -25344
9D002DD8  24422DEC   ADDIU V0, V0, 11756
9D002DDC  00431021   ADDU V0, V0, V1
9D002DE0  8C420000   LW V0, 0(V0)
9D002DE4  00400008   JR V0
9D002DE8  00000000   NOP
9D002E04  24050003   ADDIU A1, ZERO, 3
9D002E10  2403FFFF   ADDIU V1, ZERO, -1
9D002E14  10430008   BEQ V0, V1, 0x9D002E38
9D002E18  AE2208D0   SW V0, 2256(S1)
9D002E1C  3C059D00   LUI A1, -25344
9D002E20  00402025   OR A0, V0, ZERO
9D002E24  00003025   OR A2, ZERO, ZERO
9D002E28  0F401ED9   JAL USB_DEVICE_EventHandlerSet
9D002E2C  24A55310   ADDIU A1, A1, 21264
9D002E30  24020001   ADDIU V0, ZERO, 1
9D002E34  AE020004   SW V0, 4(S0)
9D002E38  8FBF0024   LW RA, 36(SP)
9D002E3C  8FB20020   LW S2, 32(SP)
9D002E40  8FB1001C   LW S1, 28(SP)
9D002E44  8FB00018   LW S0, 24(SP)
9D002E48  03E00008   JR RA
9D002E4C  27BD0028   ADDIU SP, SP, 40
9D002E50  9202000F   LBU V0, 15(S0)
9D002E64  1440FFF5   BNE V0, ZERO, 0x9D002E3C
9D002E68  8FBF0024   LW RA, 36(SP)
9D002E6C  8E05002C   LW A1, 44(S0)
9D002E70  3C11A000   LUI S1, -24576
9D002E74  24060800   ADDIU A2, ZERO, 2048
9D002E78  0F401DF7   JAL RB_Read
9D002E7C  26240918   ADDIU A0, S1, 2328
9D002E80  26240918   ADDIU A0, S1, 2328
9D002E84  0F4000E4   JAL RB_GetUsed
9D002E88  00409025   OR S2, V0, ZERO
9D002E8C  0002102B   SLTU V0, ZERO, V0
9D002E90  16400059   BNE S2, ZERO, 0x9D002FF8
9D002E94  24420001   ADDIU V0, V0, 1
9D002E98  24020002   ADDIU V0, ZERO, 2
9D002E9C  AE020004   SW V0, 4(S0)
9D002EA0  8FBF0024   LW RA, 36(SP)
9D002EA4  8FB20020   LW S2, 32(SP)
9D002EA8  8FB1001C   LW S1, 28(SP)
9D002EAC  8FB00018   LW S0, 24(SP)
9D002EB0  03E00008   JR RA
9D002EB4  27BD0028   ADDIU SP, SP, 40
9D002EB8  9202000F   LBU V0, 15(S0)
9D002ECC  1440FFDB   BNE V0, ZERO, 0x9D002E3C
9D002ED0  8FBF0024   LW RA, 36(SP)
9D002ED4  92020021   LBU V0, 33(S0)
9D002ED8  1040FFD8   BEQ V0, ZERO, 0x9D002E3C
9D002EDC  8FBF0024   LW RA, 36(SP)
9D002EE0  24020002   ADDIU V0, ZERO, 2
9D002EE4  1000FFEE   BEQ ZERO, ZERO, 0x9D002EA0
9D002EE8  AE020004   SW V0, 4(S0)
9D002EEC  9202000F   LBU V0, 15(S0)
9D002F00  1440FFCE   BNE V0, ZERO, 0x9D002E3C
9D002F04  8FBF0024   LW RA, 36(SP)
9D002F08  92020020   LBU V0, 32(S0)
9D002F0C  24030003   ADDIU V1, ZERO, 3
9D002F10  1040FFC9   BEQ V0, ZERO, 0x9D002E38
9D002F14  AE030004   SW V1, 4(S0)
9D002F18  8E020030   LW V0, 48(S0)
9D002F1C  1440FFC7   BNE V0, ZERO, 0x9D002E3C
9D002F20  8FBF0024   LW RA, 36(SP)
9D002F24  8E060028   LW A2, 40(S0)
9D002F28  3C05A000   LUI A1, -24576
9D002F2C  2411FFFF   ADDIU S1, ZERO, -1
9D002F30  24070800   ADDIU A3, ZERO, 2048
9D002F34  24A508E8   ADDIU A1, A1, 2280
9D002F38  00002025   OR A0, ZERO, ZERO
9D002F3C  A2000020   SB ZERO, 32(S0)
9D002F40  0F40104C   JAL USB_DEVICE_CDC_Read
9D002F44  AE110018   SW S1, 24(S0)
9D002F48  8E020018   LW V0, 24(S0)
9D002F4C  1451FFBB   BNE V0, S1, 0x9D002E3C
9D002F50  8FBF0024   LW RA, 36(SP)
9D002F54  24020006   ADDIU V0, ZERO, 6
9D002F58  1000FFB7   BEQ ZERO, ZERO, 0x9D002E38
9D002F5C  AE020004   SW V0, 4(S0)
9D002F60  9202000F   LBU V0, 15(S0)
9D002F74  1440FFB1   BNE V0, ZERO, 0x9D002E3C
9D002F78  8FBF0024   LW RA, 36(SP)
9D002F7C  92020020   LBU V0, 32(S0)
9D002F80  5440000F   BNEL V0, ZERO, 0x9D002FC0
9D002F84  8E110030   LW S1, 48(S0)
9D002F88  24020004   ADDIU V0, ZERO, 4
9D002F8C  AE020004   SW V0, 4(S0)
9D002F90  8FBF0024   LW RA, 36(SP)
9D002F94  8FB20020   LW S2, 32(SP)
9D002F98  8FB1001C   LW S1, 28(SP)
9D002F9C  8FB00018   LW S0, 24(SP)
9D002FA0  03E00008   JR RA
9D002FA4  27BD0028   ADDIU SP, SP, 40
9D002FA8  9202000F   LBU V0, 15(S0)
9D002FAC  1040FFA3   BEQ V0, ZERO, 0x9D002E3C
9D002FB0  8FBF0024   LW RA, 36(SP)
9D002FB4  24020002   ADDIU V0, ZERO, 2
9D002FB8  1000FFB9   BEQ ZERO, ZERO, 0x9D002EA0
9D002FBC  AE020004   SW V0, 4(S0)
9D002FC0  3C12A000   LUI S2, -24576
9D002FC4  0F4000D2   JAL RB_GetFree
9D002FC8  26440908   ADDIU A0, S2, 2312
9D002FCC  0222102B   SLTU V0, S1, V0
9D002FD0  1040FFEE   BEQ V0, ZERO, 0x9D002F8C
9D002FD4  24020004   ADDIU V0, ZERO, 4
9D002FD8  8E060030   LW A2, 48(S0)
9D002FDC  8E050028   LW A1, 40(S0)
9D002FE0  0F401DE0   JAL RB_Write
9D002FE4  26440908   ADDIU A0, S2, 2312
9D002FE8  24020004   ADDIU V0, ZERO, 4
9D002FEC  AE000030   SW ZERO, 48(S0)
9D002FF0  1000FFE7   BEQ ZERO, ZERO, 0x9D002F90
9D002FF4  AE020004   SW V0, 4(S0)
9D002FF8  8E06002C   LW A2, 44(S0)
9D002FFC  AFA20010   SW V0, 16(SP)
9D003000  3C05A000   LUI A1, -24576
9D003004  2402FFFF   ADDIU V0, ZERO, -1
9D003008  AE02001C   SW V0, 28(S0)
9D00300C  02403825   OR A3, S2, ZERO
9D003010  24A508EC   ADDIU A1, A1, 2284
9D003014  00002025   OR A0, ZERO, ZERO
9D003018  24020005   ADDIU V0, ZERO, 5
9D00301C  A2000021   SB ZERO, 33(S0)
9D003020  0F400EE2   JAL USB_DEVICE_CDC_Write
9D003024  AE020004   SW V0, 4(S0)
9D003028  1000FF84   BEQ ZERO, ZERO, 0x9D002E3C
9D00302C  8FBF0024   LW RA, 36(SP)
9D005310  2C82000B   SLTIU V0, A0, 11
9D005314  10400046   BEQ V0, ZERO, APP_USBDeviceEventHandler
9D005318  00042080   SLL A0, A0, 2
9D00531C  3C029D00   LUI V0, -25344
9D005320  24425340   ADDIU V0, V0, 21312
9D005324  00442021   ADDU A0, V0, A0
9D005328  8C820000   LW V0, 0(A0)
9D00532C  27BDFFE0   ADDIU SP, SP, -32
9D005330  AFBF001C   SW RA, 28(SP)
9D005334  AFB10018   SW S1, 24(SP)
9D005338  00400008   JR V0
9D00533C  AFB00014   SW S0, 20(SP)
9D00536C  3C10A000   LUI S0, -24576
9D00537C  A2000034   SB ZERO, 52(S0)
9D005380  8FBF001C   LW RA, 28(SP)
9D005384  8FB10018   LW S1, 24(SP)
9D005388  8FB00014   LW S0, 20(SP)
9D00538C  03E00008   JR RA
9D005390  27BD0020   ADDIU SP, SP, 32
9D005394  90B00000   LBU S0, 0(A1)
9D005398  24020001   ADDIU V0, ZERO, 1
9D00539C  1602FFF9   BNE S0, V0, APP_USBDeviceEventHandler
9D0053A0  8FBF001C   LW RA, 28(SP)
9D0053A4  3C11A000   LUI S1, -24576
9D0053AC  262608D0   ADDIU A2, S1, 2256
9D0053B0  24A561AC   ADDIU A1, A1, 25004
9D0053C0  1000FFEF   BEQ ZERO, ZERO, APP_USBDeviceEventHandler
9D0053C4  A230000F   SB S0, 15(S1)
9D0053C8  8FBF001C   LW RA, 28(SP)
9D0053CC  3C02A000   LUI V0, -24576
9D0053D0  8FB10018   LW S1, 24(SP)
9D0053D4  8FB00014   LW S0, 20(SP)
9D0053D8  A04008DF   SB ZERO, 2271(V0)
9D0053DC  03E00008   JR RA
9D0053E0  27BD0020   ADDIU SP, SP, 32
9D0053E4  8FBF001C   LW RA, 28(SP)
9D0053E8  3C02A000   LUI V0, -24576
9D0053EC  24030001   ADDIU V1, ZERO, 1
9D0053F0  8FB10018   LW S1, 24(SP)
9D0053F4  8FB00014   LW S0, 20(SP)
9D0053F8  A04308F2   SB V1, 2290(V0)
9D0053FC  03E00008   JR RA
9D005400  27BD0020   ADDIU SP, SP, 32
9D005404  3C10A000   LUI S0, -24576
9D005408  8E0408D0   LW A0, 2256(S0)
9D00540C  0F401D48   JAL USB_DEVICE_Attach
9D005410  261008D0   ADDIU S0, S0, 2256
9D005414  8FBF001C   LW RA, 28(SP)
9D005418  24020001   ADDIU V0, ZERO, 1
9D00541C  A2020034   SB V0, 52(S0)
9D005420  8FB10018   LW S1, 24(SP)
9D005424  8FB00014   LW S0, 20(SP)
9D005428  03E00008   JR RA
9D00542C  27BD0020   ADDIU SP, SP, 32
9D005430  03E00008   JR RA
9D005434  00000000   NOP
9D0061AC  2CA20009   SLTIU V0, A1, 9
9D0061B0  10400012   BEQ V0, ZERO, 0x9D0061FC
9D0061B4  00051080   SLL V0, A1, 2
9D0061B8  3C059D00   LUI A1, -25344
9D0061BC  24A561D0   ADDIU A1, A1, 25040
9D0061C0  00A22821   ADDU A1, A1, V0
9D0061C4  8CA20000   LW V0, 0(A1)
9D0061C8  00400008   JR V0
9D0061CC  00000000   NOP
9D0061F4  24020001   ADDIU V0, ZERO, 1
9D0061FC  03E00008   JR RA
9D006200  00000000   NOP
9D006204  8CC20004   LW V0, 4(A2)
9D006208  24030001   ADDIU V1, ZERO, 1
9D00620C  A0E30020   SB V1, 32(A3)
9D006210  03E00008   JR RA
9D006214  ACE20030   SW V0, 48(A3)
9D006218  8CE40000   LW A0, 0(A3)
9D00621C  0B401C56   J USB_DEVICE_ControlStatus
9D006220  00002825   OR A1, ZERO, ZERO
9D006224  8CE40000   LW A0, 0(A3)
9D006228  24060007   ADDIU A2, ZERO, 7
9D00622C  0B401F9D   J USB_DEVICE_ControlReceive
9D006230  24E50008   ADDIU A1, A3, 8
9D006234  8CE40000   LW A0, 0(A3)
9D006238  24060007   ADDIU A2, ZERO, 7
9D00623C  0B401B00   J USB_DEVICE_ControlSend
9D006240  24E50010   ADDIU A1, A3, 16
9D006244  90C30000   LBU V1, 0(A2)
9D006248  90E20017   LBU V0, 23(A3)
9D00624C  8CE40000   LW A0, 0(A3)
9D006250  00002825   OR A1, ZERO, ZERO
9D006254  7C620004   INS V0, V1, 0, 1
9D006258  A0E20017   SB V0, 23(A3)
9D00625C  90C30000   LBU V1, 0(A2)
9D006260  7C630040   EXT V1, V1, 1, 1
9D006264  7C620844   INS V0, V1, 1, 1
9D006268  0B401C56   J USB_DEVICE_ControlStatus
9D00626C  A0E20017   SB V0, 23(A3)
9D006270  94C20000   LHU V0, 0(A2)
9D006274  8CE40000   LW A0, 0(A3)
9D006278  00002825   OR A1, ZERO, ZERO
9D00627C  0B401C56   J USB_DEVICE_ControlStatus
9D006280  A4E20024   SH V0, 36(A3)
9D006284  8C8A001C   LW T2, 28(A0)
9D006680  3C07A000   LUI A3, -24576
9D006684  24E208D0   ADDIU V0, A3, 2256
9D006688  2403FFFF   ADDIU V1, ZERO, -1
9D00668C  ACE308D0   SW V1, 2256(A3)
9D006690  AC430018   SW V1, 24(V0)
9D006694  AC43001C   SW V1, 28(V0)
9D006698  24030101   ADDIU V1, ZERO, 257
9D00669C  A4430020   SH V1, 32(V0)
9D0066A0  3C03A000   LUI V1, -24576
9D0066A4  27BDFFE0   ADDIU SP, SP, -32
9D0066A8  24631228   ADDIU V1, V1, 4648
9D0066AC  AFB10018   SW S1, 24(SP)
9D0066B0  AC430028   SW V1, 40(V0)
9D0066B4  3C11A000   LUI S1, -24576
9D0066B8  24072580   ADDIU A3, ZERO, 9600
9D0066BC  3C05A000   LUI A1, -24576
9D0066C0  3C03A000   LUI V1, -24576
9D0066C4  26240908   ADDIU A0, S1, 2312
9D0066C8  AC470010   SW A3, 16(V0)
9D0066CC  24631A28   ADDIU V1, V1, 6696
9D0066D0  24070008   ADDIU A3, ZERO, 8
9D0066D4  24060900   ADDIU A2, ZERO, 2304
9D0066D8  24A52228   ADDIU A1, A1, 8744
9D0066DC  AFBF001C   SW RA, 28(SP)
9D0066E0  AFB00014   SW S0, 20(SP)
9D0066E4  A0470016   SB A3, 22(V0)
9D0066E8  AC43002C   SW V1, 44(V0)
9D0066EC  AC400004   SW ZERO, 4(V0)
9D0066F0  A040000F   SB ZERO, 15(V0)
9D0066F4  A0400015   SB ZERO, 21(V0)
9D0066F8  AC400030   SW ZERO, 48(V0)
9D0066FC  A0400022   SB ZERO, 34(V0)
9D006700  0F4000BA   JAL RB_Init
9D006704  3C10A000   LUI S0, -24576
9D006708  3C05A000   LUI A1, -24576
9D00670C  26310908   ADDIU S1, S1, 2312
9D006710  26040918   ADDIU A0, S0, 2328
9D006714  24060900   ADDIU A2, ZERO, 2304
9D006718  24A50928   ADDIU A1, A1, 2344
9D00671C  0F4000BA   JAL RB_Init
9D006720  AF918020   SW S1, -32736(GP)
9D006724  8FBF001C   LW RA, 28(SP)
9D006728  26100918   ADDIU S0, S0, 2328
9D00672C  AF90801C   SW S0, -32740(GP)
9D006730  8FB10018   LW S1, 24(SP)
9D006734  8FB00014   LW S0, 20(SP)
9D006738  03E00008   JR RA
9D00673C  27BD0020   ADDIU SP, SP, 32
9D0080DC  3C02A000   LUI V0, -24576
9D0080E4  2403FFFF   ADDIU V1, ZERO, -1
9D0080E8  AC430018   SW V1, 24(V0)
9D0080EC  AC43001C   SW V1, 28(V0)
9D0080F0  24040001   ADDIU A0, ZERO, 1
9D0080F4  24030101   ADDIU V1, ZERO, 257
9D0080F8  AC440004   SW A0, 4(V0)
9D0080FC  AC400030   SW ZERO, 48(V0)
9D008100  A4430020   SH V1, 32(V0)
9D008104  03E00008   JR RA
9D008108  24020001   ADDIU V0, ZERO, 1
---  c:/users/db/desktop/nano_tx/firmware/src/btl_app.c  ------------------------------------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       app.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It
15:                      implements the logic of the application's state machine and it may call
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // *****************************************************************************
25:                  // *****************************************************************************
26:                  // Section: Included Files
27:                  // *****************************************************************************
28:                  // *****************************************************************************
29:                  
30:                  #include "app.h"
31:                  //#include "app_x1txo.h"
32:                  #include "definitions.h"                // GPIO
33:                  //#include "user_hal/crc.h"
34:                  //#include "user_hal/iis2iclx.h"
35:                  //#include "user_hal/lsm6dsv16x.h"
36:                  //#include "user_hal/lps22hh.h"
37:                  //#include "user_hal/sdp3x.h"
38:                  //#include "user_hal/w25q.h"
39:                  #include "user_hal/debug.h"
40:                  #include "user_hal/config.h"
41:                  #include <math.h>
42:                  //#include <stdio.h>
43:                  #include "user_hal/printf.h"
44:                  #include "user_hal/strconv.h"
45:                  #include "bootloader/bootloader_common.h"
46:                  
47:                  #define TS_FREQ 1000
48:                  #define TS_TICKS (CORE_TIMER_FREQUENCY / TS_FREQ)
49:                  
50:                  #if CORE_TIMER_FREQUENCY==36000000
51:                      #define TS_120S_MASK    0xFFFFFFFF
52:                      #define TS_8S_MASK      0x0FFFFFFF
53:                      #define TS_2S_MASK      0x03FFFFFF
54:                      #define TS_1S_MASK      0x01FFFFFF
55:                      #define TS_30MS_MASK    0x000FFFFF
56:                  #endif
57:                  
58:                  /// Debounce low time: >= 0.1 s
59:                  #define BUTTON_T_LOW_LONG (0.1 * CORE_TIMER_FREQUENCY)
60:                      
61:                  /// Long button press high time: >= 2 s
62:                  #define BUTTON_T_HIGH_LONG (2 * CORE_TIMER_FREQUENCY)
63:                  
64:                  /// Power up button hold time: >= 2 s
65:                  #define BUTTON_T_HOLD (2 * CORE_TIMER_FREQUENCY)
66:                      
67:                  /// Battery low warning threshold: 3.6 V
68:                  #define VBAT_LOW_WARN 3.6
69:                  #define VBAT_LOW_RELEASE 3.7
70:                  
71:                  /// 2.716619E-04: 3.58 V measured reads as 3.5 V in PIC
72:                  //#define CAL_ADC_VBAT_GAIN 2.716619E-04f
73:                  /// 2.778713E-04: 3.5 V measured should read as 3.5 V in PIC (not yet tested)
74:                  #define CAL_ADC_VBAT_GAIN 2.778713E-04f
75:                  
76:                  /// Beep time: 0.1 s
77:                  #define BEEP_T (0.1 * CORE_TIMER_FREQUENCY)
78:                  
79:                  // *****************************************************************************
80:                  // *****************************************************************************
81:                  // Section: Global Data Definitions
82:                  // *****************************************************************************
83:                  // *****************************************************************************
84:                  
85:                  // *****************************************************************************
86:                  /* Application Data
87:                  
88:                    Summary:
89:                      Holds application data
90:                  
91:                    Description:
92:                      This structure holds the application's data.
93:                  
94:                    Remarks:
95:                      This structure should be initialized by the APP_Initialize function.
96:                  
97:                      Application strings and buffers are be defined outside this structure.
98:                  */
99:                  
100:                 APP_DATA appData;
101:                 
102:                 // Non-volatile memory
103:                 //uint8_t appDataNvm[1024] __attribute__((section(".nvm_mem"), used));
104:                 
105:                 // *****************************************************************************
106:                 // *****************************************************************************
107:                 // Section: Application Callback Functions
108:                 // *****************************************************************************
109:                 // *****************************************************************************
110:                 
111:                 /* TODO:  Add any necessary callback functions.
112:                 */
113:                 
114:                 // *****************************************************************************
115:                 // *****************************************************************************
116:                 // Section: Application Local Functions
117:                 // *****************************************************************************
118:                 // *****************************************************************************
119:                 
120:                 void getParam(char** rem, char** param)
121:                 {
122:                     int i;
123:                 
124:                     // Return with no parameter if buffer empty
125:                     if ((*rem == NULL) || ((*rem)[0] == '\0')) {
126:                         *param = NULL;
127:                         return;
128:                     }
129:                     // Skip leading white spaces
130:                     for (; ; (*rem)++) {
131:                         if ((**rem != ' ') && (**rem != ',')) {
132:                             break;
133:                         }
134:                     }
135:                     // Find end of parameter
136:                     *param = *rem;
137:                     char *pend;
138:                     for (i = 0; ; i++) {
139:                         if ((*rem)[i] == ',') {
140:                             (*rem)[i] = '\0';
141:                             pend = (*rem) + i + 0;
142:                             *rem = (*rem) + i + 1;
143:                             break;
144:                         } else  if (((*rem)[i] == '\0') || ((*rem)[i] == '\r')) {
145:                             (*rem)[i] = '\0';
146:                             pend = (*rem) + i + 0;
147:                             *rem = NULL;
148:                             break;
149:                         }
150:                     }
151:                     // Skip trailing white spaces
152:                     for (i = 1; pend - i > *param; i++) {
153:                         if ((*(pend - i) != ' ') && (*(pend - i) != ',')) {
154:                             break;
155:                         }
156:                         *(pend - i) = '\0';
157:                     }
158:                 }
159:                 
160:                 int isCmd(char* buf, char* cmd, char** rem)
161:                 {
162:                     if (buf == NULL) {
163:                         return 0;
164:                     }
165:                     int i;
166:                     if (rem != NULL) {
167:                         *rem = NULL;
168:                     }
169:                     for (i = 0; ; i++) {
170:                         if ((buf[i] == ' ') && (cmd[i] == '\0')) {
171:                             if (rem != NULL) {
172:                                 *rem = &buf[i+1];
173:                             }
174:                             return 1;
175:                         } else  if ((buf[i] == '\0') && (cmd[i] == '\0')) {
176:                             return 1;
177:                         } else  if ((buf[i] == '\r') && (cmd[i] == '\0')) {
178:                             return 1;
179:                         } else if (buf[i] != cmd[i]) {
180:                             return 0;
181:                         }
182:                     }
183:                 }
184:                 
185:                 bool paramToInt(char* param, int* value)
186:                 {
187:                     if (param == NULL) {
188:                         return false;
189:                     }
190:                     char* pend;
191:                 //    int valueStrtol = (int)strtol(param, &pend, 10);
192:                     int valid = 0;
193:                     int valueStrtol = strToInt(param, &valid, &pend);
194:                     if (valid && (*pend == '\0')) {
195:                         *value = valueStrtol;
196:                         return true;
197:                     }
198:                     return false;
199:                 }
200:                 
201:                 // *****************************************************************************
202:                 // *****************************************************************************
203:                 // Section: Application Initialization and State Machine Functions
204:                 // *****************************************************************************
205:                 // *****************************************************************************
206:                 
207:                 /*******************************************************************************
208:                   Function:
209:                     void APP_Initialize ( void )
210:                 
211:                   Remarks:
212:                     See prototype in app.h.
213:                  */
214:                 
215:                 void APP_Initialize ( void )
216:                 {
217:                     memset(&appData, 0, sizeof(APP_DATA));
218:                     
219:                     /* Place the App state machine in its initial state. */
220:                     appData.state = APP_STATE_INIT;
221:                 
222:                     /* Start core timer */
223:                     CORETIMER_Start();
224:                 }
225:                 
226:                 
227:                 /******************************************************************************
228:                   Function:
229:                     void APP_Tasks ( void )
230:                 
231:                   Remarks:
232:                     See prototype in app.h.
233:                  */
234:                 
235:                 void APP_Tasks ( void )
236:                 {
237:                     // User button
238:                     uint32_t button = (GPIO_RA7_BUTTON_Get())? 0 : 1;
239:                     uint32_t ts32 = _CP0_GET_COUNT();    
240:                 
241:                     /* Check the application's current state. */
242:                     switch ( appData.state )
243:                     {
244:                         /* Application's initial state. */
245:                         case APP_STATE_INIT:
246:                         {
247:                             //Debug_Enable(appUsbRbHostIn);
248:                             GPIO_RA10_LED_Set();
249:                             
250:                             //crcInit();
251:                             //IIS2ICLX_Init();
252:                             //LPS22HH_Init();
253:                            // LSM6DSV16X_Init();
254:                             //AD1CON1SET = _AD1CON1_ASAM_MASK;
255:                             //W25Q_Init();
256:                             //Capture_Init();
257:                             appData.state = APP_STATE_SERVICE_TASKS;
258:                             
259:                             // Enter bind mode
260:                            // APP_X1TXO_setMode(X1TXO_MODE_INIT);
261:                             
262:                             // Initialize edge and short/long/hold button detection
263:                             appData.button = button;
264:                             appData.buttonTRise = ts32;
265:                             appData.buttonTFall = ts32;
266:                             appData.buttonHold = button;
267:                             appData.tBeep = ts32 + BEEP_T;
268:                             
269:                             GPIO_RC4_SPI_NCS_ACC_Clear();
270:                             break;
271:                         }
272:                 
273:                         case APP_STATE_SERVICE_TASKS:
274:                         {   
275:                             // Identify state to end binding mode
276:                            // if (button == 0) {
277:                                 //APP_X1TXO_setMode(X1TXO_MODE_NORMAL);
278:                            // }
279:                             
280:                             // Identify edges and store edge timestamps
281:                             if ((button != 0) && (appData.button == 0)) {
282:                                 // Rising edge
283:                                 dprintf("<BUTTON T HIGH STARTS>\n");
284:                                 appData.buttonTRise = ts32;
285:                                 appData.buttonEventPending |= appData.buttonEventArmed;
286:                                 appData.buttonEventArmed = false;
287:                             } else if ((button == 0) && (appData.button != 0)) {
288:                                 // Falling edge
289:                                 dprintf("<BUTTON T LOW STARTS>\n");
290:                                 appData.buttonTFall = ts32;
291:                             }
292:                             appData.button = button;
293:                 
294:                             // Identify short event when low time reaches threshold
295:                             uint32_t tLow = ts32 - appData.buttonTFall;
296:                             if ((button == 0) && (tLow >= BUTTON_T_LOW_LONG)) {
297:                                 appData.buttonEventArmed = true;
298:                                 if (appData.buttonEventPending) {
299:                                     dprintf("<SHORT BUTTON PRESS EVENT>\n");
300:                                     appData.buttonEventPending = false;
301:                                 }
302:                             }
303:                 
304:                             // Identify long event when high time reaches threshold
305:                             uint32_t tHigh = ts32 - appData.buttonTRise;
306:                             if ((button == 1) && (tHigh >= BUTTON_T_HIGH_LONG)) {
307:                                 if (appData.buttonEventPending) {
308:                                     dprintf("<LONG BUTTON PRESS EVENT>\n");
309:                                     appData.buttonEventPending = false;
310:                                     appData.shutdown = true;
311:                                 }
312:                             }
313:                             
314:                             // Identify hold after power up event
315:                             appData.buttonHold = (button == 0)? 0: appData.buttonHold;
316:                             uint32_t tHold = ts32 - appData.buttonTRise;
317:                             if (tHold >= BUTTON_T_HOLD) {
318:                                 if ((button == 1) && appData.buttonHold) {
319:                                     dprintf("<BUTTON HOLD EVENT>\n");
320:                                     //APP_X1TXO_setMode(X1TXO_MODE_BIND);
321:                                 }
322:                                 appData.buttonHold = 0;
323:                             }
324:                             
325:                             // Shutdown mode: wait until capture is no longer pending, then
326:                             // disable power supply
327:                             if (appData.shutdown /*&& !Capture_IsPending()*/) {
328:                                 GPIO_RC6_LDOEN_Clear();
329:                                 appData.tBeep = ts32 + BEEP_T;
330:                             }
331:                             
332:                             // Command line interface
333:                             char* rem;
334:                             char command[128];
335:                             uint32_t link;
336:                             for (link = 0; link < 2; link++) {
337:                                 // Select link
338:                                 RINGBUFFER* rbHostOut;
339:                                 RINGBUFFER* rbHostIn;
340:                                 if (link == 0) {
341:                                     rbHostOut = appUsbRbHostOut;
342:                                     rbHostIn = appUsbRbHostIn;
343:                                 } else {
344:                                     rbHostOut = appBleRbHostOut;
345:                                     rbHostIn = appBleRbHostIn;
346:                                 }
347:                                 
348:                                 // Handle link
349:                                 uint32_t len = RB_ReadLine(rbHostOut, command, sizeof(command), "\r\n");
350:                                 if (len == 0) {
351:                                     continue;
352:                                 }
353:                                 
354:                                 char ans[256] = "";
355:                                 if (strstr(command, "HALLO?") != NULL) {
356:                                     sprintf(ans, "AU HOI vom Bootloader!%s", config.ansEol);
357:                                 } else if (isCmd(command, "BTL:RUN", NULL)) {
358:                                     run_Application(APP_JUMP_ADDRESS);  
359:                                 } else if (isCmd(command, "DIAG:APP?", NULL)) {
360:                                     sprintf(ans, "appData.maxCycleTime: %d, .lastCycleTime: %d%s",
361:                                             appData.maxCycleTime, appData.lastCycleTime,
362:                                             config.ansEol);
363:                                 } else if (isCmd(command, "DIAG:DEBUG", &rem)) {
364:                                     char* param;
365:                                     int value = 0;
366:                                     getParam(&rem, &param);
367:                                     if (paramToInt(param, &value) == false) {
368:                                         // Invalid parameter
369:                                     } else if (value) {
370:                                         Debug_Enable(rbHostIn);
371:                                         sprintf(ans, "Enable debug output%s", config.ansEol);
372:                                     } else {
373:                                         Debug_Disable();
374:                                         sprintf(ans, "Disable debug output%s", config.ansEol);
375:                                     }
376:                                 } else if (isCmd(command, "DIAG:ERR?", NULL)) {
377:                                     sprintf(ans, "%d%s", gwsError, config.ansEol);
378:                                 }
379:                 
380:                                 // Return answer
381:                                 if (ans[0] != '\0') {
382:                                     RB_Write(rbHostIn, ans, strlen(ans));
383:                                 }
384:                             }
385:                             
386:                             // High resolution cycle time measurement
387:                             uint32_t ts32d = (uint32_t)(appData.ts64 & 0x00000000FFFFFFFFllu);
388:                             appData.lastCycleTime = ts32 - ts32d;
389:                             if ((appData.ts64 > 0)
390:                                     && (appData.lastCycleTime > appData.maxCycleTime)) {
391:                                 appData.maxCycleTime = appData.lastCycleTime;
392:                             }
393:                             
394:                             // High resolution 64 bits timestamp
395:                             if (ts32 < (uint32_t)(appData.ts64 & 0x00000000FFFFFFFFllu)) {
396:                                 appData.ts64 += 0x0000000100000000llu;
397:                             };
398:                             appData.ts64 = ((uint64_t)ts32)
399:                                     | (appData.ts64 & 0xFFFFFFFF00000000llu);
400:                             
401:                             // LED flasher
402:                             uint32_t tsLed = ts32 >> 18;
403:                             if (appData.shutdown) {
404:                                 GPIO_RA10_LED_Clear();
405:                             } else if ((tsLed & 0x78) == 0x00) {
406:                                 GPIO_RA10_LED_Set();
407:                             } else if ((tsLed & 0x78) == 0x10) {
408:                                 GPIO_RA10_LED_Set();
409:                             } else if ((tsLed & 0x78) == 0x10) {
410:                                 GPIO_RA10_LED_Set();
411:                             } else if ((tsLed & 0x78) == 0x20) {
412:                                 GPIO_RA10_LED_Set();
413:                             } else if ((tsLed & 0x78) == 0x30) {
414:                                 GPIO_RA10_LED_Set();
415:                             } else {
416:                                 GPIO_RA10_LED_Clear();
417:                             }
418:                 
419:                             // Read LSM6DSV16(B)X accelerometer/gyroscope
420:                 //            if ((appData.counter & 0x1F) == 0) {
421:                 //                LSM6DSV16X_ReadTAG();
422:                 //            }
423:                             
424:                             // ADC battery voltage
425:                             // (I don't like the generated plib_adc.c library, write own one)
426:                             //
427:                             // In case of problems with the ADC:
428:                             // MCC may have misconfigured the input scan:
429:                             // The correct setup in "plib_adc.c" is "AD1CSSL = 0xa8f;"
430:                             // (see GIT history)
431:                 //            if (IFS0bits.AD1IF) {
432:                 //                // ADC input scan stores samples from selected sources in an
433:                 //                // array of result buffers, the order is as shown in MCC
434:                 //                appData.adcAd0GimbalX = appData.adcAd0GimbalX * 15 / 16
435:                 //                        + ADC_ResultGet(ADC_RESULT_BUFFER_0);
436:                 //                appData.adcAd1GimbalY = appData.adcAd1GimbalY * 15 / 16
437:                 //                        + ADC_ResultGet(ADC_RESULT_BUFFER_1);
438:                 //                appData.adcAd9Batms = appData.adcAd9Batms * 15 / 16
439:                 //                        + ADC_ResultGet(ADC_RESULT_BUFFER_5);
440:                 //                
441:                 //                appX1txoData.ch[0] = appData.adcAd0GimbalX >> 4; // compensate filter gain
442:                 //                appX1txoData.ch[1] = appData.adcAd1GimbalY >> 4; // compensate filter gain
443:                 //                appX1txoData.ch[2] = appData.adcAd0GimbalX >> 4; // compensate filter gain
444:                 //                appX1txoData.ch[3] = appData.adcAd1GimbalY >> 4; // compensate filter gain
445:                 //                appX1txoData.ch[4] = appData.adcAd0GimbalX >> 4; // compensate filter gain
446:                 //                appX1txoData.ch[5] = appData.adcAd1GimbalY >> 4; // compensate filter gain
447:                 //                IFS0CLR = _IFS0_AD1IF_MASK;
448:                 //            }
449:                             
450:                 //            // Low battery voltage shutdown
451:                 //            if ((ts32 & TS_2S_MASK) < (ts32d & TS_2S_MASK)) {
452:                 //                float vBat = (float)appData.adcAd9Batms * CAL_ADC_VBAT_GAIN;
453:                 //                if (vBat < VBAT_LOW_SHUTDOWN) {
454:                 //                    //appData.shutdown = true;
455:                 //                    //Capture_Stop();
456:                 //                    //RB_Printf(appUsbRbHostIn, "LOW BATTERY VOLTAGE\n");
457:                 //                }
458:                 //            }
459:                             
460:                 //            // Low battery voltage alarm
461:                 //            float vBat = (float)appData.adcAd9Batms * CAL_ADC_VBAT_GAIN;
462:                 //            if (vBat <= VBAT_LOW_WARN) {
463:                 //                appData.vBatAlarm = TRUE;
464:                 //            } else if (vBat >= VBAT_LOW_RELEASE) {
465:                 //                appData.vBatAlarm = FALSE;
466:                 //            }
467:                 //            
468:                             // Beeper
469:                             // We use GPIO_RC4_SPI_NCS_ACC since in the original PCB design
470:                             // there was no beeper
471:                             if (appData.vBatAlarm) {
472:                                 if ((tsLed & 0x08) == 0x00) {
473:                                     GPIO_RC4_SPI_NCS_ACC_Set();
474:                                 } else {
475:                                     GPIO_RC4_SPI_NCS_ACC_Clear();
476:                                 }
477:                             } else {
478:                                 // Difference appData.tBeep - ts32 does overflow, but being
479:                                 // unsigned, it is still correct
480:                                 // Low values (just above zero) indicate the beep time has not
481:                                 // yet completed
482:                                 // High values (just below may) indicate the beep time has
483:                                 // completed (appData.tBeep is from the past, thus less than
484:                                 // ts32)
485:                                 // We simply test for it being below or above midscale
486:                                 uint32_t tBeep = appData.tBeep - ts32;
487:                                 if ((tBeep > 0) && (tBeep < UINT32_MAX / 2)) {
488:                                     GPIO_RC4_SPI_NCS_ACC_Set();
489:                                 } else {
490:                                     appData.tBeep = ts32;
491:                                     GPIO_RC4_SPI_NCS_ACC_Clear();
492:                                 }
493:                             }
494:                 
495:                             appData.counter++;
496:                             break;
497:                         }
498:                 
499:                         /* The default state should never be executed. */
500:                         default:
501:                         {
502:                             /* Handle error in application's state machine. */
503:                             break;
504:                         }
505:                     }
506:                 }
507:                 
508:                 /*******************************************************************************
509:                  End of File
510:                  */
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000008  00000000   NOP
00000010  00000000   NOP
00000018  00000000   NOP
9D0017FC  27BDFE20   ADDIU SP, SP, -480
9D001800  AFB201C0   SW S2, 448(SP)
9D001804  3C12BF88   LUI S2, -16504
9D001808  8E426020   LW V0, 24608(S2)
9D00180C  AFBF01DC   SW RA, 476(SP)
9D001810  AFBE01D8   SW FP, 472(SP)
9D001814  000211C2   SRL V0, V0, 7
9D001818  AFB701D4   SW S7, 468(SP)
9D00181C  AFB601D0   SW S6, 464(SP)
9D001820  AFB501CC   SW S5, 460(SP)
9D001824  AFB401C8   SW S4, 456(SP)
9D001828  AFB301C4   SW S3, 452(SP)
9D00182C  AFB101BC   SW S1, 444(SP)
9D001830  AFB001B8   SW S0, 440(SP)
9D001834  40104800   MFC0 S0, Count
9D001838  3C08A000   LUI T0, -24576
9D00183C  8D110880   LW S1, 2176(T0)
9D001840  1220008E   BEQ S1, ZERO, 0x9D001A7C
9D001844  24030001   ADDIU V1, ZERO, 1
9D001848  16230081   BNE S1, V1, 0x9D001A50
9D00184C  8FBF01DC   LW RA, 476(SP)
9D001850  251E0880   ADDIU FP, T0, 2176
9D001854  30420001   ANDI V0, V0, 1
9D001858  104000AD   BEQ V0, ZERO, 0x9D001B10
9D00185C  8FC30020   LW V1, 32(FP)
9D001860  14600128   BNE V1, ZERO, 0x9D001D04
9D001864  3C030036   LUI V1, 54
9D001868  8FC2002C   LW V0, 44(FP)
9D00186C  3463EE80   ORI V1, V1, -4480
9D001870  02021023   SUBU V0, S0, V0
9D001874  0043102B   SLTU V0, V0, V1
9D001878  54400005   BNEL V0, ZERO, 0x9D001890
9D00187C  8FC20028   LW V0, 40(FP)
9D001880  93C20034   LBU V0, 52(FP)
9D001884  14400125   BNE V0, ZERO, 0x9D001D1C
9D001888  A3D10035   SB S1, 53(FP)
9D00188C  8FC20028   LW V0, 40(FP)
9D001890  3C03044A   LUI V1, 1098
9D001894  3463A200   ORI V1, V1, -24064
9D001898  02021023   SUBU V0, S0, V0
9D00189C  0043102B   SLTU V0, V0, V1
9D0018A0  104000AC   BEQ V0, ZERO, 0x9D001B54
9D0018A4  AFC00024   SW ZERO, 36(FP)
9D0018A8  93C2003C   LBU V0, 60(FP)
9D0018AC  10400011   BEQ V0, ZERO, 0x9D0018F4
9D0018B0  3C029D00   LUI V0, -25344
9D0018B4  24020040   ADDIU V0, ZERO, 64
9D0018B8  02002025   OR A0, S0, ZERO
9D0018BC  AE426234   SW V0, 25140(S2)
9D0018C0  0F401F71   JAL __floatunsidf
9D0018C4  00000000   NOP
9D0018C8  3C049D00   LUI A0, -25344
9D0018CC  8C8603D8   LW A2, 984(A0)
9D0018D0  8C8703DC   LW A3, 988(A0)
9D0018D4  00602825   OR A1, V1, ZERO
9D0018D8  0F4008BD   JAL __adddf3
9D0018DC  00402025   OR A0, V0, ZERO
9D0018E0  00402025   OR A0, V0, ZERO
9D0018E4  0F401BF0   JAL __fixunsdfsi
9D0018E8  00602825   OR A1, V1, ZERO
9D0018EC  AFC20030   SW V0, 48(FP)
9D0018F0  3C029D00   LUI V0, -25344
9D0018F4  AFA201A8   SW V0, 424(SP)
9D0018F8  3C029D00   LUI V0, -25344
9D0018FC  24424F38   ADDIU V0, V0, 20280
9D001900  3C149D00   LUI S4, -25344
9D001904  3C159D00   LUI S5, -25344
9D001908  AFA201AC   SW V0, 428(SP)
9D00190C  3C029D00   LUI V0, -25344
9D001910  00009825   OR S3, ZERO, ZERO
9D001914  3C169D00   LUI S6, -25344
9D001918  26944ED0   ADDIU S4, S4, 20176
9D00191C  26B54EF4   ADDIU S5, S5, 20212
9D001920  AFA201B0   SW V0, 432(SP)
9D001924  12600098   BEQ S3, ZERO, 0x9D001B88
9D001928  8F848028   LW A0, -32728(GP)
9D00192C  26C74ECC   ADDIU A3, S6, 20172
9D001930  24060080   ADDIU A2, ZERO, 128
9D001934  27A50118   ADDIU A1, SP, 280
9D001938  0F400000   JAL RB_ReadLine
9D00193C  8F978024   LW S7, -32732(GP)
9D001940  10400013   BEQ V0, ZERO, 0x9D001990
9D001944  24020001   ADDIU V0, ZERO, 1
9D001948  00002825   OR A1, ZERO, ZERO
9D00194C  27A4001C   ADDIU A0, SP, 28
9D001950  240600FC   ADDIU A2, ZERO, 252
9D001954  0F401B54   JAL memset
9D001958  AFA00018   SW ZERO, 24(SP)
9D00195C  02802825   OR A1, S4, ZERO
9D001960  0F401E0E   JAL strstr
9D001964  27A40118   ADDIU A0, SP, 280
9D001968  10400099   BEQ V0, ZERO, isCmd
9D00196C  3C059D00   LUI A1, -25344
9D001970  27868010   ADDIU A2, GP, -32752
9D001974  24A54ED8   ADDIU A1, A1, 20184
9D001978  0F401F61   JAL sprintf_
9D00197C  27A40018   ADDIU A0, SP, 24
9D001980  83A20018   LB V0, 24(SP)
9D001984  1440008A   BNE V0, ZERO, 0x9D001BB0
9D001988  00000000   NOP
9D00198C  24020001   ADDIU V0, ZERO, 1
9D001990  5662FFE4   BNEL S3, V0, 0x9D001924
9D001994  02209825   OR S3, S1, ZERO
9D001998  8FC20008   LW V0, 8(FP)
9D00199C  8FC3000C   LW V1, 12(FP)
9D0019A0  02022023   SUBU A0, S0, V0
9D0019A4  00432825   OR A1, V0, V1
9D0019A8  10A00007   BEQ A1, ZERO, 0x9D0019C8
9D0019AC  AFC40018   SW A0, 24(FP)
9D0019B0  8FC5001C   LW A1, 28(FP)
9D0019B4  00A4282B   SLTU A1, A1, A0
9D0019B8  54A00001   BNEL A1, ZERO, 0x9D0019C0
9D0019BC  AFC4001C   SW A0, 28(FP)
9D0019C0  0202102B   SLTU V0, S0, V0
9D0019C4  00621821   ADDU V1, V1, V0
9D0019C8  93C4003C   LBU A0, 60(FP)
9D0019CC  AFD00008   SW S0, 8(FP)
9D0019D0  AFC3000C   SW V1, 12(FP)
9D0019D4  1480000B   BNE A0, ZERO, 0x9D001A04
9D0019D8  00101482   SRL V0, S0, 18
9D0019DC  30430078   ANDI V1, V0, 120
9D0019E0  5060005F   BEQL V1, ZERO, 0x9D001B60
9D0019E4  24030400   ADDIU V1, ZERO, 1024
9D0019E8  24040010   ADDIU A0, ZERO, 16
9D0019EC  1064005B   BEQ V1, A0, 0x9D001B5C
9D0019F0  24040020   ADDIU A0, ZERO, 32
9D0019F4  10640059   BEQ V1, A0, 0x9D001B5C
9D0019F8  24040030   ADDIU A0, ZERO, 48
9D0019FC  10640058   BEQ V1, A0, 0x9D001B60
9D001A00  24030400   ADDIU V1, ZERO, 1024
9D001A04  24030400   ADDIU V1, ZERO, 1024
9D001A08  AE436034   SW V1, 24628(S2)
9D001A0C  93C3003D   LBU V1, 61(FP)
9D001A10  14600058   BNE V1, ZERO, 0x9D001B74
9D001A14  30420008   ANDI V0, V0, 8
9D001A18  8FC20030   LW V0, 48(FP)
9D001A1C  3C037FFF   LUI V1, 32767
9D001A20  3463FFFE   ORI V1, V1, -2
9D001A24  2442FFFF   ADDIU V0, V0, -1
9D001A28  00501023   SUBU V0, V0, S0
9D001A2C  0043102B   SLTU V0, V0, V1
9D001A30  14400052   BNE V0, ZERO, 0x9D001B7C
9D001A34  24020010   ADDIU V0, ZERO, 16
9D001A38  AFD00030   SW S0, 48(FP)
9D001A3C  AE426234   SW V0, 25140(S2)
9D001A40  8FC20038   LW V0, 56(FP)
9D001A44  24420001   ADDIU V0, V0, 1
9D001A48  AFC20038   SW V0, 56(FP)
9D001A4C  8FBF01DC   LW RA, 476(SP)
9D001A50  8FBE01D8   LW FP, 472(SP)
9D001A54  8FB701D4   LW S7, 468(SP)
9D001A58  8FB601D0   LW S6, 464(SP)
9D001A5C  8FB501CC   LW S5, 460(SP)
9D001A60  8FB401C8   LW S4, 456(SP)
9D001A64  8FB301C4   LW S3, 452(SP)
9D001A68  8FB201C0   LW S2, 448(SP)
9D001A6C  8FB101BC   LW S1, 444(SP)
9D001A70  8FB001B8   LW S0, 440(SP)
9D001A74  03E00008   JR RA
9D001A78  27BD01E0   ADDIU SP, SP, 480
9D001A7C  24030400   ADDIU V1, ZERO, 1024
9D001A80  00021027   NOR V0, ZERO, V0
9D001A84  25110880   ADDIU S1, T0, 2176
9D001A88  30420001   ANDI V0, V0, 1
9D001A8C  AE436038   SW V1, 24632(S2)
9D001A90  24030001   ADDIU V1, ZERO, 1
9D001A94  02002025   OR A0, S0, ZERO
9D001A98  AD030880   SW V1, 2176(T0)
9D001A9C  AE300028   SW S0, 40(S1)
9D001AA0  AE30002C   SW S0, 44(S1)
9D001AA4  AE220020   SW V0, 32(S1)
9D001AA8  0F401F71   JAL __floatunsidf
9D001AAC  AE220024   SW V0, 36(S1)
9D001AB0  3C049D00   LUI A0, -25344
9D001AB4  8C8603D8   LW A2, 984(A0)
9D001AB8  8C8703DC   LW A3, 988(A0)
9D001ABC  00602825   OR A1, V1, ZERO
9D001AC0  0F4008BD   JAL __adddf3
9D001AC4  00402025   OR A0, V0, ZERO
9D001AC8  00402025   OR A0, V0, ZERO
9D001ACC  0F401BF0   JAL __fixunsdfsi
9D001AD0  00602825   OR A1, V1, ZERO
9D001AD4  8FBF01DC   LW RA, 476(SP)
9D001AD8  AE220030   SW V0, 48(S1)
9D001ADC  24020010   ADDIU V0, ZERO, 16
9D001AE0  AE426234   SW V0, 25140(S2)
9D001AE4  8FBE01D8   LW FP, 472(SP)
9D001AE8  8FB701D4   LW S7, 468(SP)
9D001AEC  8FB601D0   LW S6, 464(SP)
9D001AF0  8FB501CC   LW S5, 460(SP)
9D001AF4  8FB401C8   LW S4, 456(SP)
9D001AF8  8FB301C4   LW S3, 452(SP)
9D001AFC  8FB201C0   LW S2, 448(SP)
9D001B00  8FB101BC   LW S1, 444(SP)
9D001B04  8FB001B8   LW S0, 440(SP)
9D001B08  03E00008   JR RA
9D001B0C  27BD01E0   ADDIU SP, SP, 480
9D001B10  1060005E   BEQ V1, ZERO, 0x9D001C8C
9D001B14  3C13044A   LUI S3, 1098
9D001B18  8FC20028   LW V0, 40(FP)
9D001B1C  3673A200   ORI S3, S3, -24064
9D001B20  02021023   SUBU V0, S0, V0
9D001B24  0053102B   SLTU V0, V0, S3
9D001B28  1440FF5F   BNE V0, ZERO, 0x9D0018A8
9D001B2C  AFD10020   SW S1, 32(FP)
9D001B30  93C20034   LBU V0, 52(FP)
9D001B34  14400069   BNE V0, ZERO, 0x9D001CDC
9D001B38  3C049D00   LUI A0, -25344
9D001B3C  8FC20024   LW V0, 36(FP)
9D001B40  5040FF59   BEQL V0, ZERO, 0x9D0018A8
9D001B44  AFC00024   SW ZERO, 36(FP)
9D001B48  3C049D00   LUI A0, -25344
9D001B4C  0F401BA7   JAL dprintf
9D001B50  24844EB4   ADDIU A0, A0, 20148
9D001B54  1000FF54   BEQ ZERO, ZERO, 0x9D0018A8
9D001B58  AFC00024   SW ZERO, 36(FP)
9D001B5C  24030400   ADDIU V1, ZERO, 1024
9D001B60  AE436038   SW V1, 24632(S2)
9D001B64  93C3003D   LBU V1, 61(FP)
9D001B68  5060FFAC   BEQL V1, ZERO, 0x9D001A1C
9D001B6C  8FC20030   LW V0, 48(FP)
9D001B70  30420008   ANDI V0, V0, 8
9D001B74  1440FFB1   BNE V0, ZERO, 0x9D001A3C
9D001B78  24020010   ADDIU V0, ZERO, 16
9D001B7C  AE426238   SW V0, 25144(S2)
9D001B80  1000FFB0   BEQ ZERO, ZERO, 0x9D001A44
9D001B84  8FC20038   LW V0, 56(FP)
9D001B88  8F848020   LW A0, -32736(GP)
9D001B8C  26C74ECC   ADDIU A3, S6, 20172
9D001B90  24060080   ADDIU A2, ZERO, 128
9D001B94  27A50118   ADDIU A1, SP, 280
9D001B98  0F400000   JAL RB_ReadLine
9D001B9C  8F97801C   LW S7, -32740(GP)
9D001BA0  1440FF6A   BNE V0, ZERO, 0x9D00194C
9D001BA4  00002825   OR A1, ZERO, ZERO
9D001BA8  1000FF5E   BEQ ZERO, ZERO, 0x9D001924
9D001BAC  02209825   OR S3, S1, ZERO
9D001BB0  0F4011F2   JAL strlen
9D001BB4  27A40018   ADDIU A0, SP, 24
9D001BB8  00403025   OR A2, V0, ZERO
9D001BBC  27A50018   ADDIU A1, SP, 24
9D001BC0  0F401DE0   JAL RB_Write
9D001BC4  02E02025   OR A0, S7, ZERO
9D001BC8  1000FF71   BEQ ZERO, ZERO, 0x9D001990
9D001BCC  24020001   ADDIU V0, ZERO, 1
9D001BD0  00003025   OR A2, ZERO, ZERO
9D001BD4  02A02825   OR A1, S5, ZERO
9D001BD8  0F401CD6   JAL isCmd
9D001BDC  27A40118   ADDIU A0, SP, 280
9D001BE0  50400006   BEQL V0, ZERO, isCmd
9D001BE4  8FA201A8   LW V0, 424(SP)
9D001BE8  3C049D00   LUI A0, -25344
9D001BEC  0F401E24   JAL run_Application
9D001BF0  3484A000   ORI A0, A0, -24576
9D001BF4  1000FF63   BEQ ZERO, ZERO, 0x9D001984
9D001BF8  83A20018   LB V0, 24(SP)
9D001BFC  00003025   OR A2, ZERO, ZERO
9D001C00  27A40118   ADDIU A0, SP, 280
9D001C04  0F401CD6   JAL isCmd
9D001C08  24454EFC   ADDIU A1, V0, 20220
9D001C0C  5440002A   BNEL V0, ZERO, 0x9D001CB8
9D001C10  8FC70018   LW A3, 24(FP)
9D001C14  8FA501AC   LW A1, 428(SP)
9D001C18  27A601A0   ADDIU A2, SP, 416
9D001C1C  27A40118   ADDIU A0, SP, 280
9D001C20  0F401CD6   JAL isCmd
9D001C24  AFA001A0   SW ZERO, 416(SP)
9D001C28  10400041   BEQ V0, ZERO, isCmd
9D001C2C  8FA201B0   LW V0, 432(SP)
9D001C30  27A401A0   ADDIU A0, SP, 416
9D001C34  27A5019C   ADDIU A1, SP, 412
9D001C38  0F401675   JAL getParam
9D001C3C  AFA00198   SW ZERO, 408(SP)
9D001C40  8FA4019C   LW A0, 412(SP)
9D001C44  1080FF4F   BEQ A0, ZERO, 0x9D001984
9D001C4C  0F401DC7   JAL paramToInt
9D001C54  1040FF4B   BEQ V0, ZERO, 0x9D001984
9D001C58  83A20018   LB V0, 24(SP)
9D001C5C  8FA20198   LW V0, 408(SP)
9D001C60  10400041   BEQ V0, ZERO, 0x9D001D68
9D001C64  00000000   NOP
9D001C68  0F4000EA   JAL Debug_Enable
9D001C6C  02E02025   OR A0, S7, ZERO
9D001C70  3C059D00   LUI A1, -25344
9D001C74  27868010   ADDIU A2, GP, -32752
9D001C78  24A54F44   ADDIU A1, A1, 20292
9D001C7C  0F401F61   JAL sprintf_
9D001C80  27A40018   ADDIU A0, SP, 24
9D001C84  1000FF3F   BEQ ZERO, ZERO, 0x9D001984
9D001C88  83A20018   LB V0, 24(SP)
9D001C8C  3C049D00   LUI A0, -25344
9D001C90  0F401BA7   JAL dprintf
9D001C94  24844E4C   ADDIU A0, A0, 20044
9D001C98  93C20034   LBU V0, 52(FP)
9D001C9C  93C30035   LBU V1, 53(FP)
9D001CA0  AFD00028   SW S0, 40(FP)
9D001CA4  A3C00035   SB ZERO, 53(FP)
9D001CA8  00431025   OR V0, V0, V1
9D001CAC  A3C20034   SB V0, 52(FP)
9D001CB0  1000FEFD   BEQ ZERO, ZERO, 0x9D0018A8
9D001CB4  AFD10020   SW S1, 32(FP)
9D001CB8  8FC6001C   LW A2, 28(FP)
9D001CBC  27828010   ADDIU V0, GP, -32752
9D001CC0  3C059D00   LUI A1, -25344
9D001CC4  AFA20010   SW V0, 16(SP)
9D001CC8  24A54F08   ADDIU A1, A1, 20232
9D001CCC  0F401F61   JAL sprintf_
9D001CD0  27A40018   ADDIU A0, SP, 24
9D001CD4  1000FF2B   BEQ ZERO, ZERO, 0x9D001984
9D001CD8  83A20018   LB V0, 24(SP)
9D001CDC  0F401BA7   JAL dprintf
9D001CE0  24844E98   ADDIU A0, A0, 20120
9D001CE4  8FC20028   LW V0, 40(FP)
9D001CE8  A3C00034   SB ZERO, 52(FP)
9D001CEC  02021023   SUBU V0, S0, V0
9D001CF0  0053982B   SLTU S3, V0, S3
9D001CF4  1260FF91   BEQ S3, ZERO, 0x9D001B3C
9D001CF8  A3D1003C   SB S1, 60(FP)
9D001CFC  1000FEEB   BEQ ZERO, ZERO, 0x9D0018AC
9D001D00  93C2003C   LBU V0, 60(FP)
9D001D04  3C049D00   LUI A0, -25344
9D001D08  0F401BA7   JAL dprintf
9D001D0C  24844E64   ADDIU A0, A0, 20068
9D001D10  AFD0002C   SW S0, 44(FP)
9D001D14  1000FEDD   BEQ ZERO, ZERO, 0x9D00188C
9D001D18  AFC00020   SW ZERO, 32(FP)
9D001D1C  3C049D00   LUI A0, -25344
9D001D20  0F401BA7   JAL dprintf
9D001D24  24844E7C   ADDIU A0, A0, 20092
9D001D28  1000FED8   BEQ ZERO, ZERO, 0x9D00188C
9D001D2C  A3C00034   SB ZERO, 52(FP)
9D001D30  00003025   OR A2, ZERO, ZERO
9D001D34  27A40118   ADDIU A0, SP, 280
9D001D38  0F401CD6   JAL isCmd
9D001D3C  24454F74   ADDIU A1, V0, 20340
9D001D40  5040FF10   BEQL V0, ZERO, 0x9D001984
9D001D44  83A20018   LB V0, 24(SP)
9D001D48  8F868014   LW A2, -32748(GP)
9D001D4C  3C059D00   LUI A1, -25344
9D001D50  27878010   ADDIU A3, GP, -32752
9D001D54  24A54F80   ADDIU A1, A1, 20352
9D001D58  0F401F61   JAL sprintf_
9D001D5C  27A40018   ADDIU A0, SP, 24
9D001D60  1000FF08   BEQ ZERO, ZERO, 0x9D001984
9D001D64  83A20018   LB V0, 24(SP)
9D001D68  0F4000E6   JAL Debug_Disable
9D001D6C  00000000   NOP
9D001D70  3C059D00   LUI A1, -25344
9D001D74  27868010   ADDIU A2, GP, -32752
9D001D78  24A54F5C   ADDIU A1, A1, 20316
9D001D7C  0F401F61   JAL sprintf_
9D001D80  27A40018   ADDIU A0, SP, 24
9D001D84  1000FEFF   BEQ ZERO, ZERO, 0x9D001984
9D001D88  83A20018   LB V0, 24(SP)
9D0059D4  8C820000   LW V0, 0(A0)
9D0059D8  10400028   BEQ V0, ZERO, getParam
9D0059DC  00000000   NOP
9D0059E0  80430000   LB V1, 0(V0)
9D0059E4  10600025   BEQ V1, ZERO, getParam
9D0059E8  24060020   ADDIU A2, ZERO, 32
9D0059EC  10000003   BEQ ZERO, ZERO, getParam
9D0059F0  2407002C   ADDIU A3, ZERO, 44
9D0059F4  AC820000   SW V0, 0(A0)
9D0059F8  80430000   LB V1, 0(V0)
9D0059FC  5066FFFD   BEQL V1, A2, getParam
9D005A00  24420001   ADDIU V0, V0, 1
9D005A04  5067FFFB   BEQL V1, A3, getParam
9D005A08  24420001   ADDIU V0, V0, 1
9D005A0C  ACA20000   SW V0, 0(A1)
9D005A10  80430000   LB V1, 0(V0)
9D005A14  10670033   BEQ V1, A3, getParam
9D005A18  24080001   ADDIU T0, ZERO, 1
9D005A1C  10600019   BEQ V1, ZERO, getParam::getParam
9D005A20  00003825   OR A3, ZERO, ZERO
9D005A24  2406000D   ADDIU A2, ZERO, 13
9D005A28  10660016   BEQ V1, A2, getParam::getParam
9D005A2C  24430001   ADDIU V1, V0, 1
9D005A30  00004025   OR T0, ZERO, ZERO
9D005A34  2409002C   ADDIU T1, ZERO, 44
9D005A38  10000005   BEQ ZERO, ZERO, getParam
9D005A3C  240A000D   ADDIU T2, ZERO, 13
9D005A40  10C00010   BEQ A2, ZERO, getParam::getParam
9D005A44  24630001   ADDIU V1, V1, 1
9D005A48  10CA000E   BEQ A2, T2, getParam::getParam
9D005A4C  00E04025   OR T0, A3, ZERO
9D005A50  80660000   LB A2, 0(V1)
9D005A54  25070001   ADDIU A3, T0, 1
9D005A58  14C9FFF9   BNE A2, T1, getParam::getParam
9D005A5C  00601025   OR V0, V1, ZERO
9D005A60  25080002   ADDIU T0, T0, 2
9D005A64  A0400000   SB ZERO, 0(V0)
9D005A68  8C820000   LW V0, 0(A0)
9D005A6C  00484021   ADDU T0, V0, T0
9D005A70  00473821   ADDU A3, V0, A3
9D005A74  10000007   BEQ ZERO, ZERO, getParam
9D005A78  AC880000   SW T0, 0(A0)
9D005A7C  03E00008   JR RA
9D005A80  ACA00000   SW ZERO, 0(A1)
9D005A84  A0400000   SB ZERO, 0(V0)
9D005A88  8C820000   LW V0, 0(A0)
9D005A8C  AC800000   SW ZERO, 0(A0)
9D005A90  00473821   ADDU A3, V0, A3
9D005A94  8CA30000   LW V1, 0(A1)
9D005A98  24E7FFFF   ADDIU A3, A3, -1
9D005A9C  00E01025   OR V0, A3, ZERO
9D005AA0  0067382B   SLTU A3, V1, A3
9D005AA4  24040020   ADDIU A0, ZERO, 32
9D005AA8  10E0000C   BEQ A3, ZERO, getParam
9D005AAC  2406002C   ADDIU A2, ZERO, 44
9D005AB0  80430000   LB V1, 0(V0)
9D005AB4  50640004   BEQL V1, A0, getParam
9D005AB8  A0400000   SB ZERO, 0(V0)
9D005ABC  14660007   BNE V1, A2, getParam
9D005AC0  00000000   NOP
9D005AC4  A0400000   SB ZERO, 0(V0)
9D005AC8  8CA30000   LW V1, 0(A1)
9D005ACC  2442FFFF   ADDIU V0, V0, -1
9D005AD0  0062182B   SLTU V1, V1, V0
9D005AD4  5460FFF7   BNEL V1, ZERO, getParam
9D005AD8  80430000   LB V1, 0(V0)
9D005ADC  03E00008   JR RA
9D005AE0  00000000   NOP
9D005AE4  1000FFDF   BEQ ZERO, ZERO, getParam
9D005AE8  00003825   OR A3, ZERO, ZERO
9D007358  00001825   OR V1, ZERO, ZERO
9D00735C  24080020   ADDIU T0, ZERO, 32
9D007360  2409000D   ADDIU T1, ZERO, 13
9D007364  00831021   ADDU V0, A0, V1
9D007368  80470000   LB A3, 0(V0)
9D00736C  00A31021   ADDU V0, A1, V1
9D007370  10E80005   BEQ A3, T0, isCmd.part.1
9D007374  80420000   LB V0, 0(V0)
9D007378  14E00009   BNE A3, ZERO, isCmd.part.1
9D00737C  00000000   NOP
9D007380  03E00008   JR RA
9D007384  2C420001   SLTIU V0, V0, 1
9D007388  1040000B   BEQ V0, ZERO, isCmd.part.1
9D00738C  00000000   NOP
9D007390  10E2FFF4   BEQ A3, V0, isCmd.part.1
9D007394  24630001   ADDIU V1, V1, 1
9D007398  03E00008   JR RA
9D00739C  00001025   OR V0, ZERO, ZERO
9D0073A0  14E9FFFB   BNE A3, T1, isCmd.part.1
9D0073A4  00000000   NOP
9D0073A8  1440FFF9   BNE V0, ZERO, isCmd.part.1
9D0073AC  00000000   NOP
9D0073B0  03E00008   JR RA
9D0073B4  24020001   ADDIU V0, ZERO, 1
9D0073B8  10C0FFFD   BEQ A2, ZERO, isCmd.part.1
9D0073BC  24630001   ADDIU V1, V1, 1
9D0073C0  00831821   ADDU V1, A0, V1
9D0073C4  ACC30000   SW V1, 0(A2)
9D0073C8  03E00008   JR RA
9D0073CC  24020001   ADDIU V0, ZERO, 1
9D00771C  27BDFFE0   ADDIU SP, SP, -32
9D007724  27A60014   ADDIU A2, SP, 20
9D007728  00A08025   OR S0, A1, ZERO
9D00772C  27A50010   ADDIU A1, SP, 16
9D007730  AFBF001C   SW RA, 28(SP)
9D007734  0F401BCC   JAL strToInt
9D007738  AFA00010   SW ZERO, 16(SP)
9D00773C  8FA30010   LW V1, 16(SP)
9D007740  00402025   OR A0, V0, ZERO
9D007744  10600005   BEQ V1, ZERO, paramToInt.part.2
9D007748  00001025   OR V0, ZERO, ZERO
9D00774C  8FA30014   LW V1, 20(SP)
9D007750  80630000   LB V1, 0(V1)
9D007754  10600005   BEQ V1, ZERO, paramToInt.part.2
9D007758  8FBF001C   LW RA, 28(SP)
9D00775C  8FBF001C   LW RA, 28(SP)
9D007760  8FB00018   LW S0, 24(SP)
9D007764  03E00008   JR RA
9D007768  27BD0020   ADDIU SP, SP, 32
9D00776C  AE040000   SW A0, 0(S0)
9D007770  24020001   ADDIU V0, ZERO, 1
9D007774  8FB00018   LW S0, 24(SP)
9D007778  03E00008   JR RA
9D00777C  27BD0020   ADDIU SP, SP, 32
9D008320  3C04A000   LUI A0, -24576
9D008324  27BDFFE8   ADDIU SP, SP, -24
9D008328  24060050   ADDIU A2, ZERO, 80
9D00832C  00002825   OR A1, ZERO, ZERO
9D008330  AFBF0014   SW RA, 20(SP)
9D008334  0F401B54   JAL memset
9D008338  24840880   ADDIU A0, A0, 2176
9D00833C  8FBF0014   LW RA, 20(SP)
9D008340  0B401D7C   J CORETIMER_Start
9D008344  27BD0018   ADDIU SP, SP, 24
---  c:/users/db/desktop/nano_tx/firmware/src/bootloader/bootloader_common.c  ---------------------------
1:                   /*******************************************************************************
2:                     Bootloader Common Source File
3:                   
4:                     File Name:
5:                       bootloader_common.c
6:                   
7:                     Summary:
8:                       This file contains common definitions and functions.
9:                   
10:                    Description:
11:                      This file contains common definitions and functions.
12:                   *******************************************************************************/
13:                  
14:                  // DOM-IGNORE-BEGIN
15:                  /*******************************************************************************
16:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
17:                  *
18:                  * Subject to your compliance with these terms, you may use Microchip software
19:                  * and any derivatives exclusively with Microchip products. It is your
20:                  * responsibility to comply with third party license terms applicable to your
21:                  * use of third party software (including open source software) that may
22:                  * accompany Microchip software.
23:                  *
24:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
25:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
26:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
27:                  * PARTICULAR PURPOSE.
28:                  *
29:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
30:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
31:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
32:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
33:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
34:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
35:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
36:                   *******************************************************************************/
37:                  // DOM-IGNORE-END
38:                  
39:                  // *****************************************************************************
40:                  // *****************************************************************************
41:                  // Section: Include Files
42:                  // *****************************************************************************
43:                  // *****************************************************************************
44:                  
45:                  #include "bootloader_common.h"
46:                  
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  // Section: Type Definitions
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  
53:                  /* Bootloader Major and Minor version sent for a Read Version command (MAJOR.MINOR)*/
54:                  #define BTL_MAJOR_VERSION       3
55:                  #define BTL_MINOR_VERSION       6
56:                  
57:                  #define WORD_ALIGN_MASK         (~(sizeof(uint32_t) - 1))
58:                  
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  // Section: Global objects
62:                  // *****************************************************************************
63:                  // *****************************************************************************
64:                  
65:                  
66:                  // *****************************************************************************
67:                  // *****************************************************************************
68:                  // Section: Bootloader Local Functions
69:                  // *****************************************************************************
70:                  // *****************************************************************************
71:                  
72:                  
73:                  // *****************************************************************************
74:                  // *****************************************************************************
75:                  // Section: Bootloader Global Functions
76:                  // *****************************************************************************
77:                  // *****************************************************************************
78:                  
79:                  
80:                  bool __WEAK bootloader_Trigger(void)
81:                  {
82:                      /* Function can be overriden with custom implementation */
83:                      return false;
84:                  }
85:                  
86:                  void __WEAK SYS_DeInitialize( void *data )
87:                  {
88:                      /* Function can be overriden with custom implementation */
89:                  }
90:                  
91:                  uint16_t __WEAK bootloader_GetVersion( void )
92:                  {
93:                      /* Function can be overriden with custom implementation */
94:                      uint16_t btlVersion = (((BTL_MAJOR_VERSION & 0xFF) << 8) | (BTL_MINOR_VERSION & 0xFF));
95:                  
96:                      return btlVersion;
97:                  }
98:                  
99:                  
100:                 
101:                 /* Function to Generate CRC by reading the firmware programmed into internal flash */
102:                 uint32_t bootloader_CRCGenerate(uint32_t start_addr, uint32_t size)
103:                 {
104:                     uint32_t   i, j, value;
105:                     uint32_t   crc_tab[256];
106:                     uint32_t   crc = 0xffffffff;
107:                     uint8_t    data;
108:                 
109:                     for (i = 0; i < 256; i++)
110:                     {
111:                         value = i;
112:                 
113:                         for (j = 0; j < 8; j++)
114:                         {
115:                             if (value & 1)
116:                             {
117:                                 value = (value >> 1) ^ 0xEDB88320;
118:                             }
119:                             else
120:                             {
121:                                 value >>= 1;
122:                             }
123:                         }
124:                         crc_tab[i] = value;
125:                     }
126:                 
127:                     for (i = 0; i < size; i++)
128:                     {
129:                         data = *(uint8_t *)KVA0_TO_KVA1((start_addr + i));
130:                 
131:                         crc = crc_tab[(crc ^ data) & 0xff] ^ (crc >> 8);
132:                     }
133:                 
134:                     return crc;
135:                 }
136:                 
137:                 
138:                 /* Trigger a reset */
139:                 void bootloader_TriggerReset(void)
140:                 {
141:                     /* Perform system unlock sequence */
142:                     SYSKEY = 0x00000000;
143:                     SYSKEY = 0xAA996655;
144:                     SYSKEY = 0x556699AA;
145:                 
146:                     RSWRSTSET = _RSWRST_SWRST_MASK;
147:                     (void)RSWRST;
148:                 }
149:                 
150:                 void run_Application(uint32_t address)
151:                 {
152:                     uint32_t jumpAddrVal = *(uint32_t *)(address & WORD_ALIGN_MASK);
153:                 
154:                     void (*fptr)(void);
155:                 
156:                     fptr = (void (*)(void))address;
157:                 
158:                     if (jumpAddrVal == 0xffffffff)
159:                     {
160:                         return;
161:                     }
162:                 
163:                     /* Call Deinitialize routine to free any resources acquired by Bootloader */
164:                     SYS_DeInitialize(NULL);
165:                 
166:                     __builtin_disable_interrupts();
167:                 
168:                     fptr();
169:                 }
170:                 
171:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
00000020  00000000   NOP
00000028  00000000   NOP
0000002C  00000000   NOP
00000030  00000000   NOP
00000038  00000000   NOP
0000003C  00000000   NOP
00000040  00000000   NOP
00000048  00000000   NOP
0000004C  00000000   NOP
00000050  00000000   NOP
00000058  00000000   NOP
0000005C  00000000   NOP
00000060  00000000   NOP
00000068  00000000   NOP
0000006C  00000000   NOP
00000070  00000000   NOP
0000007C  00000000   NOP
00000084  00000000   NOP
9D000318  03E00008   JR RA
9D00031C  00000000   NOP
9D007890  00801025   OR V0, A0, ZERO
9D007894  7C020804   INS V0, ZERO, 0, 2
9D007898  8C430000   LW V1, 0(V0)
9D00789C  2402FFFF   ADDIU V0, ZERO, -1
9D0078A0  1062000E   BEQ V1, V0, 0x9D0078DC
9D0078A4  00000000   NOP
9D0078A8  27BDFFE8   ADDIU SP, SP, -24
9D0078AC  AFB00010   SW S0, 16(SP)
9D0078B0  00808025   OR S0, A0, ZERO
9D0078B4  AFBF0014   SW RA, 20(SP)
9D0078B8  0F4000C6   JAL SYS_DeInitialize
9D0078BC  00002025   OR A0, ZERO, ZERO
9D0078C0  41626000   DI V0
9D0078C4  000000C0   EHB
9D0078C8  0200C825   OR T9, S0, ZERO
9D0078CC  8FBF0014   LW RA, 20(SP)
9D0078D0  8FB00010   LW S0, 16(SP)
9D0078D4  03200008   JR T9
9D0078D8  27BD0018   ADDIU SP, SP, 24
9D0078DC  03E00008   JR RA
9D0078E0  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/app_ble.c  ------------------------------------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       app_ble.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It
15:                      implements the logic of the application's state machine and it may call
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // *****************************************************************************
25:                  // *****************************************************************************
26:                  // Section: Included Files
27:                  // *****************************************************************************
28:                  // *****************************************************************************
29:                  
30:                  #include "app_ble.h"
31:                  #include "user_hal/bm7x.h"
32:                  #include <stdint.h>
33:                  
34:                  // *****************************************************************************
35:                  // *****************************************************************************
36:                  // Section: Global Data Definitions
37:                  // *****************************************************************************
38:                  // *****************************************************************************
39:                  
40:                  extern bool taskBusy;
41:                  uint8_t appBleHostOutStreamBuffer[APP_BLE_STREAM_BUFFER_SIZE];
42:                  uint8_t appBleHostInStreamBuffer[APP_BLE_STREAM_BUFFER_SIZE];
43:                  RINGBUFFER* appBleRbHostOut = NULL;
44:                  RINGBUFFER* appBleRbHostIn = NULL;
45:                  
46:                  // *****************************************************************************
47:                  /* Application Data
48:                  
49:                    Summary:
50:                      Holds application data
51:                  
52:                    Description:
53:                      This structure holds the application's data.
54:                  
55:                    Remarks:
56:                      This structure should be initialized by the APP_BLE_Initialize function.
57:                  
58:                      Application strings and buffers are be defined outside this structure.
59:                  */
60:                  
61:                  APP_BLE_DATA appBleData;
62:                  
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  // Section: Application Callback Functions
66:                  // *****************************************************************************
67:                  // *****************************************************************************
68:                  
69:                  /* TODO:  Add any necessary callback functions.
70:                  */
71:                  
72:                  // *****************************************************************************
73:                  // *****************************************************************************
74:                  // Section: Application Local Functions
75:                  // *****************************************************************************
76:                  // *****************************************************************************
77:                  
78:                  
79:                  /* TODO:  Add any necessary local functions.
80:                  */
81:                  
82:                  
83:                  // *****************************************************************************
84:                  // *****************************************************************************
85:                  // Section: Application Initialization and State Machine Functions
86:                  // *****************************************************************************
87:                  // *****************************************************************************
88:                  
89:                  /*******************************************************************************
90:                    Function:
91:                      void APP_BLE_Initialize ( void )
92:                  
93:                    Remarks:
94:                      See prototype in app_ble.h.
95:                   */
96:                  
97:                  void APP_BLE_Initialize ( void )
98:                  {
99:                      /* Place the App state machine in its initial state. */
100:                     appBleData.state = APP_BLE_STATE_INIT;
101:                 
102:                     /* Set up the host output stream buffer */
103:                     RB_Init(&appBleData.rbHostOut,
104:                             appBleHostOutStreamBuffer,
105:                             sizeof(appBleHostOutStreamBuffer));
106:                     appBleRbHostOut = &appBleData.rbHostOut;
107:                     
108:                     /* Set up the host input stream buffer */
109:                     RB_Init(&appBleData.rbHostIn,
110:                             appBleHostInStreamBuffer,
111:                             sizeof(appBleHostInStreamBuffer));
112:                     appBleRbHostIn = &appBleData.rbHostIn;
113:                 }
114:                 
115:                 
116:                 /******************************************************************************
117:                   Function:
118:                     void APP_BLE_Tasks ( void )
119:                 
120:                   Remarks:
121:                     See prototype in app_ble.h.
122:                  */
123:                 
124:                 void APP_BLE_Tasks ( void )
125:                 {
126:                 
127:                     /* Check the application's current state. */
128:                     switch (appBleData.state)
129:                     {
130:                         /* Application's initial state. */
131:                         case APP_BLE_STATE_INIT:
132:                         {
133:                             BM7X_Initialize();
134:                             appBleData.state = APP_BLE_STATE_SERVICE_TASKS;
135:                             break;
136:                         }
137:                 
138:                         case APP_BLE_STATE_SERVICE_TASKS:
139:                         {
140:                 //            // Test mode: send incoming character + 1
141:                 //            char* buffer[128];
142:                 //            uint32_t size = BM7X_Read(buffer, sizeof(buffer) - 1);
143:                 //            buffer[size] = '\0';
144:                 //            dprintf("APP_BLE_Tasks: read <%s>\n", buffer);
145:                 //            int i;
146:                 //            for (i = 0; i < size; i++) {
147:                 //                buffer[i]++;
148:                 //            }
149:                 //            BM7X_Write(buffer, size);
150:                             
151:                             // Forward error messages
152:                             gwsError |= BM7X_GetError();
153:                             
154:                             // Forward incoming data to BLE ring buffer
155:                             uint8_t buffer[128];
156:                             uint32_t size = RB_GetFree(&appBleData.rbHostOut);
157:                             size = (size <= sizeof(buffer))? size : sizeof(buffer);
158:                             size = BM7X_Read(buffer, size);
159:                             RB_Write(&appBleData.rbHostOut, buffer, size);
160:                             if (size > 0) {
161:                                 buffer[sizeof(buffer) - 1] = '\0';
162:                                 if (size < sizeof(buffer)) {
163:                                     buffer[size] = '\0';
164:                                 }
165:                                 dprintf("APP_BLE_Tasks: read <%s>\n", buffer);
166:                             }
167:                             
168:                             // Forward outgoing data from BLE ring buffer
169:                             size = BM7X_GetWriteBufferFree();
170:                             size = (size <= sizeof(buffer))? size : sizeof(buffer);
171:                             size = RB_Read(&appBleData.rbHostIn, buffer, size);
172:                             uint32_t sent = BM7X_Write(buffer, size);            
173:                             if (sent != size) {
174:                                 gwsError |= BM7X_UART_TX_QUEUE_OVERFLOW;
175:                             }
176:                             if (sent > 0) {
177:                                 buffer[sizeof(buffer) - 1] = '\0';
178:                                 if (sent < sizeof(buffer)) {
179:                                     buffer[sent] = '\0';
180:                                 }
181:                                 dprintf("APP_BLE_Tasks: write <%s>\n", buffer);
182:                             }
183:                             
184:                             break;
185:                         }
186:                 
187:                         /* The default state should never be executed. */
188:                         default:
189:                         {
190:                             /* TODO: Handle error in application's state machine. */
191:                             break;
192:                         }
193:                     }
194:                 }
195:                 
196:                 
197:                 /*******************************************************************************
198:                  End of File
199:                  */
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D004A80  27BDFF60   ADDIU SP, SP, -160
9D004A84  AFB00094   SW S0, 148(SP)
9D004A88  3C10A000   LUI S0, -24576
9D004A8C  8E022C28   LW V0, 11304(S0)
9D004A90  AFBF009C   SW RA, 156(SP)
9D004A94  10400044   BEQ V0, ZERO, 0x9D004BA8
9D004A98  AFB10098   SW S1, 152(SP)
9D004A9C  24030001   ADDIU V1, ZERO, 1
9D004AA0  1443003D   BNE V0, V1, 0x9D004B98
9D004AA4  8FBF009C   LW RA, 156(SP)
9D004AA8  0F401DAE   JAL BM7X_GetError
9D004AAC  3C11A000   LUI S1, -24576
9D004AB0  8F838014   LW V1, -32748(GP)
9D004AB4  26242C2C   ADDIU A0, S1, 11308
9D004AB8  00621025   OR V0, V1, V0
9D004ABC  0F4000D2   JAL RB_GetFree
9D004AC0  AF828014   SW V0, -32748(GP)
9D004AC4  2C450081   SLTIU A1, V0, 129
9D004AC8  24030080   ADDIU V1, ZERO, 128
9D004ACC  0045180B   MOVN V1, V0, A1
9D004AD0  27A40010   ADDIU A0, SP, 16
9D004AD4  0F4000EC   JAL BM7X_Read
9D004AD8  00602825   OR A1, V1, ZERO
9D004ADC  00408025   OR S0, V0, ZERO
9D004AE0  00403025   OR A2, V0, ZERO
9D004AE4  27A50010   ADDIU A1, SP, 16
9D004AE8  0F401DE0   JAL RB_Write
9D004AEC  26242C2C   ADDIU A0, S1, 11308
9D004AF0  1200000A   BEQ S0, ZERO, 0x9D004B1C
9D004AF4  2E020080   SLTIU V0, S0, 128
9D004AF8  10400004   BEQ V0, ZERO, 0x9D004B0C
9D004AFC  A3A0008F   SB ZERO, 143(SP)
9D004B00  27A20010   ADDIU V0, SP, 16
9D004B04  00508021   ADDU S0, V0, S0
9D004B08  A2000000   SB ZERO, 0(S0)
9D004B0C  3C049D00   LUI A0, -25344
9D004B10  27A50010   ADDIU A1, SP, 16
9D004B14  0F401BA7   JAL dprintf
9D004B18  24847EAC   ADDIU A0, A0, 32428
9D004B1C  0F4000F2   JAL BM7X_GetWriteBufferFree
9D004B20  00000000   NOP
9D004B24  2C460081   SLTIU A2, V0, 129
9D004B28  24030080   ADDIU V1, ZERO, 128
9D004B2C  0046180B   MOVN V1, V0, A2
9D004B30  3C04A000   LUI A0, -24576
9D004B34  27A50010   ADDIU A1, SP, 16
9D004B38  24842C3C   ADDIU A0, A0, 11324
9D004B3C  0F401DF7   JAL RB_Read
9D004B40  00603025   OR A2, V1, ZERO
9D004B44  00402825   OR A1, V0, ZERO
9D004B48  27A40010   ADDIU A0, SP, 16
9D004B4C  0F4000EE   JAL BM7X_Write
9D004B50  00408025   OR S0, V0, ZERO
9D004B54  12020003   BEQ S0, V0, 0x9D004B64
9D004B58  8F838014   LW V1, -32748(GP)
9D004B5C  34630008   ORI V1, V1, 8
9D004B60  AF838014   SW V1, -32748(GP)
9D004B64  1040000C   BEQ V0, ZERO, 0x9D004B98
9D004B68  8FBF009C   LW RA, 156(SP)
9D004B6C  2C430080   SLTIU V1, V0, 128
9D004B70  10600004   BEQ V1, ZERO, 0x9D004B84
9D004B74  A3A0008F   SB ZERO, 143(SP)
9D004B78  27A30010   ADDIU V1, SP, 16
9D004B7C  00621021   ADDU V0, V1, V0
9D004B80  A0400000   SB ZERO, 0(V0)
9D004B84  3C049D00   LUI A0, -25344
9D004B88  27A50010   ADDIU A1, SP, 16
9D004B8C  0F401BA7   JAL dprintf
9D004B90  24847EC8   ADDIU A0, A0, 32456
9D004B94  8FBF009C   LW RA, 156(SP)
9D004B98  8FB10098   LW S1, 152(SP)
9D004B9C  8FB00094   LW S0, 148(SP)
9D004BA0  03E00008   JR RA
9D004BA4  27BD00A0   ADDIU SP, SP, 160
9D004BA8  0F4020BE   JAL BM7X_Initialize
9D004BAC  00000000   NOP
9D004BB0  8FBF009C   LW RA, 156(SP)
9D004BB4  24020001   ADDIU V0, ZERO, 1
9D004BB8  AE022C28   SW V0, 11304(S0)
9D004BBC  8FB10098   LW S1, 152(SP)
9D004BC0  8FB00094   LW S0, 148(SP)
9D004BC4  03E00008   JR RA
9D004BC8  27BD00A0   ADDIU SP, SP, 160
9D0074B4  27BDFFE0   ADDIU SP, SP, -32
9D0074B8  AFB10018   SW S1, 24(SP)
9D0074BC  3C05A000   LUI A1, -24576
9D0074C0  3C11A000   LUI S1, -24576
9D0074C4  26242C2C   ADDIU A0, S1, 11308
9D0074C8  3C02A000   LUI V0, -24576
9D0074CC  24060100   ADDIU A2, ZERO, 256
9D0074D0  24A52C4C   ADDIU A1, A1, 11340
9D0074D4  AFBF001C   SW RA, 28(SP)
9D0074D8  AFB00014   SW S0, 20(SP)
9D0074DC  AC402C28   SW ZERO, 11304(V0)
9D0074E0  0F4000BA   JAL RB_Init
9D0074E4  3C10A000   LUI S0, -24576
9D0074E8  3C05A000   LUI A1, -24576
9D0074EC  26312C2C   ADDIU S1, S1, 11308
9D0074F0  26042C3C   ADDIU A0, S0, 11324
9D0074F4  24060100   ADDIU A2, ZERO, 256
9D0074F8  24A52B28   ADDIU A1, A1, 11048
9D0074FC  0F4000BA   JAL RB_Init
9D007500  AF918028   SW S1, -32728(GP)
9D007504  8FBF001C   LW RA, 28(SP)
9D007508  26102C3C   ADDIU S0, S0, 11324
9D00750C  AF908024   SW S0, -32732(GP)
9D007510  8FB10018   LW S1, 24(SP)
9D007514  8FB00014   LW S0, 20(SP)
9D007518  03E00008   JR RA
9D00751C  27BD0020   ADDIU SP, SP, 32
---  D:/MPLABX/v6.05/packs/Microchip/PIC32MX_DFP/1.5.259/xc32/startup/crt0.S  ---------------------------
                                                  1:     /*********************************************************************
                                                  2:      *
                                                  3:      *                  C Runtime Startup
                                                  4:      *
                                                  5:      *********************************************************************
                                                  6:      * Filename:        crt0.S
                                                  7:      *
                                                  8:      * Processor:       PIC32
                                                  9:      *
                                                  10:     * Compiler:        MPLAB XC32
                                                  11:     *                  MPLAB X IDE
                                                  12:     * Company:         Microchip Technology Inc.
                                                  13:     *
                                                  14:     * Software License Agreement
                                                  15:     *
                                                  16:     * Copyright (c) 2014, Microchip Technology Inc. and its subsidiaries ("Microchip")
                                                  17:     * All rights reserved.
                                                  18:     *
                                                  19:     * This software is developed by Microchip Technology Inc. and its
                                                  20:     * subsidiaries ("Microchip").
                                                  21:     *
                                                  22:     * Redistribution and use in source and binary forms, with or without
                                                  23:     * modification, are permitted provided that the following conditions are met:
                                                  24:     *
                                                  25:     * 1.      Redistributions of source code must retain the above copyright
                                                  26:     * notice, this list of conditions and the following disclaimer.
                                                  27:     *
                                                  28:     * 2.      Redistributions in binary form must reproduce the above copyright
                                                  29:     * notice, this list of conditions and the following disclaimer in the
                                                  30:     * documentation and/or other materials provided with the distribution.
                                                  31:     * Publication is not required when this file is used in an embedded 
                                                  32:     * application.
                                                  33:     *
                                                  34:     * 3.      Microchip's name may not be used to endorse or promote products
                                                  35:     * derived from this software without specific prior written permission.
                                                  36:     *
                                                  37:     * THIS SOFTWARE IS PROVIDED BY MICROCHIP "AS IS" AND ANY EXPRESS OR IMPLIED
                                                  38:     * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
                                                  39:     * MERCHANTABILITY AND FITNESS FOR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
                                                  40:     * MICROCHIP BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                                                  41:     * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING BUT NOT LIMITED TO
                                                  42:     * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA OR PROFITS;
                                                  43:     * OR BUSINESS INTERRUPTION) HOWSOEVER CAUSED AND ON ANY THEORY OF LIABILITY,
                                                  44:     * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
                                                  45:     * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
                                                  46:     * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                  47:     *
                                                  48:     ********************************************************************/
                                                  49:    
                                                  50:    #include "xc.h"
                                                  51:    #include <cp0defs.h>
                                                  52:    
                                                  53:    #ifdef __LIBBUILD__
                                                  54:       # Replace the standard debugging information with a simple filename. This
                                                  55:       # prevents the library build directory from showing up in MPLAB IDE. It
                                                  56:       # also effectively disables source-line debugging.
                                                  57:       .file 1 "libpic32/startup/crt0.S"
                                                  58:       .loc 1 0
                                                  59:    #endif
                                                  60:    
                                                  61:    #if (__XC32_VERSION > 1000) && !defined(CPP_INIT)
                                                  62:    #define CPP_INIT
                                                  63:    #endif
                                                  64:    
                                                  65:    #if !defined(PIC32_SRS_SET_COUNT)
                                                  66:    #  if defined(__PIC32_SRS_SET_COUNT)
                                                  67:    #    define PIC32_SRS_SET_COUNT __PIC32_SRS_SET_COUNT
                                                  68:    #  else
                                                  69:    #    warning PIC32_SRS_SET_COUNT not defined on build line
                                                  70:    #    define PIC32_SRS_SET_COUNT 2
                                                  71:    #  endif
                                                  72:    #endif
                                                  73:    
                                                  74:    #if defined(__PIC32MX) || defined(__PIC32MM) || defined(__PIC32MZ)
                                                  75:    #define INIT_DATA 1
                                                  76:    #endif
                                                  77:    
                                                  78:    /* This file contains 32-bit assembly code */
                                                  79:           .set nomips16
                                                  80:    
                                                  81:            ##################################################################
                                                  82:            # Entry point of the entire application
                                                  83:            ##################################################################
                                                  84:            .section .reset,code,keep
                                                  85:            .align 2
                                                  86:            .set noreorder
                                                  87:            .ent _reset
                                                  88:    
                                                  89:    ############################
                                                  90:    # Begin ISA switching code #
                                                  91:    ############################
                                                  92:    
                                                  93:    #if defined (__mips_micromips)
                                                  94:            .set micromips
                                                  95:    #endif
                                                  96:    
                                                  97:    #if (defined(__PIC32_HAS_MICROMIPS)) && (defined(__PIC32_HAS_MIPS32R2))
                                                  98:    _reset:
                                                  99:            .word 0x10000003     /* MIPS32:    branch forward 0x10 bytes from here  */
                                                  100:                                /* MicroMIPS: ADDI32 $0, $0, 0x0007 (nop)          */
                                                  101:                                /* DO NOT change the relative branch               */
                                                  102:   
                                                  103:           .word 0x00000000     /* NOP */
                                                  104:   __reset_micromips_isa:
                                                  105:           .set    micromips
                                                  106:           jal     _startup
                                                  107:           nop
                                                  108:   
                                                  109:           .align 2
                                                  110:           /* Device not in proper ISA mode */
                                                  111:           .set nomicromips
                                                  112:   __reset_switch_isa:
                                                  113:           jal _startup
                                                  114:           nop
                                                  115:   
                                                  116:   #else
                                                  117:   
                                                  118:   _reset:
BFC00000  0FF00002   JAL 0xBFC00008               119:           jal _startup
BFC00004  00000000   NOP                          120:           nop
                                                  121:   
                                                  122:   #endif  /* __PIC32_HAS_MICROMIPS */
                                                  123:   
                                                  124:           .align 2
                                                  125:           .end _reset
                                                  126:           .globl _reset
                                                  127:           .size _reset, .-_reset
                                                  128:   
                                                  129:           .section .reset.startup,code,keep
                                                  130:           .align 2
                                                  131:           .set noreorder
                                                  132:   
                                                  133:   #if defined (__mips_micromips)
                                                  134:           .set micromips
                                                  135:   #else
                                                  136:           .set nomicromips
                                                  137:   #endif
                                                  138:   
                                                  139:   ############################
                                                  140:   # End ISA switching code   #
                                                  141:   ############################
                                                  142:   
                                                  143:           ##################################################################
                                                  144:           # Startup code
                                                  145:           ##################################################################
                                                  146:           .align 2
                                                  147:           .globl _startup
                                                  148:           .set noreorder
                                                  149:           .ent _startup
                                                  150:   _startup:
                                                  151:           ##################################################################
                                                  152:           # If entered because of an NMI, jump to the NMI handler.
                                                  153:           ##################################################################
BFC00008  401A6000   MFC0 K0, Status              154:           mfc0    k0,_CP0_STATUS
BFC0000C  7F5A04C0   EXT K0, K0, 19, 1            155:           ext     k0,k0,19,1              # Extract NMI bit
BFC00010  13400005   BEQ K0, ZERO, 0xBFC00028     156:           beqz    k0,_no_nmi
BFC00014  00000000   NOP                          157:           nop
BFC00018  3C1A9D00   LUI K0, -25344               158:           la      k0,_nmi_handler
BFC00020  03400008   JR K0                        159:           jr      k0
BFC00024  00000000   NOP                          160:           nop
                                                  161:   _no_nmi:
                                                  162:   
                                                  163:           ##################################################################
                                                  164:           # Initialize Stack Pointer
                                                  165:           #   _stack is initialized by the linker script to point to the
                                                  166:           #    starting location of the stack in DRM
                                                  167:           ##################################################################
BFC00028  3C1DA001   LUI SP, -24575               168:           la      sp,_stack
                                                  169:   
                                                  170:           ##################################################################
                                                  171:           # Initialize Global Pointer
                                                  172:           #   _gp is initialized by the linker script to point to "middle"
                                                  173:           #   of the small variables region
                                                  174:           ##################################################################
BFC00030  3C1CA001   LUI GP, -24575               175:           la      gp,_gp
                                                  176:   
                                                  177:   #if (PIC32_SRS_SET_COUNT == 2)
                                                  178:           ##################################################################
                                                  179:           # Initialize Global Pointer in Shadow Set
                                                  180:           #   The SRSCtl's PSS field must be set to the shadow set in which
                                                  181:           #   to initialize the global pointer.  Since we have only a
                                                  182:           #   single shadow set (besides the normal), we will initialize
                                                  183:           #   SRSCtl<PSS> to SRSCtl<HSS>.  We then write the global pointer
                                                  184:           #   to the previous shadow set to ensure that on interrupt, the
                                                  185:           #   global pointer has been initialized.
                                                  186:           ##################################################################
                                                  187:           mfc0    t1,_CP0_SRSCTL          # Read SRSCtl register
                                                  188:           add     t3,t1,zero              # Save off current SRSCtl
                                                  189:           ext     t2,t1,26,4              # to obtain HSS field
                                                  190:           ins     t1,t2,6,4               # Put HSS field
                                                  191:           mtc0    t1,_CP0_SRSCTL          # into SRSCtl<PSS>
                                                  192:           ehb                             # Clear hazard before using new SRSCTL
                                                  193:           wrpgpr  gp,gp                   # Set global pointer in PSS
                                                  194:           mtc0    t3,_CP0_SRSCTL          # Restore SRSCtl
                                                  195:           ehb
                                                  196:   
                                                  197:   #elif (PIC32_SRS_SET_COUNT > 2)
                                                  198:           ##################################################################
                                                  199:           # Initialize Global Pointer in Shadow Set(s)
                                                  200:           #   The SRSCtl PSS field must be set to the shadow set in which
                                                  201:           #   to initialize the global pointer.  We will initialize
                                                  202:           #   SRSCtl<PSS> to the number of reg sets and work down to set zero.
                                                  203:           #   We write the global pointer to the previous shadow set to
                                                  204:           #   ensure that on interrupt, the global pointer has been
                                                  205:           #   initialized.
                                                  206:           ##################################################################
                                                  207:           mfc0    t1,_CP0_SRSCTL          # Read SRSCtl register
                                                  208:           add     t3,t1,zero              # Save off current SRSCtl
                                                  209:   
                                                  210:           li      t2,(PIC32_SRS_SET_COUNT-1)
                                                  211:   
                                                  212:   1:      ins     t1,t2,6,4               # Put next shadow set field
                                                  213:           mtc0    t1,_CP0_SRSCTL          # into SRSCtl<PSS>
                                                  214:           ehb                             # Clear hazard before using new SRSCTL
                                                  215:           wrpgpr  gp,gp                   # Set global pointer in PSS
                                                  216:   
                                                  217:           addiu   t2,t2,-1                # Next lower shadow set
                                                  218:                                           # Loop for all sets
                                                  219:           bne     t2,$0,1b                # Down to zero (normal GPR set)
                                                  220:           nop
                                                  221:   
                                                  222:           mtc0    t3,_CP0_SRSCTL          # Restore SRSCtl
                                                  223:           ehb
                                                  224:   
                                                  225:   #endif /* (PIC32_SRS_SET_COUNT > 2) */
                                                  226:   
                                                  227:           ##################################################################
                                                  228:           # Call the "on reset" procedure
                                                  229:           ##################################################################
BFC00038  3C089D00   LUI T0, -25344               230:           la      t0,_on_reset
BFC00040  0100F809   JALR T0                      231:           jalr    t0
BFC00044  00000000   NOP                          232:           nop
                                                  233:   
                                                  234:   #if defined(INIT_MMU_MZ_FIXED) || defined(__PIC32_HAS_MMU_MZ_FIXED)
                                                  235:           ##################################################################
                                                  236:           # Initialize TLB for fixed mapping to EBI and SQI
                                                  237:           ##################################################################
                                                  238:           .extern __pic32_tlb_init_ebi_sqi
                                                  239:           la      t0,__pic32_tlb_init_ebi_sqi
                                                  240:           jalr    t0
                                                  241:           nop
                                                  242:   #endif
                                                  243:   
                                                  244:           ##################################################################
                                                  245:           # Clear uninitialized data sections
                                                  246:           ##################################################################
                                                  247:   _start_bss_init:
BFC00048  3C08A000   LUI T0, -24576               248:           la      t0,_bss_begin
BFC00050  3C09A000   LUI T1, -24576               249:           la      t1,_bss_end
BFC00058  10000003   BEQ ZERO, ZERO, 0xBFC00068   250:           b       _bss_check
BFC0005C  00000000   NOP                          251:           nop
                                                  252:   
                                                  253:   _bss_init:
BFC00060  AD000000   SW ZERO, 0(T0)               254:           sw      zero,0x0(t0)
BFC00064  25080004   ADDIU T0, T0, 4              255:           addu    t0,4
                                                  256:   _bss_check:
BFC00068  0109082B   SLTU AT, T0, T1              257:           bltu    t0,t1,_bss_init
BFC00070  00000000   NOP                          258:           nop
                                                  259:   
                                                  260:   #if defined(INIT_L1_CACHE) || defined(__PIC32_HAS_L1CACHE)
                                                  261:           ##################################################################
                                                  262:           # Initialize L1 cache. This must be done after bss clearing
                                                  263:           # since the _bss_end symbol may not be cache-line aligned.
                                                  264:           ##################################################################
                                                  265:           .extern   __pic32_init_cache
                                                  266:           la      t0,__pic32_init_cache
                                                  267:           jalr    t0
                                                  268:           nop
                                                  269:   #endif
                                                  270:   
                                                  271:   #if defined(INIT_DATA) || defined(__PIC32_HAS_INIT_DATA)
                                                  272:   
                                                  273:   #if defined(__LIBBUILD__) /* Prebuilt crt0.o file */
                                                  274:   
                                                  275:           ##################################################################
                                                  276:           # Initialize data using the linker-generated .dinit table
                                                  277:           # For use with XC32 versions prior to XC32 v2.10 only.
                                                  278:           ##################################################################
                                                  279:           .equiv FMT_CLEAR,0
                                                  280:           .equiv FMT_COPY,1
                                                  281:   _dinit_init:
                                                  282:           la      t0,_dinit_addr
                                                  283:   
                                                  284:   #define SRC t0
                                                  285:   #define DST t1
                                                  286:   #define LEN t2
                                                  287:   #define FMT t3
                                                  288:   
                                                  289:   0:      lw      DST,0(SRC)
                                                  290:           beqz    DST,9f
                                                  291:           addu    SRC,4
                                                  292:           lw      LEN,0(SRC)
                                                  293:           addu    SRC,4
                                                  294:           lw      FMT,0(SRC)
                                                  295:           beq     FMT,$0,_dinit_clear
                                                  296:           addu    SRC,4
                                                  297:   
                                                  298:   _dinit_copy:
                                                  299:           lbu     t4,0(SRC)
                                                  300:           subu    LEN,1
                                                  301:           addu    SRC,1
                                                  302:           sb      t4,0(DST)
                                                  303:           bne     LEN,$0,_dinit_copy
                                                  304:           addu    DST,1
                                                  305:   
                                                  306:           b       _dinit_end
                                                  307:           nop
                                                  308:   
                                                  309:   _dinit_clear:
                                                  310:           sb      $0,(DST)
                                                  311:           subu    LEN,1
                                                  312:           bne     LEN,$0,_dinit_clear
                                                  313:           addu    DST,1
                                                  314:   
                                                  315:   _dinit_end:
                                                  316:           addu    SRC,3
                                                  317:           addiu   LEN,$0,-4
                                                  318:           and     SRC,LEN,SRC
                                                  319:           lw      DST,0(SRC)
                                                  320:           bne     DST,$0,0b
                                                  321:           nop
                                                  322:   9:
                                                  323:   
                                                  324:   #else
                                                  325:           #####################################################################
                                                  326:           # Initialize data using the linker-generated .dinit table
                                                  327:           # XC32 v2.10 and later provide the data-init code in a separate file
                                                  328:           # packaged with the compiler rather than the DFP. Use that init
                                                  329:           # code instead.
                                                  330:           #####################################################################
                                                  331:           .extern   __pic32_data_init
BFC00074  3C089D01   LUI T0, -25343               332:           la      t0, __pic32_data_init
BFC0007C  0100F809   JALR T0                      333:           jalr    t0
BFC00080  00000000   NOP                          334:           nop
                                                  335:   
                                                  336:   #if defined(_OFF168_VOFF_POSITION)
                                                  337:           lui	t1,%hi(OFF168)
                                                  338:           lui	t2,%hi(__vector_offset_168)
                                                  339:           addiu	t2,t2,%lo(__vector_offset_168)
                                                  340:           sw	t2,%lo(OFF168)(t1)
                                                  341:   #endif
                                                  342:   
                                                  343:   #endif /* __LIBBUILD__ */
                                                  344:   
                                                  345:   #endif /* INIT_DATA */
                                                  346:   
                                                  347:           ##################################################################
                                                  348:           # If there are no RAM functions, skip the next section --
                                                  349:           # initializing bus matrix registers.
                                                  350:           ##################################################################
BFC00084  3C090000   LUI T1, 0                    351:           la      t1,_ramfunc_begin
BFC0008C  11200010   BEQ T1, ZERO, 0xBFC000D0     352:           beqz    t1,_ramfunc_done
BFC00090  00000000   NOP                          353:           nop
                                                  354:   
                                                  355:   #if defined(INIT_SSX) || defined(__PIC32_HAS_SSX)
                                                  356:     /* No initialization required */
                                                  357:   #else /* Use BMX */
                                                  358:           ##################################################################
                                                  359:           # Initialize bus matrix registers if RAM functions exist in the
                                                  360:           # application
                                                  361:           ##################################################################
BFC00094  3C090001   LUI T1, 1                    362:           la      t1,_bmxdkpba_address
BFC0009C  3C0ABF88   LUI T2, -16504               363:           la      t2,BMXDKPBA
BFC000A4  AD490000   SW T1, 0(T2)                 364:           sw      t1,0(t2)
BFC000A8  3C090001   LUI T1, 1                    365:           la      t1,_bmxdudba_address
BFC000B0  3C0ABF88   LUI T2, -16504               366:           la      t2,BMXDUDBA
BFC000B8  AD490000   SW T1, 0(T2)                 367:           sw      t1,0(t2)
BFC000BC  3C090001   LUI T1, 1                    368:           la      t1,_bmxdupba_address
BFC000C4  3C0ABF88   LUI T2, -16504               369:           la      t2,BMXDUPBA
BFC000CC  AD490000   SW T1, 0(T2)                 370:           sw      t1,0(t2)
                                                  371:   #endif /* INIT_SSX */
                                                  372:   
                                                  373:   _ramfunc_done:
                                                  374:   
                                                  375:           ##################################################################
                                                  376:           # Initialize CP0 registers
                                                  377:           ##################################################################
                                                  378:           # Initialize Count register
                                                  379:           ##################################################################
BFC000D0  40804800   MTC0 ZERO, Count             380:           mtc0    zero,_CP0_COUNT
                                                  381:   
                                                  382:           ##################################################################
                                                  383:           # Initialize Compare register
                                                  384:           ##################################################################
BFC000D4  240AFFFF   ADDIU T2, ZERO, -1           385:           li      t2,-1
BFC000D8  408A5800   MTC0 T2, Compare             386:           mtc0    t2,_CP0_COMPARE
                                                  387:   
                                                  388:           ##################################################################
                                                  389:           # Ensure BEV set and Initialize EBase register
                                                  390:           ##################################################################
BFC000DC  3C080040   LUI T0, 64                   391:           li      t0, (1<<22)
BFC000E0  400A6000   MFC0 T2, Status              392:           mfc0    t2,_CP0_STATUS
BFC000E4  010A5025   OR T2, T0, T2                393:           or      t2,t0,t2               # Set BEV bit 22
BFC000E8  408A6000   MTC0 T2, Status              394:           mtc0    t2,_CP0_STATUS
                                                  395:   
BFC000EC  3C099D00   LUI T1, -25344               396:           la      t1,_ebase_address
BFC000F4  000000C0   EHB                          397:           ehb
BFC000F8  40897801   MTC0 T1, EBase               398:           mtc0    t1,_CP0_EBASE
                                                  399:           
                                                  400:           ##################################################################
                                                  401:           # Initialize PRISS register to a safer default for devices that 
                                                  402:           # have it. The application should re-initialize it to an
                                                  403:           # application-specific value.
                                                  404:           #
                                                  405:           # We do NOT do this by default.
                                                  406:           ##################################################################
                                                  407:   #if defined(USE_DEFAULT_PRISS_VALUE) 
                                                  408:   #if defined(_PRISS_PRI7SS_POSITION)
                                                  409:   #if (PIC32_SRS_SET_COUNT >= 7)
                                                  410:           li	    t2, 0x76540000
                                                  411:           addiu	t2, t2, 0x3210
                                                  412:           lui	    t1, %hi(PRISS)
                                                  413:           sw	    t2, %lo(PRISS)(t1)
                                                  414:   #elif (PIC32_SRS_SET_COUNT <= 2)
                                                  415:           li	    t2, 0x10000000
                                                  416:           lui	    t1, %hi(PRISS)
                                                  417:           sw	    t2, %lo(PRISS)(t1)
                                                  418:   #endif /* PIC32_SRS_SET_COUNT */
                                                  419:   #endif /* _PRISS_PRI7SS_POSITION */
                                                  420:   #endif /* USE_DEFAULT_PRISS_VALUE */
                                                  421:           
                                                  422:           ##################################################################
                                                  423:           # Initialize IntCtl/INTCON.VS register with _vector_spacing
                                                  424:           ##################################################################
BFC000FC  3C090000   LUI T1, 0                    425:           la      t1,_vector_spacing
                                                  426:   #if defined(INIT_INTCONVS) || defined(__PIC32_HAS_INTCONVS)
                                                  427:           la      t0, INTCON
                                                  428:           lw      t2, 0(t0)
                                                  429:           li      t2, 0
                                                  430:           ins     t2, t1, 16, 7
                                                  431:   #if defined(__PIC32MM) && defined(_INTCON_MVEC_MASK)
                                                  432:           ori     t2, t2, _INTCON_MVEC_MASK
                                                  433:   #endif
                                                  434:           sw      t2, 0(t0)
                                                  435:   #endif
BFC00104  240A0000   ADDIU T2, ZERO, 0            436:           li      t2,0                    # Clear t2 and
BFC00108  7D2A4944   INS T2, T1, 5, 5             437:           ins     t2,t1,5,5               # shift value to VS field
BFC0010C  408A6001   MTC0 T2, IntCtl              438:           mtc0    t2,_CP0_INTCTL
                                                  439:   
                                                  440:           ##################################################################
                                                  441:           # Initialize CAUSE registers
                                                  442:           # - Enable counting of Count register <DC = 0>
                                                  443:           # - Use special exception vector <IV = 1>
                                                  444:           # - Clear pending software interrupts <IP1:IP0 = 0>
                                                  445:           ##################################################################
BFC00110  3C090080   LUI T1, 128                  446:           li      t1,0x00800000
BFC00114  40896800   MTC0 T1, Cause               447:           mtc0    t1,_CP0_CAUSE
                                                  448:   
                                                  449:           ##################################################################
                                                  450:           # Initialize STATUS register
                                                  451:           # - Access to Coprocessor 0 not allowed in user mode <CU0 = 0>
                                                  452:           # - User mode uses configured endianness <RE = 0>
                                                  453:           # - Preserve Bootstrap Exception vectors <BEV>
                                                  454:           # - Preserve soft reset <SR> and non-maskable interrupt <NMI>
                                                  455:           # - CorExtend enabled based on whether CorExtend User Defined
                                                  456:           #   Instructions have been implemented <CEE = Config<UDI>>
                                                  457:           # - Disable any pending interrupts <IM7..IM2 = 0, IM1..IM0 = 0>
                                                  458:           # - Disable hardware interrupts <IPL7:IPL2 = 0>
                                                  459:           # - Base mode is Kernel mode <UM = 0>
                                                  460:           # - Error level is normal <ERL = 0>
                                                  461:           # - Exception level is normal <EXL = 0>
                                                  462:           # - Interrupts are disabled <IE = 0>
                                                  463:           # - DSPr2 ASE is enabled for devices that support it <MX = 1>
                                                  464:           # - FPU64 is enabled for devices that support it <CU1=1> & <FR=1>
                                                  465:           ##################################################################
BFC00118  40088000   MFC0 T0, Config              466:           mfc0    t0,_CP0_CONFIG
BFC0011C  7D090580   EXT T1, T0, 22, 1            467:           ext     t1,t0,22,1              # Extract UDI from Config register
BFC00120  00094C40   SLL T1, T1, 17               468:           sll     t1,t1,17                # Move UDI to Status.CEE location
BFC00124  40086000   MFC0 T0, Status              469:           mfc0    t0,_CP0_STATUS
BFC00128  3C010058   LUI AT, 88                   470:           and     t0,t0,0x00580000        # Preserve SR, NMI, and BEV
                                                  471:   #if defined(INIT_DSPR2) || defined(__PIC32_HAS_DSPR2)
                                                  472:           li      t2, 0x01000000          # Set the Status.MX bit to enable DSP
                                                  473:           or      t0,t2,t0
                                                  474:   #endif
                                                  475:   #if defined(INIT_FPU64) || defined(__PIC32_HAS_FPU64)
                                                  476:           li      t2, 0x24000000          # Set the Status.CU1 and Status.FR bits to
                                                  477:           or      t0,t2,t0                # enable the FPU in FR64 mode
                                                  478:   #endif
                                                  479:   
BFC00130  01284025   OR T0, T1, T0                480:           or      t0,t1,t0                # Include Status.CEE (from UDI)
BFC00134  40886000   MTC0 T0, Status              481:           mtc0    t0,_CP0_STATUS
                                                  482:           
                                                  483:   #if defined(PIC32WK) && defined(_CP0_CONFIG3) && defined (__mips_micromips)
                                                  484:           # Ensure that the ISAONEXEC bit is set for the microMIPS ISA for the PIC32WK family
                                                  485:           # _bsc0 (_CP0_CONFIG3, _CP0_CONFIG3_SELECT, ISAONEXEC_MASK)
                                                  486:           li      t1,0x10000              # ISAONEXEC bit
                                                  487:           mfc0    t0,_CP0_CONFIG3
                                                  488:           or      t1,t0,t1
                                                  489:           mtc0    t1,_CP0_CONFIG3
                                                  490:   
                                                  491:   #endif /* PIC32WK && __mips_micromips */
                                                  492:   
                                                  493:   #if defined(INIT_FPU64) || defined(__PIC32_HAS_FPU64)
                                                  494:                                           # FPU Control and Status
                                                  495:           li      t2,0x1000000            # FCSR: RM=0, FS=1, FO=0, FN=0
                                                  496:                                           # Enables: 0b00000 E=1, V=0, Z=0, O=0, U=0, I=0
                                                  497:           ctc1    t2, $31                 # High perf on denormal operands & tiny results
                                                  498:   #endif
BFC00138  000000C0   EHB                          499:           ehb
                                                  500:   
                                                  501:           ##################################################################
                                                  502:           # Call the "on bootstrap" procedure
                                                  503:           ##################################################################
BFC0013C  3C089D00   LUI T0, -25344               504:           la      t0,_on_bootstrap
BFC00144  0100F809   JALR T0                      505:           jalr    t0
BFC00148  00000000   NOP                          506:           nop
                                                  507:   
                                                  508:           ##################################################################
                                                  509:           # Initialize Status<BEV> for normal exception vectors
                                                  510:           ##################################################################
BFC0014C  40086000   MFC0 T0, Status              511:           mfc0    t0,_CP0_STATUS
BFC00150  3C01FFBF   LUI AT, -65                  512:           and     t0,t0,0xffbfffff        # Clear BEV
BFC0015C  40886000   MTC0 T0, Status              513:           mtc0    t0,_CP0_STATUS
                                                  514:   
                                                  515:           ##################################################################
                                                  516:           # Call main. We do this via a thunk in the text section so that
                                                  517:           # a normal jump and link can be used, enabling the startup code
                                                  518:           # to work properly whether main is written in MIPS16 or MIPS32
                                                  519:           # code. I.e., the linker will correctly adjust the JAL to JALX if
                                                  520:           # necessary
                                                  521:           ##################################################################
BFC00160  30840000   ANDI A0, A0, 0               522:           and     a0,a0,0
BFC00164  30A50000   ANDI A1, A1, 0               523:           and     a1,a1,0
BFC00168  3C089D00   LUI T0, -25344               524:           la      t0,_main_entry
BFC00170  01000008   JR T0                        525:           jr      t0
BFC00174  00000000   NOP                          526:           nop
                                                  527:   
                                                  528:           .end _startup
                                                  529:   
                                                  530:           ##################################################################
                                                  531:           # Boot Exception Vector Handler
                                                  532:           # Jumps to _bootstrap_exception_handler
                                                  533:           ##################################################################
                                                  534:           .section .bev_handler,code,keep
                                                  535:           .align 2
                                                  536:           .set noreorder
                                                  537:           .ent _bev_exception
                                                  538:   _bev_exception:
BFC00380  3C1A9D00   LUI K0, -25344               539:           la        k0,_bootstrap_exception_handler
BFC00388  03400008   JR K0                        540:           jr        k0
BFC0038C  00000000   NOP                          541:           nop
                                                  542:   
                                                  543:           .end _bev_exception
                                                  544:   
                                                  545:           ##################################################################
                                                  546:           # General Exception Vector Handler
                                                  547:           # Jumps to _general_exception_context
                                                  548:           ##################################################################
                                                  549:           .section .gen_handler,code
                                                  550:           .align 2
                                                  551:           .set noreorder
                                                  552:           .ent _gen_exception
                                                  553:   _gen_exception:
9D000180  3C1A9D00   LUI K0, -25344               554:   0:      la      k0,_general_exception_context
9D000188  03400008   JR K0                        555:           jr      k0
9D00018C  00000000   NOP                          556:           nop
                                                  557:   
                                                  558:           .end _gen_exception
                                                  559:   
                                                  560:   #if defined(INIT_MMU_MZ_FIXED) || defined(__PIC32_HAS_MMU_MZ_FIXED)
                                                  561:           ##################################################################
                                                  562:           # Simple TLB-Refill Exception Vector
                                                  563:           # Jumps to _simple_tlb_refill_exception_context
                                                  564:           ##################################################################
                                                  565:           .section .simple_tlb_refill_vector,code,keep
                                                  566:           .align 2
                                                  567:           .set noreorder
                                                  568:           .ent simple_tlb_refill_vector
                                                  569:   simple_tlb_refill_vector:
                                                  570:           la      k0,_simple_tlb_refill_exception_context
                                                  571:           jr      k0
                                                  572:           nop
                                                  573:   
                                                  574:           .end simple_tlb_refill_vector
                                                  575:   #endif
                                                  576:   
                                                  577:   #if defined(INIT_L1_CACHE) || defined(__PIC32_HAS_L1CACHE)
                                                  578:           ##################################################################
                                                  579:           # Cache-Error Exception Vector Handler
                                                  580:           # Jumps to _cache_err_exception_context
                                                  581:           ##################################################################
                                                  582:           .section .cache_err_vector,code,keep
                                                  583:           .align 2
                                                  584:           .set noreorder
                                                  585:           .ent _cache_err_vector
                                                  586:   _cache_err_vector:
                                                  587:           la      k0,_cache_err_exception_context
                                                  588:           jr      k0
                                                  589:           nop
                                                  590:   
                                                  591:           .end _cache_err_vector
                                                  592:   #endif
                                                  593:   
                                                  594:           .section .text.main_entry,code,keep
                                                  595:           .align 2
                                                  596:           .ent _main_entry
                                                  597:   _main_entry:
                                                  598:   
                                                  599:   #if defined(CPP_INIT)
                                                  600:           .weak _init
                                                  601:           # call .init section to run constructors etc
9D007938  3C040000   LUI A0, 0                    602:           lui	a0,%hi(_init)
9D00793C  27BDFFE8   ADDIU SP, SP, -24            603:           addiu	sp,sp,-24
9D007940  24840000   ADDIU A0, A0, 0              604:           addiu	a0,a0,%lo(_init)
9D007944  10800003   BEQ A0, ZERO, 0x9D007954     605:           beq	a0,$0,2f
9D007948  AFBF0014   SW RA, 20(SP)                606:           sw	$31,20(sp)	 #,
9D00794C  0080F809   JALR A0                      607:           jalr	a0
9D007950  00000000   NOP                          608:           nop
                                                  609:   2:
                                                  610:   #endif
9D007954  30840000   ANDI A0, A0, 0               611:           and     a0,a0,0
9D007958  30A50000   ANDI A1, A1, 0               612:           and     a1,a1,0
                                                  613:   
                                                  614:           ##################################################################
                                                  615:   
                                                  616:           # Call main
                                                  617:           ##################################################################
9D00795C  3C089D01   LUI T0, -25343               618:           la    	t0,main
9D007964  0100F809   JALR T0                      619:           jalr 	t0
9D007968  00000000   NOP                          620:           nop
                                                  621:   
                                                  622:   #if defined(CALL_EXIT)
                                                  623:           ##################################################################
                                                  624:           # Call exit()
                                                  625:           ##################################################################
                                                  626:           jal exit
                                                  627:           nop
                                                  628:   #endif
                                                  629:   
                                                  630:           ##################################################################
                                                  631:           # Just in case, go into infinite loop
                                                  632:           # Call a software breakpoint only with -mdebugger compiler option
                                                  633:           ##################################################################
                                                  634:           .weak __exception_handler_break
                                                  635:   __crt0_exit:
                                                  636:   1:
9D00796C  3C029D00   LUI V0, -25344               637:           la      v0,__exception_handler_break
9D007974  10400003   BEQ V0, ZERO, 0x9D007984     638:           beq     v0,0,0f
9D007978  00000000   NOP                          639:           nop
9D00797C  0040F809   JALR V0                      640:           jalr    v0
9D007980  00000000   NOP                          641:           nop
                                                  642:   
9D007984  1000FFF9   BEQ ZERO, ZERO, 0x9D00796C   643:   0:      b       1b
9D007988  00000000   NOP                          644:           nop
                                                  645:   
                                                  646:           .globl __crt0_exit
                                                  647:           .end _main_entry
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/string/xc32/strstr.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D007838  00801025   OR V0, A0, ZERO
9D00783C  80A40000   LB A0, 0(A1)
9D007840  1080000C   BEQ A0, ZERO, 0x9D007874
9D007844  00000000   NOP
9D007848  80430000   LB V1, 0(V0)
9D00784C  14600003   BNE V1, ZERO, 0x9D00785C
9D007850  00000000   NOP
9D007854  03E00008   JR RA
9D007858  00001025   OR V0, ZERO, ZERO
9D00785C  1483000A   BNE A0, V1, 0x9D007888
9D007860  24030001   ADDIU V1, ZERO, 1
9D007864  00A33021   ADDU A2, A1, V1
9D007868  80C60000   LB A2, 0(A2)
9D00786C  14C00003   BNE A2, ZERO, 0x9D00787C
9D007870  00433821   ADDU A3, V0, V1
9D007874  03E00008   JR RA
9D007878  00000000   NOP
9D00787C  80E70000   LB A3, 0(A3)
9D007880  10E6FFF8   BEQ A3, A2, 0x9D007864
9D007884  24630001   ADDIU V1, V1, 1
9D007888  1000FFEF   BEQ ZERO, ZERO, 0x9D007848
9D00788C  24420001   ADDIU V0, V0, 1
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-gcc/gcc/libgcc/floatunsidf.c  ---
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D007DC4  27BDFFE8   ADDIU SP, SP, -24
9D007DC8  AFB00010   SW S0, 16(SP)
9D007DCC  AFBF0014   SW RA, 20(SP)
9D007DD0  0F401CF4   JAL __floatsidf
9D007DD4  00808025   OR S0, A0, ZERO
9D007DD8  06010006   BGEZ S0, 0x9D007DF4
9D007DDC  00602825   OR A1, V1, ZERO
9D007DE0  3C049D00   LUI A0, -25344
9D007DE4  8C8603E8   LW A2, 1000(A0)
9D007DE8  8C8703EC   LW A3, 1004(A0)
9D007DEC  0F4008BD   JAL __adddf3
9D007DF0  00402025   OR A0, V0, ZERO
9D007DF4  8FBF0014   LW RA, 20(SP)
9D007DF8  8FB00010   LW S0, 16(SP)
9D007DFC  03E00008   JR RA
9D007E00  27BD0018   ADDIU SP, SP, 24
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/build-Linux/pic32m-libs/libpic32/stubs/default-on-reset.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0003F0  03E00008   JR RA
9D0003F4  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/build-Linux/pic32m-libs/libpic32/stubs/default-on-bootstrap.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0003F8  03E00008   JR RA
9D0003FC  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/build-Linux/pic32m-libs/libpic32/startup/software-debug-break.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D000174  7000003F   SDBBP 0
9D000178  03E00008   JR RA
9D00017C  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/build-Linux/pic32m-libs/libpic32/default_vector_dispatch/defaultinterrupt.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D007BAC  3C020000   LUI V0, 0
9D007BB0  24420000   ADDIU V0, V0, 0
9D007BB4  10400007   BEQ V0, ZERO, 0x9D007BD4
9D007BB8  3C029D00   LUI V0, -25344
9D007BBC  24420174   ADDIU V0, V0, 372
9D007BC0  50400005   BEQL V0, ZERO, 0x9D007BD8
9D007BC4  3C029D00   LUI V0, -25344
9D007BC8  7000003F   SDBBP 0
9D007BCC  03E00008   JR RA
9D007BD0  00000000   NOP
9D007BD4  3C029D00   LUI V0, -25344
9D007BD8  24427CC0   ADDIU V0, V0, 31936
9D007BDC  10400003   BEQ V0, ZERO, 0x9D007BEC
9D007BE0  00000000   NOP
9D007BE4  0040F809   JALR V0
9D007BE8  00000000   NOP
9D007BEC  03E00008   JR RA
9D007BF0  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/user_hal/strconv.c  ---------------------------------------
1:                   int strToInt(char* str, int* valid, char** end)
2:                   {
3:                       int value = 0;
4:                       int sign = 0;
5:                       int i = 0;
6:                       while (str[i] != '\0') {
7:                           if ((sign == 0) && (str[i] == '+')) {
8:                               sign = +1;
9:                           } else if ((sign == 0) && (str[i] == '-')) {
10:                              sign = -1;
11:                          } else if ((str[i] >= '0') && (str[i] <= '9')) {
12:                              value = value * 10 + (int)(str[i] - '0');
13:                              if (value & 0x80000000) {
14:                                  *valid = 0;
15:                              }
16:                          } else {
17:                              break;
18:                          }
19:                          i++;
20:                      }
21:                      *end = &str[i];
22:                      if (sign == -1) {
23:                          value = -value;
24:                      }
25:                      return value;
26:                  }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
00000024  00000000   NOP
0000002C  00000000   NOP
00000030  00000000   NOP
00000034  00000000   NOP
00000038  00000000   NOP
0000003C  00000000   NOP
00000040  00000000   NOP
00000048  00000000   NOP
00000050  00000000   NOP
00000058  00000000   NOP
00000060  00000000   NOP
00000064  00000000   NOP
0000006C  00000000   NOP
00000074  00000000   NOP
0000007C  00000000   NOP
00000084  00000000   NOP
00000088  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/user_hal/ringbuffer.c  ------------------------------------
1:                   /**
2:                    * @file ringbuffer.c
3:                    * @brief Ring buffer (FIFO) implementation
4:                    * @author David Bender <d_bender@bluewin.ch>
5:                    * @date 22.12.2022
6:                    */
7:                   
8:                   #include "ringbuffer.h"
9:                   #include <string.h>
10:                  #include <stdarg.h>
11:                  #include <stdio.h>
12:                  
13:                  /**
14:                   * Initializes a ring buffer (FIFO).
15:                   * @param[in]       rb          Pointer to ring buffer.
16:                   * @param[in]       buffer      Data buffer assigned to this ring buffer.
17:                   * @param[in]       size        Buffer size in bytes.
18:                   */
19:                  void RB_Init(RINGBUFFER* rb, void* buffer, uint32_t size)
20:                  {
21:                      rb->buffer = buffer;
22:                      rb->size = size;
23:                      rb->used = 0;
24:                      rb->tail = 0;
25:                  }
26:                  
27:                  /**
28:                   * Reports the number of bytes that can be read from the buffer before it
29:                   * becomes empty.
30:                   * @param[in]       rb          Pointer to ring buffer.
31:                   * @return                      Number of used bytes.
32:                   */
33:                  uint32_t RB_GetUsed(RINGBUFFER* rb)
34:                  {
35:                      return rb->used;
36:                  }
37:                  
38:                  /**
39:                   * Reports the number of bytes that can be written to the buffer before it
40:                   * becomes full.
41:                   * @param[in]       rb          Pointer to ring buffer.
42:                   * @return                      Number of free bytes.
43:                   */
44:                  uint32_t RB_GetFree(RINGBUFFER* rb)
45:                  {
46:                      return rb->size - rb->used;
47:                  }
48:                  
49:                  /**
50:                   * Writes into the current contiguous range of a ring buffer.
51:                   * Since there are two separate contiguous ranges, one before and one after the
52:                   * head pointer wrap, two calls may be needed to write all data.
53:                   * @param[in]       rb          Pointer to ring buffer.
54:                   * @param[in]       data        Write data.
55:                   * @param[in]       size        Write data length in bytes.
56:                   * @return                      Number of bytes written to the ring buffer. 0 is
57:                   *                              returned if the buffer is full.
58:                   */
59:                  uint32_t RB_WriteContiguous(RINGBUFFER* rb, void* data, uint32_t size)
60:                  {
61:                      uint32_t free = rb->size - rb->used;
62:                      uint32_t head = rb->tail + rb->used;
63:                      head -= (head >= rb->size)? rb->size: 0;
64:                      uint32_t chunk = rb->size - head;
65:                      chunk = (chunk > size)? size: chunk;
66:                      chunk = (chunk > free)? free: chunk;
67:                      if (chunk > 0) {
68:                          memcpy((uint8_t*)rb->buffer + head, data, chunk);
69:                          rb->used += chunk;
70:                      }
71:                      return chunk;
72:                  }
73:                  
74:                  /**
75:                   * Writes into a ring buffer.
76:                   * @param[in]       rb          Pointer to ring buffer.
77:                   * @param[in]       data        Write data.
78:                   * @param[in]       size        Write data length in bytes.
79:                   * @return                      Number of bytes written to the ring buffer.
80:                   *                              Usually the same as size. 0 is returned if the
81:                   *                              buffer is full. Less than size if the buffer
82:                   *                              became full before writing all bytes.
83:                   */
84:                  uint32_t RB_Write(RINGBUFFER* rb, void* data, uint32_t size)
85:                  {
86:                      uint32_t done = 0;
87:                      done += RB_WriteContiguous(rb, (uint8_t*)data + done, size - done);
88:                      done += RB_WriteContiguous(rb, (uint8_t*)data + done, size - done);
89:                      return done;
90:                  }
91:                  
92:                  /**
93:                   * Writes a NULL-terminated C string into a ring buffer.
94:                   * @param[in]       rb          Pointer to ring buffer.
95:                   * @param[in]       data        NULL-terminated C string.
96:                   * @return                      Number of bytes written to the ring buffer.
97:                   *                              The same as the string length or 0 if the buffer
98:                   *                              is (almost) full.
99:                   */
100:                 uint32_t RB_WriteString(RINGBUFFER* rb, char* data)
101:                 {
102:                     uint32_t size = strlen(data);
103:                     if (RB_GetFree(rb) < size) {
104:                         return 0;
105:                     }
106:                     return RB_Write(rb, data, size);
107:                 }
108:                 
109:                 /**
110:                  * Prints a NULL-terminated C string into a ring buffer.
111:                  * @param[in]       rb          Pointer to ring buffer.
112:                  * @param[in]       format      Like printf().
113:                  * @param[in]       ...         Like printf().
114:                  * @return                      Number of bytes written to the ring buffer.
115:                  *                              Usually the same as the string length.
116:                  *                              0 is returned if the buffer is full. Less than
117:                  *                              size if the buffer became full before writing
118:                  *                              all bytes.
119:                  */
120:                 uint32_t RB_Printf(RINGBUFFER* rb, const char* format, ...)
121:                 {
122:                     char str[128];
123:                     va_list vlist;
124:                     va_start(vlist, format);
125:                     vsnprintf(str, sizeof(str), format, vlist);
126:                     va_end(vlist);
127:                     return RB_WriteString(rb, str);
128:                 }
129:                 
130:                 /**
131:                  * Reads from the current contiguous range of a ring buffer.
132:                  * Since there are two separate contiguous ranges, one before and one after the
133:                  * tail pointer wrap, two calls may be needed to read all data.
134:                  * @param[in]       rb          Pointer to ring buffer.
135:                  * @param[out]      data        Read data.
136:                  * @param[in]       size        Read data length in bytes.
137:                  * @return                      Number of bytes read from the ring buffer. 0 is
138:                  *                              returned if the buffer is full.
139:                  */
140:                 uint32_t RB_ReadContiguous(RINGBUFFER* rb, void* data, uint32_t size)
141:                 {
142:                     uint32_t chunk = rb->size - rb->tail;
143:                     chunk = (chunk > size)? size: chunk;
144:                     chunk = (chunk > rb->used)? rb->used: chunk;
145:                     if (chunk > 0) {
146:                         memcpy(data, (uint8_t*)rb->buffer + rb->tail, chunk);
147:                         rb->used -= chunk;
148:                         rb->tail += chunk;
149:                         rb->tail -= (rb->tail >= rb->size)? rb->size: 0;
150:                     }
151:                     return chunk;
152:                 }
153:                 
154:                 /**
155:                  * Reads from a ring buffer.
156:                  * @param[in]       rb          Pointer to ring buffer.
157:                  * @param[out]      data        Read data.
158:                  * @param[in]       size        Read data length in bytes.
159:                  * @return                      Number of bytes read from the ring buffer.
160:                  *                              Usually the same as size. 0 is returned if the
161:                  *                              buffer is empty. Less than size if the buffer
162:                  *                              became empty before reading all bytes.
163:                  */
164:                 uint32_t RB_Read(RINGBUFFER* rb, void* data, uint32_t size)
165:                 {
166:                     uint32_t done = 0;
167:                     done += RB_ReadContiguous(rb, (uint8_t*)data + done, size - done);
168:                     done += RB_ReadContiguous(rb, (uint8_t*)data + done, size - done);
169:                     return done;
170:                 }
171:                 
172:                 /**
173:                  * Reads from a ring buffer, until (and including) a delimiter character.
174:                  * @param[in]       rb          Pointer to ring buffer.
175:                  * @param[out]      data        Read data, NULL terminated string.
176:                  * @param[in]       size        Read data length in bytes excluding termination
177:                  *                              character.
178:                  * @return                      Number of bytes read from the ring buffer,
179:                  *                              including the delimiter. 0 if ring buffer is
180:                  *                              empty or does not contain the delimiter.
181:                  */
182:                 uint32_t RB_ReadLine(RINGBUFFER* rb, char* data, uint32_t size, char* delim)
183:                 {
184:                     // Reserve character for NULL termination
185:                     if (size == 0) {
186:                         return 0;
187:                     }
188:                     size--;
189:                 
190:                     // Start with zero checked characters and current tail and usage
191:                     uint32_t used = rb->used;
192:                     uint32_t tail = rb->tail;
193:                     uint32_t checked = 0;
194:                 
195:                     // Search for delimiter until reaching end of buffer
196:                     while (1) {
197:                         uint32_t chunk = rb->size - tail;
198:                         chunk = (chunk > size)? size: chunk;
199:                         chunk = (chunk > used)? used: chunk;
200:                 
201:                         if (chunk > 0) {
202:                             // See if delimiter is found within current chunk of data
203:                             //void* pDelim = memchr((uint8_t*)rb->buffer + tail, delim, chunk);
204:                             void* pBrk = RB_mempbrk((uint8_t*)rb->buffer + tail, delim, chunk);
205:                             if (pBrk != NULL) {
206:                                 // String size is 1 + delimiter position - tail position
207:                                 size = 1 + (uint8_t*)pBrk - ((uint8_t*)rb->buffer + tail);
208:                                 size += checked;
209:                 
210:                                 // Size underflows if tail is before and delimiter is after wrap
211:                                 // -> make it overflow to undo underflow :-)
212:                                 size += (size >= rb->size)? rb->size: 0;
213:                 
214:                                 // Read until and including delimiter
215:                                 RB_Read(rb, data, size);
216:                 
217:                                 // Null terminate and return, reported size is excluding
218:                                 // termination character
219:                                 data[size] = '\0';
220:                                 return size;
221:                             }
222:                 
223:                             // Move tail, update usage and remember number of checked characters
224:                             used -= chunk;
225:                             tail += chunk;
226:                             tail -= (tail >= rb->size)? rb->size: 0;
227:                             checked += chunk;
228:                 
229:                         } else {
230:                             // If current chunk is empty there is no delimiter so return empty
231:                             // string
232:                             data[0] = '\0';
233:                             return 0;
234:                         }
235:                     }
236:                 }
237:                 
238:                 /**
239:                  * Returns position of first break character in data buffer.
240:                  * Basically a combination of memchr() and strpbrk(), so unlike strpbrk() it
241:                  * does not only stop at a '\0' character but also at the specified size.
242:                  * @param[in]       void        Pointer to data buffer.
243:                  * @param[in]       str         Null-terminated array of break characters.
244:                  * @param[in]       size        Data buffer size in bytes.
245:                  * @return                      Pointer to first break character or NULL if no
246:                  *                              break character is found.
247:                  */
248:                 void* RB_mempbrk(void* mem, char* str, uint32_t size)
249:                 {
250:                     char* mem_c = (char*)mem;
251:                     uint32_t i;
252:                     for (i = 0; (i < size) && (mem_c[i] != '\0'); i++) {
253:                         uint32_t j;
254:                         for (j = 0; str[j] != '\0'; j++) {
255:                             if (mem_c[i] == str[j]) {
256:                                 return (void*)&mem_c[i];
257:                             }
258:                         }
259:                     }
260:                     return NULL;
261:                 }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
00000020  00000000   NOP
00000028  00000000   NOP
0000002C  00000000   NOP
00000030  00000000   NOP
00000034  00000000   NOP
00000038  00000000   NOP
00000040  00000000   NOP
00000044  00000000   NOP
00000048  00000000   NOP
0000004C  00000000   NOP
00000058  00000000   NOP
0000005C  00000000   NOP
00000064  00000000   NOP
00000068  00000000   NOP
9D00B000  27BDFFE0   ADDIU SP, SP, -32
9D00B004  AFBF001C   SW RA, 28(SP)
9D00B008  AFB10018   SW S1, 24(SP)
9D00B00C  10C00041   BEQ A2, ZERO, 0x9D00B114
9D00B010  AFB00014   SW S0, 20(SP)
9D00B014  8C8C000C   LW T4, 12(A0)
9D00B018  8C8B0004   LW T3, 4(A0)
9D00B01C  8C8A0008   LW T2, 8(A0)
9D00B020  24CEFFFF   ADDIU T6, A2, -1
9D00B024  016C4823   SUBU T1, T3, T4
9D00B028  0149102B   SLTU V0, T2, T1
9D00B02C  0142480B   MOVN T1, T2, V0
9D00B030  01201025   OR V0, T1, ZERO
9D00B034  012E482B   SLTU T1, T1, T6
9D00B038  01C9100A   MOVZ V0, T6, T1
9D00B03C  1040002A   BEQ V0, ZERO, 0x9D00B0E8
9D00B040  00404825   OR T1, V0, ZERO
9D00B044  8C980000   LW T8, 0(A0)
9D00B048  00007825   OR T7, ZERO, ZERO
9D00B04C  030C6821   ADDU T5, T8, T4
9D00B050  01A04025   OR T0, T5, ZERO
9D00B054  81060000   LB A2, 0(T0)
9D00B058  10C00013   BEQ A2, ZERO, 0x9D00B0A8
9D00B05C  01891021   ADDU V0, T4, T1
9D00B060  80E20000   LB V0, 0(A3)
9D00B064  5040000B   BEQL V0, ZERO, 0x9D00B094
9D00B068  25080001   ADDIU T0, T0, 1
9D00B06C  10C20030   BEQ A2, V0, 0x9D00B130
9D00B070  24E20001   ADDIU V0, A3, 1
9D00B074  10000004   BEQ ZERO, ZERO, 0x9D00B088
9D00B078  80430000   LB V1, 0(V0)
9D00B07C  1066002D   BEQ V1, A2, 0x9D00B134
9D00B080  25100001   ADDIU S0, T0, 1
9D00B084  80430000   LB V1, 0(V0)
9D00B088  1460FFFC   BNE V1, ZERO, RB_mempbrk
9D00B08C  24420001   ADDIU V0, V0, 1
9D00B090  25080001   ADDIU T0, T0, 1
9D00B094  010D1023   SUBU V0, T0, T5
9D00B098  0049102B   SLTU V0, V0, T1
9D00B09C  5440FFEE   BNEL V0, ZERO, 0x9D00B058
9D00B0A0  81060000   LB A2, 0(T0)
9D00B0A4  01891021   ADDU V0, T4, T1
9D00B0A8  004B182B   SLTU V1, V0, T3
9D00B0AC  14600016   BNE V1, ZERO, 0x9D00B108
9D00B0B0  01495023   SUBU T2, T2, T1
9D00B0B4  004B6023   SUBU T4, V0, T3
9D00B0B8  01603025   OR A2, T3, ZERO
9D00B0BC  01621023   SUBU V0, T3, V0
9D00B0C0  00461021   ADDU V0, V0, A2
9D00B0C4  014E182B   SLTU V1, T2, T6
9D00B0C8  01403025   OR A2, T2, ZERO
9D00B0CC  01C3300A   MOVZ A2, T6, V1
9D00B0D0  00C01825   OR V1, A2, ZERO
9D00B0D4  0046302B   SLTU A2, V0, A2
9D00B0D8  0066100A   MOVZ V0, V1, A2
9D00B0DC  01E97821   ADDU T7, T7, T1
9D00B0E0  1440FFDA   BNE V0, ZERO, RB_mempbrk
9D00B0E4  00404825   OR T1, V0, ZERO
9D00B0E8  A0A00000   SB ZERO, 0(A1)
9D00B0EC  8FBF001C   LW RA, 28(SP)
9D00B0F0  00008025   OR S0, ZERO, ZERO
9D00B0F4  02001025   OR V0, S0, ZERO
9D00B0F8  8FB10018   LW S1, 24(SP)
9D00B0FC  8FB00014   LW S0, 20(SP)
9D00B100  03E00008   JR RA
9D00B104  27BD0020   ADDIU SP, SP, 32
9D00B108  00406025   OR T4, V0, ZERO
9D00B10C  1000FFEB   BEQ ZERO, ZERO, 0x9D00B0BC
9D00B110  00003025   OR A2, ZERO, ZERO
9D00B114  8FBF001C   LW RA, 28(SP)
9D00B118  00008025   OR S0, ZERO, ZERO
9D00B11C  02001025   OR V0, S0, ZERO
9D00B120  8FB10018   LW S1, 24(SP)
9D00B124  8FB00014   LW S0, 20(SP)
9D00B128  03E00008   JR RA
9D00B12C  27BD0020   ADDIU SP, SP, 32
9D00B130  25100001   ADDIU S0, T0, 1
9D00B134  020D8023   SUBU S0, S0, T5
9D00B138  020F8021   ADDU S0, S0, T7
9D00B13C  020B102B   SLTU V0, S0, T3
9D00B140  020B5821   ADDU T3, S0, T3
9D00B144  0162800A   MOVZ S0, T3, V0
9D00B148  00A08825   OR S1, A1, ZERO
9D00B14C  0F405F2E   JAL RB_Read
9D00B150  02003025   OR A2, S0, ZERO
9D00B154  02302821   ADDU A1, S1, S0
9D00B158  A0A00000   SB ZERO, 0(A1)
9D00B15C  8FBF001C   LW RA, 28(SP)
9D00B160  02001025   OR V0, S0, ZERO
9D00B164  8FB10018   LW S1, 24(SP)
9D00B168  8FB00014   LW S0, 20(SP)
9D00B16C  03E00008   JR RA
9D00B170  27BD0020   ADDIU SP, SP, 32
9D00B348  AC850000   SW A1, 0(A0)
9D00B34C  AC860004   SW A2, 4(A0)
9D00B350  AC800008   SW ZERO, 8(A0)
9D00B354  03E00008   JR RA
9D00B358  AC80000C   SW ZERO, 12(A0)
9D00B3C8  8C830004   LW V1, 4(A0)
9D00B3CC  8C820008   LW V0, 8(A0)
9D00B3D0  03E00008   JR RA
9D00B3D4  00621023   SUBU V0, V1, V0
9D00B3F8  03E00008   JR RA
9D00B3FC  8C820008   LW V0, 8(A0)
9D01608C  8C830008   LW V1, 8(A0)
9D016090  8C87000C   LW A3, 12(A0)
9D016094  8C820004   LW V0, 4(A0)
9D016098  27BDFFE0   ADDIU SP, SP, -32
9D01609C  00673821   ADDU A3, V1, A3
9D0160A0  00E2402B   SLTU T0, A3, V0
9D0160A4  AFBF001C   SW RA, 28(SP)
9D0160A8  AFB10018   SW S1, 24(SP)
9D0160AC  AFB00014   SW S0, 20(SP)
9D0160B0  15000011   BNE T0, ZERO, 0x9D0160F8
9D0160B4  00431823   SUBU V1, V0, V1
9D0160B8  00404025   OR T0, V0, ZERO
9D0160BC  00C3802B   SLTU S0, A2, V1
9D0160C0  00E24823   SUBU T1, A3, V0
9D0160C4  00471023   SUBU V0, V0, A3
9D0160C8  00481021   ADDU V0, V0, T0
9D0160CC  00D0180B   MOVN V1, A2, S0
9D0160D0  0043802B   SLTU S0, V0, V1
9D0160D4  0070100A   MOVZ V0, V1, S0
9D0160D8  14400011   BNE V0, ZERO, 0x9D016120
9D0160DC  00408025   OR S0, V0, ZERO
9D0160E0  8FBF001C   LW RA, 28(SP)
9D0160E4  02001025   OR V0, S0, ZERO
9D0160E8  8FB10018   LW S1, 24(SP)
9D0160EC  8FB00014   LW S0, 20(SP)
9D0160F0  03E00008   JR RA
9D0160F4  27BD0020   ADDIU SP, SP, 32
9D0160F8  00C3802B   SLTU S0, A2, V1
9D0160FC  00004025   OR T0, ZERO, ZERO
9D016100  00471023   SUBU V0, V0, A3
9D016104  00481021   ADDU V0, V0, T0
9D016108  00D0180B   MOVN V1, A2, S0
9D01610C  0043802B   SLTU S0, V0, V1
9D016110  0070100A   MOVZ V0, V1, S0
9D016114  00E04825   OR T1, A3, ZERO
9D016118  1040FFF1   BEQ V0, ZERO, 0x9D0160E0
9D01611C  00408025   OR S0, V0, ZERO
9D016120  00808825   OR S1, A0, ZERO
9D016124  8C840000   LW A0, 0(A0)
9D016128  00403025   OR A2, V0, ZERO
9D01612C  0F404CCF   JAL memcpy
9D016130  00892021   ADDU A0, A0, T1
9D016134  8E220008   LW V0, 8(S1)
9D016138  8FBF001C   LW RA, 28(SP)
9D01613C  00501021   ADDU V0, V0, S0
9D016140  AE220008   SW V0, 8(S1)
9D016144  02001025   OR V0, S0, ZERO
9D016148  8FB10018   LW S1, 24(SP)
9D01614C  8FB00014   LW S0, 20(SP)
9D016150  03E00008   JR RA
9D016154  27BD0020   ADDIU SP, SP, 32
9D016D4C  8C830008   LW V1, 8(A0)
9D016D50  8C87000C   LW A3, 12(A0)
9D016D54  8C820004   LW V0, 4(A0)
9D016D58  27BDFFE0   ADDIU SP, SP, -32
9D016D5C  AFB10018   SW S1, 24(SP)
9D016D60  00C3882B   SLTU S1, A2, V1
9D016D64  00471023   SUBU V0, V0, A3
9D016D68  0071300A   MOVZ A2, V1, S1
9D016D6C  0046882B   SLTU S1, V0, A2
9D016D70  00D1100A   MOVZ V0, A2, S1
9D016D74  AFBF001C   SW RA, 28(SP)
9D016D78  AFB00014   SW S0, 20(SP)
9D016D7C  14400007   BNE V0, ZERO, 0x9D016D9C
9D016D80  00408825   OR S1, V0, ZERO
9D016D84  8FBF001C   LW RA, 28(SP)
9D016D88  02201025   OR V0, S1, ZERO
9D016D8C  8FB00014   LW S0, 20(SP)
9D016D90  8FB10018   LW S1, 24(SP)
9D016D94  03E00008   JR RA
9D016D98  27BD0020   ADDIU SP, SP, 32
9D016D9C  8C820000   LW V0, 0(A0)
9D016DA0  00808025   OR S0, A0, ZERO
9D016DA4  02203025   OR A2, S1, ZERO
9D016DA8  00A02025   OR A0, A1, ZERO
9D016DAC  0F404CCF   JAL memcpy
9D016DB0  00472821   ADDU A1, V0, A3
9D016DB4  8E02000C   LW V0, 12(S0)
9D016DB8  8E030004   LW V1, 4(S0)
9D016DBC  8E040008   LW A0, 8(S0)
9D016DC0  02221021   ADDU V0, S1, V0
9D016DC4  8FBF001C   LW RA, 28(SP)
9D016DC8  0043282B   SLTU A1, V0, V1
9D016DCC  00431823   SUBU V1, V0, V1
9D016DD0  00912023   SUBU A0, A0, S1
9D016DD4  0065100A   MOVZ V0, V1, A1
9D016DD8  AE02000C   SW V0, 12(S0)
9D016DDC  AE040008   SW A0, 8(S0)
9D016DE0  02201025   OR V0, S1, ZERO
9D016DE4  8FB00014   LW S0, 20(SP)
9D016DE8  8FB10018   LW S1, 24(SP)
9D016DEC  03E00008   JR RA
9D016DF0  27BD0020   ADDIU SP, SP, 32
9D017A68  27BDFFE0   ADDIU SP, SP, -32
9D017A6C  AFB00014   SW S0, 20(SP)
9D017A70  00808025   OR S0, A0, ZERO
9D017A74  00A02025   OR A0, A1, ZERO
9D017A78  AFB10018   SW S1, 24(SP)
9D017A7C  AFBF001C   SW RA, 28(SP)
9D017A80  0F404D29   JAL strlen
9D017A84  00A08825   OR S1, A1, ZERO
9D017A88  8E030004   LW V1, 4(S0)
9D017A94  0062182B   SLTU V1, V1, V0
9D017A98  10600006   BEQ V1, ZERO, 0x9D017AB4
9D017A9C  8FBF001C   LW RA, 28(SP)
9D017AA0  00001025   OR V0, ZERO, ZERO
9D017AA4  8FB10018   LW S1, 24(SP)
9D017AA8  8FB00014   LW S0, 20(SP)
9D017AAC  03E00008   JR RA
9D017AB0  27BD0020   ADDIU SP, SP, 32
9D017AB4  02202825   OR A1, S1, ZERO
9D017AB8  02002025   OR A0, S0, ZERO
9D017ABC  8FB10018   LW S1, 24(SP)
9D017AC0  8FB00014   LW S0, 20(SP)
9D017AC4  00403025   OR A2, V0, ZERO
9D017AC8  0B405F17   J RB_Write
9D017ACC  27BD0020   ADDIU SP, SP, 32
9D017AD0  27BDFFF8   ADDIU SP, SP, -8
9D017C5C  27BDFFD8   ADDIU SP, SP, -40
9D017C60  AFBF0024   SW RA, 36(SP)
9D017C64  AFB30020   SW S3, 32(SP)
9D017C68  AFB2001C   SW S2, 28(SP)
9D017C6C  AFB10018   SW S1, 24(SP)
9D017C70  AFB00014   SW S0, 20(SP)
9D017C74  00808825   OR S1, A0, ZERO
9D017C78  00A09025   OR S2, A1, ZERO
9D017C7C  0F405823   JAL RB_WriteContiguous
9D017C80  00C09825   OR S3, A2, ZERO
9D017C84  02623023   SUBU A2, S3, V0
9D017C88  02422821   ADDU A1, S2, V0
9D017C8C  02202025   OR A0, S1, ZERO
9D017C90  0F405823   JAL RB_WriteContiguous
9D017C94  00408025   OR S0, V0, ZERO
9D017C98  8FBF0024   LW RA, 36(SP)
9D017C9C  02021021   ADDU V0, S0, V0
9D017CA0  8FB30020   LW S3, 32(SP)
9D017CA4  8FB2001C   LW S2, 28(SP)
9D017CA8  8FB10018   LW S1, 24(SP)
9D017CAC  8FB00014   LW S0, 20(SP)
9D017CB0  03E00008   JR RA
9D017CB4  27BD0028   ADDIU SP, SP, 40
9D017CB8  27BDFFD8   ADDIU SP, SP, -40
9D017CBC  AFBF0024   SW RA, 36(SP)
9D017CC0  AFB30020   SW S3, 32(SP)
9D017CC4  AFB2001C   SW S2, 28(SP)
9D017CC8  AFB10018   SW S1, 24(SP)
9D017CCC  AFB00014   SW S0, 20(SP)
9D017CD0  00808825   OR S1, A0, ZERO
9D017CD4  00A09025   OR S2, A1, ZERO
9D017CD8  0F405B53   JAL RB_ReadContiguous
9D017CDC  00C09825   OR S3, A2, ZERO
9D017CE0  02623023   SUBU A2, S3, V0
9D017CE4  02422821   ADDU A1, S2, V0
9D017CE8  02202025   OR A0, S1, ZERO
9D017CEC  0F405B53   JAL RB_ReadContiguous
9D017CF0  00408025   OR S0, V0, ZERO
9D017CF4  8FBF0024   LW RA, 36(SP)
9D017CF8  02021021   ADDU V0, S0, V0
9D017CFC  8FB30020   LW S3, 32(SP)
9D017D00  8FB2001C   LW S2, 28(SP)
9D017D04  8FB10018   LW S1, 24(SP)
9D017D08  8FB00014   LW S0, 20(SP)
9D017D0C  03E00008   JR RA
9D017D10  27BD0028   ADDIU SP, SP, 40
---  c:/users/db/desktop/nano_tx/firmware/src/user_hal/printf.c  ----------------------------------------
1:                   ///////////////////////////////////////////////////////////////////////////////
2:                   // \author (c) Marco Paland (info@paland.com)
3:                   //             2014-2019, PALANDesign Hannover, Germany
4:                   //
5:                   // \license The MIT License (MIT)
6:                   //
7:                   // Permission is hereby granted, free of charge, to any person obtaining a copy
8:                   // of this software and associated documentation files (the "Software"), to deal
9:                   // in the Software without restriction, including without limitation the rights
10:                  // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
11:                  // copies of the Software, and to permit persons to whom the Software is
12:                  // furnished to do so, subject to the following conditions:
13:                  //
14:                  // The above copyright notice and this permission notice shall be included in
15:                  // all copies or substantial portions of the Software.
16:                  //
17:                  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
18:                  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
19:                  // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
20:                  // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
21:                  // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
22:                  // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
23:                  // THE SOFTWARE.
24:                  //
25:                  // \brief Tiny printf, sprintf and (v)snprintf implementation, optimized for speed on
26:                  //        embedded systems with a very limited resources. These routines are thread
27:                  //        safe and reentrant!
28:                  //        Use this instead of the bloated standard/newlib printf cause these use
29:                  //        malloc for printf (and may not be thread safe).
30:                  //
31:                  ///////////////////////////////////////////////////////////////////////////////
32:                  
33:                  #include <stdbool.h>
34:                  #include <stdint.h>
35:                  
36:                  #include "printf.h"
37:                  
38:                  
39:                  // define this globally (e.g. gcc -DPRINTF_INCLUDE_CONFIG_H ...) to include the
40:                  // printf_config.h header file
41:                  // default: undefined
42:                  #ifdef PRINTF_INCLUDE_CONFIG_H
43:                  #include "printf_config.h"
44:                  #endif
45:                  
46:                  
47:                  // 'ntoa' conversion buffer size, this must be big enough to hold one converted
48:                  // numeric number including padded zeros (dynamically created on stack)
49:                  // default: 32 byte
50:                  #ifndef PRINTF_NTOA_BUFFER_SIZE
51:                  #define PRINTF_NTOA_BUFFER_SIZE    32U
52:                  #endif
53:                  
54:                  // 'ftoa' conversion buffer size, this must be big enough to hold one converted
55:                  // float number including padded zeros (dynamically created on stack)
56:                  // default: 32 byte
57:                  #ifndef PRINTF_FTOA_BUFFER_SIZE
58:                  #define PRINTF_FTOA_BUFFER_SIZE    32U
59:                  #endif
60:                  
61:                  // support for the floating point type (%f)
62:                  // default: activated
63:                  #ifndef PRINTF_DISABLE_SUPPORT_FLOAT
64:                  #define PRINTF_SUPPORT_FLOAT
65:                  #endif
66:                  
67:                  // support for exponential floating point notation (%e/%g)
68:                  // default: activated
69:                  #ifndef PRINTF_DISABLE_SUPPORT_EXPONENTIAL
70:                  #define PRINTF_SUPPORT_EXPONENTIAL
71:                  #endif
72:                  
73:                  // define the default floating point precision
74:                  // default: 6 digits
75:                  #ifndef PRINTF_DEFAULT_FLOAT_PRECISION
76:                  #define PRINTF_DEFAULT_FLOAT_PRECISION  6U
77:                  #endif
78:                  
79:                  // define the largest float suitable to print with %f
80:                  // default: 1e9
81:                  #ifndef PRINTF_MAX_FLOAT
82:                  #define PRINTF_MAX_FLOAT  1e9
83:                  #endif
84:                  
85:                  // support for the long long types (%llu or %p)
86:                  // default: activated
87:                  #ifndef PRINTF_DISABLE_SUPPORT_LONG_LONG
88:                  #define PRINTF_SUPPORT_LONG_LONG
89:                  #endif
90:                  
91:                  // support for the ptrdiff_t type (%t)
92:                  // ptrdiff_t is normally defined in <stddef.h> as long or long long type
93:                  // default: activated
94:                  #ifndef PRINTF_DISABLE_SUPPORT_PTRDIFF_T
95:                  #define PRINTF_SUPPORT_PTRDIFF_T
96:                  #endif
97:                  
98:                  ///////////////////////////////////////////////////////////////////////////////
99:                  
100:                 // internal flag definitions
101:                 #define FLAGS_ZEROPAD   (1U <<  0U)
102:                 #define FLAGS_LEFT      (1U <<  1U)
103:                 #define FLAGS_PLUS      (1U <<  2U)
104:                 #define FLAGS_SPACE     (1U <<  3U)
105:                 #define FLAGS_HASH      (1U <<  4U)
106:                 #define FLAGS_UPPERCASE (1U <<  5U)
107:                 #define FLAGS_CHAR      (1U <<  6U)
108:                 #define FLAGS_SHORT     (1U <<  7U)
109:                 #define FLAGS_LONG      (1U <<  8U)
110:                 #define FLAGS_LONG_LONG (1U <<  9U)
111:                 #define FLAGS_PRECISION (1U << 10U)
112:                 #define FLAGS_ADAPT_EXP (1U << 11U)
113:                 
114:                 
115:                 // import float.h for DBL_MAX
116:                 #if defined(PRINTF_SUPPORT_FLOAT)
117:                 #include <float.h>
118:                 #endif
119:                 
120:                 
121:                 // output function type
122:                 typedef void (*out_fct_type)(char character, void* buffer, size_t idx, size_t maxlen);
123:                 
124:                 
125:                 // wrapper (used as buffer) for output function type
126:                 typedef struct {
127:                   void  (*fct)(char character, void* arg);
128:                   void* arg;
129:                 } out_fct_wrap_type;
130:                 
131:                 
132:                 // internal buffer output
133:                 static inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)
134:                 {
135:                   if (idx < maxlen) {
136:                     ((char*)buffer)[idx] = character;
137:                   }
138:                 }
139:                 
140:                 
141:                 // internal null output
142:                 static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
143:                 {
144:                   (void)character; (void)buffer; (void)idx; (void)maxlen;
145:                 }
146:                 
147:                 
148:                 // internal _putchar wrapper
149:                 static inline void _out_char(char character, void* buffer, size_t idx, size_t maxlen)
150:                 {
151:                   (void)buffer; (void)idx; (void)maxlen;
152:                   if (character) {
153:                     _putchar(character);
154:                   }
155:                 }
156:                 
157:                 
158:                 // internal output function wrapper
159:                 static inline void _out_fct(char character, void* buffer, size_t idx, size_t maxlen)
160:                 {
161:                   (void)idx; (void)maxlen;
162:                   if (character) {
163:                     // buffer is the output fct pointer
164:                     ((out_fct_wrap_type*)buffer)->fct(character, ((out_fct_wrap_type*)buffer)->arg);
165:                   }
166:                 }
167:                 
168:                 
169:                 // internal secure strlen
170:                 // \return The length of the string (excluding the terminating 0) limited by 'maxsize'
171:                 static inline unsigned int _strnlen_s(const char* str, size_t maxsize)
172:                 {
173:                   const char* s;
174:                   for (s = str; *s && maxsize--; ++s);
175:                   return (unsigned int)(s - str);
176:                 }
177:                 
178:                 
179:                 // internal test if char is a digit (0-9)
180:                 // \return true if char is a digit
181:                 static inline bool _is_digit(char ch)
182:                 {
183:                   return (ch >= '0') && (ch <= '9');
184:                 }
185:                 
186:                 
187:                 // internal ASCII string to unsigned int conversion
188:                 static unsigned int _atoi(const char** str)
189:                 {
190:                   unsigned int i = 0U;
191:                   while (_is_digit(**str)) {
192:                     i = i * 10U + (unsigned int)(*((*str)++) - '0');
193:                   }
194:                   return i;
195:                 }
196:                 
197:                 
198:                 // output the specified string in reverse, taking care of any zero-padding
199:                 static size_t _out_rev(out_fct_type out, char* buffer, size_t idx, size_t maxlen, const char* buf, size_t len, unsigned int width, unsigned int flags)
200:                 {
201:                   const size_t start_idx = idx;
202:                 
203:                   // pad spaces up to given width
204:                   if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
205:                     for (size_t i = len; i < width; i++) {
206:                       out(' ', buffer, idx++, maxlen);
207:                     }
208:                   }
209:                 
210:                   // reverse string
211:                   while (len) {
212:                     out(buf[--len], buffer, idx++, maxlen);
213:                   }
214:                 
215:                   // append pad spaces up to given width
216:                   if (flags & FLAGS_LEFT) {
217:                     while (idx - start_idx < width) {
218:                       out(' ', buffer, idx++, maxlen);
219:                     }
220:                   }
221:                 
222:                   return idx;
223:                 }
224:                 
225:                 
226:                 // internal itoa format
227:                 static size_t _ntoa_format(out_fct_type out, char* buffer, size_t idx, size_t maxlen, char* buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)
228:                 {
229:                   // pad leading zeros
230:                   if (!(flags & FLAGS_LEFT)) {
231:                     if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
232:                       width--;
233:                     }
234:                     while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
235:                       buf[len++] = '0';
236:                     }
237:                     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
238:                       buf[len++] = '0';
239:                     }
240:                   }
241:                 
242:                   // handle hash
243:                   if (flags & FLAGS_HASH) {
244:                     if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
245:                       len--;
246:                       if (len && (base == 16U)) {
247:                         len--;
248:                       }
249:                     }
250:                     if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
251:                       buf[len++] = 'x';
252:                     }
253:                     else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
254:                       buf[len++] = 'X';
255:                     }
256:                     else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
257:                       buf[len++] = 'b';
258:                     }
259:                     if (len < PRINTF_NTOA_BUFFER_SIZE) {
260:                       buf[len++] = '0';
261:                     }
262:                   }
263:                 
264:                   if (len < PRINTF_NTOA_BUFFER_SIZE) {
265:                     if (negative) {
266:                       buf[len++] = '-';
267:                     }
268:                     else if (flags & FLAGS_PLUS) {
269:                       buf[len++] = '+';  // ignore the space if the '+' exists
270:                     }
271:                     else if (flags & FLAGS_SPACE) {
272:                       buf[len++] = ' ';
273:                     }
274:                   }
275:                 
276:                   return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
277:                 }
278:                 
279:                 
280:                 // internal itoa for 'long' type
281:                 static size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
282:                 {
283:                   char buf[PRINTF_NTOA_BUFFER_SIZE];
284:                   size_t len = 0U;
285:                 
286:                   // no hash for 0 values
287:                   if (!value) {
288:                     flags &= ~FLAGS_HASH;
289:                   }
290:                 
291:                   // write if precision != 0 and value is != 0
292:                   if (!(flags & FLAGS_PRECISION) || value) {
293:                     do {
294:                       const char digit = (char)(value % base);
295:                       buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
296:                       value /= base;
297:                     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
298:                   }
299:                 
300:                   return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
301:                 }
302:                 
303:                 
304:                 // internal itoa for 'long long' type
305:                 #if defined(PRINTF_SUPPORT_LONG_LONG)
306:                 static size_t _ntoa_long_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long long value, bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)
307:                 {
308:                   char buf[PRINTF_NTOA_BUFFER_SIZE];
309:                   size_t len = 0U;
310:                 
311:                   // no hash for 0 values
312:                   if (!value) {
313:                     flags &= ~FLAGS_HASH;
314:                   }
315:                 
316:                   // write if precision != 0 and value is != 0
317:                   if (!(flags & FLAGS_PRECISION) || value) {
318:                     do {
319:                       const char digit = (char)(value % base);
320:                       buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
321:                       value /= base;
322:                     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
323:                   }
324:                 
325:                   return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
326:                 }
327:                 #endif  // PRINTF_SUPPORT_LONG_LONG
328:                 
329:                 
330:                 #if defined(PRINTF_SUPPORT_FLOAT)
331:                 
332:                 #if defined(PRINTF_SUPPORT_EXPONENTIAL)
333:                 // forward declaration so that _ftoa can switch to exp notation for values > PRINTF_MAX_FLOAT
334:                 static size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags);
335:                 #endif
336:                 
337:                 
338:                 // internal ftoa for fixed decimal floating point
339:                 static size_t _ftoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)
340:                 {
341:                   char buf[PRINTF_FTOA_BUFFER_SIZE];
342:                   size_t len  = 0U;
343:                   double diff = 0.0;
344:                 
345:                   // powers of 10
346:                   static const double pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };
347:                 
348:                   // test for special values
349:                   if (value != value)
350:                     return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
351:                   if (value < -DBL_MAX)
352:                     return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
353:                   if (value > DBL_MAX)
354:                     return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
355:                 
356:                   // test for very large values
357:                   // standard printf behavior is to print EVERY whole number digit -- which could be 100s of characters overflowing your buffers == bad
358:                   if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
359:                 #if defined(PRINTF_SUPPORT_EXPONENTIAL)
360:                     return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
361:                 #else
362:                     return 0U;
363:                 #endif
364:                   }
365:                 
366:                   // test for negative
367:                   bool negative = false;
368:                   if (value < 0) {
369:                     negative = true;
370:                     value = 0 - value;
371:                   }
372:                 
373:                   // set default precision, if not set explicitly
374:                   if (!(flags & FLAGS_PRECISION)) {
375:                     prec = PRINTF_DEFAULT_FLOAT_PRECISION;
376:                   }
377:                   // limit precision to 9, cause a prec >= 10 can lead to overflow errors
378:                   while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
379:                     buf[len++] = '0';
380:                     prec--;
381:                   }
382:                 
383:                   int whole = (int)value;
384:                   double tmp = (value - whole) * pow10[prec];
385:                   unsigned long frac = (unsigned long)tmp;
386:                   diff = tmp - frac;
387:                 
388:                   if (diff > 0.5) {
389:                     ++frac;
390:                     // handle rollover, e.g. case 0.99 with prec 1 is 1.0
391:                     if (frac >= pow10[prec]) {
392:                       frac = 0;
393:                       ++whole;
394:                     }
395:                   }
396:                   else if (diff < 0.5) {
397:                   }
398:                   else if ((frac == 0U) || (frac & 1U)) {
399:                     // if halfway, round up if odd OR if last digit is 0
400:                     ++frac;
401:                   }
402:                 
403:                   if (prec == 0U) {
404:                     diff = value - (double)whole;
405:                     if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
406:                       // exactly 0.5 and ODD, then round up
407:                       // 1.5 -> 2, but 2.5 -> 2
408:                       ++whole;
409:                     }
410:                   }
411:                   else {
412:                     unsigned int count = prec;
413:                     // now do fractional part, as an unsigned number
414:                     while (len < PRINTF_FTOA_BUFFER_SIZE) {
415:                       --count;
416:                       buf[len++] = (char)(48U + (frac % 10U));
417:                       if (!(frac /= 10U)) {
418:                         break;
419:                       }
420:                     }
421:                     // add extra 0s
422:                     while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
423:                       buf[len++] = '0';
424:                     }
425:                     if (len < PRINTF_FTOA_BUFFER_SIZE) {
426:                       // add decimal
427:                       buf[len++] = '.';
428:                     }
429:                   }
430:                 
431:                   // do whole part, number is reversed
432:                   while (len < PRINTF_FTOA_BUFFER_SIZE) {
433:                     buf[len++] = (char)(48 + (whole % 10));
434:                     if (!(whole /= 10)) {
435:                       break;
436:                     }
437:                   }
438:                 
439:                   // pad leading zeros
440:                   if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
441:                     if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
442:                       width--;
443:                     }
444:                     while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
445:                       buf[len++] = '0';
446:                     }
447:                   }
448:                 
449:                   if (len < PRINTF_FTOA_BUFFER_SIZE) {
450:                     if (negative) {
451:                       buf[len++] = '-';
452:                     }
453:                     else if (flags & FLAGS_PLUS) {
454:                       buf[len++] = '+';  // ignore the space if the '+' exists
455:                     }
456:                     else if (flags & FLAGS_SPACE) {
457:                       buf[len++] = ' ';
458:                     }
459:                   }
460:                 
461:                   return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
462:                 }
463:                 
464:                 
465:                 #if defined(PRINTF_SUPPORT_EXPONENTIAL)
466:                 // internal ftoa variant for exponential floating-point type, contributed by Martijn Jasperse <m.jasperse@gmail.com>
467:                 static size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)
468:                 {
469:                   // check for NaN and special values
470:                   if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
471:                     return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
472:                   }
473:                 
474:                   // determine the sign
475:                   const bool negative = value < 0;
476:                   if (negative) {
477:                     value = -value;
478:                   }
479:                 
480:                   // default precision
481:                   if (!(flags & FLAGS_PRECISION)) {
482:                     prec = PRINTF_DEFAULT_FLOAT_PRECISION;
483:                   }
484:                 
485:                   // determine the decimal exponent
486:                   // based on the algorithm by David Gay (https://www.ampl.com/netlib/fp/dtoa.c)
487:                   union {
488:                     uint64_t U;
489:                     double   F;
490:                   } conv;
491:                 
492:                   conv.F = value;
493:                   int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
494:                   conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
495:                   // now approximate log10 from the log2 integer part and an expansion of ln around 1.5
496:                   int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
497:                   // now we want to compute 10^expval but we want to be sure it won't overflow
498:                   exp2 = (int)(expval * 3.321928094887362 + 0.5);
499:                   const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
500:                   const double z2 = z * z;
501:                   conv.U = (uint64_t)(exp2 + 1023) << 52U;
502:                   // compute exp(z) using continued fractions, see https://en.wikipedia.org/wiki/Exponential_function#Continued_fractions_for_ex
503:                   conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
504:                   // correct for rounding errors
505:                   if (value < conv.F) {
506:                     expval--;
507:                     conv.F /= 10;
508:                   }
509:                 
510:                   // the exponent format is "%+03d" and largest value is "307", so set aside 4-5 characters
511:                   unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
512:                 
513:                   // in "%g" mode, "prec" is the number of *significant figures* not decimals
514:                   if (flags & FLAGS_ADAPT_EXP) {
515:                     // do we want to fall-back to "%f" mode?
516:                     if ((value >= 1e-4) && (value < 1e6)) {
517:                       if ((int)prec > expval) {
518:                         prec = (unsigned)((int)prec - expval - 1);
519:                       }
520:                       else {
521:                         prec = 0;
522:                       }
523:                       flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
524:                       // no characters in exponent
525:                       minwidth = 0U;
526:                       expval   = 0;
527:                     }
528:                     else {
529:                       // we use one sigfig for the whole part
530:                       if ((prec > 0) && (flags & FLAGS_PRECISION)) {
531:                         --prec;
532:                       }
533:                     }
534:                   }
535:                 
536:                   // will everything fit?
537:                   unsigned int fwidth = width;
538:                   if (width > minwidth) {
539:                     // we didn't fall-back so subtract the characters required for the exponent
540:                     fwidth -= minwidth;
541:                   } else {
542:                     // not enough characters, so go back to default sizing
543:                     fwidth = 0U;
544:                   }
545:                   if ((flags & FLAGS_LEFT) && minwidth) {
546:                     // if we're padding on the right, DON'T pad the floating part
547:                     fwidth = 0U;
548:                   }
549:                 
550:                   // rescale the float value
551:                   if (expval) {
552:                     value /= conv.F;
553:                   }
554:                 
555:                   // output the floating part
556:                   const size_t start_idx = idx;
557:                   idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
558:                 
559:                   // output the exponent part
560:                   if (minwidth) {
561:                     // output the exponential symbol
562:                     out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
563:                     // output the exponent value
564:                     idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);
565:                     // might need to right-pad spaces
566:                     if (flags & FLAGS_LEFT) {
567:                       while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);
568:                     }
569:                   }
570:                   return idx;
571:                 }
572:                 #endif  // PRINTF_SUPPORT_EXPONENTIAL
573:                 #endif  // PRINTF_SUPPORT_FLOAT
574:                 
575:                 
576:                 // internal vsnprintf
577:                 static int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)
578:                 {
579:                   unsigned int flags, width, precision, n;
580:                   size_t idx = 0U;
581:                 
582:                   if (!buffer) {
583:                     // use null output function
584:                     out = _out_null;
585:                   }
586:                 
587:                   while (*format)
588:                   {
589:                     // format specifier?  %[flags][width][.precision][length]
590:                     if (*format != '%') {
591:                       // no
592:                       out(*format, buffer, idx++, maxlen);
593:                       format++;
594:                       continue;
595:                     }
596:                     else {
597:                       // yes, evaluate it
598:                       format++;
599:                     }
600:                 
601:                     // evaluate flags
602:                     flags = 0U;
603:                     do {
604:                       switch (*format) {
605:                         case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
606:                         case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
607:                         case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
608:                         case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
609:                         case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
610:                         default :                                   n = 0U; break;
611:                       }
612:                     } while (n);
613:                 
614:                     // evaluate width field
615:                     width = 0U;
616:                     if (_is_digit(*format)) {
617:                       width = _atoi(&format);
618:                     }
619:                     else if (*format == '*') {
620:                       const int w = va_arg(va, int);
621:                       if (w < 0) {
622:                         flags |= FLAGS_LEFT;    // reverse padding
623:                         width = (unsigned int)-w;
624:                       }
625:                       else {
626:                         width = (unsigned int)w;
627:                       }
628:                       format++;
629:                     }
630:                 
631:                     // evaluate precision field
632:                     precision = 0U;
633:                     if (*format == '.') {
634:                       flags |= FLAGS_PRECISION;
635:                       format++;
636:                       if (_is_digit(*format)) {
637:                         precision = _atoi(&format);
638:                       }
639:                       else if (*format == '*') {
640:                         const int prec = (int)va_arg(va, int);
641:                         precision = prec > 0 ? (unsigned int)prec : 0U;
642:                         format++;
643:                       }
644:                     }
645:                 
646:                     // evaluate length field
647:                     switch (*format) {
648:                       case 'l' :
649:                         flags |= FLAGS_LONG;
650:                         format++;
651:                         if (*format == 'l') {
652:                           flags |= FLAGS_LONG_LONG;
653:                           format++;
654:                         }
655:                         break;
656:                       case 'h' :
657:                         flags |= FLAGS_SHORT;
658:                         format++;
659:                         if (*format == 'h') {
660:                           flags |= FLAGS_CHAR;
661:                           format++;
662:                         }
663:                         break;
664:                 #if defined(PRINTF_SUPPORT_PTRDIFF_T)
665:                       case 't' :
666:                         flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
667:                         format++;
668:                         break;
669:                 #endif
670:                       case 'j' :
671:                         flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
672:                         format++;
673:                         break;
674:                       case 'z' :
675:                         flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
676:                         format++;
677:                         break;
678:                       default :
679:                         break;
680:                     }
681:                 
682:                     // evaluate specifier
683:                     switch (*format) {
684:                       case 'd' :
685:                       case 'i' :
686:                       case 'u' :
687:                       case 'x' :
688:                       case 'X' :
689:                       case 'o' :
690:                       case 'b' : {
691:                         // set the base
692:                         unsigned int base;
693:                         if (*format == 'x' || *format == 'X') {
694:                           base = 16U;
695:                         }
696:                         else if (*format == 'o') {
697:                           base =  8U;
698:                         }
699:                         else if (*format == 'b') {
700:                           base =  2U;
701:                         }
702:                         else {
703:                           base = 10U;
704:                           flags &= ~FLAGS_HASH;   // no hash for dec format
705:                         }
706:                         // uppercase
707:                         if (*format == 'X') {
708:                           flags |= FLAGS_UPPERCASE;
709:                         }
710:                 
711:                         // no plus or space flag for u, x, X, o, b
712:                         if ((*format != 'i') && (*format != 'd')) {
713:                           flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
714:                         }
715:                 
716:                         // ignore '0' flag when precision is given
717:                         if (flags & FLAGS_PRECISION) {
718:                           flags &= ~FLAGS_ZEROPAD;
719:                         }
720:                 
721:                         // convert the integer
722:                         if ((*format == 'i') || (*format == 'd')) {
723:                           // signed
724:                           if (flags & FLAGS_LONG_LONG) {
725:                 #if defined(PRINTF_SUPPORT_LONG_LONG)
726:                             const long long value = va_arg(va, long long);
727:                             idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
728:                 #endif
729:                           }
730:                           else if (flags & FLAGS_LONG) {
731:                             const long value = va_arg(va, long);
732:                             idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
733:                           }
734:                           else {
735:                             const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
736:                             idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
737:                           }
738:                         }
739:                         else {
740:                           // unsigned
741:                           if (flags & FLAGS_LONG_LONG) {
742:                 #if defined(PRINTF_SUPPORT_LONG_LONG)
743:                             idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
744:                 #endif
745:                           }
746:                           else if (flags & FLAGS_LONG) {
747:                             idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
748:                           }
749:                           else {
750:                             const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
751:                             idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
752:                           }
753:                         }
754:                         format++;
755:                         break;
756:                       }
757:                 #if defined(PRINTF_SUPPORT_FLOAT)
758:                       case 'f' :
759:                       case 'F' :
760:                         if (*format == 'F') flags |= FLAGS_UPPERCASE;
761:                         idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
762:                         format++;
763:                         break;
764:                 #if defined(PRINTF_SUPPORT_EXPONENTIAL)
765:                       case 'e':
766:                       case 'E':
767:                       case 'g':
768:                       case 'G':
769:                         if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;
770:                         if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
771:                         idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
772:                         format++;
773:                         break;
774:                 #endif  // PRINTF_SUPPORT_EXPONENTIAL
775:                 #endif  // PRINTF_SUPPORT_FLOAT
776:                       case 'c' : {
777:                         unsigned int l = 1U;
778:                         // pre padding
779:                         if (!(flags & FLAGS_LEFT)) {
780:                           while (l++ < width) {
781:                             out(' ', buffer, idx++, maxlen);
782:                           }
783:                         }
784:                         // char output
785:                         out((char)va_arg(va, int), buffer, idx++, maxlen);
786:                         // post padding
787:                         if (flags & FLAGS_LEFT) {
788:                           while (l++ < width) {
789:                             out(' ', buffer, idx++, maxlen);
790:                           }
791:                         }
792:                         format++;
793:                         break;
794:                       }
795:                 
796:                       case 's' : {
797:                         const char* p = va_arg(va, char*);
798:                         unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
799:                         // pre padding
800:                         if (flags & FLAGS_PRECISION) {
801:                           l = (l < precision ? l : precision);
802:                         }
803:                         if (!(flags & FLAGS_LEFT)) {
804:                           while (l++ < width) {
805:                             out(' ', buffer, idx++, maxlen);
806:                           }
807:                         }
808:                         // string output
809:                         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
810:                           out(*(p++), buffer, idx++, maxlen);
811:                         }
812:                         // post padding
813:                         if (flags & FLAGS_LEFT) {
814:                           while (l++ < width) {
815:                             out(' ', buffer, idx++, maxlen);
816:                           }
817:                         }
818:                         format++;
819:                         break;
820:                       }
821:                 
822:                       case 'p' : {
823:                         width = sizeof(void*) * 2U;
824:                         flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
825:                 #if defined(PRINTF_SUPPORT_LONG_LONG)
826:                         const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
827:                         if (is_ll) {
828:                           idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
829:                         }
830:                         else {
831:                 #endif
832:                           idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
833:                 #if defined(PRINTF_SUPPORT_LONG_LONG)
834:                         }
835:                 #endif
836:                         format++;
837:                         break;
838:                       }
839:                 
840:                       case '%' :
841:                         out('%', buffer, idx++, maxlen);
842:                         format++;
843:                         break;
844:                 
845:                       default :
846:                         out(*format, buffer, idx++, maxlen);
847:                         format++;
848:                         break;
849:                     }
850:                   }
851:                 
852:                   // termination
853:                   out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
854:                 
855:                   // return written chars without terminating \0
856:                   return (int)idx;
857:                 }
858:                 
859:                 
860:                 ///////////////////////////////////////////////////////////////////////////////
861:                 
862:                 int printf_(const char* format, ...)
863:                 {
864:                   va_list va;
865:                   va_start(va, format);
866:                   char buffer[1];
867:                   const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
868:                   va_end(va);
869:                   return ret;
870:                 }
871:                 
872:                 
873:                 int sprintf_(char* buffer, const char* format, ...)
874:                 {
875:                   va_list va;
876:                   va_start(va, format);
877:                   const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
878:                   va_end(va);
879:                   return ret;
880:                 }
881:                 
882:                 
883:                 int snprintf_(char* buffer, size_t count, const char* format, ...)
884:                 {
885:                   va_list va;
886:                   va_start(va, format);
887:                   const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
888:                   va_end(va);
889:                   return ret;
890:                 }
891:                 
892:                 
893:                 int vprintf_(const char* format, va_list va)
894:                 {
895:                   char buffer[1];
896:                   return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
897:                 }
898:                 
899:                 
900:                 int vsnprintf_(char* buffer, size_t count, const char* format, va_list va)
901:                 {
902:                   return _vsnprintf(_out_buffer, buffer, count, format, va);
903:                 }
904:                 
905:                 
906:                 int fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...)
907:                 {
908:                   va_list va;
909:                   va_start(va, format);
910:                   const out_fct_wrap_type out_fct_wrap = { out, arg };
911:                   const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
912:                   va_end(va);
913:                   return ret;
914:                 }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000024  00000000   NOP
00000028  00000000   NOP
0000002C  00000000   NOP
00000030  00000000   NOP
00000034  00000000   NOP
00000038  00000000   NOP
0000003C  00000000   NOP
00000044  00000000   NOP
00000048  00000000   NOP
0000004C  00000000   NOP
00000050  00000000   NOP
00000054  00000000   NOP
00000058  00000000   NOP
0000005C  00000000   NOP
00000060  00000000   NOP
00000064  00000000   NOP
00000068  00000000   NOP
0000006C  00000000   NOP
00000074  00000000   NOP
00000078  00000000   NOP
0000007C  00000000   NOP
00000080  00000000   NOP
00000084  00000000   NOP
00000088  00000000   NOP
00000090  00000000   NOP
00000094  00000000   NOP
0000009C  00000000   NOP
000000A4  00000000   NOP
000000A8  00000000   NOP
000000AC  00000000   NOP
000000B0  00000000   NOP
000000B8  00000000   NOP
000000BC  00000000   NOP
000000C0  00000000   NOP
000000C4  00000000   NOP
000000C8  00000000   NOP
000000CC  00000000   NOP
000000D0  00000000   NOP
000000D4  00000000   NOP
000000D8  00000000   NOP
000000DC  00000000   NOP
000000E4  00000000   NOP
000000E8  00000000   NOP
000000EC  00000000   NOP
000000F0  00000000   NOP
000000F8  00000000   NOP
00000100  00000000   NOP
00000104  00000000   NOP
00000108  00000000   NOP
00000110  00000000   NOP
00000118  00000000   NOP
0000011C  00000000   NOP
00000120  00000000   NOP
00000128  00000000   NOP
0000012C  00000000   NOP
00000130  00000000   NOP
00000134  00000000   NOP
0000013C  00000000   NOP
00000140  00000000   NOP
00000148  00000000   NOP
00000154  00000000   NOP
0000015C  00000000   NOP
00000160  00000000   NOP
00000164  00000000   NOP
00000168  00000000   NOP
0000016C  00000000   NOP
00000170  00000000   NOP
00000178  00000000   NOP
0000017C  00000000   NOP
00000180  00000000   NOP
00000184  00000000   NOP
00000190  00000000   NOP
00000194  00000000   NOP
0000019C  00000000   NOP
000001A0  00000000   NOP
000001A8  00000000   NOP
000001AC  00000000   NOP
000001B0  00000000   NOP
000001B8  00000000   NOP
000001BC  00000000   NOP
000001C4  00000000   NOP
000001D0  00000000   NOP
000001D8  00000000   NOP
000001DC  00000000   NOP
000001E0  00000000   NOP
000001E4  00000000   NOP
000001E8  00000000   NOP
000001F0  00000000   NOP
000001F8  00000000   NOP
000001FC  00000000   NOP
00000200  00000000   NOP
00000208  00000000   NOP
00000220  00000000   NOP
00000228  00000000   NOP
00000230  00000000   NOP
0000023C  00000000   NOP
00000244  00000000   NOP
00000250  00000000   NOP
00000254  00000000   NOP
00000268  00000000   NOP
0000026C  00000000   NOP
00000278  00000000   NOP
00000294  00000000   NOP
0000029C  00000000   NOP
000002A0  00000000   NOP
000002A4  00000000   NOP
000002AC  00000000   NOP
000002B4  00000000   NOP
000002BC  00000000   NOP
000002C0  00000000   NOP
000002C4  00000000   NOP
000002C8  00000000   NOP
000002D0  00000000   NOP
000002D8  00000000   NOP
000002E0  00000000   NOP
000002E4  00000000   NOP
000002EC  00000000   NOP
000002F8  00000000   NOP
00000300  00000000   NOP
0000030C  00000000   NOP
0000031C  00000000   NOP
00000320  00000000   NOP
00000328  00000000   NOP
0000032C  00000000   NOP
00000338  00000000   NOP
00000340  00000000   NOP
0000034C  00000000   NOP
0000035C  00000000   NOP
00000360  00000000   NOP
00000364  00000000   NOP
00000368  00000000   NOP
0000036C  00000000   NOP
00000370  00000000   NOP
00000374  00000000   NOP
00000378  00000000   NOP
0000037C  00000000   NOP
00000384  00000000   NOP
00000388  00000000   NOP
00000390  00000000   NOP
00000398  00000000   NOP
0000039C  00000000   NOP
000003A0  00000000   NOP
000003A8  00000000   NOP
000003AC  00000000   NOP
000003B0  00000000   NOP
000003B4  00000000   NOP
000003B8  00000000   NOP
000003BC  00000000   NOP
000003C4  00000000   NOP
000003D0  00000000   NOP
000003D4  00000000   NOP
000003D8  00000000   NOP
000003DC  00000000   NOP
000003E0  00000000   NOP
000003E8  00000000   NOP
000003EC  00000000   NOP
000003F4  00000000   NOP
000003FC  00000000   NOP
00000400  00000000   NOP
00000404  00000000   NOP
00000408  00000000   NOP
0000040C  00000000   NOP
00000414  00000000   NOP
00000418  00000000   NOP
0000041C  00000000   NOP
00000420  00000000   NOP
00000424  00000000   NOP
00000428  00000000   NOP
00000430  00000000   NOP
00000434  00000000   NOP
00000438  00000000   NOP
00000440  00000000   NOP
00000444  00000000   NOP
00000450  00000000   NOP
00000454  00000000   NOP
00000458  00000000   NOP
0000045C  00000000   NOP
00000460  00000000   NOP
00000464  00000000   NOP
00000468  00000000   NOP
00000470  00000000   NOP
00000474  00000000   NOP
00000478  00000000   NOP
0000047C  00000000   NOP
00000484  00000000   NOP
00000488  00000000   NOP
0000048C  00000000   NOP
00000490  00000000   NOP
00000494  00000000   NOP
0000049C  00000000   NOP
000004A0  00000000   NOP
000004A8  00000000   NOP
000004AC  00000000   NOP
000004B0  00000000   NOP
000004B4  00000000   NOP
000004C4  00000000   NOP
000004C8  00000000   NOP
000004CC  00000000   NOP
000004D0  00000000   NOP
000004D8  00000000   NOP
000004E0  00000000   NOP
000004E4  00000000   NOP
000004E8  00000000   NOP
000004EC  00000000   NOP
000004F0  00000000   NOP
000004F4  00000000   NOP
000004F8  00000000   NOP
00000500  00000000   NOP
00000504  00000000   NOP
0000050C  00000000   NOP
00000510  00000000   NOP
00000514  00000000   NOP
00000518  00000000   NOP
0000051C  00000000   NOP
00000520  00000000   NOP
00000524  00000000   NOP
00000528  00000000   NOP
0000052C  00000000   NOP
00000530  00000000   NOP
00000534  00000000   NOP
00000538  00000000   NOP
0000053C  00000000   NOP
00000540  00000000   NOP
00000544  00000000   NOP
0000054C  00000000   NOP
00000554  00000000   NOP
00000558  00000000   NOP
0000055C  00000000   NOP
00000568  00000000   NOP
0000056C  00000000   NOP
00000574  00000000   NOP
00000578  00000000   NOP
0000057C  00000000   NOP
000005B0  00000000   NOP
000005B4  00000000   NOP
000005BC  00000000   NOP
000005C0  00000000   NOP
000005C4  00000000   NOP
000005C8  00000000   NOP
000005D0  00000000   NOP
000005E0  00000000   NOP
000005EC  00000000   NOP
00000600  00000000   NOP
00000608  00000000   NOP
00000618  00000000   NOP
00000620  00000000   NOP
00000628  00000000   NOP
00000634  00000000   NOP
00000640  00000000   NOP
0000064C  00000000   NOP
00000654  00000000   NOP
00000658  00000000   NOP
00000660  00000000   NOP
00000664  00000000   NOP
0000066C  00000000   NOP
00000670  00000000   NOP
0000067C  00000000   NOP
00000688  00000000   NOP
00000690  00000000   NOP
00000694  00000000   NOP
0000069C  00000000   NOP
000006A0  00000000   NOP
000006A8  00000000   NOP
000006AC  00000000   NOP
000006B4  00000000   NOP
000006B8  00000000   NOP
000006BC  00000000   NOP
000006D4  00000000   NOP
000006D8  00000000   NOP
000006E8  00000000   NOP
000006F0  00000000   NOP
000006F8  00000000   NOP
000006FC  00000000   NOP
00000708  00000000   NOP
00000710  00000000   NOP
00000718  00000000   NOP
0000071C  00000000   NOP
00000720  00000000   NOP
00000728  00000000   NOP
00000730  00000000   NOP
00000734  00000000   NOP
00000740  00000000   NOP
0000074C  00000000   NOP
00000764  00000000   NOP
00000768  00000000   NOP
00000770  00000000   NOP
00000778  00000000   NOP
00000780  00000000   NOP
0000078C  00000000   NOP
000007A4  00000000   NOP
000007A8  00000000   NOP
000007BC  00000000   NOP
000007C0  00000000   NOP
000007C4  00000000   NOP
000007CC  00000000   NOP
000007D0  00000000   NOP
000007D8  00000000   NOP
000007DC  00000000   NOP
000007E0  00000000   NOP
000007E8  00000000   NOP
000007F0  00000000   NOP
000007F4  00000000   NOP
000007F8  00000000   NOP
00000804  00000000   NOP
0000080C  00000000   NOP
00000814  00000000   NOP
00000818  00000000   NOP
00000820  00000000   NOP
00000824  00000000   NOP
0000082C  00000000   NOP
00000830  00000000   NOP
00000838  00000000   NOP
0000083C  00000000   NOP
00000848  00000000   NOP
0000084C  00000000   NOP
00000850  00000000   NOP
00000870  00000000   NOP
00000874  00000000   NOP
0000087C  00000000   NOP
00000884  00000000   NOP
0000089C  00000000   NOP
000008A0  00000000   NOP
000008A4  00000000   NOP
000008B8  00000000   NOP
000008BC  00000000   NOP
000008C4  00000000   NOP
000008C8  00000000   NOP
000008DC  00000000   NOP
000008E4  00000000   NOP
000008EC  00000000   NOP
00000900  00000000   NOP
00000914  00000000   NOP
00000918  00000000   NOP
0000091C  00000000   NOP
00000924  00000000   NOP
00000934  00000000   NOP
0000093C  00000000   NOP
00000940  00000000   NOP
00000944  00000000   NOP
0000094C  00000000   NOP
00000950  00000000   NOP
00000958  00000000   NOP
00000960  00000000   NOP
00000964  00000000   NOP
0000096C  00000000   NOP
00000970  00000000   NOP
00000974  00000000   NOP
0000097C  00000000   NOP
00000984  00000000   NOP
00000988  00000000   NOP
00000990  00000000   NOP
00000998  00000000   NOP
0000099C  00000000   NOP
000009BC  00000000   NOP
000009D4  00000000   NOP
000009D8  00000000   NOP
000009E8  00000000   NOP
000009F0  00000000   NOP
000009F8  00000000   NOP
00000A00  00000000   NOP
00000A08  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/user_hal/lsm6dsv16x.c  ------------------------------------
1:                   // Note: we actually got an LSM6DSV16BX, not an LSM6DSV16X!
2:                   
3:                   #include "lsm6dsv16x.h"
4:                   #include "definitions.h"                // GPIO
5:                   #include "conversion.h"                 // Bit reversal
6:                   #include <stddef.h>
7:                   #include <math.h>
8:                   
9:                   /**
10:                   * LSM6DSV16X accelerometer and gyroscope register definitions
11:                   */
12:                  #define LSM6DSV16X_RW_BIT                   15
13:                  #define LSM6DSV16X_ADDR_BIT 				8
14:                  #define LSM6DSV16X_ADDR_MASK				0x7F
15:                  
16:                  #define LSM6DSV16X_DATA_BIT 				0
17:                  #define LSM6DSV16X_DATA_MASK				0xFF
18:                  
19:                  #define LSM6DSV16X_ADDR_WHOAMI              0x0F
20:                  #define LSM6DSV16X_ADDR_CTRL1               0x10
21:                      #define LSM6DSV16X_CTRL1_BF_OP_MODE_XL      6,4
22:                      #define LSM6DSV16X_CTRL1_BF_ODR_XL          3,0
23:                  #define LSM6DSV16X_ADDR_CTRL2               0x11
24:                      #define LSM6DSV16X_CTRL2_BF_OP_MODE_G       6,4
25:                      #define LSM6DSV16X_CTRL2_BF_ODR_G           3,0
26:                  //#define LSM6DSV16X_ADDR_CTRL3               0x12
27:                  //    #define LSM6DSV16X_CTRL3_BF_BDU             6,6
28:                  #define LSM6DSV16C_ADDR_OUTX_L_G            0x22
29:                  #define LSM6DSV16C_ADDR_OUTX_H_G            0x23
30:                  #define LSM6DSV16C_ADDR_OUTY_L_G            0x24
31:                  #define LSM6DSV16C_ADDR_OUTY_H_G            0x25
32:                  #define LSM6DSV16C_ADDR_OUTZ_L_G            0x26
33:                  #define LSM6DSV16C_ADDR_OUTZ_H_G            0x27
34:                  #define LSM6DSV16C_ADDR_OUTX_L_A            0x28
35:                  #define LSM6DSV16C_ADDR_OUTX_H_A            0x29
36:                  #define LSM6DSV16C_ADDR_OUTY_L_A            0x2A
37:                  #define LSM6DSV16C_ADDR_OUTY_H_A            0x2B
38:                  #define LSM6DSV16C_ADDR_OUTZ_L_A            0x2C
39:                  #define LSM6DSV16C_ADDR_OUTZ_H_A            0x2D
40:                  
41:                  LSM6DSV16X_DATA lsm6dsv16xData = {0};
42:                  
43:                  int LSM6DSV16X_Write(int address, uint8_t data);
44:                  int LSM6DSV16X_Read(int address, uint8_t* data);
45:                  
46:                  int LSM6DSV16X_Init(void)
47:                  {
48:                      // Configure accelerometer: high performance mode, 15 Hz update rate
49:                      uint8_t data = 0;
50:                      data |= SET_BF(LSM6DSV16X_CTRL1_BF_OP_MODE_XL, 0);
51:                      data |= SET_BF(LSM6DSV16X_CTRL1_BF_ODR_XL, 3);
52:                      int retval = LSM6DSV16X_Write(LSM6DSV16X_ADDR_CTRL1, data);
53:                      
54:                      // Configure gyroscope: high performance mode, 15 Hz update rate
55:                      data = 0;
56:                      data |= SET_BF(LSM6DSV16X_CTRL2_BF_OP_MODE_G, 0);
57:                      data |= SET_BF(LSM6DSV16X_CTRL2_BF_ODR_G, 3);
58:                      retval = LSM6DSV16X_Write(LSM6DSV16X_ADDR_CTRL2, data);
59:                      
60:                      // Read diagnostic information including ID
61:                      LSM6DSV16X_ReadDiagnostic();
62:                      
63:                      return retval;
64:                  }
65:                  
66:                  int LSM6DSV16X_Write(int address, uint8_t data)
67:                  {
68:                  	// Prepare command
69:                  	uint16_t command = (0 << LSM6DSV16X_RW_BIT) | 
70:                                    ((address & LSM6DSV16X_ADDR_MASK) << LSM6DSV16X_ADDR_BIT);
71:                  	command |= ((int)(data & LSM6DSV16X_DATA_MASK)) << LSM6DSV16X_DATA_BIT;
72:                      command = byterev16(command);
73:                  
74:                  	// Send command to chip
75:                  	GPIO_RC4_SPI_NCS_ACC_Clear();
76:                      bool status = SPI1_Write(&command, sizeof(command));
77:                  	while (SPI1_IsTransmitterBusy()) {
78:                  	}
79:                  	GPIO_RC4_SPI_NCS_ACC_Set();
80:                  
81:                  	return (status)? 0: -1;
82:                  }
83:                  
84:                  int LSM6DSV16X_Read(int address, uint8_t* data)
85:                  {
86:                  	// Prepare command and response buffers
87:                  	uint16_t command = (1 << LSM6DSV16X_RW_BIT) |
88:                                         ((address & LSM6DSV16X_ADDR_MASK) << LSM6DSV16X_ADDR_BIT);
89:                      command = byterev16(command);
90:                      uint16_t resp = 0;
91:                  
92:                  	// Send command to chip
93:                  	GPIO_RC4_SPI_NCS_ACC_Clear();
94:                      bool status = SPI1_WriteRead(&command, sizeof(command), &resp, sizeof(resp));
95:                  	while (SPI1_IsTransmitterBusy()) {
96:                  	}
97:                  	GPIO_RC4_SPI_NCS_ACC_Set();
98:                  
99:                  	// Extract data
100:                     resp = byterev16(resp);
101:                 	if (data != NULL) {
102:                 		*data = (uint8_t)((resp >> LSM6DSV16X_DATA_BIT) & LSM6DSV16X_DATA_MASK);
103:                 	}
104:                 
105:                 	return (status)? 0: -1;
106:                 }
107:                 
108:                 int LSM6DSV16X_ReadDiagnostic(void)
109:                 {
110:                 	uint8_t data = 0;
111:                 	int retval = LSM6DSV16X_Read(LSM6DSV16X_ADDR_WHOAMI, &data);
112:                 	lsm6dsv16xData.id = (int)data;
113:                     return retval;
114:                 }
115:                 
116:                 int LSM6DSV16X_ReadTAG(void)
117:                 {
118:                     int address = 0x20;
119:                     uint8_t cmd = (1 << (LSM6DSV16X_RW_BIT - 8))
120:                             | ((address & LSM6DSV16X_ADDR_MASK) << (LSM6DSV16X_ADDR_BIT - 8));
121:                     uint8_t resp[15] = {0};
122:                 
123:                     // Send command to chip
124:                 	GPIO_RC4_SPI_NCS_ACC_Clear();
125:                     bool status = SPI1_WriteRead(&cmd, sizeof(cmd), &resp, sizeof(resp));
126:                 	while (SPI1_IsTransmitterBusy()) {
127:                 	}
128:                 	GPIO_RC4_SPI_NCS_ACC_Set();
129:                     
130:                     lsm6dsv16xData.t  =  (resp[1] << 0) |  (resp[2] << 8);
131:                     lsm6dsv16xData.gx =  (resp[3] << 0) |  (resp[4] << 8);
132:                     lsm6dsv16xData.gy =  (resp[5] << 0) |  (resp[6] << 8);
133:                     lsm6dsv16xData.gz =  (resp[7] << 0) |  (resp[8] << 8);
134:                     lsm6dsv16xData.ax =  (resp[9] << 0) | (resp[10] << 8);
135:                     lsm6dsv16xData.ay = (resp[11] << 0) | (resp[12] << 8);
136:                     lsm6dsv16xData.az = (resp[13] << 0) | (resp[14] << 8);
137:                     
138:                     return (status)? 0: -1;
139:                 }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
00000028  00000000   NOP
00000030  00000000   NOP
00000044  00000000   NOP
00000048  00000000   NOP
00000054  00000000   NOP
0000005C  00000000   NOP
00000064  00000000   NOP
00000068  00000000   NOP
0000006C  00000000   NOP
00000070  00000000   NOP
00000074  00000000   NOP
00000078  00000000   NOP
00000080  00000000   NOP
00000084  00000000   NOP
00000088  00000000   NOP
0000008C  00000000   NOP
00000090  00000000   NOP
00000094  00000000   NOP
00000098  00000000   NOP
0000009C  00000000   NOP
000000A0  00000000   NOP
000000A4  00000000   NOP
000000A8  00000000   NOP
000000AC  00000000   NOP
000000B0  00000000   NOP
000000B4  00000000   NOP
000000B8  00000000   NOP
000000BC  00000000   NOP
000000C4  00000000   NOP
000000C8  00000000   NOP
000000CC  00000000   NOP
000000D0  00000000   NOP
000000D4  00000000   NOP
000000D8  00000000   NOP
000000DC  00000000   NOP
000000E0  00000000   NOP
000000E4  00000000   NOP
000000EC  00000000   NOP
000000F8  00000000   NOP
000000FC  00000000   NOP
00000100  00000000   NOP
00000104  00000000   NOP
00000108  00000000   NOP
0000010C  00000000   NOP
00000110  00000000   NOP
00000114  00000000   NOP
9D0168AC  00041200   SLL V0, A0, 8
9D0168B0  30427F00   ANDI V0, V0, 32512
9D0168B4  34428000   ORI V0, V0, -32768
9D0168B8  27BDFFD8   ADDIU SP, SP, -40
9D0168BC  00402025   OR A0, V0, ZERO
9D0168C0  AFBF0024   SW RA, 36(SP)
9D0168C4  AFB20020   SW S2, 32(SP)
9D0168C8  AFB1001C   SW S1, 28(SP)
9D0168CC  AFB00018   SW S0, 24(SP)
9D0168D0  00A09025   OR S2, A1, ZERO
9D0168D4  0F402D22   JAL byterev16
9D0168D8  A7A20012   SH V0, 18(SP)
9D0168DC  A7A20012   SH V0, 18(SP)
9D0168E0  3C11BF88   LUI S1, -16504
9D0168E4  24020010   ADDIU V0, ZERO, 16
9D0168E8  24070002   ADDIU A3, ZERO, 2
9D0168EC  27A60010   ADDIU A2, SP, 16
9D0168F0  24050002   ADDIU A1, ZERO, 2
9D0168F4  27A40012   ADDIU A0, SP, 18
9D0168F8  A7A00010   SH ZERO, 16(SP)
9D0168FC  AE226234   SW V0, 25140(S1)
9D016900  0F40626C   JAL SPI1_WriteRead
9D016904  00000000   NOP
9D016908  00408025   OR S0, V0, ZERO
9D01690C  0F402CB2   JAL SPI1_IsTransmitterBusy
9D016910  00000000   NOP
9D016914  1440FFFD   BNE V0, ZERO, 0x9D01690C
9D016918  97A40010   LHU A0, 16(SP)
9D01691C  24020010   ADDIU V0, ZERO, 16
9D016920  AE226238   SW V0, 25144(S1)
9D016924  0F402D22   JAL byterev16
9D016928  00000000   NOP
9D01692C  56400001   BNEL S2, ZERO, 0x9D016934
9D016930  A2420000   SB V0, 0(S2)
9D016934  8FBF0024   LW RA, 36(SP)
9D016938  3A020001   XORI V0, S0, 1
9D01693C  304200FF   ANDI V0, V0, 255
9D016940  00021023   SUBU V0, ZERO, V0
9D016944  8FB20020   LW S2, 32(SP)
9D016948  8FB1001C   LW S1, 28(SP)
9D01694C  8FB00018   LW S0, 24(SP)
9D016950  03E00008   JR RA
9D016954  27BD0028   ADDIU SP, SP, 40
9D0174E0  00042200   SLL A0, A0, 8
9D0174E4  30847F00   ANDI A0, A0, 32512
9D0174E8  00852825   OR A1, A0, A1
9D0174EC  27BDFFD8   ADDIU SP, SP, -40
9D0174F0  00A02025   OR A0, A1, ZERO
9D0174F4  AFBF0024   SW RA, 36(SP)
9D0174F8  AFB10020   SW S1, 32(SP)
9D0174FC  AFB0001C   SW S0, 28(SP)
9D017500  0F402D22   JAL byterev16
9D017504  A7A50010   SH A1, 16(SP)
9D017508  A7A20010   SH V0, 16(SP)
9D01750C  3C11BF88   LUI S1, -16504
9D017510  24020010   ADDIU V0, ZERO, 16
9D017514  24050002   ADDIU A1, ZERO, 2
9D017518  27A40010   ADDIU A0, SP, 16
9D01751C  AE226234   SW V0, 25140(S1)
9D017520  0F406391   JAL SPI1_Write
9D017524  00000000   NOP
9D017528  00408025   OR S0, V0, ZERO
9D01752C  0F402CB2   JAL SPI1_IsTransmitterBusy
9D017530  00000000   NOP
9D017534  1440FFFD   BNE V0, ZERO, 0x9D01752C
9D017538  8FBF0024   LW RA, 36(SP)
9D01753C  3A020001   XORI V0, S0, 1
9D017540  304200FF   ANDI V0, V0, 255
9D017544  24030010   ADDIU V1, ZERO, 16
9D017548  AE236238   SW V1, 25144(S1)
9D01754C  00021023   SUBU V0, ZERO, V0
9D017550  8FB10020   LW S1, 32(SP)
9D017554  8FB0001C   LW S0, 28(SP)
9D017558  03E00008   JR RA
9D01755C  27BD0028   ADDIU SP, SP, 40
9D017E28  27BDFFE0   ADDIU SP, SP, -32
9D017E2C  24050003   ADDIU A1, ZERO, 3
9D017E30  24040010   ADDIU A0, ZERO, 16
9D017E34  AFBF001C   SW RA, 28(SP)
9D017E38  0F405D38   JAL LSM6DSV16X_Write
9D017E3C  AFB00018   SW S0, 24(SP)
9D017E40  24050003   ADDIU A1, ZERO, 3
9D017E44  0F405D38   JAL LSM6DSV16X_Write
9D017E48  24040011   ADDIU A0, ZERO, 17
9D017E4C  27A50010   ADDIU A1, SP, 16
9D017E50  2404000F   ADDIU A0, ZERO, 15
9D017E54  00408025   OR S0, V0, ZERO
9D017E58  0F405A2B   JAL LSM6DSV16X_Read
9D017E5C  A3A00010   SB ZERO, 16(SP)
9D017E60  93A40010   LBU A0, 16(SP)
9D017E64  8FBF001C   LW RA, 28(SP)
9D017E68  3C03A000   LUI V1, -24576
9D017E6C  02001025   OR V0, S0, ZERO
9D017E70  A4642E34   SH A0, 11828(V1)
9D017E74  8FB00018   LW S0, 24(SP)
9D017E78  03E00008   JR RA
9D017E7C  27BD0020   ADDIU SP, SP, 32
---  c:/users/db/desktop/nano_tx/firmware/src/user_hal/debug.c  -----------------------------------------
1:                   #include "debug.h"
2:                   #include "ringbuffer.h"
3:                   #include "configuration.h"
4:                   #include "definitions.h"
5:                   #include <string.h>
6:                   #include <stdarg.h>
7:                   #include <stdio.h>
8:                   
9:                   RINGBUFFER* debugRb = NULL;
10:                  ERROR_T gwsError = NO_ERROR;
11:                  
12:                  bool Debug_IsEnabled(void)
13:                  {
14:                      return (debugRb == NULL)? false: true;
15:                  }
16:                  
17:                  void Debug_Disable(void)
18:                  {
19:                      debugRb = NULL;
20:                  }
21:                  
22:                  void Debug_Enable(RINGBUFFER* rb)
23:                  {
24:                      debugRb = rb;
25:                  }
26:                  
27:                  RINGBUFFER* Debug_GetRb(void)
28:                  {
29:                      return debugRb;
30:                  }
31:                  
32:                  /**
33:                   * Prints a NULL-terminated C string into the active debug stream.
34:                   * @param[in]       format      Like printf().
35:                   * @param[in]       ...         Like printf().
36:                   * @return                      Number of bytes written to the ring buffer.
37:                   *                              Usually the same as the string length.
38:                   *                              0 is returned if the buffer is full. Less than
39:                   *                              size if the buffer became full before writing
40:                   *                              all bytes.
41:                   */
42:                  uint32_t dprintf(const char* format, ...)
43:                  {
44:                      if (debugRb == NULL) {
45:                          return 0;
46:                      }
47:                      
48:                      while (RB_GetUsed(debugRb) > 0) {
49:                          USB_DEVICE_Tasks(sysObj.usbDevObject0);
50:                          APP_USB_Tasks();
51:                      }
52:                      
53:                      char str[128];
54:                      va_list vlist;
55:                      va_start(vlist, format);
56:                      vsnprintf(str, sizeof(str), format, vlist);
57:                      va_end(vlist);
58:                      return RB_WriteString(debugRb, str);
59:                  }
60:                  
61:                  void _putchar(char character)
62:                  {
63:                      (void)character;    
64:                  }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
9D00B418  03E00008   JR RA
9D00B41C  AF808034   SW ZERO, -32716(GP)
9D00B438  03E00008   JR RA
9D00B43C  AF848034   SW A0, -32716(GP)
9D01708C  8F828034   LW V0, -32716(GP)
9D017090  27BDFF60   ADDIU SP, SP, -160
9D017094  AFB00098   SW S0, 152(SP)
9D017098  AFBF009C   SW RA, 156(SP)
9D01709C  AFA500A4   SW A1, 164(SP)
9D0170A0  AFA600A8   SW A2, 168(SP)
9D0170A4  AFA700AC   SW A3, 172(SP)
9D0170A8  14400008   BNE V0, ZERO, 0x9D0170CC
9D0170AC  00808025   OR S0, A0, ZERO
9D0170B0  10000017   BEQ ZERO, ZERO, 0x9D017110
9D0170B4  8FBF009C   LW RA, 156(SP)
9D0170B8  0F404DD9   JAL USB_DEVICE_Tasks
9D0170BC  8F848028   LW A0, -32728(GP)
9D0170C0  0F4042A7   JAL APP_USB_Tasks
9D0170C4  00000000   NOP
9D0170C8  8F828034   LW V0, -32716(GP)
9D0170CC  0F402CFE   JAL RB_GetUsed
9D0170D0  00402025   OR A0, V0, ZERO
9D0170D4  1440FFF8   BNE V0, ZERO, 0x9D0170B8
9D0170D8  27A200A4   ADDIU V0, SP, 164
9D0170DC  27A40010   ADDIU A0, SP, 16
9D0170E0  02003025   OR A2, S0, ZERO
9D0170E4  00403825   OR A3, V0, ZERO
9D0170E8  24050080   ADDIU A1, ZERO, 128
9D0170EC  0F405919   JAL vsnprintf
9D0170F0  AFA20090   SW V0, 144(SP)
9D0170F4  8F848034   LW A0, -32716(GP)
9D0170F8  0F405E9A   JAL RB_WriteString
9D0170FC  27A50010   ADDIU A1, SP, 16
9D017100  8FBF009C   LW RA, 156(SP)
9D017104  8FB00098   LW S0, 152(SP)
9D017108  03E00008   JR RA
9D01710C  27BD00A0   ADDIU SP, SP, 160
9D017110  00001025   OR V0, ZERO, ZERO
9D017114  8FB00098   LW S0, 152(SP)
9D017118  03E00008   JR RA
9D01711C  27BD00A0   ADDIU SP, SP, 160
---  c:/users/db/desktop/nano_tx/firmware/src/user_hal/crc.c  -------------------------------------------
1:                   /**********************************************************************
2:                    *
3:                    * Filename:    crc.c
4:                    * 
5:                    * Description: Slow and fast implementations of the CRC standards.
6:                    *
7:                    * Notes:       The parameters for each supported CRC standard are
8:                    *				defined in the header file crc.h.  The implementations
9:                    *				here should stand up to further additions to that list.
10:                   *
11:                   * 
12:                   * Copyright (c) 2000 by Michael Barr.  This software is placed into
13:                   * the public domain and may be used for any purpose.  However, this
14:                   * notice must not be changed or removed and no warranty is either
15:                   * expressed or implied by its publication or distribution.
16:                   **********************************************************************/
17:                   
18:                  #include "crc.h"
19:                  
20:                  
21:                  /*
22:                   * Derive parameters from the standard-specific parameters in crc.h.
23:                   */
24:                  #define WIDTH    (8 * sizeof(crc))
25:                  #define TOPBIT   (1 << (WIDTH - 1))
26:                  
27:                  #if (REFLECT_DATA == TRUE)
28:                  #undef  REFLECT_DATA
29:                  #define REFLECT_DATA(X)			((unsigned char) reflect((X), 8))
30:                  #else
31:                  #undef  REFLECT_DATA
32:                  #define REFLECT_DATA(X)			(X)
33:                  #endif
34:                  
35:                  #if (REFLECT_REMAINDER == TRUE)
36:                  #undef  REFLECT_REMAINDER
37:                  #define REFLECT_REMAINDER(X)	((crc) reflect((X), WIDTH))
38:                  #else
39:                  #undef  REFLECT_REMAINDER
40:                  #define REFLECT_REMAINDER(X)	(X)
41:                  #endif
42:                  
43:                  
44:                  /*********************************************************************
45:                   *
46:                   * Function:    reflect()
47:                   * 
48:                   * Description: Reorder the bits of a binary sequence, by reflecting
49:                   *				them about the middle position.
50:                   *
51:                   * Notes:		No checking is done that nBits <= 32.
52:                   *
53:                   * Returns:		The reflection of the original data.
54:                   *
55:                   *********************************************************************/
56:                  //static unsigned long
57:                  //reflect(unsigned long data, unsigned char nBits)
58:                  //{
59:                  //	unsigned long  reflection = 0x00000000;
60:                  //	unsigned char  bit;
61:                  //
62:                  //	/*
63:                  //	 * Reflect the data about the center bit.
64:                  //	 */
65:                  //	for (bit = 0; bit < nBits; ++bit)
66:                  //	{
67:                  //		/*
68:                  //		 * If the LSB bit is set, set the reflection of it.
69:                  //		 */
70:                  //		if (data & 0x01)
71:                  //		{
72:                  //			reflection |= (1 << ((nBits - 1) - bit));
73:                  //		}
74:                  //
75:                  //		data = (data >> 1);
76:                  //	}
77:                  //
78:                  //	return (reflection);
79:                  //
80:                  //}	/* reflect() */
81:                  
82:                  
83:                  /*********************************************************************
84:                   *
85:                   * Function:    crcSlow()
86:                   * 
87:                   * Description: Compute the CRC of a given message.
88:                   *
89:                   * Notes:		
90:                   *
91:                   * Returns:		The CRC of the message.
92:                   *
93:                   *********************************************************************/
94:                  crc
95:                  crcSlow(unsigned char const message[], int nBytes)
96:                  {
97:                      crc            remainder = INITIAL_REMAINDER;
98:                  	int            byte;
99:                  	unsigned char  bit;
100:                 
101:                 
102:                     /*
103:                      * Perform modulo-2 division, a byte at a time.
104:                      */
105:                     for (byte = 0; byte < nBytes; ++byte)
106:                     {
107:                         /*
108:                          * Bring the next byte into the remainder.
109:                          */
110:                         remainder ^= (REFLECT_DATA(message[byte]) << (WIDTH - 8));
111:                 
112:                         /*
113:                          * Perform modulo-2 division, a bit at a time.
114:                          */
115:                         for (bit = 8; bit > 0; --bit)
116:                         {
117:                             /*
118:                              * Try to divide the current data bit.
119:                              */
120:                             if (remainder & TOPBIT)
121:                             {
122:                                 remainder = (remainder << 1) ^ POLYNOMIAL;
123:                             }
124:                             else
125:                             {
126:                                 remainder = (remainder << 1);
127:                             }
128:                         }
129:                     }
130:                 
131:                     /*
132:                      * The final remainder is the CRC result.
133:                      */
134:                     return (REFLECT_REMAINDER(remainder) ^ FINAL_XOR_VALUE);
135:                 
136:                 }   /* crcSlow() */
137:                 
138:                 
139:                 crc  crcTable[256];
140:                 
141:                 
142:                 /*********************************************************************
143:                  *
144:                  * Function:    crcInit()
145:                  * 
146:                  * Description: Populate the partial CRC lookup table.
147:                  *
148:                  * Notes:		This function must be rerun any time the CRC standard
149:                  *				is changed.  If desired, it can be run "offline" and
150:                  *				the table results stored in an embedded system's ROM.
151:                  *
152:                  * Returns:		None defined.
153:                  *
154:                  *********************************************************************/
155:                 void
156:                 crcInit(void)
157:                 {
158:                     crc			   remainder;
159:                 	int			   dividend;
160:                 	unsigned char  bit;
161:                 
162:                 
163:                     /*
164:                      * Compute the remainder of each possible dividend.
165:                      */
166:                     for (dividend = 0; dividend < 256; ++dividend)
167:                     {
168:                         /*
169:                          * Start with the dividend followed by zeros.
170:                          */
171:                         remainder = dividend << (WIDTH - 8);
172:                 
173:                         /*
174:                          * Perform modulo-2 division, a bit at a time.
175:                          */
176:                         for (bit = 8; bit > 0; --bit)
177:                         {
178:                             /*
179:                              * Try to divide the current data bit.
180:                              */			
181:                             if (remainder & TOPBIT)
182:                             {
183:                                 remainder = (remainder << 1) ^ POLYNOMIAL;
184:                             }
185:                             else
186:                             {
187:                                 remainder = (remainder << 1);
188:                             }
189:                         }
190:                 
191:                         /*
192:                          * Store the result into the table.
193:                          */
194:                         crcTable[dividend] = remainder;
195:                     }
196:                 
197:                 }   /* crcInit() */
198:                 
199:                 
200:                 /*********************************************************************
201:                  *
202:                  * Function:    crcFast()
203:                  * 
204:                  * Description: Compute the CRC of a given message.
205:                  *
206:                  * Notes:		crcInit() must be called first.
207:                  *
208:                  * Returns:		The CRC of the message.
209:                  *
210:                  *********************************************************************/
211:                 crc
212:                 crcFast(unsigned char const message[], int nBytes)
213:                 {
214:                     crc	           remainder = INITIAL_REMAINDER;
215:                     unsigned char  data;
216:                 	int            byte;
217:                 
218:                 
219:                     /*
220:                      * Divide the message by the polynomial, a byte at a time.
221:                      */
222:                     for (byte = 0; byte < nBytes; ++byte)
223:                     {
224:                         data = REFLECT_DATA(message[byte]) ^ (remainder >> (WIDTH - 8));
225:                   		remainder = crcTable[data] ^ (remainder << 8);
226:                     }
227:                 
228:                     /*
229:                      * The final remainder is the CRC.
230:                      */
231:                     return (REFLECT_REMAINDER(remainder) ^ FINAL_XOR_VALUE);
232:                 
233:                 }   /* crcFast() */
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
00000024  00000000   NOP
00000028  00000000   NOP
00000030  00000000   NOP
00000034  00000000   NOP
00000038  00000000   NOP
0000003C  00000000   NOP
00000044  00000000   NOP
00000048  00000000   NOP
00000058  00000000   NOP
0000005C  00000000   NOP
9D017D14  3C07A000   LUI A3, -24576
9D017D18  00003025   OR A2, ZERO, ZERO
9D017D1C  24E72488   ADDIU A3, A3, 9352
9D017D20  24080100   ADDIU T0, ZERO, 256
9D017D24  30C200FF   ANDI V0, A2, 255
9D017D28  24030008   ADDIU V1, ZERO, 8
9D017D2C  00022040   SLL A0, V0, 1
9D017D30  7C022C20   SEB A1, V0
9D017D34  00801025   OR V0, A0, ZERO
9D017D38  304200FF   ANDI V0, V0, 255
9D017D3C  04A10002   BGEZ A1, 0x9D017D48
9D017D40  38840031   XORI A0, A0, 49
9D017D44  308200FF   ANDI V0, A0, 255
9D017D48  2463FFFF   ADDIU V1, V1, -1
9D017D4C  306300FF   ANDI V1, V1, 255
9D017D50  1460FFF7   BNE V1, ZERO, 0x9D017D30
9D017D54  00022040   SLL A0, V0, 1
9D017D58  00E61821   ADDU V1, A3, A2
9D017D5C  24C60001   ADDIU A2, A2, 1
9D017D60  14C8FFF0   BNE A2, T0, 0x9D017D24
9D017D64  A0620000   SB V0, 0(V1)
9D017D68  03E00008   JR RA
9D017D6C  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/user_hal/conversion.c  ------------------------------------
1:                   /**
2:                    * @file conversion.c
3:                    * @brief Bit and byte order (endianness) conversion
4:                    * @author David Bender <d_bender@bluewin.ch>
5:                    * @date 05.12.2022
6:                    */
7:                   
8:                   #include "conversion.h"
9:                   
10:                  /**
11:                   * Bit reversal algorithm from http://aggregate.org/MAGIC/#Bit%20Reversal .
12:                   * @param[in]   x       Original 16 bits value.
13:                   * @return              Bit reversed 16 bits value.
14:                   */
15:                  uint16_t bitrev16(uint16_t x)
16:                  {
17:                  	x = (((x & 0xaaaa) >> 1) | ((x & 0x5555) << 1));
18:                  	x = (((x & 0xcccc) >> 2) | ((x & 0x3333) << 2));
19:                  	x = (((x & 0xf0f0) >> 4) | ((x & 0x0f0f) << 4));
20:                  	return ((x >> 8) | (x << 8));
21:                  }
22:                  
23:                  /**
24:                   * Byte (endianness) reversal.
25:                   * @param[in]   x       Original 16 bits value.
26:                   * @return              Byte (or endianness) reversed 16 bits value.
27:                   */
28:                  uint16_t byterev16(uint16_t x)
29:                  {
30:                      return (((x & 0xFF00) >> 8) | ((x & 0x00FF) << 8));
31:                  }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
00000024  00000000   NOP
00000028  00000000   NOP
0000002C  00000000   NOP
00000034  00000000   NOP
00000038  00000000   NOP
0000003C  00000000   NOP
00000040  00000000   NOP
00000044  00000000   NOP
00000048  00000000   NOP
9D00B488  7C0410A0   WSBH V0, A0
9D00B48C  03E00008   JR RA
9D00B490  3042FFFF   ANDI V0, V0, -1
---  c:/users/db/desktop/nano_tx/firmware/src/user_hal/bm7x.c  ------------------------------------------
1:                   /**
2:                    * @file bm7x.c
3:                    * @brief BM70/71 bluetooth low energy module interface
4:                    * @author David Bender <d_bender@bluewin.ch>
5:                    * @date 30.01.2023
6:                    */
7:                   
8:                   #include "bm7x.h"
9:                   #include "definitions.h"                // GPIO, UART
10:                  
11:                  void BM7X_Initialize(void)
12:                  {
13:                      // Wait for BM7X minimum reset pulse width
14:                      CORETIMER_DelayMs(1);
15:                      GPIO_RC2_BM70_HCI_RST_N_Set();
16:                  }
17:                  
18:                  uint32_t BM7X_Read(void* buffer, uint32_t size)
19:                  {
20:                      return UART1_Read(buffer, size);
21:                  }
22:                  
23:                  uint32_t BM7X_Write(void* buffer, uint32_t size)
24:                  {
25:                      return UART1_Write(buffer, size);
26:                  }
27:                  
28:                  uint32_t BM7X_GetWriteBufferFree(void)
29:                  {
30:                      return UART1_WriteFreeBufferCountGet();
31:                  }
32:                  
33:                  ERROR_T BM7X_GetError(void)
34:                  {
35:                      UART_ERROR eUart = UART1_ErrorGet();
36:                      ERROR_T eGws = 0;
37:                      eGws |= (eUart == UART_ERROR_OVERRUN)? BM7X_UART_RX_OVERRUN: 0;
38:                      eGws |= (eUart == UART_ERROR_FRAMING)? BM7X_UART_RX_FRAMING: 0;
39:                      eGws |= (eUart == UART_ERROR_PARITY)? BM7X_UART_RX_PARITY: 0;
40:                      return eGws;
41:                  }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00B458  0B40578A   J UART1_Read
9D00B45C  00000000   NOP
9D00B460  0B4060DF   J _DefaultInterrupt
9D00B494  0B4053FB   J UART1_Write
9D00B498  00000000   NOP
9D00B4A8  0B406284   J UART1_WriteFreeBufferCountGet
9D00B4AC  00000000   NOP
9D017B98  27BDFFE8   ADDIU SP, SP, -24
9D017B9C  AFBF0014   SW RA, 20(SP)
9D017BA0  0F402C8A   JAL UART1_ErrorGet
9D017BA4  00000000   NOP
9D017BA8  24030002   ADDIU V1, ZERO, 2
9D017BAC  1043000E   BEQ V0, V1, 0x9D017BE8
9D017BB0  24040004   ADDIU A0, ZERO, 4
9D017BB4  14440005   BNE V0, A0, 0x9D017BCC
9D017BB8  24030020   ADDIU V1, ZERO, 32
9D017BBC  8FBF0014   LW RA, 20(SP)
9D017BC0  00601025   OR V0, V1, ZERO
9D017BC4  03E00008   JR RA
9D017BC8  27BD0018   ADDIU SP, SP, 24
9D017BCC  38420008   XORI V0, V0, 8
9D017BD0  8FBF0014   LW RA, 20(SP)
9D017BD4  2C420001   SLTIU V0, V0, 1
9D017BD8  00021980   SLL V1, V0, 6
9D017BDC  00601025   OR V0, V1, ZERO
9D017BE0  03E00008   JR RA
9D017BE4  27BD0018   ADDIU SP, SP, 24
9D017BE8  8FBF0014   LW RA, 20(SP)
9D017BEC  24030010   ADDIU V1, ZERO, 16
9D017BF0  00601025   OR V0, V1, ZERO
9D017BF4  03E00008   JR RA
9D017BF8  27BD0018   ADDIU SP, SP, 24
9D018CE4  27BDFFE8   ADDIU SP, SP, -24
9D018CE8  AFBF0014   SW RA, 20(SP)
9D018CEC  0F4060F1   JAL CORETIMER_DelayMs
9D018CF0  24040001   ADDIU A0, ZERO, 1
9D018CF4  8FBF0014   LW RA, 20(SP)
9D018CF8  3C02BF88   LUI V0, -16504
9D018CFC  24030004   ADDIU V1, ZERO, 4
9D018D00  AC436238   SW V1, 25144(V0)
9D018D04  03E00008   JR RA
9D018D08  27BD0018   ADDIU SP, SP, 24
---  c:/users/db/desktop/nano_tx/firmware/src/main.c  ---------------------------------------------------
1:                   /*******************************************************************************
2:                     Main Source File
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       main.c
9:                   
10:                    Summary:
11:                      This file contains the "main" function for a project.
12:                  
13:                    Description:
14:                      This file contains the "main" function for a project.  The
15:                      "main" function calls the "SYS_Initialize" function to initialize the state
16:                      machines of all modules in the system
17:                   *******************************************************************************/
18:                  
19:                  // *****************************************************************************
20:                  // *****************************************************************************
21:                  // Section: Included Files
22:                  // *****************************************************************************
23:                  // *****************************************************************************
24:                  
25:                  #include <stddef.h>                     // Defines NULL
26:                  #include <stdbool.h>                    // Defines true
27:                  #include <stdlib.h>                     // Defines EXIT_FAILURE
28:                  #include "definitions.h"                // SYS function prototypes
29:                  
30:                  
31:                  // *****************************************************************************
32:                  // *****************************************************************************
33:                  // Section: Main Entry Point
34:                  // *****************************************************************************
35:                  // *****************************************************************************
36:                  
37:                  int main ( void )
38:                  {
39:                      /* Initialize all modules */
40:                      SYS_Initialize ( NULL );
41:                  
42:                      while ( true )
43:                      {
44:                          /* Maintain state machines of all polled MPLAB Harmony modules. */
45:                          SYS_Tasks ( );
46:                      }
47:                  
48:                      /* Execution should not come here during normal operation */
49:                  
50:                      return ( EXIT_FAILURE );
51:                  }
52:                  
53:                  
54:                  /*******************************************************************************
55:                   End of File
56:                  */
57:                  
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D018D34  27BDFFE8   ADDIU SP, SP, -24
9D018D38  AFBF0014   SW RA, 20(SP)
9D018D3C  0F40547F   JAL SYS_Initialize
9D018D40  00002025   OR A0, ZERO, ZERO
9D018D44  0F4060BB   JAL SYS_Tasks
9D018D48  00000000   NOP
9D018D4C  0F4060BB   JAL SYS_Tasks
9D018D50  00000000   NOP
9D018D54  1000FFFB   BEQ ZERO, ZERO, main
9D018D58  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/usb/src/usb_device_cdc_acm.c  --------------
1:                   /*******************************************************************************
2:                    USB CDC ACM SubClass
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       usb_device_cdc_acm.c
9:                   
10:                    Summary:
11:                      USB CDC ACM SubClass
12:                  
13:                    Description:
14:                      USB CDC ACM SubClass
15:                   *******************************************************************************/
16:                  
17:                  // DOM-IGNORE-BEGIN
18:                  /*******************************************************************************
19:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
20:                  *
21:                  * Subject to your compliance with these terms, you may use Microchip software
22:                  * and any derivatives exclusively with Microchip products. It is your
23:                  * responsibility to comply with third party license terms applicable to your
24:                  * use of third party software (including open source software) that may
25:                  * accompany Microchip software.
26:                  *
27:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                  * PARTICULAR PURPOSE.
31:                  *
32:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
33:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
34:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
35:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
36:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
37:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
38:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
39:                   *******************************************************************************/
40:                  // DOM-IGNORE-END
41:                  
42:                  // *****************************************************************************
43:                  // *****************************************************************************
44:                  // Section: Included Files
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  /*  This section lists the other files that are included in this file.
48:                   */
49:                  #include <stdio.h>
50:                  #include <stdint.h>
51:                  #include "usb/usb_cdc.h"
52:                  #include "usb/usb_device_cdc.h"
53:                  #include "usb/src/usb_device_cdc_local.h"
54:                  
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  // Section: File Scope or Global Constants
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  
61:                  
62:                  // *****************************************************************************
63:                  // *****************************************************************************
64:                  // Section: File Scope or Global Data Types
65:                  // *****************************************************************************
66:                  // *****************************************************************************
67:                  
68:                  // *****************************************************************************
69:                  // *****************************************************************************
70:                  // Section: File Scope Functions
71:                  // *****************************************************************************
72:                  // *****************************************************************************
73:                  
74:                  //******************************************************************************
75:                  /* Function:
76:                      void _USB_DEVICE_CDC_ACMSetUpPacketHandler ( USB_DEVICE_CDC_INSTANCE *instance,
77:                                                                      uint16_t value )
78:                  
79:                    Summary:
80:                      Handles ACM sub class specific requests.
81:                  
82:                    Description:
83:                      This function handles ACM sub class specific requests.
84:                  
85:                    Remarks:
86:                      Called by the CDC function driver.
87:                   */
88:                  
89:                  void _USB_DEVICE_CDC_ACMSetUpPacketHandler 
90:                  (
91:                      SYS_MODULE_INDEX iCDC ,
92:                      USB_DEVICE_CDC_INSTANCE * thisCDCDevice,
93:                      USB_SETUP_PACKET * setupRequest
94:                  )
95:                  {
96:                      
97:                      /* Check the request */
98:                      switch (setupRequest->bRequest )
99:                      {
100:                         case USB_CDC_REQUEST_SET_LINE_CODING:
101:                 
102:                             /* Send this event to application. The application
103:                              * should issues a control receive request to receive
104:                              * the data from the host. */
105:                 
106:                             if(thisCDCDevice->appEventCallBack != NULL)
107:                             {
108:                                 thisCDCDevice->appEventCallBack(iCDC, 
109:                                         USB_DEVICE_CDC_EVENT_SET_LINE_CODING, 
110:                                         NULL, thisCDCDevice->userData);
111:                             }
112:                 
113:                             break;
114:                 
115:                         case USB_CDC_REQUEST_GET_LINE_CODING:
116:                 
117:                             /* Send this event to application. The application should
118:                              * issue a control send request to send this request to 
119:                              * the host. */
120:                 
121:                             if(thisCDCDevice->appEventCallBack != NULL)
122:                             {
123:                                 thisCDCDevice->appEventCallBack(iCDC, 
124:                                         USB_DEVICE_CDC_EVENT_GET_LINE_CODING, 
125:                                         NULL, thisCDCDevice->userData);
126:                             }
127:                 
128:                             break;
129:                 
130:                         case USB_CDC_REQUEST_SET_CONTROL_LINE_STATE:
131:                 
132:                             /* In this event, the data is available in the
133:                              * setup packet. Send it to the application */
134:                 
135:                             if(thisCDCDevice->appEventCallBack != NULL)
136:                             {
137:                                 thisCDCDevice->appEventCallBack(iCDC,
138:                                         USB_DEVICE_CDC_EVENT_SET_CONTROL_LINE_STATE,
139:                                         (USB_CDC_CONTROL_LINE_STATE *)(&setupRequest->wValue),
140:                                         thisCDCDevice->userData);
141:                             }
142:                 
143:                             break;
144:                 
145:                             /* AT commands */
146:                         case USB_CDC_REQUEST_SEND_ENCAPSULATED_COMMAND:
147:                         case USB_CDC_REQUEST_GET_ENCAPSULATED_RESPONSE:
148:                 
149:                             /* AT commands are not supported */
150:                             USB_DEVICE_ControlStatus(thisCDCDevice->deviceHandle, 
151:                                     USB_DEVICE_CONTROL_STATUS_ERROR);
152:                             break;
153:                 
154:                             /* break request */
155:                         case USB_CDC_REQUEST_SEND_BREAK:
156:                 
157:                             /* In this event, the data is available in the
158:                              * setup packet. Send it to the application */
159:                 
160:                             if(thisCDCDevice->appEventCallBack != NULL)
161:                             {
162:                                 thisCDCDevice->appEventCallBack(iCDC,
163:                                         USB_DEVICE_CDC_EVENT_SEND_BREAK,
164:                                         (uint16_t *)(&setupRequest->wValue), thisCDCDevice->userData);
165:                             }
166:                 
167:                             break;
168:                 
169:                             /* requests that do not belog to ACM sub class */
170:                         case USB_CDC_REQUEST_SET_COMM_FEATURE:
171:                         case USB_CDC_REQUEST_GET_COMM_FEATURE:
172:                         case USB_CDC_REQUEST_CLEAR_COMM_FEATURE:
173:                         case USB_CDC_REQUEST_SET_AUX_LINE_STATE:
174:                         case USB_CDC_REQUEST_SET_HOOK_STATE:
175:                         case USB_CDC_REQUEST_PULSE_SETUP:
176:                         case USB_CDC_REQUEST_SEND_PULSE:
177:                         case USB_CDC_REQUEST_SET_PULSE_TIME:
178:                         case USB_CDC_REQUEST_RING_AUX_JACK:
179:                         case USB_CDC_REQUEST_SET_RINGER_PARMS:
180:                         case USB_CDC_REQUEST_GET_RINGER_PARMS:
181:                         case USB_CDC_REQUEST_SET_OPERATIONAL_PARMS:
182:                         case USB_CDC_REQUEST_GET_OPERATIONAL_PARMS:
183:                         case USB_CDC_REQUEST_SET_LINE_PARMS:
184:                         case USB_CDC_REQUEST_GET_LINE_PARMS:
185:                         case USB_CDC_REQUEST_DIAL_DIGITS:
186:                         case USB_CDC_REQUEST_SET_UNIT_PARAMETER:
187:                         case USB_CDC_REQUEST_GET_UNIT_PARAMETER:
188:                         case USB_CDC_REQUEST_CLEAR_UNIT_PARAMETER:
189:                         case USB_CDC_REQUEST_GET_PROFILE:
190:                         case USB_CDC_REQUEST_SET_ETHERNET_MULTICAST_FILTERS:
191:                         case USB_CDC_REQUEST_SET_ETHERNET_POWER_MANAGEMENT_FILTER:
192:                         case USB_CDC_REQUEST_GET_ETHERNET_POWER_MANAGEMENT_FILTER:
193:                         case USB_CDC_REQUEST_SET_ETHERNET_PACKET_FILTER:
194:                         case USB_CDC_REQUEST_GET_ETHERNET_STATISTIC:
195:                         case USB_CDC_REQUEST_SET_ATM_DATA_FORMAT:
196:                         case USB_CDC_REQUEST_GET_ATM_DEVICE_STATISTICS:
197:                         case USB_CDC_REQUEST_SET_ATM_DEFAULT_VC:
198:                         case USB_CDC_REQUEST_GET_ATM_VC_STATISTICS:
199:                         default:
200:                 
201:                             /* These request are not supported */
202:                 
203:                             USB_DEVICE_ControlStatus(thisCDCDevice->deviceHandle,
204:                                        USB_DEVICE_CONTROL_STATUS_ERROR);
205:                 
206:                             break;
207:                     }
208:                 }
209:                 
210:                 
211:                 
212:                 /*******************************************************************************
213:                  End of File
214:                  */
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D016F44  90C20001   LBU V0, 1(A2)
9D016F48  2442FFE0   ADDIU V0, V0, -32
9D016F4C  304200FF   ANDI V0, V0, 255
9D016F50  2C430004   SLTIU V1, V0, 4
9D016F54  1060000B   BEQ V1, ZERO, __jend__USB_DEVICE_CDC_ACMSetUpPacketHandler_4
9D016F58  3C039D01   LUI V1, -25343
9D016F5C  00021080   SLL V0, V0, 2
9D016F60  24636F74   ADDIU V1, V1, 28532
9D016F64  00621021   ADDU V0, V1, V0
9D016F68  8C420000   LW V0, 0(V0)
9D016F6C  00400008   JR V0
9D016F70  8CB90020   LW T9, 32(A1)
9D016F84  8CA40000   LW A0, 0(A1)
9D016F88  0B405CF7   J USB_DEVICE_ControlStatus
9D016F8C  24050001   ADDIU A1, ZERO, 1
9D016F90  13200013   BEQ T9, ZERO, 0x9D016FE0
9D016F94  00003025   OR A2, ZERO, ZERO
9D016F98  8CA70024   LW A3, 36(A1)
9D016F9C  03200008   JR T9
9D016FA0  24050001   ADDIU A1, ZERO, 1
9D016FA4  1320000E   BEQ T9, ZERO, 0x9D016FE0
9D016FA8  24C60002   ADDIU A2, A2, 2
9D016FAC  8CA70024   LW A3, 36(A1)
9D016FB0  03200008   JR T9
9D016FB4  24050003   ADDIU A1, ZERO, 3
9D016FB8  13200009   BEQ T9, ZERO, 0x9D016FE0
9D016FBC  24C60002   ADDIU A2, A2, 2
9D016FC0  8CA70024   LW A3, 36(A1)
9D016FC4  03200008   JR T9
9D016FC8  24050002   ADDIU A1, ZERO, 2
9D016FCC  13200004   BEQ T9, ZERO, 0x9D016FE0
9D016FD0  00003025   OR A2, ZERO, ZERO
9D016FD4  8CA70024   LW A3, 36(A1)
9D016FD8  03200008   JR T9
9D016FDC  00002825   OR A1, ZERO, ZERO
9D016FE0  03E00008   JR RA
9D016FE4  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/usb/src/usb_device_cdc.c  ------------------
1:                   /*******************************************************************************
2:                    USB CDC Class Function Driver
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       usb_device_cdc.c
9:                   
10:                    Summary:
11:                      USB CDC class function driver.
12:                  
13:                    Description:
14:                      USB CDC class function driver.
15:                   *******************************************************************************/
16:                  
17:                  // DOM-IGNORE-BEGIN
18:                  /*******************************************************************************
19:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
20:                  *
21:                  * Subject to your compliance with these terms, you may use Microchip software
22:                  * and any derivatives exclusively with Microchip products. It is your
23:                  * responsibility to comply with third party license terms applicable to your
24:                  * use of third party software (including open source software) that may
25:                  * accompany Microchip software.
26:                  *
27:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                  * PARTICULAR PURPOSE.
31:                  *
32:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
33:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
34:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
35:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
36:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
37:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
38:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
39:                   *******************************************************************************/
40:                  // DOM-IGNORE-END
41:                  
42:                  // *****************************************************************************
43:                  // *****************************************************************************
44:                  // Section: Included Files
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  #include "usb/usb_device_cdc.h"
48:                  #include "usb/src/usb_device_cdc_local.h"
49:                  #include "usb/src/usb_external_dependencies.h"
50:                  
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: File Scope or Global Data Types
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  // *****************************************************************************
59:                  /* CDC Device function driver structure
60:                  
61:                    Summary:
62:                      Defines the function driver structure required for the device layer.
63:                  
64:                    Description:
65:                      This data type defines the function driver structure required for the
66:                      device layer.
67:                  
68:                    Remarks:
69:                      This structure is private to the USB stack.
70:                  */
71:                  
72:                  const USB_DEVICE_FUNCTION_DRIVER cdcFunctionDriver =
73:                  {
74:                  
75:                      /* CDC init function */
76:                      .initializeByDescriptor         = _USB_DEVICE_CDC_Initialization ,
77:                  
78:                      /* CDC de-init function */
79:                      .deInitialize                   = _USB_DEVICE_CDC_Deinitialization ,
80:                  
81:                      /* EP0 activity callback */
82:                      .controlTransferNotification    = _USB_DEVICE_CDC_ControlTransferHandler,
83:                  
84:                      /* CDC tasks function */
85:                      .tasks                          = NULL,
86:                  
87:                      /* CDC Global Initialize */
88:                      .globalInitialize = _USB_DEVICE_CDC_GlobalInitialize
89:                  };
90:                  
91:                  // *****************************************************************************
92:                  /* CDC Device IRPs
93:                  
94:                    Summary:
95:                      Array of CDC Device IRP. 
96:                  
97:                    Description:
98:                      Array of CDC Device IRP. This array of IRP will be shared by read, write and
99:                      notification data requests.
100:                 
101:                   Remarks:
102:                     This array is private to the USB stack.
103:                 */
104:                 
105:                 USB_DEVICE_IRP gUSBDeviceCDCIRP[USB_DEVICE_CDC_QUEUE_DEPTH_COMBINED];
106:                 
107:                 
108:                 /* Create a variable for holding CDC IRP mutex Handle and status */
109:                 USB_DEVICE_CDC_COMMON_DATA_OBJ gUSBDeviceCdcCommonDataObj;
110:                  
111:                 
112:                 // *****************************************************************************
113:                 /* CDC Instance structure
114:                 
115:                   Summary:
116:                     Defines the CDC instance(s).
117:                 
118:                   Description:
119:                     This data type defines the CDC instance(s). The number of instances is
120:                     defined by the application using USB_DEVICE_CDC_INSTANCES_NUMBER.
121:                 
122:                   Remarks:
123:                     This structure is private to the CDC.
124:                 */
125:                 
126:                 USB_DEVICE_CDC_INSTANCE gUSBDeviceCDCInstance[USB_DEVICE_CDC_INSTANCES_NUMBER];
127:                 
128:                 // *****************************************************************************
129:                 /* CDC Instance Serial State Response structure
130:                 
131:                   Summary:
132:                     Defines the Serial State Response structures.
133:                 
134:                   Description:
135:                     This data type defines the CDC Serial State Response structures. 
136:                 	The number of buffers is defined by the application using the 
137:                 	USB_DEVICE_CDC_INSTANCES_NUMBER.
138:                 
139:                   Remarks:
140:                     This structure is private to the CDC.
141:                 */
142:                 USB_CDC_SERIAL_STATE_RESPONSE gUSBDeviceCDCSerialStateResponse[USB_DEVICE_CDC_INSTANCES_NUMBER] USB_ALIGN;
143:                 
144:                 // *****************************************************************************
145:                 // *****************************************************************************
146:                 // Section: File Scope Functions
147:                 // *****************************************************************************
148:                 // *****************************************************************************
149:                 // ******************************************************************************
150:                 /* Function:
151:                     void _USB_DEVICE_CDC_GlobalInitialize ( void )
152:                 
153:                   Summary:
154:                     This function initializes resourses required common to all instances of CDC
155:                     function driver.
156:                 
157:                   Description:
158:                     This function initializes resourses common to all instances of CDC function
159:                     driver. This function is called by the USB Device layer during Initalization.
160:                 
161:                   Remarks:
162:                     This is local function and should not be called directly by the application.
163:                 */
164:                 void _USB_DEVICE_CDC_GlobalInitialize (void)
165:                 {
166:                     OSAL_RESULT osal_err;
167:                     
168:                     /* Create Mutex for CDC IRP objects if not created already */
169:                     if (gUSBDeviceCdcCommonDataObj.isMutexCdcIrpInitialized == false)
170:                     {
171:                         /* This means that mutexes where not created. Create them. */
172:                         osal_err = OSAL_MUTEX_Create(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP);
173:                 
174:                         if(osal_err != OSAL_RESULT_TRUE)
175:                         {
176:                             /*do not proceed lock was not created, let user know about error*/
177:                             return;
178:                         }
179:                 
180:                          /* Set this flag so that global mutexes get allocated only once */
181:                          gUSBDeviceCdcCommonDataObj.isMutexCdcIrpInitialized = true;
182:                     }
183:                 }
184:                 // ******************************************************************************
185:                 /* Function:
186:                     void _USB_DEVICE_CDC_Initialization 
187:                     ( 
188:                         SYS_MODULE_INDEX iCDC ,
189:                         DRV_HANDLE deviceHandle ,
190:                         void* initData ,
191:                         uint8_t infNum ,
192:                         uint8_t altSetting ,
193:                         uint8_t descType ,
194:                         uint8_t * pDesc 
195:                     )
196:                 
197:                   Summary:
198:                     USB Device CDC function called by the device layer during Set Configuration
199:                     processing.
200:                   
201:                   Description:
202:                     USB Device CDC function called by the device layer during Set Configuration
203:                     processing.
204:                 
205:                   Remarks:
206:                     This is local function and should not be called directly by the application.
207:                 */
208:                 
209:                 void _USB_DEVICE_CDC_Initialization 
210:                 ( 
211:                     SYS_MODULE_INDEX iCDC ,
212:                     USB_DEVICE_HANDLE deviceHandle ,
213:                     void* initData ,
214:                     uint8_t infNum ,
215:                     uint8_t altSetting ,
216:                     uint8_t descType ,
217:                     uint8_t * pDesc 
218:                 )
219:                 {
220:                     /* Avoid unused warning */
221:                     ( void ) ( altSetting );
222:                     ( void ) ( initData );
223:                     uint8_t epAddress;
224:                     uint8_t epDir;
225:                     uint16_t maxPacketSize;
226:                     USB_DEVICE_CDC_INSTANCE * thisCDCInstance;
227:                     USB_DEVICE_CDC_INIT * cdcInit;
228:                     USB_ENDPOINT_DESCRIPTOR *pEPDesc;
229:                     USB_INTERFACE_DESCRIPTOR *pInfDesc;
230:                     USB_DEVICE_CDC_ENDPOINT * deviceCDCEndpoint;
231:                 
232:                     /* Check the validity of the function driver index */
233:                     if (iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER)
234:                     {
235:                         /* Assert on invalid CDC index */
236:                         SYS_DEBUG(0, "USB Device CDC: Invalid index");
237:                         return;
238:                     }
239:                 
240:                     thisCDCInstance = &gUSBDeviceCDCInstance[iCDC];
241:                 
242:                 
243:                     /* Initialize the queue sizes. This code may run several times
244:                      * but then we dont expect the queue sizes to change.*/
245:                 
246:                     cdcInit = ((USB_DEVICE_CDC_INIT *)initData);
247:                     thisCDCInstance->queueSizeWrite = cdcInit->queueSizeWrite;
248:                     thisCDCInstance->queueSizeRead = cdcInit->queueSizeRead;
249:                     thisCDCInstance->queueSizeSerialStateNotification = 
250:                     cdcInit->queueSizeSerialStateNotification;
251:                     thisCDCInstance->currentQSizeWrite = 0;
252:                     thisCDCInstance->currentQSizeRead = 0;
253:                     thisCDCInstance->currentQSizeSerialStateNotification = 0;
254:                 	
255:                 	/* Initialize pointer to the Serial state notification buffer */ 
256:                 	thisCDCInstance->serialStateResponse = &gUSBDeviceCDCSerialStateResponse[iCDC]; 
257:                 
258:                     
259:                     /* check the type of descriptor passed by device layer */
260:                     switch ( descType )
261:                     {
262:                         /* Interface descriptor passed */
263:                         case USB_DESCRIPTOR_INTERFACE:
264:                             {
265:                                 pInfDesc = ( USB_INTERFACE_DESCRIPTOR * )pDesc;
266:                 
267:                                 /* Preserve the device layer handle */
268:                                 thisCDCInstance->deviceHandle = deviceHandle;
269:                 
270:                                 /* check if this is notification(communication) interface */
271:                                 if ( ( pInfDesc->bInterfaceClass == USB_CDC_COMMUNICATIONS_INTERFACE_CLASS_CODE ) &&
272:                                         ( pInfDesc->bInterfaceSubClass == USB_CDC_SUBCLASS_ABSTRACT_CONTROL_MODEL ) )
273:                                 {
274:                                     /* Save the notification interface number */
275:                                     thisCDCInstance->notificationInterface.interfaceNum = infNum;
276:                                 }
277:                 
278:                                 /* data interface */
279:                                 else if ( ( pInfDesc->bInterfaceClass == USB_CDC_DATA_INTERFACE_CLASS_CODE ) )
280:                                 {
281:                                     /* save the data interface number */
282:                                     thisCDCInstance->dataInterface.interfaceNum = infNum;
283:                                 }
284:                 
285:                                 else
286:                                 {
287:                                     /* Ignore anything else */
288:                                     SYS_DEBUG(0, "USB Device CDC: Invalid interface presented to CDC " );
289:                                 }
290:                 
291:                                 break;
292:                             }
293:                 
294:                             /* Endpoint descriptor passed */
295:                         case USB_DESCRIPTOR_ENDPOINT:
296:                             {
297:                                 pEPDesc = ( USB_ENDPOINT_DESCRIPTOR* ) pDesc;
298:                 
299:                                 /* Save the ep address */
300:                                 epAddress = pEPDesc->bEndpointAddress;
301:                 
302:                                 /* Get the direction */
303:                                 epDir = ( epAddress & 0x80 ) ? 
304:                                     ( USB_DEVICE_CDC_ENDPOINT_TX ) : ( USB_DEVICE_CDC_ENDPOINT_RX );
305:                 
306:                                 /* Save max packet size */
307:                                 maxPacketSize = ( ( USB_ENDPOINT_DESCRIPTOR* ) pDesc )->wMaxPacketSize;
308:                 
309:                                 if ( pEPDesc->transferType == USB_TRANSFER_TYPE_BULK )
310:                                 {
311:                                     /* This is a data interface endpoint */
312:                                     deviceCDCEndpoint = &thisCDCInstance->dataInterface.endpoint[epDir];
313:                                 }
314:                                 else if( pEPDesc->transferType == USB_TRANSFER_TYPE_INTERRUPT)
315:                                 {
316:                                     /* This is notification endpoint */
317:                                     deviceCDCEndpoint = &thisCDCInstance->notificationInterface.endpoint[epDir];
318:                                 }
319:                                 else
320:                                 {
321:                                     /* We cannot support ny other type of endpoint for now */
322:                                     SYS_DEBUG(0, "USB Device CDC: Cannot handle this endpoint type" );
323:                                     break;
324:                                 }
325:                 
326:                                 /* Save ep address to the data interface */
327:                                 deviceCDCEndpoint->address = epAddress;
328:                 
329:                                 /* Save max packet size to the data interface */
330:                                 deviceCDCEndpoint->maxPacketSize = maxPacketSize;
331:                 
332:                                 /* Enable the endpoint */
333:                                 USB_DEVICE_EndpointEnable ( deviceHandle ,
334:                                         0,
335:                                         epAddress ,
336:                                         (USB_TRANSFER_TYPE)pEPDesc->transferType ,
337:                                         maxPacketSize );
338:                 
339:                                 /* Indicate that the endpoint is configured */
340:                                 deviceCDCEndpoint->isConfigured = true;
341:                 
342:                                 break;
343:                             }
344:                 
345:                         case USB_CDC_DESC_CS_INTERFACE:
346:                             {
347:                                 break;
348:                             }
349:                 
350:                         default:
351:                             /* Unsupported descriptor type */
352:                             break;
353:                     }
354:                 }
355:                 
356:                 // ******************************************************************************
357:                 /* Function:
358:                     void _USB_DEVICE_CDC_EndpointDisable
359:                     (
360:                         USB_DEVICE_HANDLE deviceHandle, 
361:                         USB_DEVICE_CDC_ENDPOINT * deviceCDCEndpoint
362:                     )
363:                 
364:                   Summary:
365:                     Disabled USB Device CDC endpoints.
366:                   
367:                   Description:
368:                     Disabled USB Device CDC endpoints.
369:                 
370:                   Remarks:
371:                     This is local function and should not be called directly by the application.
372:                 */
373:                 
374:                 void _USB_DEVICE_CDC_EndpointDisable
375:                 (
376:                     USB_DEVICE_HANDLE deviceHandle, 
377:                     USB_DEVICE_CDC_ENDPOINT * deviceCDCEndpoint
378:                 )
379:                 {
380:                     if(deviceCDCEndpoint->isConfigured)
381:                     {
382:                         USB_DEVICE_IRPCancelAll(deviceHandle, deviceCDCEndpoint->address);
383:                         USB_DEVICE_EndpointDisable(deviceHandle, deviceCDCEndpoint->address);
384:                         deviceCDCEndpoint->isConfigured = false;
385:                     }
386:                 }
387:                 
388:                 // ******************************************************************************
389:                 /* Function:
390:                     void _USB_DEVICE_CDC_Deinitialization ( SYS_MODULE_INDEX iCDC )
391:                  
392:                   Summary:
393:                     Deinitializes the function driver instance.
394:                   
395:                   Description:
396:                     Deinitializes the function driver instance.
397:                 
398:                   Remarks:
399:                     This is local function and should not be called directly by the application.
400:                 */
401:                 
402:                 void _USB_DEVICE_CDC_Deinitialization ( SYS_MODULE_INDEX iCDC )
403:                 {
404:                     /* Cancel all IRPs on the owned endpoints and then 
405:                      * disable the endpoint */
406:                 
407:                     USB_DEVICE_HANDLE deviceHandle;
408:                     USB_DEVICE_CDC_ENDPOINT * deviceCDCEndpoint;
409:                 
410:                     if(iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER)
411:                     {
412:                         SYS_DEBUG(0, "USB Device CDC: Invalid instance");
413:                         return;
414:                     } 
415:                 
416:                     deviceHandle = gUSBDeviceCDCInstance[iCDC].deviceHandle;
417:                 
418:                     deviceCDCEndpoint = &gUSBDeviceCDCInstance[iCDC].dataInterface.endpoint[0];
419:                     _USB_DEVICE_CDC_EndpointDisable(deviceHandle, deviceCDCEndpoint);
420:                     
421:                     deviceCDCEndpoint = &gUSBDeviceCDCInstance[iCDC].dataInterface.endpoint[1];
422:                     _USB_DEVICE_CDC_EndpointDisable(deviceHandle, deviceCDCEndpoint);
423:                     
424:                     deviceCDCEndpoint = &gUSBDeviceCDCInstance[iCDC].notificationInterface.endpoint[0];
425:                     _USB_DEVICE_CDC_EndpointDisable(deviceHandle, deviceCDCEndpoint);
426:                     
427:                     deviceCDCEndpoint = &gUSBDeviceCDCInstance[iCDC].notificationInterface.endpoint[1];
428:                     _USB_DEVICE_CDC_EndpointDisable(deviceHandle, deviceCDCEndpoint);
429:                 
430:                 }
431:                 
432:                 // ******************************************************************************
433:                 /* Function:
434:                     void _USB_DEVICE_CDC_ControlTransferHandler 
435:                     (
436:                         USB_DEVICE_CONTROL_TRANSFER_HANDLE controlTransferHandle ,
437:                         SYS_MODULE_INDEX iCDC ,
438:                         USB_DEVICE_EVENT controlTransferEvent,
439:                         void * controlTransferEventData
440:                     )
441:                  
442:                   Summary:
443:                     Control Transfer Handler for class specific control transfer.
444:                   
445:                   Description:
446:                     This is theControl Transfer Handler for class specific control transfer. The
447:                     device layer calls this functions for control transfer that are targetted to
448:                     an interface or endpoint that is owned by this function driver.
449:                 
450:                   Remarks:
451:                     This is local function and should not be called directly by the application.
452:                 */
453:                 
454:                 void _USB_DEVICE_CDC_ControlTransferHandler 
455:                 (
456:                     SYS_MODULE_INDEX iCDC ,
457:                     USB_DEVICE_EVENT controlTransferEvent,
458:                     USB_SETUP_PACKET * setupRequest
459:                 )
460:                 {
461:                     USB_DEVICE_HANDLE deviceHandle;
462:                     USB_DEVICE_CDC_INSTANCE * thisCDCDevice;
463:                     
464:                     /* Check the validity of the function driver index */
465:                     if (iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER)
466:                     {
467:                         /* invalid CDC index */
468:                         SYS_DEBUG(0, "USB Device CDC: Invalid CDC index" );
469:                         return;
470:                     }
471:                 
472:                     /* Get a local reference */
473:                     thisCDCDevice = &gUSBDeviceCDCInstance[iCDC];
474:                 
475:                     /* Get the Device Layer handle */
476:                     deviceHandle = thisCDCDevice->deviceHandle;
477:                 
478:                     switch (controlTransferEvent)
479:                     {
480:                         /* Setup packet received */
481:                 
482:                         case USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST:
483:                 
484:                             /* This means we have a setup packet for this interface */
485:                             
486:                             if(!(setupRequest->bmRequestType & USB_CDC_REQUEST_CLASS_SPECIFIC))
487:                             {
488:                                 /* This means this is not a class specific request.
489:                                  * We stall this request */
490:                 
491:                                 USB_DEVICE_ControlStatus(deviceHandle, USB_DEVICE_CONTROL_STATUS_ERROR);
492:                             }
493:                             else
494:                             {
495:                                 /* Check if the requests belong to the ACM sub class */
496:                                 switch(setupRequest->bRequest)
497:                                 {
498:                                     case USB_CDC_REQUEST_SET_LINE_CODING:
499:                                     case USB_CDC_REQUEST_GET_LINE_CODING:
500:                                     case USB_CDC_REQUEST_SET_CONTROL_LINE_STATE:
501:                                     case USB_CDC_REQUEST_SEND_BREAK:
502:                                     case USB_CDC_REQUEST_SEND_ENCAPSULATED_COMMAND:
503:                                     case USB_CDC_REQUEST_GET_ENCAPSULATED_RESPONSE:
504:                 
505:                                         /* These are ACM requests */
506:                 
507:                                         _USB_DEVICE_CDC_ACMSetUpPacketHandler(iCDC, thisCDCDevice, 
508:                                                 setupRequest);
509:                 
510:                                         break;
511:                                     default:
512:                                         /* This is an un-supported request */
513:                                         USB_DEVICE_ControlStatus(deviceHandle, USB_DEVICE_CONTROL_STATUS_ERROR);
514:                                         break;
515:                                 }
516:                             }
517:                 
518:                             break;
519:                 
520:                         case USB_DEVICE_EVENT_CONTROL_TRANSFER_DATA_RECEIVED:
521:                 
522:                             /* A control transfer data stage is complete. Send
523:                              * this event to application */
524:                 
525:                             if(thisCDCDevice->appEventCallBack != NULL)
526:                             {
527:                                 thisCDCDevice->appEventCallBack(iCDC, 
528:                                         USB_DEVICE_CDC_EVENT_CONTROL_TRANSFER_DATA_RECEIVED,
529:                                         NULL, thisCDCDevice->userData );
530:                             }
531:                 
532:                             break;
533:                 
534:                         case USB_DEVICE_EVENT_CONTROL_TRANSFER_DATA_SENT:
535:                 
536:                             /* A control transfer data stage is complete. Send
537:                              * this event to application */
538:                 
539:                             if(thisCDCDevice->appEventCallBack != NULL)
540:                             {
541:                                 thisCDCDevice->appEventCallBack(iCDC, 
542:                                         USB_DEVICE_CDC_EVENT_CONTROL_TRANSFER_DATA_SENT,
543:                                         NULL, thisCDCDevice->userData );
544:                             }
545:                 
546:                         default:
547:                             break;
548:                     }
549:                 }
550:                 
551:                 // ******************************************************************************
552:                 /* Function:
553:                     void _USB_DEVICE_CDC_SerialStateSendIRPCallback (USB_DEVICE_IRP * irp )
554:                  
555:                   Summary:
556:                     IRP call back for Serial State Send IRPs.
557:                   
558:                   Description:
559:                     This is IRP call back for IRPs submitted through the
560:                     USB_DEVICE_CDC_SerialStateSend() function.
561:                 
562:                   Remarks:
563:                     This is local function and should not be called directly by the application.
564:                 */
565:                 
566:                 void _USB_DEVICE_CDC_SerialStateSendIRPCallback (USB_DEVICE_IRP * irp )
567:                 {
568:                     USB_DEVICE_CDC_INSTANCE * thisCDCDevice;
569:                 
570:                     /* This function is called when a CDC Write IRP has
571:                      * terminated */
572:                     
573:                     USB_DEVICE_CDC_EVENT_DATA_SERIAL_STATE_NOTIFICATION_COMPLETE serialStateEventData;
574:                 
575:                     /* The user data field of the IRP contains the CDC instance
576:                      * that submitted this IRP */
577:                     thisCDCDevice = &gUSBDeviceCDCInstance[irp->userData];
578:                 
579:                     /* populate the event handler for this transfer */
580:                     serialStateEventData.handle = ( USB_DEVICE_CDC_TRANSFER_HANDLE ) irp;
581:                 
582:                     /* update the size written */
583:                     serialStateEventData.length = irp->size;
584:                     
585:                     /* Get transfer status */
586:                     if ((irp->status == USB_DEVICE_IRP_STATUS_COMPLETED) 
587:                         || (irp->status == USB_DEVICE_IRP_STATUS_COMPLETED_SHORT))
588:                     {
589:                         /* Transfer completed successfully */
590:                         serialStateEventData.status = USB_DEVICE_CDC_RESULT_OK; 
591:                     }
592:                     else if (irp->status == USB_DEVICE_IRP_STATUS_ABORTED_ENDPOINT_HALT)
593:                     {
594:                         /* Transfer cancelled due to Endpoint Halt */
595:                         serialStateEventData.status = USB_DEVICE_CDC_RESULT_ERROR_ENDPOINT_HALTED; 
596:                     }
597:                     else if (irp->status == USB_DEVICE_IRP_STATUS_TERMINATED_BY_HOST)
598:                     {
599:                         /* Transfer Cancelled by Host (Host sent a Clear feature )*/
600:                         serialStateEventData.status = USB_DEVICE_CDC_RESULT_ERROR_TERMINATED_BY_HOST; 
601:                     }
602:                     else
603:                     {
604:                         /* Transfer was not completed successfully */
605:                         serialStateEventData.status = USB_DEVICE_CDC_RESULT_ERROR; 
606:                     }
607:                 
608:                     /* Reduce the queue size */
609:                 
610:                     thisCDCDevice->currentQSizeSerialStateNotification --;
611:                 
612:                     /* valid application event handler present? */
613:                     if ( thisCDCDevice->appEventCallBack )
614:                     {
615:                         /* inform the application */
616:                         thisCDCDevice->appEventCallBack ( (USB_DEVICE_CDC_INDEX)(irp->userData) , 
617:                                    USB_DEVICE_CDC_EVENT_SERIAL_STATE_NOTIFICATION_COMPLETE ,
618:                                    &serialStateEventData, thisCDCDevice->userData);
619:                     }
620:                 
621:                 }
622:                 
623:                 // ******************************************************************************
624:                 /* Function:
625:                     void _USB_DEVICE_CDC_ReadIRPCallback (USB_DEVICE_IRP * irp )
626:                  
627:                   Summary:
628:                     IRP call back for Data Read IRPs.
629:                   
630:                   Description:
631:                     This is IRP call back for IRPs submitted through the USB_DEVICE_CDC_Read()
632:                     function.
633:                 
634:                   Remarks:
635:                     This is local function and should not be called directly by the application.
636:                 */
637:                 
638:                 void _USB_DEVICE_CDC_ReadIRPCallback (USB_DEVICE_IRP * irp )
639:                 {
640:                     USB_DEVICE_CDC_INSTANCE * thisCDCDevice;
641:                 
642:                     /* This function is called when a CDC Write IRP has
643:                      * terminated */
644:                     
645:                     USB_DEVICE_CDC_EVENT_DATA_READ_COMPLETE readEventData;
646:                 
647:                     /* The user data field of the IRP contains the CDC instance
648:                      * that submitted this IRP */
649:                     thisCDCDevice = &gUSBDeviceCDCInstance[irp->userData];
650:                 
651:                     /* populate the event handler for this transfer */
652:                     readEventData.handle = ( USB_DEVICE_CDC_TRANSFER_HANDLE ) irp;
653:                 
654:                     /* update the size written */
655:                     readEventData.length = irp->size;
656:                     
657:                     /* Get transfer status */
658:                     if ((irp->status == USB_DEVICE_IRP_STATUS_COMPLETED) 
659:                         || (irp->status == USB_DEVICE_IRP_STATUS_COMPLETED_SHORT))
660:                     {
661:                         /* Transfer completed successfully */
662:                         readEventData.status = USB_DEVICE_CDC_RESULT_OK; 
663:                     }
664:                     else if (irp->status == USB_DEVICE_IRP_STATUS_ABORTED_ENDPOINT_HALT)
665:                     {
666:                         /* Transfer cancelled due to Endpoint Halt */
667:                         readEventData.status = USB_DEVICE_CDC_RESULT_ERROR_ENDPOINT_HALTED; 
668:                     }
669:                     else if (irp->status == USB_DEVICE_IRP_STATUS_TERMINATED_BY_HOST)
670:                     {
671:                         /* Transfer Cancelled by Host (Host sent a Clear feature )*/
672:                         readEventData.status = USB_DEVICE_CDC_RESULT_ERROR_TERMINATED_BY_HOST; 
673:                     }
674:                     else
675:                     {
676:                         /* Transfer was not completed successfully */
677:                         readEventData.status = USB_DEVICE_CDC_RESULT_ERROR; 
678:                     }
679:                 
680:                     /* update the queue size */
681:                     thisCDCDevice->currentQSizeRead --;
682:                 
683:                     /* valid application event handler present? */
684:                     if ( thisCDCDevice->appEventCallBack )
685:                     {
686:                         /* inform the application */
687:                         thisCDCDevice->appEventCallBack ( (USB_DEVICE_CDC_INDEX)(irp->userData) , 
688:                                    USB_DEVICE_CDC_EVENT_READ_COMPLETE , 
689:                                    &readEventData, thisCDCDevice->userData);
690:                     }
691:                 
692:                 }
693:                 
694:                 // ******************************************************************************
695:                 /* Function:
696:                     void _USB_DEVICE_CDC_WriteIRPCallback (USB_DEVICE_IRP * irp )
697:                  
698:                   Summary:
699:                     IRP call back for Data Write IRPs.
700:                   
701:                   Description:
702:                     This is IRP call back for IRPs submitted through the USB_DEVICE_CDC_Write()
703:                     function.
704:                 
705:                   Remarks:
706:                     This is local function and should not be called directly by the application.
707:                 */
708:                 
709:                 void _USB_DEVICE_CDC_WriteIRPCallback (USB_DEVICE_IRP * irp )
710:                 {
711:                     USB_DEVICE_CDC_INSTANCE * thisCDCDevice;
712:                 
713:                     /* This function is called when a CDC Write IRP has
714:                      * terminated */
715:                     
716:                     USB_DEVICE_CDC_EVENT_DATA_WRITE_COMPLETE writeEventData;
717:                 
718:                     /* The user data field of the IRP contains the CDC instance
719:                      * that submitted this IRP */
720:                     thisCDCDevice = &gUSBDeviceCDCInstance[irp->userData];
721:                 
722:                     /* populate the event handler for this transfer */
723:                     writeEventData.handle = ( USB_DEVICE_CDC_TRANSFER_HANDLE ) irp;
724:                 
725:                     /* update the size written */
726:                     writeEventData.length = irp->size;
727:                     
728:                     /* Get transfer status */
729:                     if ((irp->status == USB_DEVICE_IRP_STATUS_COMPLETED) 
730:                         || (irp->status == USB_DEVICE_IRP_STATUS_COMPLETED_SHORT))
731:                     {
732:                         /* Transfer completed successfully */
733:                         writeEventData.status = USB_DEVICE_CDC_RESULT_OK; 
734:                     }
735:                     else if (irp->status == USB_DEVICE_IRP_STATUS_ABORTED_ENDPOINT_HALT)
736:                     {
737:                         /* Transfer cancelled due to Endpoint Halt */
738:                         writeEventData.status = USB_DEVICE_CDC_RESULT_ERROR_ENDPOINT_HALTED; 
739:                     }
740:                     else if (irp->status == USB_DEVICE_IRP_STATUS_TERMINATED_BY_HOST)
741:                     {
742:                         /* Transfer Cancelled by Host (Host sent a Clear feature )*/
743:                         writeEventData.status = USB_DEVICE_CDC_RESULT_ERROR_TERMINATED_BY_HOST; 
744:                     }
745:                     else
746:                     {
747:                         /* Transfer was not completed successfully */
748:                         writeEventData.status = USB_DEVICE_CDC_RESULT_ERROR; 
749:                     }
750:                 
751:                     /* Update the queue size*/
752:                     thisCDCDevice->currentQSizeWrite --;
753:                 
754:                     /* valid application event handler present? */
755:                     if ( thisCDCDevice->appEventCallBack )
756:                     {
757:                         /* inform the application */
758:                         thisCDCDevice->appEventCallBack ( (USB_DEVICE_CDC_INDEX)(irp->userData) , 
759:                                    USB_DEVICE_CDC_EVENT_WRITE_COMPLETE , 
760:                                    &writeEventData, thisCDCDevice->userData);
761:                     }
762:                 
763:                 }
764:                 
765:                 // *****************************************************************************
766:                 // *****************************************************************************
767:                 // Section: CDC Interface Function Definitions
768:                 // *****************************************************************************
769:                 // *****************************************************************************
770:                 
771:                 
772:                 // *****************************************************************************
773:                 /* Function:
774:                     USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_Read 
775:                     (
776:                         USB_DEVICE_CDC_INDEX instance, 
777:                         USB_CDC_DEVICE_TRANSFER_HANDLE * transferHandle,
778:                         void * data, 
779:                         size_t size
780:                     );
781:                 
782:                   Summary:
783:                     This function requests a data read from the USB Device CDC Function Driver 
784:                     Layer.
785:                 
786:                   Description:
787:                     This function requests a data read from the USB Device CDC Function Driver
788:                     Layer. The function places a requests with driver, the request will get
789:                     serviced as data is made available by the USB Host. A handle to the request
790:                     is returned in the transferHandle parameter. The termination of the request
791:                     is indicated by the USB_DEVICE_CDC_EVENT_READ_COMPLETE event. The amount of
792:                     data read and the transfer handle associated with the request is returned
793:                     along with the event in the pData parameter of the event handler. The
794:                     transfer handle expires when event handler for the
795:                     USB_DEVICE_CDC_EVENT_READ_COMPLETE exits. If the read request could not be
796:                     accepted, the function returns an error code and transferHandle will contain
797:                     the value USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID.
798:                 
799:                     If the size parameter is not a multiple of maxPacketSize or is 0, the
800:                     function returns USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID in transferHandle
801:                     and returns an error code as a return value. If the size parameter is a
802:                     multiple of maxPacketSize and the host send less than maxPacketSize data in
803:                     any transaction, the transfer completes and the function driver will issue a
804:                     USB_DEVICE_CDC_EVENT_READ_COMPLETE event along with the
805:                     USB_DEVICE_CDC_EVENT_READ_COMPLETE_DATA data structure. If the size
806:                     parameter is a multiple of maxPacketSize and the host sends maxPacketSize
807:                     amount of data, and total data received does not exceed size, then the
808:                     function driver will wait for the next packet. 
809:                   
810:                   Remarks:
811:                     Refer to usb_device_cdc.h for usage information.
812:                 */   
813:                 
814:                 USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_Read 
815:                 (
816:                     USB_DEVICE_CDC_INDEX iCDC ,
817:                     USB_DEVICE_CDC_TRANSFER_HANDLE * transferHandle ,
818:                     void * data , size_t size
819:                 )
820:                 {
821:                     unsigned int cnt;
822:                     unsigned int remainder;
823:                     USB_DEVICE_IRP * irp;
824:                     USB_DEVICE_CDC_ENDPOINT * endpoint;
825:                     USB_DEVICE_CDC_INSTANCE * thisCDCDevice;
826:                     OSAL_RESULT osalError;
827:                     USB_ERROR irpError;
828:                     OSAL_CRITSECT_DATA_TYPE IntState;
829:                 
830:                     /* Check the validity of the function driver index */
831:                     
832:                     if (  iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER  )
833:                     {
834:                         /* Invalid CDC index */
835:                         SYS_ASSERT(false, "Invalid CDC Device Index");
836:                         return USB_DEVICE_CDC_RESULT_ERROR_INSTANCE_INVALID;
837:                     }
838:                 
839:                     thisCDCDevice = &gUSBDeviceCDCInstance[iCDC];
840:                     endpoint = &thisCDCDevice->dataInterface.endpoint[USB_DEVICE_CDC_ENDPOINT_RX];
841:                     *transferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
842:                 
843:                     /* Check if the endpoint is configured */
844:                     if(!(endpoint->isConfigured))
845:                     {
846:                         /* This means that the endpoint is not configured yet */
847:                         SYS_ASSERT(false, "Endpoint not configured");
848:                         return (USB_DEVICE_CDC_RESULT_ERROR_INSTANCE_NOT_CONFIGURED);
849:                     }
850:                 
851:                     /* For read the size should be a multiple of endpoint size*/
852:                     remainder = size % endpoint->maxPacketSize;
853:                 
854:                     if((size == 0) || (remainder != 0))
855:                     {
856:                         /* Size is not valid */
857:                         SYS_ASSERT(false, "Invalid size in IRP read");
858:                         return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_SIZE_INVALID);
859:                     }
860:                 
861:                     /* Make sure that we are with in the queue size for this instance */
862:                     if(thisCDCDevice->currentQSizeRead >= thisCDCDevice->queueSizeRead)
863:                     {
864:                         SYS_ASSERT(false, "Read Queue is full");
865:                         return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_QUEUE_FULL);
866:                     }
867:                 
868:                     /*Obtain mutex to get access to a shared resource, check return value*/
869:                     osalError = OSAL_MUTEX_Lock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP, OSAL_WAIT_FOREVER);
870:                     if(osalError != OSAL_RESULT_TRUE)
871:                     {
872:                       /*Do not proceed lock was not obtained, or error occurred, let user know about error*/
873:                       return (USB_DEVICE_CDC_RESULT_ERROR);
874:                     }
875:                 
876:                     /* Loop and find a free IRP in the Q */
877:                     for ( cnt = 0; cnt < USB_DEVICE_CDC_QUEUE_DEPTH_COMBINED; cnt ++ )
878:                     {
879:                         if(gUSBDeviceCDCIRP[cnt].status <
880:                                 (USB_DEVICE_IRP_STATUS)USB_DEVICE_IRP_FLAG_DATA_PENDING)
881:                         {
882:                             /* This means the IRP is free. Configure the IRP
883:                              * update the current queue size and then submit */
884:                 
885:                             irp = &gUSBDeviceCDCIRP[cnt];
886:                             irp->data = data;
887:                             irp->size = size;
888:                             irp->userData = (uintptr_t) iCDC;
889:                             irp->callback = _USB_DEVICE_CDC_ReadIRPCallback;
890:                             
891:                             /* Prevent other tasks pre-empting this sequence of code */ 
892:                             IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
893:                             /* Update the read queue size */ 
894:                             thisCDCDevice->currentQSizeRead++;
895:                             OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, IntState);
896:                             
897:                             *transferHandle = (USB_DEVICE_CDC_TRANSFER_HANDLE)irp;
898:                             irpError = USB_DEVICE_IRPSubmit(thisCDCDevice->deviceHandle,
899:                                     endpoint->address, irp);
900:                 
901:                             /* If IRP Submit function returned any error, then invalidate the
902:                                Transfer handle.  */
903:                             if (irpError != USB_ERROR_NONE )
904:                             {
905:                                 /* Prevent other tasks pre-empting this sequence of code */ 
906:                                 IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
907:                                 /* Update the read queue size */ 
908:                                 thisCDCDevice->currentQSizeRead--;
909:                                 OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, IntState);
910:                                 *transferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
911:                             }
912:                             
913:                             /*Release mutex, done with shared resource*/
914:                             osalError = OSAL_MUTEX_Unlock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP);
915:                             if(osalError != OSAL_RESULT_TRUE)
916:                             {
917:                                 /*Do not proceed unlock was not complete, or error occurred, let user know about error*/
918:                                 return (USB_DEVICE_CDC_RESULT_ERROR);
919:                             }
920:                             
921:                             return((USB_DEVICE_CDC_RESULT)irpError);
922:                         }
923:                     }
924:                     
925:                     /*Release mutex, done with shared resource*/
926:                     osalError = OSAL_MUTEX_Unlock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP);
927:                     if(osalError != OSAL_RESULT_TRUE)
928:                     {
929:                         /*Do not proceed unlock was not complete, or error occurred, let user know about error*/
930:                         return (USB_DEVICE_CDC_RESULT_ERROR);
931:                     }
932:                     /* If here means we could not find a spare IRP */
933:                     return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_QUEUE_FULL);
934:                 }
935:                 
936:                 // *****************************************************************************
937:                 /* Function:
938:                     USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_Write 
939:                     (   
940:                         USB_DEVICE_CDC_INDEX instance, 
941:                         USB_CDC_DEVICE_TRANSFER_HANDLE * transferHandle, 
942:                         const void * data, 
943:                         size_t size, 
944:                         USB_DEVICE_CDC_TRANSFER_FLAGS flags 
945:                     );
946:                 
947:                   Summary:
948:                     This function requests a data write to the USB Device CDC Function Driver 
949:                     Layer.
950:                 
951:                   Description:
952:                     This function requests a data write to the USB Device CDC Function Driver
953:                     Layer. The function places a requests with driver, the request will get
954:                     serviced as data is requested by the USB Host. A handle to the request is
955:                     returned in the transferHandle parameter. The termination of the request is
956:                     indicated by the USB_DEVICE_CDC_EVENT_WRITE_COMPLETE event. The amount of
957:                     data written and the transfer handle associated with the request is returned
958:                     along with the event in writeCompleteData member of the pData parameter in
959:                     the event handler. The transfer handle expires when event handler for the
960:                     USB_DEVICE_CDC_EVENT_WRITE_COMPLETE exits.  If the read request could not be
961:                     accepted, the function returns an error code and transferHandle will contain
962:                     the value USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID.
963:                 
964:                   Remarks:
965:                     Refer to usb_device_cdc.h for usage information.
966:                 */
967:                 
968:                 USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_Write 
969:                 (
970:                     USB_DEVICE_CDC_INDEX iCDC ,
971:                     USB_DEVICE_CDC_TRANSFER_HANDLE * transferHandle ,
972:                     const void * data , size_t size ,
973:                     USB_DEVICE_CDC_TRANSFER_FLAGS flags 
974:                 )
975:                 {
976:                     unsigned int cnt;
977:                     unsigned int remainder;
978:                     USB_DEVICE_IRP * irp;
979:                     USB_DEVICE_IRP_FLAG irpFlag = USB_DEVICE_IRP_FLAG_NONE;
980:                     USB_DEVICE_CDC_INSTANCE * thisCDCDevice;
981:                     USB_DEVICE_CDC_ENDPOINT * endpoint;
982:                     OSAL_RESULT osalError;
983:                     USB_ERROR irpError; 
984:                     OSAL_CRITSECT_DATA_TYPE IntState;
985:                 
986:                     /* Check the validity of the function driver index */
987:                     
988:                     if (  iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER  )
989:                     {
990:                         /* Invalid CDC index */
991:                         SYS_ASSERT(false, "Invalid CDC Device Index");
992:                         return USB_DEVICE_CDC_RESULT_ERROR_INSTANCE_INVALID;
993:                     }
994:                 
995:                     /* Initialize the transfer handle, get the instance object
996:                      * and the transmit endpoint */
997:                 
998:                     * transferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
999:                     thisCDCDevice = &gUSBDeviceCDCInstance[iCDC];
1000:                    endpoint = &thisCDCDevice->dataInterface.endpoint[USB_DEVICE_CDC_ENDPOINT_TX];
1001:                
1002:                    if(!(endpoint->isConfigured))
1003:                    {
1004:                        /* This means that the endpoint is not configured yet */
1005:                        SYS_ASSERT(false, "Endpoint not configured");
1006:                        return (USB_DEVICE_CDC_RESULT_ERROR_INSTANCE_NOT_CONFIGURED);
1007:                    }
1008:                
1009:                    if(size == 0) 
1010:                    {
1011:                        /* Size cannot be zero */
1012:                        return (USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_SIZE_INVALID);
1013:                    }
1014:                
1015:                    /* Check the flag */
1016:                
1017:                    if(flags & USB_DEVICE_CDC_TRANSFER_FLAGS_MORE_DATA_PENDING)
1018:                    {
1019:                        if(size < endpoint->maxPacketSize)
1020:                        {
1021:                            /* For a data pending flag, we must atleast get max packet
1022:                             * size worth data */
1023:                
1024:                            return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_SIZE_INVALID);
1025:                        }
1026:                
1027:                        remainder = size % endpoint->maxPacketSize;
1028:                        
1029:                        if(remainder != 0)
1030:                        {
1031:                            size -= remainder;
1032:                        }
1033:                
1034:                        irpFlag = USB_DEVICE_IRP_FLAG_DATA_PENDING;
1035:                    }
1036:                    else if(flags & USB_DEVICE_CDC_TRANSFER_FLAGS_DATA_COMPLETE)
1037:                    {
1038:                        irpFlag = USB_DEVICE_IRP_FLAG_DATA_COMPLETE;
1039:                    }
1040:                
1041:                    if(thisCDCDevice->currentQSizeWrite >= thisCDCDevice->queueSizeWrite)
1042:                    {
1043:                        SYS_ASSERT(false, "Write Queue is full");
1044:                        return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_QUEUE_FULL);
1045:                    }
1046:                
1047:                    /*Obtain mutex to get access to a shared resource, check return value*/
1048:                    osalError = OSAL_MUTEX_Lock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP, OSAL_WAIT_FOREVER);
1049:                    if(osalError != OSAL_RESULT_TRUE)
1050:                    {
1051:                      /*Do not proceed lock was not obtained, or error occurred, let user know about error*/
1052:                      return (USB_DEVICE_CDC_RESULT_ERROR);
1053:                    }
1054:                
1055:                    /* loop and find a free IRP in the Q */
1056:                    for ( cnt = 0; cnt < USB_DEVICE_CDC_QUEUE_DEPTH_COMBINED; cnt ++ )
1057:                    {
1058:                        if(gUSBDeviceCDCIRP[cnt].status <
1059:                                (USB_DEVICE_IRP_STATUS)USB_DEVICE_IRP_FLAG_DATA_PENDING)
1060:                        {
1061:                            /* This means the IRP is free */
1062:                
1063:                            irp         = &gUSBDeviceCDCIRP[cnt];
1064:                            irp->data   = (void *)data;
1065:                            irp->size   = size;
1066:                
1067:                            irp->userData   = (uintptr_t) iCDC;
1068:                            irp->callback   = _USB_DEVICE_CDC_WriteIRPCallback;
1069:                            irp->flags      = irpFlag;
1070:                
1071:                            /* Prevent other tasks pre-empting this sequence of code */ 
1072:                            IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
1073:                            /* Update the Write queue size */ 
1074:                            thisCDCDevice->currentQSizeWrite++;
1075:                            OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, IntState);
1076:                            
1077:                            *transferHandle = (USB_DEVICE_CDC_TRANSFER_HANDLE)irp;
1078:                
1079:                            irpError = USB_DEVICE_IRPSubmit(thisCDCDevice->deviceHandle,
1080:                                    endpoint->address, irp);
1081:                
1082:                            /* If IRP Submit function returned any error, then invalidate the
1083:                               Transfer handle.  */
1084:                            if (irpError != USB_ERROR_NONE )
1085:                            {
1086:                                /* Prevent other tasks pre-empting this sequence of code */ 
1087:                                IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
1088:                                /* Update the Write queue size */ 
1089:                                thisCDCDevice->currentQSizeWrite--;
1090:                                OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, IntState);
1091:                                *transferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
1092:                            }
1093:                            /*Release mutex, done with shared resource*/
1094:                            osalError = OSAL_MUTEX_Unlock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP);
1095:                            if(osalError != OSAL_RESULT_TRUE)
1096:                            {
1097:                                /*Do not proceed unlock was not complete, or error occurred, let user know about error*/
1098:                                return (USB_DEVICE_CDC_RESULT_ERROR);
1099:                            }
1100:                
1101:                            return((USB_DEVICE_CDC_RESULT)irpError);
1102:                        }
1103:                    }
1104:                    
1105:                    /*Release mutex, done with shared resource*/
1106:                    osalError = OSAL_MUTEX_Unlock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP);
1107:                    if(osalError != OSAL_RESULT_TRUE)
1108:                    {
1109:                        /*Do not proceed unlock was not complete, or error occurred, let user know about error*/
1110:                        return (USB_DEVICE_CDC_RESULT_ERROR);
1111:                    }
1112:                    /* If here means we could not find a spare IRP */
1113:                    return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_QUEUE_FULL);
1114:                }
1115:                
1116:                USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_EventHandlerSet 
1117:                (
1118:                    USB_DEVICE_CDC_INDEX iCDC ,
1119:                    USB_DEVICE_CDC_EVENT_HANDLER eventHandler,
1120:                    uintptr_t userData
1121:                
1122:                )
1123:                {
1124:                    /* Check the validity of the function driver index */
1125:                    if (( iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER ) )
1126:                    {
1127:                        /* invalid CDC index */
1128:                        return USB_DEVICE_CDC_RESULT_ERROR_INSTANCE_INVALID;
1129:                    }
1130:                
1131:                    /* Check if the given event handler is valid */
1132:                    if ( eventHandler )
1133:                    {
1134:                        /* update the event handler for this instance */
1135:                        gUSBDeviceCDCInstance[iCDC].appEventCallBack = eventHandler;
1136:                        gUSBDeviceCDCInstance[iCDC].userData = userData;
1137:                
1138:                        /* return success */
1139:                        return USB_DEVICE_CDC_RESULT_OK;
1140:                    }
1141:                
1142:                    else
1143:                    {
1144:                        /* invalid event handler passed */
1145:                        return USB_DEVICE_CDC_RESULT_ERROR_PARAMETER_INVALID;
1146:                    }
1147:                }
1148:                
1149:                uint16_t USB_DEVICE_CDC_ReadPacketSizeGet ( USB_DEVICE_CDC_INDEX iCDC )
1150:                {
1151:                    /* check the validity of the function driver index */
1152:                    if ( ( iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER ) )
1153:                    {
1154:                        /* Invalid CDC index */
1155:                        SYS_ASSERT ( false , "Invalid CDC index" );
1156:                        return (0);
1157:                    }
1158:                
1159:                    /* max read packet size for this instance */
1160:                    return (gUSBDeviceCDCInstance[iCDC].dataInterface
1161:                            .endpoint[USB_DEVICE_CDC_ENDPOINT_RX].maxPacketSize );
1162:                
1163:                }
1164:                
1165:                // *****************************************************************************
1166:                /* Function:
1167:                    USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_EventHandlerSet 
1168:                    (
1169:                        USB_DEVICE_CDC_INDEX instance 
1170:                        USB_DEVICE_CDC_EVENT_HANDLER eventHandler 
1171:                        uintptr_t context
1172:                    );
1173:                
1174:                  Summary:
1175:                    This function registers a event handler for the specified CDC function
1176:                    driver instance. 
1177:                
1178:                  Description:
1179:                    This function registers a event handler for the specified CDC function
1180:                    driver instance. This function should be called by the client when it
1181:                    receives a SET CONFIGURATION event from the device layer. A event handler
1182:                    must be registered for function driver to respond to function driver
1183:                    specific commands. If the event handler is not registered, the device layer
1184:                    will stall function driver specific commands and the USB device may not
1185:                    function. 
1186:                
1187:                  Remarks:
1188:                    Refer to usb_device_cdc.h for usage information.
1189:                */
1190:                
1191:                
1192:                uint16_t USB_DEVICE_CDC_WritePacketSizeGet ( USB_DEVICE_CDC_INDEX iCDC )
1193:                {
1194:                    /* check the validity of the function driver index */
1195:                    if ( ( iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER ) )
1196:                    {
1197:                        /* Invalid CDC index */
1198:                        SYS_ASSERT ( false , "Invalid CDC index" );
1199:                        return (0);
1200:                    }
1201:                
1202:                    /* max read packet size for this instance */
1203:                    return (gUSBDeviceCDCInstance[iCDC].dataInterface.
1204:                            endpoint[USB_DEVICE_CDC_ENDPOINT_TX].maxPacketSize );
1205:                }
1206:                // *****************************************************************************
1207:                /* Function:
1208:                    USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_SerialStateNotificationSend
1209:                    (
1210:                        USB_DEVICE_CDC_INDEX instanceIndex,
1211:                        USB_DEVICE_CDC_TRANSFER_HANDLE * transferHandle,
1212:                        USB_DEVICE_CDC_SERIAL_STATE_NOTIFICATION * notificationData
1213:                    );
1214:                    
1215:                  Summary:
1216:                    This function schedules a request to send serial state notification to the host.
1217:                
1218:                  Description:
1219:                    This function places a request to send serial state notificatin data to the
1220:                    host. The function will place the request with the driver, the request will
1221:                    get serviced when the data is requested by the USB host.  A handle to the
1222:                    request is returned in the transferHandle parameter. The termination of the
1223:                    request is indicated by the
1224:                    USB_DEVICE_CDC_EVENT_SERIAL_STATE_NOTIFICATION_COMPLETE event. The amount of
1225:                    data transmitted and the transfer handle associated with the request is
1226:                    returned along with the event in the serialStateNotificationCompleteData
1227:                    member of pData paramter of the event handler. The transfer handle expires
1228:                    when the event handler for the
1229:                    USB_DEVICE_CDC_EVENT_SERIAL_STATE_NOTIFICATION_COMPLETE event exits. If the
1230:                    send request could not be accepted, the function returns an error code and
1231:                    transferHandle will contain the value
1232:                    USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID.
1233:                
1234:                  Remarks:
1235:                    Refer to usb_device_cdc.h for usage information.
1236:                */
1237:                
1238:                USB_DEVICE_CDC_RESULT USB_DEVICE_CDC_SerialStateNotificationSend 
1239:                (
1240:                    USB_DEVICE_CDC_INDEX iCDC ,
1241:                    USB_DEVICE_CDC_TRANSFER_HANDLE * transferHandle ,
1242:                    USB_CDC_SERIAL_STATE * notificationData 
1243:                )
1244:                {
1245:                    unsigned int cnt;
1246:                    USB_DEVICE_IRP * irp;
1247:                    USB_DEVICE_CDC_ENDPOINT * endpoint;
1248:                    USB_DEVICE_CDC_INSTANCE * thisCDCDevice;
1249:                    OSAL_RESULT osalError;
1250:                    USB_ERROR irpError;
1251:                    OSAL_CRITSECT_DATA_TYPE IntState;
1252:                	USB_CDC_SERIAL_STATE_RESPONSE * serialStateResponse; 
1253:                
1254:                    *transferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
1255:                
1256:                    /* Check the validity of the function driver index */
1257:                    
1258:                    if (  iCDC >= USB_DEVICE_CDC_INSTANCES_NUMBER  )
1259:                    {
1260:                        /* Invalid CDC index */
1261:                        SYS_ASSERT(false, "Invalid CDC Device Index");
1262:                        return USB_DEVICE_CDC_RESULT_ERROR_INSTANCE_INVALID;
1263:                    }
1264:                
1265:                    thisCDCDevice = &gUSBDeviceCDCInstance[iCDC];
1266:                    endpoint = &thisCDCDevice->notificationInterface.endpoint[USB_DEVICE_CDC_ENDPOINT_TX];
1267:                	
1268:                	serialStateResponse = thisCDCDevice->serialStateResponse; 
1269:                	
1270:                	/* Fill in the USB CDC Serial state buffer */ 
1271:                	
1272:                	/* bmRequestType = 10100001B (Direction = Device to Host, Request Type = Class, Recipient = Interface) */ 
1273:                	serialStateResponse->bmRequestType = 0xA1; 
1274:                	
1275:                	/* bRequest = SERIAL_STATE */ 
1276:                	serialStateResponse->bNotification = USB_CDC_NOTIFICATION_SERIAL_STATE; 
1277:                	
1278:                	/* wValue = Zero */ 
1279:                	serialStateResponse->wValue = 0; 
1280:                	
1281:                	/* Get the interface Number from the CDC instance */ 
1282:                	serialStateResponse->wIndex = (uint16_t)(thisCDCDevice->notificationInterface.interfaceNum); 
1283:                	
1284:                	/* Fill in the length */ 
1285:                	serialStateResponse->wLength = sizeof(USB_CDC_SERIAL_STATE);
1286:                	
1287:                	/* Copy Serial state data received from the client to the buffer */ 
1288:                	memcpy (&(serialStateResponse->stSerial), notificationData, sizeof(USB_CDC_SERIAL_STATE)); 
1289:                	
1290:                
1291:                    if(!(endpoint->isConfigured))
1292:                    {
1293:                        /* This means that the endpoint is not configured yet */
1294:                        SYS_ASSERT(false, "Endpoint not configured");
1295:                        return (USB_DEVICE_CDC_RESULT_ERROR_INSTANCE_NOT_CONFIGURED);
1296:                    }
1297:                
1298:                    if(thisCDCDevice->currentQSizeSerialStateNotification >=
1299:                            thisCDCDevice->queueSizeSerialStateNotification)
1300:                    {
1301:                        SYS_ASSERT(false, "Serial State Notification Send Queue is full");
1302:                        return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_QUEUE_FULL);
1303:                    }
1304:                
1305:                    /*Obtain mutex to get access to a shared resource, check return value*/
1306:                    osalError = OSAL_MUTEX_Lock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP, OSAL_WAIT_FOREVER);
1307:                    if(osalError != OSAL_RESULT_TRUE)
1308:                    {
1309:                      /*Do not proceed lock was not obtained, or error occurred, let user know about error*/
1310:                      return (USB_DEVICE_CDC_RESULT_ERROR);
1311:                    }
1312:                
1313:                    /* Loop and find a free IRP in the Q */
1314:                    for ( cnt = 0; cnt < USB_DEVICE_CDC_QUEUE_DEPTH_COMBINED; cnt ++ )
1315:                    {
1316:                        if(gUSBDeviceCDCIRP[cnt].status < (USB_DEVICE_IRP_STATUS)USB_DEVICE_IRP_FLAG_DATA_PENDING)
1317:                        {
1318:                            /* This means the IRP is free */
1319:                
1320:                            irp = &gUSBDeviceCDCIRP[cnt];
1321:                            irp->data = serialStateResponse;
1322:                            irp->size = sizeof(USB_CDC_SERIAL_STATE_RESPONSE);
1323:                            irp->userData = (uintptr_t) iCDC;
1324:                            irp->callback = _USB_DEVICE_CDC_SerialStateSendIRPCallback;
1325:                            irp->flags = USB_DEVICE_IRP_FLAG_DATA_COMPLETE;
1326:                            /* Prevent other tasks pre-empting this sequence of code */ 
1327:                            IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
1328:                            /* Update Serial State Notification Queue Size */ 
1329:                            thisCDCDevice->currentQSizeSerialStateNotification ++;
1330:                            OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, IntState);
1331:                            
1332:                            *transferHandle = (USB_DEVICE_CDC_TRANSFER_HANDLE) irp;
1333:                            irpError = USB_DEVICE_IRPSubmit(thisCDCDevice->deviceHandle, endpoint->address, irp);
1334:                            
1335:                            /* If IRP Submit function returned any error, then invalidate the
1336:                               Transfer handle.  */
1337:                            if (irpError != USB_ERROR_NONE )
1338:                            {
1339:                                /* Prevent other tasks pre-empting this sequence of code */ 
1340:                                IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
1341:                                /* Update Serial State Notification Queue Size */ 
1342:                                thisCDCDevice->currentQSizeSerialStateNotification --;
1343:                                OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, IntState);
1344:                                
1345:                                *transferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
1346:                            }
1347:                
1348:                            /*Release mutex, done with shared resource*/
1349:                            osalError = OSAL_MUTEX_Unlock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP);
1350:                            if(osalError != OSAL_RESULT_TRUE)
1351:                            {
1352:                                /*Do not proceed unlock was not complete, or error occurred, let user know about error*/
1353:                                return (USB_DEVICE_CDC_RESULT_ERROR);
1354:                            }
1355:                            
1356:                            return((USB_DEVICE_CDC_RESULT)irpError);
1357:                        }
1358:                    }
1359:                    
1360:                    /*Release mutex, done with shared resource*/
1361:                    osalError = OSAL_MUTEX_Unlock(&gUSBDeviceCdcCommonDataObj.mutexCDCIRP);
1362:                    if(osalError != OSAL_RESULT_TRUE)
1363:                    {
1364:                        /*Do not proceed unlock was not complete, or error occurred, let user know about error*/
1365:                        return (USB_DEVICE_CDC_RESULT_ERROR);
1366:                    }
1367:                    /* If here means we could not find a spare IRP */
1368:                    return(USB_DEVICE_CDC_RESULT_ERROR_TRANSFER_QUEUE_FULL);
1369:                }
1370:                
1371:                /*******************************************************************************
1372:                 End of File
1373:                 */
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
00000024  00000000   NOP
00000028  00000000   NOP
00000030  00000000   NOP
00000038  00000000   NOP
0000003C  00000000   NOP
00000040  00000000   NOP
00000044  00000000   NOP
0000004C  00000000   NOP
00000050  00000000   NOP
00000054  00000000   NOP
00000058  00000000   NOP
0000005C  00000000   NOP
00000060  00000000   NOP
00000064  00000000   NOP
0000006C  00000000   NOP
00000070  00000000   NOP
00000074  00000000   NOP
0000007C  00000000   NOP
00000080  00000000   NOP
00000084  00000000   NOP
00000088  00000000   NOP
00000090  00000000   NOP
00000094  00000000   NOP
0000009C  00000000   NOP
000000A0  00000000   NOP
000000BC  00000000   NOP
000000C4  00000000   NOP
000000C8  00000000   NOP
000000D4  00000000   NOP
000000D8  00000000   NOP
000000E4  00000000   NOP
000000F4  00000000   NOP
000000F8  00000000   NOP
000000FC  00000000   NOP
00000104  00000000   NOP
00000110  00000000   NOP
00000118  00000000   NOP
0000011C  00000000   NOP
00000130  00000000   NOP
00000134  00000000   NOP
00000138  00000000   NOP
00000144  00000000   NOP
0000014C  00000000   NOP
00000154  00000000   NOP
0000015C  00000000   NOP
00000164  00000000   NOP
0000016C  00000000   NOP
00000170  00000000   NOP
00000180  00000000   NOP
00000188  00000000   NOP
0000018C  00000000   NOP
00000194  00000000   NOP
0000019C  00000000   NOP
000001A4  00000000   NOP
000001AC  00000000   NOP
000001B4  00000000   NOP
000001BC  00000000   NOP
000001C0  00000000   NOP
000001C8  00000000   NOP
000001D0  00000000   NOP
000001D4  00000000   NOP
000001DC  00000000   NOP
000001E4  00000000   NOP
000001EC  00000000   NOP
000001F4  00000000   NOP
9D00B248  93828024   LBU V0, -32732(GP)
9D00B24C  14400002   BNE V0, ZERO, 0x9D00B258
9D00B250  24020101   ADDIU V0, ZERO, 257
9D00B254  A7828024   SH V0, -32732(GP)
9D00B258  03E00008   JR RA
9D00B25C  00000000   NOP
9D0121AC  27BDFFD8   ADDIU SP, SP, -40
9D0121B0  AFBF0024   SW RA, 36(SP)
9D0121B4  AFB30020   SW S3, 32(SP)
9D0121B8  AFB2001C   SW S2, 28(SP)
9D0121BC  AFB10018   SW S1, 24(SP)
9D0121C0  AFB00014   SW S0, 20(SP)
9D0121C4  1480006B   BNE A0, ZERO, 0x9D012374
9D0121C8  8FA20038   LW V0, 56(SP)
9D0121CC  3C13A000   LUI S3, -24576
9D0121D0  26702D18   ADDIU S0, S3, 11544
9D0121D4  92030010   LBU V1, 16(S0)
9D0121D8  00A09025   OR S2, A1, ZERO
9D0121DC  2405FFFF   ADDIU A1, ZERO, -1
9D0121E0  10600066   BEQ V1, ZERO, 0x9D01237C
9D0121E4  AE450000   SW A1, 0(S2)
9D0121E8  50E0000D   BEQL A3, ZERO, 0x9D012220
9D0121EC  2411FF82   ADDIU S1, ZERO, -126
9D0121F0  30430002   ANDI V1, V0, 2
9D0121F4  54600012   BNEL V1, ZERO, 0x9D012240
9D0121F8  9602000E   LHU V0, 14(S0)
9D0121FC  30430001   ANDI V1, V0, 1
9D012200  8E020034   LW V0, 52(S0)
9D012204  8E050028   LW A1, 40(S0)
9D012208  0045102B   SLTU V0, V0, A1
9D01220C  10400061   BEQ V0, ZERO, 0x9D012394
9D012210  93828025   LBU V0, -32731(GP)
9D012214  24050001   ADDIU A1, ZERO, 1
9D012220  8FBF0024   LW RA, 36(SP)
9D012224  02201025   OR V0, S1, ZERO
9D012228  8FB30020   LW S3, 32(SP)
9D01222C  8FB2001C   LW S2, 28(SP)
9D012230  8FB10018   LW S1, 24(SP)
9D012234  8FB00014   LW S0, 20(SP)
9D012238  03E00008   JR RA
9D01223C  27BD0028   ADDIU SP, SP, 40
9D012240  00E2182B   SLTU V1, A3, V0
9D012244  1460FFF6   BNE V1, ZERO, 0x9D012220
9D012248  2411FF82   ADDIU S1, ZERO, -126
9D01224C  00E2001B   DIVU A3, V0
9D012250  004001F4   TEQ V0, ZERO
9D012254  24030002   ADDIU V1, ZERO, 2
9D012258  00001010   MFHI V0
9D01225C  1000FFE8   BEQ ZERO, ZERO, 0x9D012200
9D012260  00E23823   SUBU A3, A3, V0
9D012264  3C05A000   LUI A1, -24576
9D01226C  8CA80008   LW T0, 8(A1)
9D012270  29080002   SLTI T0, T0, 2
9D012274  15000012   BNE T0, ZERO, 0x9D0122C0
9D012278  A3808025   SB ZERO, -32731(GP)
9D01227C  8CA4002C   LW A0, 44(A1)
9D012280  28840002   SLTI A0, A0, 2
9D012284  14800038   BNE A0, ZERO, 0x9D012368
9D012288  3C11A000   LUI S1, -24576
9D01228C  8CA40050   LW A0, 80(A1)
9D012290  28840002   SLTI A0, A0, 2
9D012294  1480003B   BNE A0, ZERO, 0x9D012384
9D012298  8FBF0024   LW RA, 36(SP)
9D01229C  2411FF80   ADDIU S1, ZERO, -128
9D0122A4  8FB30020   LW S3, 32(SP)
9D0122A8  02201025   OR V0, S1, ZERO
9D0122AC  8FB2001C   LW S2, 28(SP)
9D0122B0  8FB10018   LW S1, 24(SP)
9D0122B4  8FB00014   LW S0, 20(SP)
9D0122B8  03E00008   JR RA
9D0122BC  27BD0028   ADDIU SP, SP, 40
9D0122C0  00A08825   OR S1, A1, ZERO
9D0122C4  000410C0   SLL V0, A0, 3
9D0122C8  00441021   ADDU V0, V0, A0
9D0122CC  00021080   SLL V0, V0, 2
9D0122D0  00A22821   ADDU A1, A1, V0
9D0122D4  3C029D01   LUI V0, -25343
9D0122D8  24426B54   ADDIU V0, V0, 27476
9D0122DC  ACA60000   SW A2, 0(A1)
9D0122E0  ACA70004   SW A3, 4(A1)
9D0122E4  ACA30010   SW V1, 16(A1)
9D0122E8  ACA2000C   SW V0, 12(A1)
9D0122EC  0F402CEE   JAL SYS_INT_Disable
9D0122F4  8E030034   LW V1, 52(S0)
9D0122FC  24630001   ADDIU V1, V1, 1
9D012300  AE030034   SW V1, 52(S0)
9D012304  0F402CF6   JAL SYS_INT_Restore
9D01230C  AE510000   SW S1, 0(S2)
9D012310  9205000C   LBU A1, 12(S0)
9D012314  8E642D18   LW A0, 11544(S3)
9D012318  0F40621F   JAL USB_DEVICE_IRPSubmit
9D01231C  02203025   OR A2, S1, ZERO
9D012320  14400004   BNE V0, ZERO, USB_DEVICE_CDC_Write::OSAL_CRIT_Enter
9D012324  00408825   OR S1, V0, ZERO
9D012328  24020001   ADDIU V0, ZERO, 1
9D01232C  1000FFBC   BEQ ZERO, ZERO, 0x9D012220
9D012330  A3828025   SB V0, -32731(GP)
9D012334  0F402CEE   JAL SYS_INT_Disable
9D01233C  8E030034   LW V1, 52(S0)
9D012344  2463FFFF   ADDIU V1, V1, -1
9D012348  AE030034   SW V1, 52(S0)
9D01234C  0F402CF6   JAL SYS_INT_Restore
9D012354  2402FFFF   ADDIU V0, ZERO, -1
9D012358  AE420000   SW V0, 0(S2)
9D01235C  24020001   ADDIU V0, ZERO, 1
9D012360  1000FFAF   BEQ ZERO, ZERO, 0x9D012220
9D012368  263127AC   ADDIU S1, S1, 10156
9D01236C  1000FFD5   BEQ ZERO, ZERO, 0x9D0122C4
9D012370  24040001   ADDIU A0, ZERO, 1
9D012374  1000FFAA   BEQ ZERO, ZERO, 0x9D012220
9D012378  2411FF88   ADDIU S1, ZERO, -120
9D01237C  1000FFA8   BEQ ZERO, ZERO, 0x9D012220
9D012380  2411FF8A   ADDIU S1, ZERO, -118
9D012384  3C11A000   LUI S1, -24576
9D012388  263127D0   ADDIU S1, S1, 10192
9D01238C  1000FFCD   BEQ ZERO, ZERO, 0x9D0122C4
9D012390  24040002   ADDIU A0, ZERO, 2
9D012394  1000FFA2   BEQ ZERO, ZERO, 0x9D012220
9D012398  2411FF80   ADDIU S1, ZERO, -128
9D012938  27BDFFD8   ADDIU SP, SP, -40
9D01293C  AFBF0024   SW RA, 36(SP)
9D012940  AFB30020   SW S3, 32(SP)
9D012944  AFB2001C   SW S2, 28(SP)
9D012948  AFB10018   SW S1, 24(SP)
9D01294C  14800065   BNE A0, ZERO, 0x9D012AE4
9D012950  AFB00014   SW S0, 20(SP)
9D012954  3C12A000   LUI S2, -24576
9D012958  26502D18   ADDIU S0, S2, 11544
9D01295C  9202000A   LBU V0, 10(S0)
9D012960  2403FFFF   ADDIU V1, ZERO, -1
9D012964  10400061   BEQ V0, ZERO, 0x9D012AEC
9D012968  ACA30000   SW V1, 0(A1)
9D01296C  96020008   LHU V0, 8(S0)
9D012970  00E2001B   DIVU A3, V0
9D012974  004001F4   TEQ V0, ZERO
9D012978  00001010   MFHI V0
9D01297C  10E0002A   BEQ A3, ZERO, 0x9D012A28
9D012980  00402025   OR A0, V0, ZERO
9D012984  54400009   BNEL V0, ZERO, 0x9D0129AC
9D012988  2411FF82   ADDIU S1, ZERO, -126
9D01298C  8E020038   LW V0, 56(S0)
9D012990  8E03002C   LW V1, 44(S0)
9D012994  0043102B   SLTU V0, V0, V1
9D012998  1040005A   BEQ V0, ZERO, 0x9D012B04
9D01299C  93828025   LBU V0, -32731(GP)
9D0129A0  24030001   ADDIU V1, ZERO, 1
9D0129A4  10430009   BEQ V0, V1, 0x9D0129CC
9D0129A8  2411FFA0   ADDIU S1, ZERO, -96
9D0129AC  8FBF0024   LW RA, 36(SP)
9D0129B0  02201025   OR V0, S1, ZERO
9D0129B4  8FB30020   LW S3, 32(SP)
9D0129B8  8FB2001C   LW S2, 28(SP)
9D0129BC  8FB10018   LW S1, 24(SP)
9D0129C0  8FB00014   LW S0, 20(SP)
9D0129C4  03E00008   JR RA
9D0129C8  27BD0028   ADDIU SP, SP, 40
9D0129CC  3C03A000   LUI V1, -24576
9D0129D4  8C680008   LW T0, 8(V1)
9D0129D8  29080002   SLTI T0, T0, 2
9D0129E4  8C64002C   LW A0, 44(V1)
9D0129E8  28840002   SLTI A0, A0, 2
9D0129EC  1480003A   BNE A0, ZERO, 0x9D012AD8
9D0129F0  3C11A000   LUI S1, -24576
9D0129F4  8C640050   LW A0, 80(V1)
9D0129F8  28840002   SLTI A0, A0, 2
9D0129FC  1480003D   BNE A0, ZERO, 0x9D012AF4
9D012A00  8FBF0024   LW RA, 36(SP)
9D012A04  2411FF80   ADDIU S1, ZERO, -128
9D012A0C  8FB30020   LW S3, 32(SP)
9D012A10  02201025   OR V0, S1, ZERO
9D012A14  8FB2001C   LW S2, 28(SP)
9D012A18  8FB10018   LW S1, 24(SP)
9D012A1C  8FB00014   LW S0, 20(SP)
9D012A20  03E00008   JR RA
9D012A24  27BD0028   ADDIU SP, SP, 40
9D012A28  1000FFE0   BEQ ZERO, ZERO, 0x9D0129AC
9D012A2C  2411FF82   ADDIU S1, ZERO, -126
9D012A30  00608825   OR S1, V1, ZERO
9D012A34  00A09825   OR S3, A1, ZERO
9D012A38  000428C0   SLL A1, A0, 3
9D012A3C  00A42021   ADDU A0, A1, A0
9D012A40  00042080   SLL A0, A0, 2
9D012A44  3C029D01   LUI V0, -25343
9D012A48  00641821   ADDU V1, V1, A0
9D012A4C  24426AAC   ADDIU V0, V0, 27308
9D012A50  AC660000   SW A2, 0(V1)
9D012A54  AC670004   SW A3, 4(V1)
9D012A58  AC62000C   SW V0, 12(V1)
9D012A5C  0F402CEE   JAL SYS_INT_Disable
9D012A64  8E030038   LW V1, 56(S0)
9D012A6C  24630001   ADDIU V1, V1, 1
9D012A70  AE030038   SW V1, 56(S0)
9D012A74  0F402CF6   JAL SYS_INT_Restore
9D012A7C  AE710000   SW S1, 0(S3)
9D012A80  92050006   LBU A1, 6(S0)
9D012A84  8E442D18   LW A0, 11544(S2)
9D012A88  0F40621F   JAL USB_DEVICE_IRPSubmit
9D012A8C  02203025   OR A2, S1, ZERO
9D012A90  14400004   BNE V0, ZERO, USB_DEVICE_CDC_Read::OSAL_CRIT_Enter
9D012A94  00408825   OR S1, V0, ZERO
9D012A98  24020001   ADDIU V0, ZERO, 1
9D012A9C  1000FFC3   BEQ ZERO, ZERO, 0x9D0129AC
9D012AA4  0F402CEE   JAL SYS_INT_Disable
9D012AAC  8E030038   LW V1, 56(S0)
9D012AB4  2463FFFF   ADDIU V1, V1, -1
9D012AB8  AE030038   SW V1, 56(S0)
9D012ABC  0F402CF6   JAL SYS_INT_Restore
9D012AC4  2402FFFF   ADDIU V0, ZERO, -1
9D012AC8  AE620000   SW V0, 0(S3)
9D012ACC  24020001   ADDIU V0, ZERO, 1
9D012AD0  1000FFB6   BEQ ZERO, ZERO, 0x9D0129AC
9D012AD4  A3828025   SB V0, -32731(GP)
9D012AD8  263127AC   ADDIU S1, S1, 10156
9D012ADC  1000FFD5   BEQ ZERO, ZERO, 0x9D012A34
9D012AE0  24040001   ADDIU A0, ZERO, 1
9D012AE4  1000FFB1   BEQ ZERO, ZERO, 0x9D0129AC
9D012AE8  2411FF88   ADDIU S1, ZERO, -120
9D012AEC  1000FFAF   BEQ ZERO, ZERO, 0x9D0129AC
9D012AF0  2411FF8A   ADDIU S1, ZERO, -118
9D012AF4  3C11A000   LUI S1, -24576
9D012AF8  263127D0   ADDIU S1, S1, 10192
9D012AFC  1000FFCD   BEQ ZERO, ZERO, 0x9D012A34
9D012B00  24040002   ADDIU A0, ZERO, 2
9D012B04  1000FFA9   BEQ ZERO, ZERO, 0x9D0129AC
9D012B08  2411FF80   ADDIU S1, ZERO, -128
9D013B50  27BDFFE0   ADDIU SP, SP, -32
9D013B54  AFBF001C   SW RA, 28(SP)
9D013B58  AFB00018   SW S0, 24(SP)
9D013B5C  93A80034   LBU T0, 52(SP)
9D013B60  14800014   BNE A0, ZERO, _USB_DEVICE_CDC_Initialization
9D013B64  8FA90038   LW T1, 56(SP)
9D013B68  8CC30008   LW V1, 8(A2)
9D013B6C  3C04A000   LUI A0, -24576
9D013B70  8CCB0004   LW T3, 4(A2)
9D013B74  8CCA0000   LW T2, 0(A2)
9D013B78  24822D18   ADDIU V0, A0, 11544
9D013B7C  AC430030   SW V1, 48(V0)
9D013B80  3C03A000   LUI V1, -24576
9D013B84  246327F4   ADDIU V1, V1, 10228
9D013B88  24060004   ADDIU A2, ZERO, 4
9D013B8C  AC400034   SW ZERO, 52(V0)
9D013B90  AC4B0028   SW T3, 40(V0)
9D013B94  AC400038   SW ZERO, 56(V0)
9D013B98  AC4A002C   SW T2, 44(V0)
9D013B9C  AC40003C   SW ZERO, 60(V0)
9D013BA0  11060016   BEQ T0, A2, _USB_DEVICE_CDC_Initialization
9D013BA4  AC430040   SW V1, 64(V0)
9D013BA8  24030005   ADDIU V1, ZERO, 5
9D013BAC  51030005   BEQL T0, V1, _USB_DEVICE_CDC_Initialization::_USB_DEVICE_CDC_Initialization
9D013BB0  91230003   LBU V1, 3(T1)
9D013BB4  8FBF001C   LW RA, 28(SP)
9D013BB8  8FB00018   LW S0, 24(SP)
9D013BBC  03E00008   JR RA
9D013BC0  27BD0020   ADDIU SP, SP, 32
9D013BC4  91260002   LBU A2, 2(T1)
9D013BC8  24070002   ADDIU A3, ZERO, 2
9D013BCC  30630003   ANDI V1, V1, 3
9D013BD0  10670018   BEQ V1, A3, _USB_DEVICE_CDC_Initialization::_USB_DEVICE_CDC_Initialization
9D013BD4  000621C2   SRL A0, A2, 7
9D013BD8  24070003   ADDIU A3, ZERO, 3
9D013BDC  1467FFF6   BNE V1, A3, _USB_DEVICE_CDC_Initialization
9D013BE0  8FBF001C   LW RA, 28(SP)
9D013BE4  00048040   SLL S0, A0, 1
9D013BE8  02048021   ADDU S0, S0, A0
9D013BEC  00108040   SLL S0, S0, 1
9D013BF0  26100014   ADDIU S0, S0, 20
9D013BF4  10000014   BEQ ZERO, ZERO, _USB_DEVICE_CDC_Initialization
9D013BF8  00508021   ADDU S0, V0, S0
9D013BFC  91230005   LBU V1, 5(T1)
9D013C00  24060002   ADDIU A2, ZERO, 2
9D013C04  10660006   BEQ V1, A2, _USB_DEVICE_CDC_Initialization
9D013C08  AC852D18   SW A1, 11544(A0)
9D013C0C  2404000A   ADDIU A0, ZERO, 10
9D013C10  5064FFE8   BEQL V1, A0, _USB_DEVICE_CDC_Initialization
9D013C14  A0470004   SB A3, 4(V0)
9D013C18  1000FFE7   BEQ ZERO, ZERO, _USB_DEVICE_CDC_Initialization
9D013C1C  8FBF001C   LW RA, 28(SP)
9D013C20  91240006   LBU A0, 6(T1)
9D013C24  5083FFE3   BEQL A0, V1, _USB_DEVICE_CDC_Initialization
9D013C28  A0470012   SB A3, 18(V0)
9D013C2C  1000FFE2   BEQ ZERO, ZERO, _USB_DEVICE_CDC_Initialization
9D013C30  8FBF001C   LW RA, 28(SP)
9D013C34  24840001   ADDIU A0, A0, 1
9D013C38  00048040   SLL S0, A0, 1
9D013C3C  02042021   ADDU A0, S0, A0
9D013C40  00048040   SLL S0, A0, 1
9D013C44  00508021   ADDU S0, V0, S0
9D013C48  91220005   LBU V0, 5(T1)
9D013C4C  91230004   LBU V1, 4(T1)
9D013C50  A2060000   SB A2, 0(S0)
9D013C54  91270003   LBU A3, 3(T1)
9D013C58  00021200   SLL V0, V0, 8
9D013C5C  00431025   OR V0, V0, V1
9D013C60  AFA20010   SW V0, 16(SP)
9D013C64  00A02025   OR A0, A1, ZERO
9D013C68  A6020002   SH V0, 2(S0)
9D013C6C  30E70003   ANDI A3, A3, 3
9D013C70  0F406155   JAL USB_DEVICE_EndpointEnable
9D013C74  00002825   OR A1, ZERO, ZERO
9D013C78  8FBF001C   LW RA, 28(SP)
9D013C7C  24020001   ADDIU V0, ZERO, 1
9D013C80  A2020004   SB V0, 4(S0)
9D013C84  8FB00018   LW S0, 24(SP)
9D013C88  03E00008   JR RA
9D013C8C  27BD0020   ADDIU SP, SP, 32
9D0158F0  14800038   BNE A0, ZERO, _USB_DEVICE_CDC_Deinitialization
9D0158F4  00000000   NOP
9D0158F8  27BDFFE0   ADDIU SP, SP, -32
9D0158FC  3C02A000   LUI V0, -24576
9D015900  AFB00014   SW S0, 20(SP)
9D015904  24502D18   ADDIU S0, V0, 11544
9D015908  9203000A   LBU V1, 10(S0)
9D01590C  AFB10018   SW S1, 24(SP)
9D015910  AFBF001C   SW RA, 28(SP)
9D015914  14600026   BNE V1, ZERO, _USB_DEVICE_CDC_Deinitialization::_USB_DEVICE_CDC_Deinitialization
9D015918  8C512D18   LW S1, 11544(V0)
9D01591C  92020010   LBU V0, 16(S0)
9D015920  1440001B   BNE V0, ZERO, _USB_DEVICE_CDC_Deinitialization::_USB_DEVICE_CDC_Deinitialization
9D015924  3C05A000   LUI A1, -24576
9D015928  92020018   LBU V0, 24(S0)
9D01592C  14400010   BNE V0, ZERO, _USB_DEVICE_CDC_EndpointDisable
9D015930  3C05A000   LUI A1, -24576
9D015934  9202001E   LBU V0, 30(S0)
9D015938  14400006   BNE V0, ZERO, _USB_DEVICE_CDC_Deinitialization
9D01593C  02202025   OR A0, S1, ZERO
9D015940  8FBF001C   LW RA, 28(SP)
9D015944  8FB10018   LW S1, 24(SP)
9D015948  8FB00014   LW S0, 20(SP)
9D01594C  03E00008   JR RA
9D015950  27BD0020   ADDIU SP, SP, 32
9D015954  8FBF001C   LW RA, 28(SP)
9D015958  8FB10018   LW S1, 24(SP)
9D01595C  8FB00014   LW S0, 20(SP)
9D015960  3C05A000   LUI A1, -24576
9D015964  24A52D32   ADDIU A1, A1, 11570
9D015968  0B406102   J _USB_DEVICE_CDC_EndpointDisable
9D01596C  27BD0020   ADDIU SP, SP, 32
9D015970  24A52D2C   ADDIU A1, A1, 11564
9D015974  0F406102   JAL _USB_DEVICE_CDC_EndpointDisable
9D015978  02202025   OR A0, S1, ZERO
9D01597C  9202001E   LBU V0, 30(S0)
9D015980  1040FFF0   BEQ V0, ZERO, _USB_DEVICE_CDC_Deinitialization
9D015984  8FBF001C   LW RA, 28(SP)
9D015988  1000FFF3   BEQ ZERO, ZERO, _USB_DEVICE_CDC_Deinitialization
9D01598C  02202025   OR A0, S1, ZERO
9D015990  24A52D24   ADDIU A1, A1, 11556
9D015994  0F406102   JAL _USB_DEVICE_CDC_EndpointDisable
9D015998  02202025   OR A0, S1, ZERO
9D01599C  92020018   LBU V0, 24(S0)
9D0159A0  5040FFE5   BEQL V0, ZERO, _USB_DEVICE_CDC_Deinitialization
9D0159A4  9202001E   LBU V0, 30(S0)
9D0159A8  1000FFF1   BEQ ZERO, ZERO, _USB_DEVICE_CDC_EndpointDisable
9D0159AC  3C05A000   LUI A1, -24576
9D0159B0  3C05A000   LUI A1, -24576
9D0159B4  24A52D1E   ADDIU A1, A1, 11550
9D0159B8  0F406102   JAL _USB_DEVICE_CDC_EndpointDisable
9D0159BC  02202025   OR A0, S1, ZERO
9D0159C0  92020010   LBU V0, 16(S0)
9D0159C4  5040FFD9   BEQL V0, ZERO, _USB_DEVICE_CDC_Deinitialization
9D0159C8  92020018   LBU V0, 24(S0)
9D0159CC  1000FFF0   BEQ ZERO, ZERO, _USB_DEVICE_CDC_Deinitialization::_USB_DEVICE_CDC_Deinitialization
9D0159D0  3C05A000   LUI A1, -24576
9D0159D4  03E00008   JR RA
9D0159D8  00000000   NOP
9D016AAC  8C820008   LW V0, 8(A0)
9D016AB0  8C850004   LW A1, 4(A0)
9D016AB4  27BDFFD8   ADDIU SP, SP, -40
9D016AB8  2C430002   SLTIU V1, V0, 2
9D016ABC  AFBF0024   SW RA, 36(SP)
9D016AC0  8C880014   LW T0, 20(A0)
9D016AC4  AFA40010   SW A0, 16(SP)
9D016AC8  1460001D   BNE V1, ZERO, 0x9D016B40
9D016ACC  AFA50014   SW A1, 20(SP)
9D016AD0  2403FFFD   ADDIU V1, ZERO, -3
9D016AD4  10430017   BEQ V0, V1, 0x9D016B34
9D016AD8  2403FFFC   ADDIU V1, ZERO, -4
9D016ADC  1043001A   BEQ V0, V1, 0x9D016B48
9D016AE0  2402FFA0   ADDIU V0, ZERO, -96
9D016AE4  AFA20018   SW V0, 24(SP)
9D016AE8  00081100   SLL V0, T0, 4
9D016AEC  00481021   ADDU V0, V0, T0
9D016AF0  3C03A000   LUI V1, -24576
9D016AF4  24632D18   ADDIU V1, V1, 11544
9D016AF8  00021080   SLL V0, V0, 2
9D016AFC  00431021   ADDU V0, V0, V1
9D016B00  8C430038   LW V1, 56(V0)
9D016B04  8C490020   LW T1, 32(V0)
9D016B08  2463FFFF   ADDIU V1, V1, -1
9D016B0C  AC430038   SW V1, 56(V0)
9D016B10  11200005   BEQ T1, ZERO, 0x9D016B28
9D016B14  27A60010   ADDIU A2, SP, 16
9D016B18  8C470024   LW A3, 36(V0)
9D016B1C  24050005   ADDIU A1, ZERO, 5
9D016B20  0120F809   JALR T1
9D016B24  01002025   OR A0, T0, ZERO
9D016B28  8FBF0024   LW RA, 36(SP)
9D016B2C  03E00008   JR RA
9D016B30  27BD0028   ADDIU SP, SP, 40
9D016B34  2402FF9E   ADDIU V0, ZERO, -98
9D016B38  1000FFEB   BEQ ZERO, ZERO, 0x9D016AE8
9D016B3C  AFA20018   SW V0, 24(SP)
9D016B40  1000FFE9   BEQ ZERO, ZERO, 0x9D016AE8
9D016B44  AFA00018   SW ZERO, 24(SP)
9D016B48  2402FF9F   ADDIU V0, ZERO, -97
9D016B4C  1000FFE6   BEQ ZERO, ZERO, 0x9D016AE8
9D016B50  AFA20018   SW V0, 24(SP)
9D016B54  8C820008   LW V0, 8(A0)
9D016B58  8C850004   LW A1, 4(A0)
9D016B5C  27BDFFD8   ADDIU SP, SP, -40
9D016B60  2C430002   SLTIU V1, V0, 2
9D016B64  AFBF0024   SW RA, 36(SP)
9D016B68  8C880014   LW T0, 20(A0)
9D016B6C  AFA40010   SW A0, 16(SP)
9D016B70  1460001D   BNE V1, ZERO, 0x9D016BE8
9D016B74  AFA50014   SW A1, 20(SP)
9D016B78  2403FFFD   ADDIU V1, ZERO, -3
9D016B7C  10430017   BEQ V0, V1, 0x9D016BDC
9D016B80  2403FFFC   ADDIU V1, ZERO, -4
9D016B84  1043001A   BEQ V0, V1, 0x9D016BF0
9D016B88  2402FFA0   ADDIU V0, ZERO, -96
9D016B8C  AFA20018   SW V0, 24(SP)
9D016B90  00081900   SLL V1, T0, 4
9D016B94  00681821   ADDU V1, V1, T0
9D016B98  3C02A000   LUI V0, -24576
9D016B9C  00031880   SLL V1, V1, 2
9D016BA0  24422D18   ADDIU V0, V0, 11544
9D016BA4  00431021   ADDU V0, V0, V1
9D016BA8  8C430034   LW V1, 52(V0)
9D016BAC  8C490020   LW T1, 32(V0)
9D016BB0  2463FFFF   ADDIU V1, V1, -1
9D016BB4  AC430034   SW V1, 52(V0)
9D016BB8  11200005   BEQ T1, ZERO, 0x9D016BD0
9D016BBC  27A60010   ADDIU A2, SP, 16
9D016BC0  8C470024   LW A3, 36(V0)
9D016BC4  24050004   ADDIU A1, ZERO, 4
9D016BC8  0120F809   JALR T1
9D016BCC  01002025   OR A0, T0, ZERO
9D016BD0  8FBF0024   LW RA, 36(SP)
9D016BD4  03E00008   JR RA
9D016BD8  27BD0028   ADDIU SP, SP, 40
9D016BDC  2402FF9E   ADDIU V0, ZERO, -98
9D016BE0  1000FFEB   BEQ ZERO, ZERO, 0x9D016B90
9D016BE4  AFA20018   SW V0, 24(SP)
9D016BE8  1000FFE9   BEQ ZERO, ZERO, 0x9D016B90
9D016BEC  AFA00018   SW ZERO, 24(SP)
9D016BF0  2402FF9F   ADDIU V0, ZERO, -97
9D016BF4  1000FFE6   BEQ ZERO, ZERO, 0x9D016B90
9D016BF8  AFA20018   SW V0, 24(SP)
9D016BFC  14800007   BNE A0, ZERO, _USB_DEVICE_CDC_ControlTransferHandler
9D016C00  2402000E   ADDIU V0, ZERO, 14
9D016C04  10A20016   BEQ A1, V0, _USB_DEVICE_CDC_ControlTransferHandler
9D016C08  2402000F   ADDIU V0, ZERO, 15
9D016C0C  10A2000C   BEQ A1, V0, _USB_DEVICE_CDC_ControlTransferHandler
9D016C10  2402000D   ADDIU V0, ZERO, 13
9D016C14  10A20003   BEQ A1, V0, _USB_DEVICE_CDC_ControlTransferHandler::_USB_DEVICE_CDC_ControlTransferHandler
9D016C18  3C02A000   LUI V0, -24576
9D016C1C  03E00008   JR RA
9D016C20  00000000   NOP
9D016C24  24422D18   ADDIU V0, V0, 11544
9D016C28  8C590020   LW T9, 32(V0)
9D016C2C  1320FFFB   BEQ T9, ZERO, _USB_DEVICE_CDC_ControlTransferHandler
9D016C30  00003025   OR A2, ZERO, ZERO
9D016C34  8C470024   LW A3, 36(V0)
9D016C38  03200008   JR T9
9D016C3C  24050008   ADDIU A1, ZERO, 8
9D016C40  3C02A000   LUI V0, -24576
9D016C44  24422D18   ADDIU V0, V0, 11544
9D016C48  8C590020   LW T9, 32(V0)
9D016C4C  1320FFF3   BEQ T9, ZERO, _USB_DEVICE_CDC_ControlTransferHandler
9D016C50  00003025   OR A2, ZERO, ZERO
9D016C54  8C470024   LW A3, 36(V0)
9D016C58  03200008   JR T9
9D016C5C  24050007   ADDIU A1, ZERO, 7
9D016C60  90C20000   LBU V0, 0(A2)
9D016C64  3C05A000   LUI A1, -24576
9D016C68  30420020   ANDI V0, V0, 32
9D016C6C  10400008   BEQ V0, ZERO, _USB_DEVICE_CDC_ControlTransferHandler
9D016C70  8CA42D18   LW A0, 11544(A1)
9D016C74  90C20001   LBU V0, 1(A2)
9D016C78  2C430002   SLTIU V1, V0, 2
9D016C7C  14600006   BNE V1, ZERO, _USB_DEVICE_CDC_ControlTransferHandler
9D016C80  2442FFE0   ADDIU V0, V0, -32
9D016C84  2C420004   SLTIU V0, V0, 4
9D016C88  14400004   BNE V0, ZERO, _USB_DEVICE_CDC_ControlTransferHandler
9D016C8C  24A52D18   ADDIU A1, A1, 11544
9D016C90  0B405CF7   J USB_DEVICE_ControlStatus
9D016C94  24050001   ADDIU A1, ZERO, 1
9D016C98  24A52D18   ADDIU A1, A1, 11544
9D016C9C  0B405BD1   J _USB_DEVICE_CDC_ACMSetUpPacketHandler
9D016CA0  00002025   OR A0, ZERO, ZERO
9D016CA4  2482FFFF   ADDIU V0, A0, -1
9D018408  27BDFFE0   ADDIU SP, SP, -32
9D018418  00A08025   OR S0, A1, ZERO
9D01841C  90A50000   LBU A1, 0(A1)
9D018420  0F40622C   JAL USB_DEVICE_IRPCancelAll
9D018424  00808825   OR S1, A0, ZERO
9D018428  92050000   LBU A1, 0(S0)
9D01842C  0F406212   JAL USB_DEVICE_EndpointDisable
9D018430  02202025   OR A0, S1, ZERO
9D018434  8FBF001C   LW RA, 28(SP)
9D018438  A2000004   SB ZERO, 4(S0)
9D01843C  8FB10018   LW S1, 24(SP)
9D018440  8FB00014   LW S0, 20(SP)
9D018444  03E00008   JR RA
9D018448  27BD0020   ADDIU SP, SP, 32
9D018738  14800009   BNE A0, ZERO, 0x9D018760
9D01873C  00000000   NOP
9D018740  10A00009   BEQ A1, ZERO, 0x9D018768
9D018744  00000000   NOP
9D018748  3C02A000   LUI V0, -24576
9D01874C  24422D18   ADDIU V0, V0, 11544
9D018750  AC450020   SW A1, 32(V0)
9D018754  AC460024   SW A2, 36(V0)
9D018758  03E00008   JR RA
9D01875C  00001025   OR V0, ZERO, ZERO
9D018760  03E00008   JR RA
9D018764  2402FF88   ADDIU V0, ZERO, -120
9D018768  03E00008   JR RA
9D01876C  2402FF83   ADDIU V0, ZERO, -125
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/usb/src/usb_device.c  ----------------------
1:                   /**************************************************************************
2:                    USB Device Layer Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                       
7:                     File Name:
8:                       usb_device.c
9:                       
10:                    Summary:
11:                      This file contains implementations of both private and public functions
12:                      of the USB Device Layer.
13:                      
14:                    Description:
15:                      This file contains the USB device layer implementation.
16:                  **************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
21:                  *
22:                  * Subject to your compliance with these terms, you may use Microchip software
23:                  * and any derivatives exclusively with Microchip products. It is your
24:                  * responsibility to comply with third party license terms applicable to your
25:                  * use of third party software (including open source software) that may
26:                  * accompany Microchip software.
27:                  *
28:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                  * PARTICULAR PURPOSE.
32:                  *
33:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                   *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  #include <stdlib.h>
44:                  #include <stdint.h>
45:                  #include <stdbool.h>
46:                  
47:                  #include "usb/src/usb_external_dependencies.h"
48:                  #include "usb/usb_common.h"
49:                  #include "usb/usb_chapter_9.h"
50:                  #include "usb/usb_device.h"
51:                  #include "usb/src/usb_device_function_driver.h"
52:                  
53:                  
54:                  #include "usb/src/usb_device_local.h"
55:                  #include "driver/usb/drv_usb.h"
56:                  
57:                  /**********************************
58:                   * Device layer instance objects.
59:                   *********************************/
60:                  static USB_DEVICE_OBJ usbDeviceInstance[USB_DEVICE_INSTANCES_NUMBER];
61:                  
62:                  /*************************************
63:                   * Device layer endpoint constants. 
64:                   *************************************/
65:                  static const USB_ENDPOINT controlEndpointTx = 0x80;
66:                  static const USB_ENDPOINT controlEndpointRx  = 0x00;
67:                  
68:                  // *****************************************************************************
69:                  // *****************************************************************************
70:                  // Section: USB Device Layer System Interface functions.
71:                  // *****************************************************************************
72:                  // *****************************************************************************
73:                  
74:                  // ******************************************************************************
75:                  /* Function:
76:                      SYS_MODULE_OBJ USB_DEVICE_Initialize
77:                      (
78:                          const SYS_MODULE_INDEX index, 
79:                          const SYS_MODULE_INIT * const initData
80:                      )
81:                  
82:                    Summary:
83:                      Initializes the required USB device layer state machines.
84:                  
85:                    Description:
86:                      This function initializes the required state machines of the USB device
87:                      layer.
88:                  
89:                    Remarks:
90:                      Refer to usb_device.h for usage information.
91:                  */
92:                  
93:                  SYS_MODULE_OBJ USB_DEVICE_Initialize
94:                  (
95:                      const SYS_MODULE_INDEX index, 
96:                      const SYS_MODULE_INIT * const initData
97:                  )
98:                  {
99:                      USB_DEVICE_INIT *deviceInit;
100:                     USB_DEVICE_OBJ* usbDeviceThisInstance;
101:                     USB_DEVICE_IRP * irpEp0Rx;
102:                     USB_DEVICE_IRP * irpEp0Tx;
103:                     uint8_t count;
104:                     USB_DEVICE_FUNCTION_DRIVER * driver;
105:                     USB_DEVICE_FUNCTION_REGISTRATION_TABLE * funcRegTable;
106:                          
107:                     /* Copy init data to local variable. */
108:                     deviceInit = (USB_DEVICE_INIT *)initData;
109:                     
110:                     /* Make sure the index is with in range. */
111:                     if(index >= USB_DEVICE_INSTANCES_NUMBER)
112:                     {
113:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid index value");
114:                         return (SYS_MODULE_OBJ_INVALID);
115:                     }
116:                     
117:                     /* Make sure that initData is not NULL. */
118:                     if(deviceInit == NULL)
119:                     {
120:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Initialization data is NULL");
121:                         return (SYS_MODULE_OBJ_INVALID);
122:                     }
123:                     
124:                     /* Make sure that the USB Device Master Descriptor is valid */
125:                     if(deviceInit->usbMasterDescriptor == NULL)
126:                     {
127:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: USB Master Descriptor table is NULL");
128:                         return (SYS_MODULE_OBJ_INVALID);
129:                     }
130:                     
131:                     /* Get this instance of USB device layer. */
132:                     usbDeviceThisInstance = &usbDeviceInstance[index];
133:                 
134:                     /* Initialize this instance */        
135:                     usbDeviceThisInstance->usbDeviceInstanceState = SYS_STATUS_BUSY;
136:                 
137:                     /* Save the "self" index for future use */    
138:                     usbDeviceThisInstance->usbDevLayerIndex = index;
139:                     
140:                     /* Set the device state to detached.*/
141:                     usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_DETACHED;
142:                     
143:                     /* Initialize the instance structure. */
144:                     usbDeviceThisInstance->ptrMasterDescTable           = deviceInit->usbMasterDescriptor;
145:                     usbDeviceThisInstance->registeredFuncDriverCount    = deviceInit->registeredFuncCount;
146:                     usbDeviceThisInstance->registeredFuncDrivers        = deviceInit->registeredFunctions;
147:                     
148:                     /* Get the user configured speed */
149:                     usbDeviceThisInstance->usbDeviceStatusStruct.usbConfiguredSpeed = deviceInit->deviceSpeed; 
150:                 
151:                     /* Initialize remote wakeup to disabled */
152:                     usbDeviceThisInstance->remoteWakeupStatus = USB_DEVICE_REMOTE_WAKEUP_DISABLED;
153:                 
154:                     /* Initialize power source to bus power */
155:                     usbDeviceThisInstance->usbDeviceStatusStruct.powerState = USB_DEVICE_POWER_STATE_BUS_POWERED;
156:                     
157:                     /* Reset set address flag.*/
158:                     usbDeviceThisInstance->usbDeviceStatusStruct.setAddressPending = false;
159:                     
160:                     /* Reset Test mode flag.*/
161:                     usbDeviceThisInstance->usbDeviceStatusStruct.testModePending = false;
162:                     
163:                     /* Initialize the RX IRP */
164:                     irpEp0Rx            = &usbDeviceThisInstance->irpEp0Rx;
165:                     irpEp0Rx->data      = usbDeviceThisInstance->ep0RxBuffer;
166:                     irpEp0Rx->size      = USB_DEVICE_EP0_BUFFER_SIZE;
167:                     irpEp0Rx->flags     = USB_DEVICE_IRP_FLAG_DATA_COMPLETE;
168:                     irpEp0Rx->status    = USB_DEVICE_IRP_STATUS_COMPLETED;
169:                     irpEp0Rx->callback  = &_USB_DEVICE_Ep0ReceiveCompleteCallback;
170:                     irpEp0Rx->userData  = (uintptr_t)usbDeviceThisInstance;
171:                 
172:                     /* Initialize the TX IRP */
173:                     irpEp0Tx            = &usbDeviceThisInstance->irpEp0Tx;
174:                     irpEp0Tx->callback  = &_USB_DEVICE_Ep0TransmitCompleteCallback;
175:                     irpEp0Tx->userData  = (uintptr_t)usbDeviceThisInstance;
176:                     irpEp0Tx->flags     = USB_DEVICE_IRP_FLAG_DATA_COMPLETE;
177:                 
178:                     /* Device is not suspended */
179:                     usbDeviceThisInstance->usbDeviceStatusStruct.isSuspended = false;
180:                 
181:                     /* Set the task state to opening the USB driver */
182:                     usbDeviceThisInstance->taskState = USB_DEVICE_TASK_STATE_OPENING_USBCD;
183:                 
184:                     /* Get a pointer to the driver interface */
185:                     usbDeviceThisInstance->driverInterface = (DRV_USB_DEVICE_INTERFACE *)(deviceInit->usbDriverInterface);
186:                     usbDeviceThisInstance->driverIndex = deviceInit->driverIndex;
187:                 
188:                     /* Initialize Endpoint Q size */ 
189:                     _USB_DEVICE_Initialize_Endpoint_Q(index, deviceInit->queueSizeEndpointRead, deviceInit->queueSizeEndpointWrite);
190:                 
191:                     /* Create Mutex for Endpoint Read Write */
192:                     _USB_DEVICE_EndpointMutexCreate (usbDeviceThisInstance);
193:                 
194:                     funcRegTable    = usbDeviceThisInstance->registeredFuncDrivers;
195:                 
196:                     for(count = 0; count < usbDeviceThisInstance->registeredFuncDriverCount; count++ )
197:                     {
198:                         /* The global intialize function of each registered function driver is
199:                          * called once when the device layer is initialized. This allows the
200:                          * function driver to create any mutexes once when the device stack is
201:                          * initialized. This happens only once. */
202:                 
203:                         driver = (USB_DEVICE_FUNCTION_DRIVER *)funcRegTable->driver;
204:                 
205:                         if (driver != NULL)
206:                         {
207:                             if(driver->globalInitialize != NULL)
208:                             {
209:                                 driver->globalInitialize();
210:                             }
211:                         }
212:                         funcRegTable++;
213:                     }
214:                 
215:                     /* Return the index as the system module object */
216:                     return index;  
217:                 }  
218:                   
219:                 // *****************************************************************************
220:                 /* Function:
221:                     void USB_DEVICE_Attach( USB_DEVICE_HANDLE usbDeviceHandle )
222:                 
223:                   Summary:
224:                     This function will attach the device to the USB.
225:                 
226:                   Description:
227:                     This function will attach the device to the USB. It does this by enabling
228:                     the pull up resistors on the D+ or D- lines. This function should be called
229:                     after the USB device layer has generated the USB_DEVICE_EVENT_POWER_DETECTED
230:                     event.
231:                 
232:                   Returns:
233:                     None.
234:                 
235:                   Remarks:
236:                      Refer to usb_device.h for usage information.
237:                 */
238:                 
239:                 void USB_DEVICE_Attach( USB_DEVICE_HANDLE usbDeviceHandle )
240:                 {
241:                     USB_DEVICE_OBJ* usbClientHandle;
242:                 
243:                     /* Validate the handle */
244:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
245:                 
246:                     if(usbClientHandle == NULL)
247:                     {
248:                         /* Handle is not valid */
249:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
250:                     }
251:                     else
252:                     {
253:                         /* Attach to Host */
254:                         usbClientHandle->driverInterface->deviceAttach(usbClientHandle->usbCDHandle); 
255:                     
256:                         /* Update the USB Device state */
257:                         usbClientHandle->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_POWERED;
258:                     } 
259:                 }
260:                 
261:                 // *****************************************************************************
262:                 /* Function:
263:                     void USB_DEVICE_Detach( USB_DEVICE_HANDLE usbDeviceHandle );
264:                 
265:                   Summary:
266:                     This function will detach the device from the USB. 
267:                 
268:                   Description:
269:                     This function will detach the device from the USB. It does this by disabling
270:                     the pull up resistors on the D+ or D- lines. This function should be called
271:                     when the application wants to disconnect the device from the bus (typically
272:                     to implement a soft detach or switch to host mode operation). It should
273:                     be called when the Device Layer has generated the
274:                     USB_DEVICE_EVENT_POWER_REMOVED event.
275:                 
276:                   Remarks:
277:                     Refer to usb_device.h for usage information.
278:                 */
279:                 
280:                 void USB_DEVICE_Detach( USB_DEVICE_HANDLE usbDeviceHandle )
281:                 {
282:                     USB_DEVICE_OBJ* usbClientHandle;
283:                 
284:                     /* Validate the handle */
285:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
286:                 
287:                     if(usbClientHandle == NULL)
288:                     {
289:                         /* Handle is not valid */
290:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
291:                     }
292:                     else
293:                     {
294:                         /* Detach from the Host */
295:                         usbClientHandle->driverInterface->deviceDetach(usbClientHandle->usbCDHandle); 
296:                     
297:                         /* Clear the suspended state */
298:                         usbClientHandle->usbDeviceStatusStruct.isSuspended = false;
299:                     
300:                         /* Update the USB Device state */
301:                         usbClientHandle->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_DETACHED;
302:                     }  
303:                 }
304:                 
305:                 //******************************************************************************
306:                 /* Function:
307:                     USB_DEVICE_RESULT USB_DEVICE_EndpointEnable
308:                     (
309:                         USB_DEVICE_HANDLE usbDeviceHandle,
310:                         uint8_t interface,
311:                         USB_ENDPOINT_ADDRESS endpoint,
312:                         USB_TRANSFER_TYPE transferType
313:                         size_t size
314:                     );
315:                  
316:                   Summary:
317:                     Enables a device endpoint.
318:                 
319:                   Description:
320:                     This function enables a device endpoint for the specified transfer type and
321:                     size. A Vendor specific device application may typically call this function
322:                     in response to a Set Interface request from the host. Note that Device Layer
323:                     will enable endpoints contained in Alternate Setting 0 of an interface, when
324:                     the host configures the device. If there is only one alternate setting in an
325:                     interface, the application may not need to call the
326:                     USB_DEVICE_EndpointEnable function. 
327:                 
328:                     If the device supports multiple alternate settings in an Interface, the
329:                     device application must then disable an endpoint (if it was enabled) before
330:                     re-enabling it with the new settings.The application can use the
331:                     USB_DEVICE_EndpointIsEnabled function to check the status of the endpoint and
332:                     USB_DEVICE_EndpointDisable function to disable the endpoint. 
333:                 
334:                   Remarks:
335:                     Refer to usb_device.h for usage information.
336:                 */
337:                 
338:                 USB_DEVICE_RESULT USB_DEVICE_EndpointEnable
339:                 (
340:                     USB_DEVICE_HANDLE usbDeviceHandle,
341:                     uint8_t interface,
342:                     USB_ENDPOINT_ADDRESS endpoint,
343:                     USB_TRANSFER_TYPE transferType,
344:                     size_t size
345:                 )
346:                 {
347:                     USB_DEVICE_OBJ* usbClientHandle;
348:                     USB_DEVICE_RESULT result; 
349:                 
350:                     /* Validate the handle */
351:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
352:                 
353:                     if(usbClientHandle == NULL)
354:                     {
355:                         /* Handle is not valid */
356:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
357:                         result = USB_DEVICE_RESULT_ERROR_ENDPOINT_INVALID; 
358:                     }
359:                     else
360:                     {
361:                         /* Enable the endpoint */
362:                         result = (USB_DEVICE_RESULT)usbClientHandle->driverInterface->deviceEndpointEnable(usbClientHandle->usbCDHandle, endpoint, transferType, size);
363:                     }
364:                     
365:                     return result; 
366:                 }
367:                 
368:                 //******************************************************************************
369:                 /* Function:
370:                     USB_DEVICE_RESULT USB_DEVICE_EndpointDisable
371:                     (
372:                         USB_DEVICE_HANDLE usbDeviceHandle,
373:                         USB_ENDPOINT_ADDRESS endpoint,
374:                     );
375:                  
376:                   Summary:
377:                     Disables a device endpoint.
378:                 
379:                   Description:
380:                     This function disables a device endpoint. The application may need to
381:                     disable the endpoint when it want to change the endpoint characteristics.
382:                     This could happen when the device features interfaces with multiple
383:                     alternate settings.  If such cases, the host may request the device to
384:                     switch to specific alternate setting by sending the Set Interface request.
385:                     The device application must then disable the endpoint (if it was enabled)
386:                     before re-enabling it with the new settings.The application can use the
387:                     USB_DEVICE_EndpointIsEnabled function to check the status of the endpoint and
388:                     USB_DEVICE_EndpointEnable function to enable the endpoint. 
389:                 
390:                   Remarks:
391:                     Refer to usb_device.h for usage information.
392:                 */
393:                 
394:                 USB_DEVICE_RESULT USB_DEVICE_EndpointDisable
395:                 (
396:                     USB_DEVICE_HANDLE usbDeviceHandle,
397:                     USB_ENDPOINT_ADDRESS endpoint
398:                 )
399:                 {
400:                     USB_DEVICE_OBJ* usbClientHandle;
401:                     USB_DEVICE_RESULT result; 
402:                 
403:                     /* Validate the handle */
404:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
405:                 
406:                     if(usbClientHandle == NULL)
407:                     {
408:                         /* Handle is not valid */
409:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
410:                         result = USB_DEVICE_RESULT_ERROR_ENDPOINT_INVALID; 
411:                     }
412:                     else
413:                     {
414:                         /* Disable the Endpoint */
415:                         result = (USB_DEVICE_RESULT)usbClientHandle->driverInterface->deviceEndpointDisable(usbClientHandle->usbCDHandle, endpoint);
416:                     }
417:                     
418:                     return result; 
419:                 }
420:                 
421:                 //******************************************************************************
422:                 /* Function:
423:                     bool USB_DEVICE_EndpointIsEnabled
424:                     (
425:                         USB_DEVICE_HANDLE usbDeviceHandle,
426:                         USB_ENDPOINT_ADDRESS endpoint,
427:                     );
428:                  
429:                   Summary:
430:                     Returns true if the endpoint is enabled.
431:                 
432:                   Description:
433:                     This function returns true if the endpoint is enabled. The application can
434:                     use this function when handling Set Interface requests in case of Vendor or
435:                     Custom USB devices.
436:                 
437:                   Remarks:
438:                     Refer to usb_device.h for usage information.
439:                 */
440:                 
441:                 bool USB_DEVICE_EndpointIsEnabled
442:                 (
443:                     USB_DEVICE_HANDLE usbDeviceHandle,
444:                     USB_ENDPOINT_ADDRESS endpoint
445:                 )
446:                 {
447:                     USB_DEVICE_OBJ* usbClientHandle;
448:                     bool result;
449:                     
450:                     /* Validate the handle */
451:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
452:                 
453:                     if(usbClientHandle == NULL)
454:                     {
455:                         /* Handle is not valid */
456:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
457:                         result = false; 
458:                     }
459:                     else
460:                     {
461:                         /* Check if the endpoint is enabled */
462:                         result = usbClientHandle->driverInterface->deviceEndpointIsEnabled(usbClientHandle->usbCDHandle, endpoint); 
463:                     }
464:                     
465:                     return result; 
466:                 }
467:                 
468:                 // *****************************************************************************
469:                 /* Function:
470:                     void USB_DEVICE_EndpointStall
471:                     (
472:                         USB_DEVICE_HANDLE usbDeviceHandle,
473:                         USB_ENDPOINT_ADDRESS endpoint
474:                     )
475:                 
476:                   Summary:
477:                     This function stalls an endpoint in the specified direction.
478:                 
479:                   Description:
480:                     This function stalls an endpoint in the specified direction.
481:                 
482:                   Remarks:
483:                     Refer to usb_device.h for usage information.
484:                 */
485:                 
486:                 void USB_DEVICE_EndpointStall 
487:                 (
488:                     USB_DEVICE_HANDLE usbDeviceHandle, 
489:                     USB_ENDPOINT_ADDRESS endpoint
490:                 )
491:                 {
492:                     USB_DEVICE_OBJ* usbClientHandle;
493:                 
494:                     /* Validate the handle */
495:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
496:                 
497:                     if(usbClientHandle == NULL)
498:                     {
499:                         /* Handle is not valid */
500:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
501:                     }
502:                     else
503:                     {
504:                         /* Stall the endpoint */
505:                         usbClientHandle->driverInterface->deviceEndpointStall(usbClientHandle->usbCDHandle, endpoint); 
506:                     }
507:                 }
508:                 
509:                 // *****************************************************************************
510:                 /* Function:
511:                     void USB_DEVICE_EndpointStallClear
512:                     (
513:                         USB_DEVICE_HANDLE usbDeviceHandle,
514:                         USB_ENDPOINT_ADDRESS endpoint
515:                     )
516:                 
517:                   Summary:
518:                     This function clears the stall on an endpoint in the specified direction.
519:                 
520:                   Description:
521:                     This function clear the stall on an endpoint in the specified direction. 
522:                 
523:                   Remarks:
524:                     Refer to usb_device.h for usage information.
525:                 */
526:                 
527:                 void USB_DEVICE_EndpointStallClear 
528:                 (
529:                     USB_DEVICE_HANDLE usbDeviceHandle, 
530:                     USB_ENDPOINT_ADDRESS endpoint
531:                 )
532:                 {
533:                     USB_DEVICE_OBJ* usbClientHandle;
534:                 
535:                     /* Validate the handle */
536:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
537:                 
538:                     if(usbClientHandle == NULL)
539:                     {
540:                         /* Handle is not valid */
541:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
542:                     }
543:                     else
544:                     { 
545:                         /* Clear endpoint stall condition */
546:                         usbClientHandle->driverInterface->deviceEndpointStallClear(usbClientHandle->usbCDHandle, endpoint); 
547:                     }
548:                 }
549:                 
550:                 // *****************************************************************************
551:                 /* Function:
552:                     bool USB_DEVICE_EndpointIsStalled
553:                     (
554:                         USB_DEVICE_HANDLE usbDeviceHandle,
555:                         USB_ENDPOINT_ADDRESS endpoint
556:                     )
557:                 
558:                   Summary:
559:                     This function returns the stall status of the specified endpoint and
560:                     direction.
561:                 
562:                   Description:
563:                     This function returns the stall status of the specified endpoint and
564:                     direction.
565:                 
566:                   Remarks:
567:                     Refer to usb_device.h for usage information.
568:                 */
569:                 
570:                 bool USB_DEVICE_EndpointIsStalled
571:                 (
572:                     USB_DEVICE_HANDLE usbDeviceHandle,
573:                     USB_ENDPOINT_ADDRESS endpoint
574:                 )
575:                 {
576:                     USB_DEVICE_OBJ* usbClientHandle;
577:                     bool result; 
578:                 
579:                     /* Validate the handle */
580:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
581:                 
582:                     if(usbClientHandle == NULL)
583:                     {
584:                         /* Handle is not valid */
585:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
586:                         result = false; 
587:                     }
588:                     else
589:                     {
590:                         /* Check if the endpoint is stalled */
591:                         result = usbClientHandle->driverInterface->deviceEndpointIsStalled(usbClientHandle->usbCDHandle, endpoint); 
592:                     }
593:                     
594:                     return result; 
595:                 }
596:                 
597:                 // *****************************************************************************
598:                 /* Function:
599:                     SYS_STATUS USB_DEVICE_Status ( SYS_MODULE_OBJ object )
600:                 
601:                   Summary:
602:                     Provides the current status of the USB device layer.
603:                 
604:                   Description:
605:                     This function provides the current status of the USB device layer.
606:                 
607:                   Remarks
608:                     Refer to usb_device.h for usage information.
609:                 */
610:                 
611:                 SYS_STATUS USB_DEVICE_Status( SYS_MODULE_OBJ object )
612:                 {
613:                     SYS_MODULE_INDEX index = (SYS_MODULE_INDEX)object;
614:                 
615:                     if(object == SYS_MODULE_OBJ_INVALID)
616:                     {
617:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid System Module Object");
618:                         return(SYS_STATUS_UNINITIALIZED);
619:                     }
620:                 
621:                     return( usbDeviceInstance[index].usbDeviceInstanceState );
622:                 }
623:                 
624:                 // *****************************************************************************
625:                 /* Function:
626:                     bool USB_DEVICE_IsSuspended( USB_DEVICE_HANDLE usbDeviceHandle )
627:                 
628:                   Summary:
629:                     Returns true if the device is in a suspended state.
630:                 
631:                   Description:
632:                     This function returns true if the device is presently in suspended state.
633:                 
634:                   Remarks:
635:                     Refer to usb_device.h for usage information.
636:                 */
637:                 
638:                 bool USB_DEVICE_IsSuspended( USB_DEVICE_HANDLE usbDeviceHandle )
639:                 {
640:                     USB_DEVICE_OBJ* usbClientHandle;
641:                     bool result; 
642:                 
643:                     /* Validate the handle */
644:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
645:                 
646:                     if(usbClientHandle == NULL)
647:                     {
648:                        /* Handle is not valid */
649:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
650:                        result = false; 
651:                     }
652:                     else
653:                     {
654:                         result = usbClientHandle->usbDeviceStatusStruct.isSuspended; 
655:                     }
656:                     
657:                     return result;  
658:                 }
659:                 
660:                 // *****************************************************************************
661:                 /* Function:
662:                     USB_DEVICE_STATE USB_DEVICE_StateGet( USB_DEVICE_HANDLE usbDeviceHandle )
663:                 
664:                   Summary:
665:                     Returns the current state of the USB device.
666:                 
667:                   Description:
668:                     This function returns the current state of the USB device, as described in
669:                     Chapter 9 of the USB 2.0 Specification.
670:                 
671:                   Remarks:
672:                     Refer to usb_device.h for usage information.
673:                 */
674:                 
675:                 USB_DEVICE_STATE USB_DEVICE_StateGet( USB_DEVICE_HANDLE usbDeviceHandle )
676:                 {
677:                     USB_DEVICE_OBJ* usbClientHandle;
678:                     USB_DEVICE_STATE result; 
679:                 
680:                     /* Validate the handle */
681:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
682:                 
683:                     if(usbClientHandle == NULL)
684:                     {
685:                        /* Handle is not valid */
686:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
687:                        result = USB_DEVICE_STATE_DETACHED; 
688:                     }
689:                     else
690:                     {
691:                         result = usbClientHandle->usbDeviceStatusStruct.usbDeviceState;
692:                     }
693:                     return result; 
694:                 }
695:                     
696:                 
697:                 // *****************************************************************************
698:                 /* Function:
699:                     void USB_DEVICE_Deinitialize ( SYS_MODULE_OBJ usbDeviceobj)
700:                 
701:                   Summary:
702:                     De initializes the specified instance of the USB device layer.
703:                 
704:                   Description:
705:                     This function de initializes the specified instance of the USB device layer,
706:                     disabling its operation (and any hardware) and invalidates all of the
707:                     internal data.
708:                 
709:                   Remarks:
710:                     Refer to usb_device.h for usage information.
711:                 */
712:                 
713:                 void USB_DEVICE_Deinitialize ( SYS_MODULE_OBJ usbDeviceObj )
714:                 {
715:                     USB_DEVICE_OBJ * usbDeviceThisInstance;
716:                     SYS_MODULE_INDEX index = (SYS_MODULE_INDEX)usbDeviceObj;
717:                 
718:                     /* Check if we have a valid system module object */
719:                     if(usbDeviceObj == SYS_MODULE_OBJ_INVALID)
720:                     {
721:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid System Module Object");
722:                         return;
723:                     }
724:                 
725:                     /* In this release of the device stack, we really dont do much in the
726:                      * deinitialize function, as we dont expect the USB Device Layer to be
727:                      * deinitialized in a typical application. */
728:                 
729:                     usbDeviceThisInstance = ( USB_DEVICE_OBJ *)&usbDeviceInstance[index];
730:                 
731:                     /* Invalidate the object */
732:                     usbDeviceThisInstance->usbDeviceInstanceState =  SYS_STATUS_UNINITIALIZED;
733:                 }
734:                  
735:                 // *****************************************************************************
736:                 /* Function:
737:                     void USB_DEVICE_Tasks( SYS_MODULE_OBJ devLayerObj )
738:                 
739:                   Summary:
740:                     Calls all USB device layer tasks.
741:                 
742:                   Description:
743:                     This function internally calls all USB Device layer tasks.
744:                 
745:                   Remarks:
746:                     Refer to usb_device.h for usage information.
747:                 */
748:                 
749:                 void USB_DEVICE_Tasks( SYS_MODULE_OBJ devLayerObj )
750:                 {
751:                     uint8_t count;
752:                     USB_SPEED speed;
753:                     uint16_t configValue;
754:                     uint16_t maxFunctionCounts;
755:                     USB_DEVICE_OBJ * usbDeviceThisInstance;
756:                     USB_DEVICE_FUNCTION_REGISTRATION_TABLE * funcRegTable;
757:                     USB_DEVICE_FUNCTION_DRIVER * driver;
758:                 
759:                     /* Assert object is valid. */
760:                     if(devLayerObj == SYS_MODULE_OBJ_INVALID)
761:                     {
762:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: System Module Object is invalid");
763:                         return;
764:                     }
765:                 
766:                     /* Get this instance of USB device layer.*/
767:                     usbDeviceThisInstance = &usbDeviceInstance[devLayerObj];    
768:                 
769:                     /* Proceed only if this instance is in initialized state. */
770:                     if( usbDeviceThisInstance->usbDeviceInstanceState <= SYS_STATUS_UNINITIALIZED )
771:                     {
772:                         /* Instance is not yet initialized. Just do a return. */
773:                         return;
774:                     }
775:                 
776:                     /* Get device layer data. */
777:                     speed           = usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed ;
778:                     configValue     = usbDeviceThisInstance->activeConfiguration ;
779:                     funcRegTable    = usbDeviceThisInstance->registeredFuncDrivers;
780:                     maxFunctionCounts = usbDeviceThisInstance->registeredFuncDriverCount;
781:                 
782:                     /* Run the device layer task routine */
783:                     switch(usbDeviceThisInstance->taskState)
784:                     {
785:                         case USB_DEVICE_TASK_STATE_OPENING_USBCD:
786:                 
787:                             /* Try to open the driver handle. This could fail if the driver is
788:                              * not ready to be opened. */
789:                             usbDeviceThisInstance->usbCDHandle = usbDeviceThisInstance->driverInterface->open( usbDeviceThisInstance->driverIndex, (DRV_IO_INTENT)(DRV_IO_INTENT_EXCLUSIVE|DRV_IO_INTENT_NONBLOCKING|DRV_IO_INTENT_READWRITE));
790:                 
791:                             /* Check if the driver was opened */
792:                             if(usbDeviceThisInstance->usbCDHandle != DRV_HANDLE_INVALID)
793:                             {
794:                                 /* Yes the driver could be opened. Advance the state to the next
795:                                  * state */
796:                                 usbDeviceThisInstance->taskState = USB_DEVICE_TASK_STATE_RUNNING;
797:                 
798:                                 /* Update the USB Device Layer state to indicate that it can be
799:                                  * opened */
800:                                 usbDeviceThisInstance->usbDeviceInstanceState = SYS_STATUS_READY;
801:                             }
802:                 
803:                             break;
804:                 
805:                         case USB_DEVICE_TASK_STATE_RUNNING:
806:                 
807:                             /* In this state, the device layer performs it's actual task, that
808:                              * is calling the tasks routines of the functions drivers. The task
809:                              * routine of a function driver is called in the context of the
810:                              * USB_DEVICE_Tasks() function. The task routine is called only if
811:                              * the current device speed matches the function driver speed
812:                              * mentioned in the function driver registration table, the current
813:                              * configuration matches the configuration value mentioned in the
814:                              * function driver registration table, if the device is not
815:                              * suspended and if the device state is in a configured state. */
816:                 
817:                             for(count = 0; count < maxFunctionCounts; count++ )
818:                             {
819:                                 if( (funcRegTable->speed & speed) && (funcRegTable->configurationValue == configValue))
820:                                 {
821:                                     if((usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState == USB_DEVICE_STATE_CONFIGURED) &&
822:                                             (usbDeviceThisInstance->usbDeviceStatusStruct.isSuspended == false))
823:                                     {
824:                                         /* Get a pointer to the driver function pointer table and
825:                                            call the task routine of the driver. */
826:                                         driver = (USB_DEVICE_FUNCTION_DRIVER *)funcRegTable->driver;
827:                 
828:                                         if (driver != NULL)
829:                                         {
830:                                             if(driver->tasks != NULL)
831:                                             {
832:                                                 driver->tasks( funcRegTable->funcDriverIndex );
833:                                             }
834:                                         }
835:                                     }
836:                                 }
837:                 
838:                                 /* Run the task routine for the next driver in the function
839:                                  * driver registration table */
840:                                 funcRegTable++;
841:                             }
842:                             break;
843:                 
844:                         default:
845:                             break;
846:                     }
847:                 }
848:                 
849:                 // *****************************************************************************
850:                 // *****************************************************************************
851:                 // Section: USB Device Layer Client Interface Functions
852:                 // *****************************************************************************
853:                 // *****************************************************************************
854:                 
855:                 // *****************************************************************************
856:                 /* Function:
857:                     USB_DEVICE_HANDLE USB_DEVICE_Open
858:                     (
859:                         const SYS_MODULE_INDEX index,
860:                         const DRV_IO_INTENT intent
861:                     )
862:                 
863:                   Summary:
864:                     Opens the specific module instance and returns a handle.
865:                 
866:                   Description:
867:                     This function opens the USB device layer for use by any client module and
868:                     provides a handle that must be provided to any of the other device layer
869:                     operations to identify the caller and the instance of the driver/hardware
870:                     module.
871:                 
872:                   Remarks
873:                     Refer to usb_device.h for usage information.
874:                 */
875:                 
876:                 USB_DEVICE_HANDLE USB_DEVICE_Open
877:                 (
878:                     const SYS_MODULE_INDEX index, 
879:                     const DRV_IO_INTENT intent
880:                 )
881:                 {
882:                     USB_DEVICE_OBJ * usbDeviceThisClient;
883:                 
884:                     /* Make sure the index is with in range. */
885:                     if(index >= USB_DEVICE_INSTANCES_NUMBER)
886:                     {
887:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Index is invalid");
888:                         return(USB_DEVICE_HANDLE_INVALID);
889:                     }
890:                 
891:                     /* Check if the instance is initialized. */   
892:                     if(usbDeviceInstance[index].usbDeviceInstanceState != SYS_STATUS_READY)
893:                     {
894:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Device Layer is not ready to be opened");
895:                         return(USB_DEVICE_HANDLE_INVALID);
896:                     }
897:                 
898:                     /* Copy this local client. This implementation of the device layer only
899:                      * allows one client. Hence there is not seperate client object. The client
900:                      * object is really the device layer object. */
901:                     usbDeviceThisClient = &usbDeviceInstance[index];
902:                 
903:                     if(!usbDeviceThisClient->inUse)
904:                     {
905:                         /* We found a free client object */
906:                         usbDeviceThisClient->inUse = true;
907:                 
908:                         /* Update client status */
909:                         usbDeviceThisClient->clientState = USB_DEVICE_CLIENT_STATUS_READY;
910:                 
911:                         /* Get the Client Handle */
912:                         return((USB_DEVICE_HANDLE)usbDeviceThisClient);
913:                     }
914:                       
915:                     /* If we have reached here, then we did not find a free client object */
916:                     SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: No free client objects");
917:                 
918:                     return(USB_DEVICE_HANDLE_INVALID);   
919:                 }    
920:                 
921:                 // *****************************************************************************
922:                 /* Function:
923:                     void USB_DEVICE_Close( DRV_HANDLE usbDevHandle )
924:                 
925:                   Summary:
926:                     Closes an opened instance of the USB device layer.
927:                 
928:                   Description:
929:                     This function closes an opened instance of the USB device layer,
930:                     invalidating the handle.
931:                 
932:                   Remarks:
933:                     Refer to usb_device.h for usage information.
934:                 */
935:                 
936:                 void USB_DEVICE_Close(USB_DEVICE_HANDLE hClient )
937:                 {
938:                     USB_DEVICE_OBJ* usbClientHandle;
939:                     
940:                     /* Validate the handle */
941:                     
942:                     usbClientHandle = _USB_DEVICE_ClientHandleValidate(hClient);
943:                     if(usbClientHandle == NULL)
944:                     {
945:                        /* Handle is not valid */
946:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
947:                        return; 
948:                     }
949:                     
950:                     /* Close this client */
951:                     usbClientHandle->clientState = (USB_DEVICE_CLIENT_STATUS)DRV_CLIENT_STATUS_CLOSED;
952:                     usbClientHandle->inUse = false;
953:                 }    
954:                 
955:                 // *****************************************************************************
956:                 /* Function:
957:                     USB_DEVICE_CLIENT_STATUS USB_DEVICE_ClientStatusGet
958:                     (
959:                         USB_DEVICE_HANDLE usbDevHandle
960:                     );
961:                 
962:                   Summary:
963:                     Gets the current client-specific status of the USB device layer.
964:                 
965:                   Description:
966:                     This function gets the client-specific status of the USB device layer
967:                     associated with the specified handle.
968:                 
969:                   Returns:
970:                     Refer to usb_device.h for usage information.
971:                 */
972:                 
973:                 USB_DEVICE_CLIENT_STATUS USB_DEVICE_ClientStatusGet( USB_DEVICE_HANDLE hHandle )
974:                 {
975:                     USB_DEVICE_OBJ * devClientHandle;
976:                 
977:                     devClientHandle = _USB_DEVICE_ClientHandleValidate(hHandle);
978:                 
979:                     if(devClientHandle == NULL)
980:                     {
981:                         return (USB_DEVICE_CLIENT_STATUS_CLOSED);
982:                     }
983:                     
984:                     /* Return the state of the client. */  
985:                     return( devClientHandle->clientState ); 
986:                 }
987:                 // ******************************************************************************
988:                 /* Function:
989:                     void USB_DEVICE_EventCallBackSet
990:                     (
991:                         USB_DEVICE_HANDLE hHandle,
992:                         const USB_DEVICE_EVENT_HANDLER callBackFunc
993:                         uintptr_t context
994:                     );
995:                 
996:                   Summary:
997:                     Sets up the callback function that will be called in case of an
998:                     event from the USB device layer.
999:                 
1000:                  Description:
1001:                    This function sets up the callback function. This callback function 
1002:                    will be called when an event occurs in the USB device layer.
1003:                
1004:                  Remarks:
1005:                    Refer to usb_device.h for usage information.
1006:                */
1007:                
1008:                void USB_DEVICE_EventHandlerSet
1009:                (
1010:                    USB_DEVICE_HANDLE hHandle, 
1011:                    const USB_DEVICE_EVENT_HANDLER callBackFunc,
1012:                    uintptr_t context
1013:                )
1014:                {
1015:                    USB_DEVICE_OBJ* devClientHandle;
1016:                
1017:                    /* Validate the handle */
1018:                
1019:                    devClientHandle = _USB_DEVICE_ClientHandleValidate(hHandle);
1020:                    if(devClientHandle == NULL)
1021:                    {
1022:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid client handle");
1023:                        return;
1024:                    }
1025:                
1026:                    /* Register the callback function. Note that the call back function is
1027:                     * invoked for control transfer events.  */
1028:                    devClientHandle->callBackFunc = callBackFunc;
1029:                    devClientHandle->context = context;
1030:                
1031:                    /* Register a callback with the driver. */
1032:                    devClientHandle->driverInterface->eventHandlerSet(devClientHandle->usbCDHandle, (uintptr_t)devClientHandle, &_USB_DEVICE_EventHandler);
1033:                }   
1034:                
1035:                // ******************************************************************************
1036:                /* Function:
1037:                   uint8_t USB_DEVICE_ActiveConfigurationGet( USB_DEVICE_HANDLE usbDeviceHandle )
1038:                
1039:                  Summary:
1040:                    Informs the client of the current USB device configuration set by the USB
1041:                    host.
1042:                
1043:                  Description:
1044:                    This function returns the current active USB device configuration.
1045:                
1046:                  Precondition:
1047:                    The USB Device Layer must have been initialized and opened before calling this
1048:                    function.
1049:                
1050:                  Remarks:  
1051:                    See usb_device.h for usage information.
1052:                */
1053:                
1054:                uint8_t USB_DEVICE_ActiveConfigurationGet(USB_DEVICE_HANDLE hHandle)
1055:                {
1056:                    USB_DEVICE_OBJ * devClientHandle;
1057:                
1058:                    /* Validate the client handle */
1059:                
1060:                    devClientHandle = _USB_DEVICE_ClientHandleValidate(hHandle);
1061:                    if(devClientHandle == NULL)
1062:                    {
1063:                        /* Client handle is invalid */
1064:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid client handle");
1065:                        return(0);
1066:                    }
1067:                    
1068:                    return(devClientHandle->activeConfiguration);
1069:                }
1070:                
1071:                // *****************************************************************************
1072:                /* Function:
1073:                    USB_SPEED USB_DEVICE_ActiveSpeedGet(USB_DEVICE_HANDLE usbDeviceHandle)
1074:                
1075:                  Summary:
1076:                    Informs the client of the current operation speed of the USB bus.
1077:                
1078:                  Description:
1079:                    The USB device stack supports both high speed and full speed operations.
1080:                    This function returns the current operation speed of the USB bus. This
1081:                    function should be called after the USB_DEVICE_EVENT_RESET event has
1082:                    occurred.
1083:                
1084:                  Precondition:
1085:                    The USB device layer must have been initialized and a valid handle
1086:                    to USB device layer must have been opened.
1087:                  
1088:                  Remarks:  
1089:                    See usb_device.h for usage information.
1090:                */
1091:                
1092:                USB_SPEED USB_DEVICE_ActiveSpeedGet(USB_DEVICE_HANDLE hHandle)
1093:                {
1094:                    USB_DEVICE_OBJ* devClientHandle;
1095:                    
1096:                    /* Validate the handle */
1097:                    devClientHandle = _USB_DEVICE_ClientHandleValidate(hHandle);
1098:                
1099:                    if(devClientHandle == NULL)
1100:                    {
1101:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid Handle");
1102:                        return(USB_SPEED_LOW);
1103:                    }
1104:                
1105:                    /* Return the current speed */
1106:                    return(devClientHandle->usbDeviceStatusStruct.usbSpeed);
1107:                }
1108:                
1109:                // *****************************************************************************
1110:                /* Function:
1111:                    USB_DEVICE_CONTROL_TRANSFER_RESULT USB_DEVICE_ControlSend
1112:                    (
1113:                        USB_DEVICE_HANDLE usbDeviceHandle,
1114:                        uint8_t * data, 
1115:                        size_t length 
1116:                    )
1117:                
1118:                  Summary:
1119:                    Sends data stage of the control transfer from device to host.
1120:                
1121:                  Description:
1122:                    Sends data stage of the control transfer from device to host.
1123:                
1124:                  Remarks:
1125:                    Refer to usb_device.h for usage information.
1126:                */
1127:                
1128:                USB_DEVICE_CONTROL_TRANSFER_RESULT USB_DEVICE_ControlSend
1129:                (
1130:                    USB_DEVICE_HANDLE hClient,
1131:                    void * data, 
1132:                    size_t length 
1133:                )
1134:                {
1135:                    USB_DEVICE_OBJ * usbDeviceThisInstance;
1136:                    USB_DEVICE_IRP * irpHandle;   
1137:                
1138:                    usbDeviceThisInstance = _USB_DEVICE_ClientHandleValidate(hClient);
1139:                
1140:                    /* Validate the client handle */
1141:                    if(usbDeviceThisInstance == NULL)
1142:                    {
1143:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid Client Handle");
1144:                        return(USB_DEVICE_CONTROL_TRANSFER_RESULT_FAILED);
1145:                    }
1146:                
1147:                    /* Get a handle to the TX IRP */
1148:                    irpHandle = &usbDeviceThisInstance->irpEp0Tx;     
1149:                    irpHandle->data = data;
1150:                    irpHandle->size = (unsigned int )length;
1151:                
1152:                    /* The function assumes the control transfer was initiated by the host and
1153:                     * the setup command has been received. controlTransferDataStageSize in such
1154:                     * a case will have the size of the control transfer data stage size. If the
1155:                     * length submitted by application is what the host is expecting, then we
1156:                     * dont have to send a ZLP. If the length is less than the what the host is
1157:                     * expecting then we should send a ZLP. */
1158:                
1159:                    if(length == usbDeviceThisInstance->controlTransferDataStageSize)
1160:                    {
1161:                        /* This means we are sending the amount of data that is required.
1162:                         * So no need to send send ZLP */
1163:                        irpHandle->flags = USB_DEVICE_IRP_FLAG_DATA_PENDING;
1164:                    }
1165:                    else if (length < usbDeviceThisInstance->controlTransferDataStageSize )
1166:                    {
1167:                        /* The length is less than requested. We let the driver manage the
1168:                         * ZLP. */
1169:                        irpHandle->flags = USB_DEVICE_IRP_FLAG_DATA_COMPLETE;
1170:                    }
1171:                
1172:                    /* Submit the IRP to the USBCD */
1173:                    (void)usbDeviceThisInstance->driverInterface->deviceIRPSubmit( usbDeviceThisInstance->usbCDHandle, controlEndpointTx, irpHandle);
1174:                
1175:                    return USB_DEVICE_CONTROL_TRANSFER_RESULT_SUCCESS;
1176:                }
1177:                
1178:                // *****************************************************************************
1179:                /* Function:
1180:                    USB_DEVICE_CONTROL_TRANSFER_RESULT USB_DEVICE_ControlReceive
1181:                    (
1182:                        USB_DEVICE_HANDLE usbDeviceHandle,
1183:                        void * data, 
1184:                        size_t length
1185:                    )
1186:                
1187:                  Summary:
1188:                    Receives data stage of the control transfer from host to device.
1189:                
1190:                  Description:
1191:                    Receives data stage of the control transfer from host to device.
1192:                
1193:                  Remarks:
1194:                    Refer to usb_device.h for usage information.
1195:                */
1196:                
1197:                USB_DEVICE_CONTROL_TRANSFER_RESULT USB_DEVICE_ControlReceive
1198:                (
1199:                    USB_DEVICE_HANDLE handle,
1200:                    void * data, 
1201:                    size_t length
1202:                )
1203:                {
1204:                    USB_DEVICE_CONTROL_TRANSFER_STRUCT * pControlTransfer;
1205:                    USB_DEVICE_OBJ * client;
1206:                
1207:                    /* Validate the client handle */
1208:                    client = _USB_DEVICE_ClientHandleValidate(handle);
1209:                    if(client == NULL)
1210:                    {
1211:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid Client Handle");
1212:                        return(USB_DEVICE_CONTROL_TRANSFER_RESULT_FAILED);
1213:                    }
1214:                
1215:                    /* Get the control transfer object. The device layer is always ready to
1216:                     * receive data from the device. It needs to know however where the received
1217:                     * data should be placed. This is determined by the rxBuffer member of the
1218:                     * control transfer object. */
1219:                    pControlTransfer = &client->controlTransfer;
1220:                    pControlTransfer->rxBuffer = data ;
1221:                    pControlTransfer->rxDataCount = 0;
1222:                    pControlTransfer->expectedRxDataCount = length ;
1223:                
1224:                    /* We are always ready to receive data on endpoint 0. So no need to submit a
1225:                     * IRP */
1226:                    return USB_DEVICE_CONTROL_TRANSFER_RESULT_SUCCESS;
1227:                }
1228:                
1229:                // *****************************************************************************
1230:                /* Function:
1231:                    USB_DEVICE_CONTROL_TRANSFER_RESULT USB_DEVICE_ControlStatus
1232:                    (
1233:                        USB_DEVICE_HANDLE hClient,
1234:                        USB_DEVICE_CONTROL_STATUS status 
1235:                    )
1236:                
1237:                  Summary:
1238:                    Initiates status stage of the control transfer.
1239:                
1240:                  Description:
1241:                    Initiates status stage of the control transfer.
1242:                
1243:                  Remarks:
1244:                    Refer to usb_device.h for usage information.
1245:                */
1246:                
1247:                USB_DEVICE_CONTROL_TRANSFER_RESULT USB_DEVICE_ControlStatus
1248:                (
1249:                    USB_DEVICE_HANDLE handle,
1250:                    USB_DEVICE_CONTROL_STATUS status
1251:                )
1252:                {
1253:                    USB_DEVICE_OBJ * usbDeviceThisInstance;
1254:                    USB_DEVICE_IRP * irpHandle;
1255:                
1256:                    usbDeviceThisInstance = _USB_DEVICE_ClientHandleValidate(handle);
1257:                    if(usbDeviceThisInstance == NULL)
1258:                    {
1259:                        /* Client handle is not valid */
1260:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid Client Handle");
1261:                        return(USB_DEVICE_CONTROL_TRANSFER_RESULT_FAILED);
1262:                    }
1263:                
1264:                    usbDeviceThisInstance->controlTransfer.inProgress = false;
1265:                
1266:                    if(USB_DEVICE_CONTROL_STATUS_ERROR == status)
1267:                    {
1268:                        /* This means the control transfer should be stalled. We stall endpoint
1269:                         * 0 */
1270:                        usbDeviceThisInstance->driverInterface->deviceEndpointStall(usbDeviceThisInstance->usbCDHandle , controlEndpointTx);        
1271:                    }
1272:                    else
1273:                    {
1274:                        /* We must acknowledge the control transfer. This is done by sending a
1275:                         * ZLP */
1276:                        irpHandle = &usbDeviceThisInstance->irpEp0Tx;
1277:                        irpHandle->data = NULL;
1278:                        irpHandle->size = 0;
1279:                
1280:                        (void)usbDeviceThisInstance->driverInterface->deviceIRPSubmit( usbDeviceThisInstance->usbCDHandle, controlEndpointTx, irpHandle);
1281:                    }
1282:                
1283:                    return USB_DEVICE_CONTROL_TRANSFER_RESULT_SUCCESS;
1284:                }
1285:                // *****************************************************************************
1286:                /* Function:
1287:                    void USB_DEVICE_PowerStateSet
1288:                    (
1289:                        USB_DEVICE_HANDLE handle,
1290:                        USB_DEVICE_POWER_STATE state
1291:                    )
1292:                
1293:                  Summary:
1294:                    Sets the power state of the device.
1295:                
1296:                  Description:
1297:                    Sets the power state of the device.
1298:                    
1299:                  Remarks:
1300:                    Refer to usb_device.h for usage information.
1301:                */
1302:                
1303:                void USB_DEVICE_PowerStateSet
1304:                (
1305:                    USB_DEVICE_HANDLE handle,
1306:                    USB_DEVICE_POWER_STATE state
1307:                )
1308:                {
1309:                    USB_DEVICE_OBJ* client;
1310:                
1311:                    /* Validate the client handle */
1312:                
1313:                    client = _USB_DEVICE_ClientHandleValidate(handle);
1314:                    if(client == NULL)
1315:                    {
1316:                        /* Client handle is invalid */
1317:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid Handle");
1318:                        return;
1319:                    }
1320:                
1321:                    /* Store the power state */
1322:                    client->usbDeviceStatusStruct.powerState = state;
1323:                }
1324:                
1325:                // ******************************************************************************
1326:                /* Function:
1327:                    USB_DEVICE_REMOTE_WAKEUP_STATUS USB_DEVICE_RemoteWakeupStatusGet
1328:                    (
1329:                        USB_DEVICE_HANDLE handle
1330:                    )
1331:                
1332:                  Summary:
1333:                    This function returns the status of remote wakeup capability of the device.
1334:                
1335:                  Description:
1336:                    This function returns the status of remote wakeup capability of the device.
1337:                
1338:                  Remarks:
1339:                    Refer to usb_device.h for usage information.
1340:                */
1341:                
1342:                USB_DEVICE_REMOTE_WAKEUP_STATUS USB_DEVICE_RemoteWakeupStatusGet
1343:                (
1344:                    USB_DEVICE_HANDLE handle
1345:                )
1346:                {
1347:                    USB_DEVICE_OBJ* client;
1348:                
1349:                    /* Validate the client handle */
1350:                
1351:                    client = _USB_DEVICE_ClientHandleValidate(handle);
1352:                    if(client == NULL)
1353:                    {
1354:                        /* Client handle is invalid */
1355:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid Handle");
1356:                        return USB_DEVICE_REMOTE_WAKEUP_DISABLED;
1357:                    }
1358:                
1359:                    return (client->remoteWakeupStatus);
1360:                }
1361:                
1362:                // *****************************************************************************
1363:                /* Function:
1364:                    void USB_DEVICE_RemoteWakeupStop ( USB_DEVICE_HANDLE usbDeviceHandle )
1365:                
1366:                  Summary:
1367:                    This function will stop the resume signalling.
1368:                
1369:                  Description:
1370:                    This function will stop the resume signalling. This function should be
1371:                    called after the client has called the USB_DEVICE_RemoteWakeupStart()
1372:                    function.
1373:                
1374:                  Remarks:
1375:                    Refer to usb_device.h for usage information.
1376:                */
1377:                
1378:                void USB_DEVICE_RemoteWakeupStop( USB_DEVICE_HANDLE handle )
1379:                {
1380:                    USB_DEVICE_OBJ* usbDeviceThisInstance;
1381:                
1382:                    /* Validate the device handle */
1383:                    usbDeviceThisInstance = _USB_DEVICE_ClientHandleValidate(handle);
1384:                    if(NULL == usbDeviceThisInstance)
1385:                    {
1386:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer Client Handle is invalid");
1387:                        return;
1388:                    }
1389:                
1390:                    /* Call the driver remote wake up function here */
1391:                    usbDeviceThisInstance->driverInterface->deviceRemoteWakeupStop(usbDeviceThisInstance->usbCDHandle);
1392:                }
1393:                
1394:                // *****************************************************************************
1395:                /* Function:
1396:                    void USB_DEVICE_RemoteWakeupStart( USB_DEVICE_HANDLE usbDeviceHandle )
1397:                
1398:                  Summary:
1399:                    This function will start the resume signalling.
1400:                
1401:                  Description:
1402:                    This function will start the resume signalling on the bus. The client calls
1403:                    this function after it has detected a idle bus (through the
1404:                    USB_DEVICE_EVENT_SUSPENDED event). The remote wakeup feature should have
1405:                    been enabled by the host, before the client can call this function. The
1406:                    client can use the USB_DEVICE_RemoteWakeupStatusGet() function to check if
1407:                    the host has enabled the remote wakeup feature.
1408:                
1409:                  Remarks:
1410:                    Refer to usb_device.h for usage information.
1411:                */
1412:                
1413:                void USB_DEVICE_RemoteWakeupStart( USB_DEVICE_HANDLE usbDeviceHandle )
1414:                {
1415:                    USB_DEVICE_OBJ * usbDeviceThisInstance;
1416:                
1417:                    /* Validate the device handle */
1418:                    usbDeviceThisInstance = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle);
1419:                    if(NULL == usbDeviceThisInstance)
1420:                    {
1421:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer Client Handle is invalid");
1422:                        return;
1423:                    }
1424:                
1425:                    /* Call the driver remote wake up function here */
1426:                    usbDeviceThisInstance->driverInterface->deviceRemoteWakeupStart(usbDeviceThisInstance->usbCDHandle);
1427:                }
1428:                // *****************************************************************************
1429:                // *****************************************************************************
1430:                // Section: USB Device Layer System Interface functions.
1431:                // *****************************************************************************
1432:                // *****************************************************************************
1433:                
1434:                // *****************************************************************************
1435:                /* Function:
1436:                    USB_ERROR USB_DEVICE_IRPSubmit
1437:                    (
1438:                        USB_DEVICE_HANDLE usbDeviceHandle, 
1439:                        USB_ENDPOINT endpointAndDirection, 
1440:                        USB_DEVICE_IRP * irp
1441:                    );
1442:                    
1443:                  Summary:
1444:                    This function submits an I/O Request Packet (IRP) for processing to the
1445:                    Hi-Speed USB Driver.
1446:                	
1447:                  Description:
1448:                    This function submits an I/O Request Packet (IRP) for processing to the USB
1449:                    Driver. The IRP allows a client to send and receive data from the USB Host.
1450:                    The data will be sent or received through the specified endpoint. The direction
1451:                    of the data transfer is indicated by the direction flag in the
1452:                    endpointAndDirection parameter. Submitting an IRP arms the endpoint to
1453:                    either send data to or receive data from the Host.  If an IRP is already
1454:                    being processed on the endpoint, the subsequent IRP submit operation
1455:                    will be queued. The contents of the IRP (including the application buffers)
1456:                    should not be changed until the IRP has been processed.
1457:                	
1458:                  Remarks:
1459:                    Refer to usb_device_function_driver.h for usage information.                                                                          
1460:                */
1461:                
1462:                USB_ERROR USB_DEVICE_IRPSubmit
1463:                (
1464:                    USB_DEVICE_HANDLE usbDeviceHandle, 
1465:                    USB_ENDPOINT endpointAndDirection, 
1466:                    USB_DEVICE_IRP * irp
1467:                )
1468:                {
1469:                    USB_DEVICE_OBJ* usbClientHandle;
1470:                    USB_ERROR result;
1471:                    
1472:                    /* Validate the handle */
1473:                    usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
1474:                
1475:                    if(usbClientHandle == NULL)
1476:                    {
1477:                       /* Handle is not valid */
1478:                       SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
1479:                       result = USB_ERROR_PARAMETER_INVALID; 
1480:                    }
1481:                    else
1482:                    {
1483:                         /* Submit IRP */
1484:                        result = usbClientHandle->driverInterface->deviceIRPSubmit(usbClientHandle->usbCDHandle,endpointAndDirection, irp ); 
1485:                    }
1486:                    
1487:                    return result; 
1488:                }
1489:                
1490:                // **************************************************************************
1491:                /* Function:
1492:                    USB_ERROR USB_DEVICE_IRPCancelAll 
1493:                    (
1494:                        USB_DEVICE_HANDLE usbDeviceHandle,
1495:                        USB_ENDPOINT endpointAndDirection
1496:                    );
1497:                    
1498:                  Summary:
1499:                    This function cancels all IRPs that are queued and in progress at the
1500:                    specified endpoint.
1501:                	
1502:                  Description:
1503:                    This function cancels all IRPs that are queued and in progress at the
1504:                    specified endpoint.
1505:                	
1506:                  Remarks:
1507:                    Refer to usb_device_function_driver.h for usage information.                                                               
1508:                */
1509:                
1510:                USB_ERROR USB_DEVICE_IRPCancelAll 
1511:                (
1512:                    USB_DEVICE_HANDLE usbDeviceHandle,
1513:                    USB_ENDPOINT endpointAndDirection
1514:                )
1515:                {
1516:                    USB_DEVICE_OBJ* usbClientHandle;
1517:                    USB_ERROR result; 
1518:                
1519:                    /* Validate the handle */
1520:                    usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
1521:                
1522:                    if(usbClientHandle == NULL)
1523:                    {
1524:                       /* Handle is not valid */
1525:                       SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
1526:                       result = USB_ERROR_PARAMETER_INVALID; 
1527:                    }
1528:                    else
1529:                    {
1530:                        /* Cancel all IRPs pending on the Endpoint */
1531:                        result = usbClientHandle->driverInterface->deviceIRPCancelAll(usbClientHandle->usbCDHandle,endpointAndDirection); 
1532:                    }
1533:                    
1534:                    return result;  
1535:                }
1536:                
1537:                // **************************************************************************
1538:                /* Function:
1539:                    USB_ERROR USB_DEVICE_IRPCancel
1540:                	(
1541:                		USB_DEVICE_HANDLE usbDeviceHandle,
1542:                		USB_DEVICE_IRP * irp
1543:                	)
1544:                    
1545:                  Summary:
1546:                    This function cancels the specific IRP that are queued and in progress at the
1547:                    specified endpoint.
1548:                	
1549:                  Description:
1550:                    This function attempts to cancel the processing of a queued IRP. An IRP that
1551:                    was in the queue but yet to be processed will be cancelled successfully and
1552:                    the IRP callback function will be called from this function with the
1553:                    USB_DEVICE_IRP_STATUS_ABORTED status. The application can release the data
1554:                    buffer memory used by the IRP when this callback occurs.  If the IRP was in
1555:                    progress (a transaction in on the bus) when the cancel function was called,
1556:                    the IRP will be canceled only when an ongoing or the next transaction has
1557:                    completed. The IRP callback function will then be called in an interrupt
1558:                    context. The application should not release the related data buffer unless
1559:                    the IRP callback has occurred.
1560:                	
1561:                  Remarks:
1562:                    Refer to usb_device_function_driver.h for usage information.
1563:                                                                                  
1564:                */
1565:                
1566:                USB_ERROR USB_DEVICE_IRPCancel
1567:                (
1568:                    USB_DEVICE_HANDLE usbDeviceHandle, 
1569:                    USB_DEVICE_IRP * irp
1570:                )
1571:                {
1572:                    USB_DEVICE_OBJ* usbClientHandle;
1573:                    USB_ERROR result;
1574:                
1575:                    /* Validate the handle */
1576:                    usbClientHandle = _USB_DEVICE_ClientHandleValidate(usbDeviceHandle );
1577:                
1578:                    if(usbClientHandle == NULL)
1579:                    {
1580:                       /* Handle is not valid */
1581:                       SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid handle");
1582:                       result = USB_ERROR_PARAMETER_INVALID; 
1583:                    }
1584:                    else
1585:                    {
1586:                        /* Cancel IRP */
1587:                        result = usbClientHandle->driverInterface->deviceIRPCancel(usbClientHandle->usbCDHandle,irp); 
1588:                        
1589:                    }
1590:                  
1591:                    return result; 
1592:                }
1593:                // *****************************************************************************
1594:                // *****************************************************************************
1595:                // Section: USB Device Layer Local Functions
1596:                // *****************************************************************************
1597:                // *****************************************************************************
1598:                
1599:                // ******************************************************************************
1600:                /* Function:
1601:                    void _USB_DEVICE_Ep0ReceiveCompleteCallback( USB_DEVICE_IRP * handle )
1602:                
1603:                  Summary:
1604:                    Control receive complete callback.
1605:                
1606:                  Description:
1607:                    This callback is called when either data/SETUP packet is received
1608:                    on the control endpoint.
1609:                
1610:                  Remarks:
1611:                    This is local function. It should not be used directly by the client.
1612:                */
1613:                
1614:                void _USB_DEVICE_Ep0ReceiveCompleteCallback( USB_DEVICE_IRP * handle )
1615:                {
1616:                    USB_DEVICE_IRP * irpHandle = (USB_DEVICE_IRP *)handle;
1617:                    USB_DEVICE_OBJ * usbDeviceThisInstance;  
1618:                    USB_DEVICE_EVENT controlEvent = USB_DEVICE_EVENT_ERROR;
1619:                    USB_DEVICE_CONTROL_TRANSFER_STRUCT * controlTransfer;
1620:                    void * eventData = NULL;
1621:                
1622:                    /* If the IRP was aborted, there is nothing for us to do */
1623:                    if(irpHandle->status == USB_DEVICE_IRP_STATUS_ABORTED)
1624:                    {
1625:                        return;
1626:                    }
1627:                
1628:                    usbDeviceThisInstance = (USB_DEVICE_OBJ *)irpHandle->userData;
1629:                    controlTransfer = &usbDeviceThisInstance->controlTransfer;
1630:                
1631:                    /* Something is received on EP0. */
1632:                
1633:                    if(irpHandle->status == USB_DEVICE_IRP_STATUS_SETUP)
1634:                    {
1635:                        /* If we have received a SETUP packet, then abort any on-going control
1636:                         * transfer. Reset the control transfer handler back to the device layer
1637:                         * */
1638:                
1639:                        if(controlTransfer->inProgress )
1640:                        {
1641:                            /* Abort any previous transfer */
1642:                            if ( controlTransfer->handler != NULL)
1643:                            {
1644:                                if (controlTransfer->handler == (void (*)(unsigned short, USB_DEVICE_EVENT, void *))usbDeviceThisInstance->callBackFunc)
1645:                                {
1646:                                    /* If the Control transfer handler is Application callback
1647:                                     * for USB Device layer, then invoke the application
1648:                                     * callback function.  */
1649:                
1650:                                    usbDeviceThisInstance->callBackFunc(USB_DEVICE_EVENT_CONTROL_TRANSFER_ABORTED, NULL, usbDeviceThisInstance->context ); 
1651:                                }
1652:                                else
1653:                                {
1654:                                    /* This means the in progress control transfer was initiated
1655:                                     * by a function driver or the device layer it self. */
1656:                                    controlTransfer->handler(controlTransfer->handlerIndex, USB_DEVICE_EVENT_CONTROL_TRANSFER_ABORTED , NULL );
1657:                                }
1658:                            }
1659:                            else
1660:                            {
1661:                                SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Control transfer Handler is NULL" );
1662:                            }
1663:                        }
1664:                
1665:                        /* Mark the control transfer as "in progress". */
1666:                        controlTransfer->inProgress = true;
1667:                
1668:                        /* Now change the transfer handler back to USB device layer handler. We
1669:                         * need to send the SETUP packet event and the SETUP packet to the
1670:                         * device layer */
1671:                        controlTransfer->handler = &_USB_DEVICE_ControlTransferHandler;
1672:                        controlTransfer->handlerIndex = usbDeviceThisInstance->usbDevLayerIndex;
1673:                        controlEvent = USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST; 
1674:                        eventData = usbDeviceThisInstance->ep0RxBuffer;
1675:                
1676:                    }
1677:                    else if( irpHandle->size == 0)
1678:                    {
1679:                        /* ZLP received. This marks the completion of control transfer. Inform
1680:                         * the handler. */
1681:                        controlTransfer->inProgress = false;
1682:                        controlEvent = USB_DEVICE_EVENT_CONTROL_TRANSFER_DATA_SENT;
1683:                        eventData = NULL;
1684:                    }
1685:                    else if( irpHandle->size &&  controlTransfer->inProgress )
1686:                    {
1687:                        /* We are in the data stage of the control transfer.  See if the control
1688:                         * transfer handler was expecting the data. */
1689:                
1690:                        if(controlTransfer->rxDataCount <  controlTransfer->expectedRxDataCount)
1691:                        {
1692:                            /* Copy the RX buffer to control transfer handler given driver
1693:                             * buffer and advance the buffer. Continue the transfer  */
1694:                            memcpy(&usbDeviceThisInstance->controlTransfer.rxBuffer[controlTransfer->rxDataCount], usbDeviceThisInstance->ep0RxBuffer, irpHandle->size );
1695:                            controlTransfer->rxDataCount += irpHandle->size;
1696:                        }
1697:                        
1698:                        /* Now that we have received the data, check if the IRP is completed */
1699:                        if(controlTransfer->rxDataCount >=  controlTransfer->expectedRxDataCount)
1700:                        {
1701:                            /* We have received all the the data that we need. Send an event to
1702:                             * the upper layer */
1703:                            controlEvent = USB_DEVICE_EVENT_CONTROL_TRANSFER_DATA_RECEIVED;
1704:                            eventData = NULL;
1705:                        }
1706:                    }
1707:                
1708:                    if(controlEvent)
1709:                    {
1710:                        /* This means that some type of control transfer event needs to be sent
1711:                         * either to the the device layer or to the function driver or client
1712:                         * driver function driver layer. If a Setup packet was recieved, then
1713:                         * this will always go the device layer first. If this was a data stage
1714:                         * or handshake stage, then entity that was responsible for completing
1715:                         * the control transfer handles the events. */
1716:                
1717:                        if (controlTransfer->handler == (void (*)(unsigned short, USB_DEVICE_EVENT, void *))usbDeviceThisInstance->callBackFunc)
1718:                        {
1719:                            /* If the Control transfer handler is Application callback for USB Device layer,
1720:                             * then invoke the application callback function.  */
1721:                            usbDeviceThisInstance->callBackFunc(controlEvent, eventData, usbDeviceThisInstance->context ); 
1722:                        }
1723:                        else
1724:                        {
1725:                            /* Propagate the event to the control transfer handler */
1726:                            controlTransfer->handler(controlTransfer->handlerIndex, controlEvent , eventData);
1727:                        }
1728:                    }
1729:                
1730:                    usbDeviceThisInstance->irpEp0Rx.size = USB_DEVICE_EP0_BUFFER_SIZE;
1731:                
1732:                    /* Submit IRP to endpoint 0 to receive the next data packet. */
1733:                    (void)usbDeviceThisInstance->driverInterface->deviceIRPSubmit( usbDeviceThisInstance->usbCDHandle, controlEndpointRx , &usbDeviceThisInstance->irpEp0Rx);
1734:                }
1735:                
1736:                // ******************************************************************************
1737:                /* Function:
1738:                    void _USB_DEVICE_Ep0TransmitCompleteCallback( void * handle)
1739:                
1740:                  Summary:
1741:                    EP0 transmit complete callback.
1742:                
1743:                  Description:
1744:                    This function is called by the controller driver after the completing the
1745:                    EP0 transmit.
1746:                
1747:                  Returns:
1748:                    This is local function. It should not be used directly by the client.
1749:                */
1750:                
1751:                void _USB_DEVICE_Ep0TransmitCompleteCallback(USB_DEVICE_IRP * handle)
1752:                {
1753:                    USB_DEVICE_IRP * irpHandle = (USB_DEVICE_IRP *)handle;
1754:                    USB_DEVICE_OBJ * usbDeviceThisInstance;
1755:                    USB_DEVICE_CONTROL_TRANSFER_STRUCT * controlTransfer;
1756:                
1757:                    usbDeviceThisInstance = (USB_DEVICE_OBJ *)irpHandle->userData;
1758:                    controlTransfer = &(usbDeviceThisInstance->controlTransfer);
1759:                    
1760:                    if(irpHandle->status == USB_DEVICE_IRP_STATUS_ABORTED)
1761:                    {
1762:                        return;
1763:                    }
1764:                
1765:                    /* If the device layer had recieved the set address request from the host
1766:                     * and we have now recieved a transmit complete callback, then this means we
1767:                     * have completed the handshake stage of the callback function and now need
1768:                     * to set the device address. */ 
1769:                    if(usbDeviceThisInstance->usbDeviceStatusStruct.setAddressPending)
1770:                    {
1771:                        usbDeviceThisInstance->driverInterface->deviceAddressSet(usbDeviceThisInstance->usbCDHandle, usbDeviceThisInstance->deviceAddress);
1772:                        usbDeviceThisInstance->usbDeviceStatusStruct.setAddressPending = false;
1773:                        
1774:                        /* Update the USB Device state */
1775:                        usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_ADDRESSED;
1776:                    }
1777:                
1778:                    /* Or else, if the host had sent a request to enter test mode, we have
1779:                     * acknowledged that request and now should enter test mode. */
1780:                
1781:                    else if(usbDeviceThisInstance->usbDeviceStatusStruct.testModePending)
1782:                    {
1783:                        /* Set the flag to false and enter test mode */
1784:                        usbDeviceThisInstance->usbDeviceStatusStruct.testModePending = false;
1785:                        usbDeviceThisInstance->driverInterface->deviceTestModeEnter(usbDeviceThisInstance->usbCDHandle, (USB_TEST_MODE_SELECTORS)usbDeviceThisInstance->usbDeviceStatusStruct.testSelector );
1786:                    }
1787:                
1788:                    if(irpHandle->status == USB_DEVICE_IRP_STATUS_COMPLETED)
1789:                    {
1790:                        if( irpHandle->size == 0 )
1791:                        {
1792:                            controlTransfer->inProgress = false;
1793:                        }
1794:                    }
1795:                }
1796:                
1797:                // *****************************************************************************
1798:                /* Function:
1799:                    void _USB_DEVICE_DeInitializeAllFunctionDrivers
1800:                    (
1801:                        USB_DEVICE_OBJ * usbDeviceThisInstance
1802:                    )
1803:                
1804:                  Summary:
1805:                    De-initializes all function drivers that are presently loaded for the
1806:                    selected configuration.
1807:                
1808:                  Description:
1809:                    De initializes all function drivers that are presently loaded for the
1810:                    selected configuration.
1811:                
1812:                  Remarks
1813:                    This function is a local function and should not be called directly by the
1814:                    client.
1815:                */
1816:                
1817:                void _USB_DEVICE_DeInitializeAllFunctionDrivers
1818:                (
1819:                    USB_DEVICE_OBJ * usbDeviceThisInstance
1820:                )
1821:                {
1822:                    /* This function is called when device layer has detected a USB reset
1823:                     * signalling or when the host has set device configuration 0. */
1824:                
1825:                    uint8_t count = 0;
1826:                    USB_SPEED speed = usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed ;
1827:                    uint16_t configValue = usbDeviceThisInstance->activeConfiguration ;
1828:                    uint16_t maxFunctionCounts = usbDeviceThisInstance->registeredFuncDriverCount;
1829:                    USB_DEVICE_FUNCTION_REGISTRATION_TABLE * funcRegTable = usbDeviceThisInstance->registeredFuncDrivers;
1830:                    USB_DEVICE_FUNCTION_DRIVER * driver;
1831:                
1832:                    for(count = 0; count < maxFunctionCounts; count++ )
1833:                    {
1834:                        if( (funcRegTable->speed & speed) && (funcRegTable->configurationValue == configValue))
1835:                        {
1836:                            /* De initialize the function driver */
1837:                            driver = (USB_DEVICE_FUNCTION_DRIVER *)funcRegTable->driver;
1838:                            if (driver != NULL)
1839:                            {
1840:                                if(driver->deInitialize != NULL)
1841:                                {
1842:                                    /* Call the function driver deInitialize routine */
1843:                                    driver->deInitialize( funcRegTable->funcDriverIndex );
1844:                                }
1845:                            }           
1846:                        }
1847:                
1848:                        funcRegTable++;
1849:                    }
1850:                }
1851:                
1852:                // ******************************************************************************
1853:                /* Function:
1854:                    void _USB_DEVICE_EventHandler
1855:                    (
1856:                        uintptr_t referenceHandle,
1857:                        DRV_USB_EVENT eventType, 
1858:                        void * eventData
1859:                    )
1860:                
1861:                  Summary:
1862:                    Handles the events originating from the USB Controller driver.
1863:                
1864:                  Description:
1865:                    This function is registered into the USB Controller driver as a callback
1866:                    function. The USB Controller driver calls this function in case of events
1867:                    from the USB Controller driver.
1868:                    
1869:                  Remarks:
1870:                    This is a local function and should not be called directly by a client.
1871:                */
1872:                
1873:                void _USB_DEVICE_EventHandler
1874:                (
1875:                    uintptr_t referenceHandle,
1876:                    DRV_USB_EVENT eventType, 
1877:                    void * eventData
1878:                )
1879:                {
1880:                    USB_DEVICE_OBJ* usbDeviceThisInstance;
1881:                    USB_DEVICE_MASTER_DESCRIPTOR * ptrMasterDescTable;
1882:                    USB_DEVICE_EVENT_DATA_SOF SOFFrameNumber;
1883:                
1884:                    usbDeviceThisInstance = (USB_DEVICE_OBJ *)referenceHandle;
1885:                
1886:                    /* Handle events, only if this instance is in initialized state */
1887:                    if( usbDeviceThisInstance->usbDeviceInstanceState <= SYS_STATUS_UNINITIALIZED )
1888:                    {
1889:                        /* The device should anyway not be attached when the device layer is
1890:                         * not initialized. If we receive driver event when the device layer is
1891:                         * not initialized, there is nothing we can do but ignore them. */
1892:                        return;                
1893:                    }
1894:                
1895:                    switch(eventType)
1896:                    {
1897:                        case DRV_USB_EVENT_RESET_DETECT:
1898:                
1899:                            /* Clear the suspended state */
1900:                            usbDeviceThisInstance->usbDeviceStatusStruct.isSuspended = false;
1901:                
1902:                            /* Cancel any IRP already submitted in the RX direction. */
1903:                            usbDeviceThisInstance->driverInterface->deviceIRPCancelAll( usbDeviceThisInstance->usbCDHandle, controlEndpointRx );
1904:                
1905:                            /* Cancel any IRP already submitted in the TX direction. */
1906:                           usbDeviceThisInstance->driverInterface->deviceIRPCancelAll( usbDeviceThisInstance->usbCDHandle, controlEndpointTx );
1907:                
1908:                            /* Deinitialize all function drivers.*/
1909:                            _USB_DEVICE_DeInitializeAllFunctionDrivers ( usbDeviceThisInstance );
1910:                
1911:                            /* Disable all endpoints except for EP0.*/
1912:                            usbDeviceThisInstance->driverInterface->deviceEndpointDisable(usbDeviceThisInstance->usbCDHandle, DRV_USB_DEVICE_ENDPOINT_ALL);
1913:                
1914:                            /* Enable EP0 endpoint. Note that the driver will ignore the
1915:                             * direction because this is endpoint 0. */
1916:                            (void)usbDeviceThisInstance->driverInterface->deviceEndpointEnable( usbDeviceThisInstance->usbCDHandle, controlEndpointTx, USB_TRANSFER_TYPE_CONTROL, USB_DEVICE_EP0_BUFFER_SIZE);
1917:                
1918:                            if(usbDeviceThisInstance->irpEp0Rx.status <= USB_DEVICE_IRP_STATUS_SETUP)
1919:                            {
1920:                                /* Submit IRP to endpoint 0 to receive the setup packet */
1921:                                (void)usbDeviceThisInstance->driverInterface->deviceIRPSubmit( usbDeviceThisInstance->usbCDHandle, controlEndpointRx , &usbDeviceThisInstance->irpEp0Rx);
1922:                            }
1923:                
1924:                            /* Change device state to Default */
1925:                            usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_DEFAULT;
1926:                
1927:                            /* Reset means chirping has already happened. So, we must be knowing
1928:                               the speed. Get the speed and save it for future. */
1929:                            usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed = usbDeviceThisInstance->driverInterface->deviceCurrentSpeedGet(usbDeviceThisInstance->usbCDHandle);
1930:                
1931:                            /* Get the master descriptor table entry.*/
1932:                            ptrMasterDescTable = usbDeviceThisInstance->ptrMasterDescTable;
1933:                
1934:                            /* Now we know the speed. So for this speed get the pointer that
1935:                               points to correct group of configurations. */
1936:                            if( usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed == USB_SPEED_HIGH )
1937:                            {
1938:                                usbDeviceThisInstance->configDescriptorsPtr = ptrMasterDescTable->highSpeedConfigDescriptorTable;
1939:                
1940:                                /* Also get the max configurations available in this group.*/
1941:                                usbDeviceThisInstance->maxConfigs = ptrMasterDescTable->highSpeedConfigDescriptorCount;
1942:                            }
1943:                            else
1944:                            {
1945:                                /* Classic speeds (full/low speed) */
1946:                                usbDeviceThisInstance->configDescriptorsPtr = ptrMasterDescTable->configDescriptorTable;
1947:                
1948:                                /* Get the maximum configurations available in this group.*/
1949:                                usbDeviceThisInstance->maxConfigs = ptrMasterDescTable->configDescriptorCount;
1950:                            }
1951:                
1952:                            /* Invalidate the current active configuration */
1953:                            usbDeviceThisInstance->activeConfiguration = 0;
1954:                            break;
1955:                
1956:                        case DRV_USB_EVENT_RESUME_DETECT:
1957:                
1958:                            /* USB device resumed. Update the flag.*/
1959:                            usbDeviceThisInstance->usbDeviceStatusStruct.isSuspended = false;
1960:                            break;
1961:                
1962:                        case DRV_USB_EVENT_IDLE_DETECT:
1963:                
1964:                            /* USB Device is suspended */
1965:                            usbDeviceThisInstance->usbDeviceStatusStruct.isSuspended = true;
1966:                            break;        
1967:                
1968:                        case DRV_USB_EVENT_SOF_DETECT:
1969:                
1970:                            /* The _USB_DEVICE_SOFEventEnable() macro resolves to eventType 
1971:                             * events are enabled in system_config.h. If enabled the event
1972:                             * will sent to the application. Else the event will not be
1973:                             * processed. */
1974:                            eventType = _USB_DEVICE_SOFEventEnable(); 
1975:                            if (eventType)
1976:                            {
1977:                                eventType = (DRV_USB_EVENT)USB_DEVICE_EVENT_SOF;
1978:                                /* Get the frame number */
1979:                                SOFFrameNumber.frameNumber = usbDeviceThisInstance->driverInterface->deviceSOFNumberGet(usbDeviceThisInstance->usbCDHandle);
1980:                                eventData = &SOFFrameNumber;
1981:                            }
1982:                
1983:                            break;
1984:                
1985:                        case DRV_USB_EVENT_DEVICE_SESSION_VALID:
1986:                
1987:                            /* VBUS is valid.*/
1988:                            usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_ATTACHED;
1989:                            break;
1990:                
1991:                        case DRV_USB_EVENT_DEVICE_SESSION_INVALID:
1992:                
1993:                            /* VBUS is not valid. */ 
1994:                            usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_DETACHED;  
1995:                            break;
1996:                
1997:                        default:
1998:                            // Nothing to do for all other cases.
1999:                
2000:                            break;
2001:                    }
2002:                
2003:                    if(eventType)
2004:                    {
2005:                        /* Inform the client about the event */
2006:                        if((usbDeviceThisInstance->clientState == USB_DEVICE_CLIENT_STATUS_READY) && (usbDeviceThisInstance->callBackFunc != NULL))
2007:                        {
2008:                            /* This means this client is valid and is a client of this device
2009:                             * layer instance. Pass event to application */
2010:                            usbDeviceThisInstance->callBackFunc((USB_DEVICE_EVENT)eventType, eventData, usbDeviceThisInstance->context);
2011:                        }
2012:                    }
2013:                }    
2014:                
2015:                // ******************************************************************************
2016:                /* Function:
2017:                    void _USB_DEVICE_ControlTransferHandler
2018:                    (
2019:                        SYS_MODULE_INDEX handlerIndex,
2020:                        USB_DEVICE_CONTROL_TRANSFER_EVENT transferEvent,
2021:                        USB_DEVICE_CONTROL_TRANSFER_EVENT_DATA * eventData 
2022:                    )
2023:                
2024:                  Summary:
2025:                    Processes the SETUP packet received from the USB Controller driver.
2026:                
2027:                  Description:
2028:                    This function processes the SETUP packet received from the USB Controller 
2029:                    driver.
2030:                   
2031:                  Remarks:
2032:                    This is a local function and should not be called directly by the client.
2033:                */
2034:                
2035:                void  _USB_DEVICE_ControlTransferHandler
2036:                (    
2037:                    SYS_MODULE_INDEX handlerIndex,
2038:                    USB_DEVICE_EVENT transferEvent,
2039:                    void * eventData
2040:                )
2041:                {
2042:                    /* This function is called from _USB_DEVICE_Ep0ReceiveCompleteCallback
2043:                     * function when a Setup packet has been received. */
2044:                
2045:                    USB_DEVICE_OBJ * usbDeviceThisInstance = (USB_DEVICE_OBJ *)&usbDeviceInstance[handlerIndex];
2046:                    USB_SETUP_PACKET * setupPkt;
2047:                    uint8_t interfaceNumber = 0;
2048:                    USB_ENDPOINT endpointNumber;
2049:                    bool enpointFoundInDescriptors = false;
2050:                  
2051:                    if( transferEvent == USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST )
2052:                    {
2053:                        /* Get pointer to Setup Packet */ 
2054:                        setupPkt = (USB_SETUP_PACKET *)(eventData);
2055:                
2056:                        /* Get of Length of the Data Stage */
2057:                        usbDeviceThisInstance->controlTransferDataStageSize = setupPkt->wLength;
2058:                
2059:                        /* Cancel any IRP that is in the pipe. */
2060:                        usbDeviceThisInstance->driverInterface->deviceIRPCancelAll( usbDeviceThisInstance->usbCDHandle, controlEndpointTx );
2061:                        
2062:                        switch (setupPkt->Recipient)
2063:                        {
2064:                            case USB_SETUP_RECIPIENT_DEVICE:
2065:                                if (setupPkt->RequestType == USB_SETUP_REQUEST_TYPE_STANDARD)
2066:                                {
2067:                                    /* This is a standard Device Request */ 
2068:                                    if (setupPkt->DataDir == USB_SETUP_REQUEST_DIRECTION_HOST_TO_DEVICE)
2069:                                    {
2070:                                        /* Serve standard Device SET requests */
2071:                                        _USB_DEVICE_ProcessStandardDeviceSetRequests ( usbDeviceThisInstance, setupPkt );
2072:                                    }
2073:                                    else
2074:                                    {
2075:                                        /* Serve standard Device GET requests */
2076:                                        _USB_DEVICE_ProcessStandardDeviceGetRequests ( usbDeviceThisInstance, setupPkt );
2077:                                    }
2078:                                }
2079:                                else if (setupPkt->RequestType == USB_SETUP_REQUEST_TYPE_VENDOR)
2080:                                {
2081:                                    /* This is a SETUP request of Vendor type  to recipient
2082:                                     * Device. The device layer does not know how to Handle
2083:                                     * these requests. Forward this request to application. */
2084:                
2085:                                    _USB_DEVICE_RedirectControlXfrToClient (usbDeviceThisInstance, USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST, setupPkt);
2086:                                }
2087:                                else if (setupPkt->RequestType == USB_SETUP_REQUEST_TYPE_CLASS )
2088:                                {
2089:                                    /* This is a SETUP request of Type Class to recipient
2090:                                     * Device. */
2091:                
2092:                                    USB_DEVICE_ControlStatus ((USB_DEVICE_HANDLE)usbDeviceThisInstance, USB_DEVICE_CONTROL_STATUS_ERROR);
2093:                                }
2094:                                break;
2095:                
2096:                            case USB_SETUP_RECIPIENT_INTERFACE:
2097:                
2098:                                 /* Serve any requests that is not "standard" type and whose
2099:                                  * recipient is not "device". (Any request whose recipient is
2100:                                  * interface/endpoint must be handled by the function driver.
2101:                                  * This is because function driver has all the information
2102:                                  * about endpoint and interface) */				
2103:                				if (setupPkt->RequestType == USB_SETUP_REQUEST_TYPE_VENDOR)
2104:                				{
2105:                					_USB_DEVICE_VendorInterfaceRequestProcess(usbDeviceThisInstance, setupPkt->bIntfID,setupPkt); 
2106:                				}
2107:                				else
2108:                				{
2109:                					_USB_DEVICE_ForwardControlXfrToFunction(usbDeviceThisInstance, setupPkt->bIntfID,setupPkt ); 
2110:                				}
2111:                                break;
2112:                
2113:                            case USB_SETUP_RECIPIENT_ENDPOINT:
2114:                
2115:                                /* Retrieve Endpoint number from Setup Packet */
2116:                                endpointNumber = setupPkt->bEPID;
2117:                
2118:                                /* Any Control request to a Non Zero Endpoint should be Stalled
2119:                                 * if the Device is not in Configured State. The request will
2120:                                 * also be stalled if there is no descriptor available for this
2121:                                 * Endpoint */ 
2122:                
2123:                                if (endpointNumber != 0)
2124:                                {
2125:                                    /* Check if the Endpoint is present in the Descriptors. If
2126:                                     * yes find the interface number */
2127:                
2128:                                    enpointFoundInDescriptors = _USB_DEVICE_FindEndpoint( usbDeviceThisInstance, endpointNumber, &interfaceNumber);
2129:                                    if ((usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState != USB_DEVICE_STATE_CONFIGURED) ||(enpointFoundInDescriptors != true))
2130:                                    {
2131:                                        /* The Device should not service the Non Zero Endpoint
2132:                                         * request if the Device is not configured or the
2133:                                         * Endpoint is not present in descriptors. So stall this
2134:                                         * request.  */
2135:                
2136:                                        USB_DEVICE_ControlStatus ((USB_DEVICE_HANDLE)usbDeviceThisInstance, USB_DEVICE_CONTROL_STATUS_ERROR);
2137:                                        return;
2138:                                    }
2139:                                }
2140:                
2141:                                /* Program control reached here means that we have received an
2142:                                 * Endpoint request on a valid Endpoint Number. */
2143:                
2144:                                if (setupPkt->RequestType == USB_SETUP_REQUEST_TYPE_STANDARD)
2145:                                {
2146:                                    /* Standard Endpoint requests are handled by Device Layer */
2147:                                    _USB_DEVICE_ProcessStandardEndpointRequest( usbDeviceThisInstance, interfaceNumber, setupPkt);
2148:                                }
2149:                                else 
2150:                                {
2151:                                    /* This is Class or Vendor request. Forward the request to
2152:                                     * right Function driver or Client */ 
2153:                
2154:                                    _USB_DEVICE_ForwardControlXfrToFunction (usbDeviceThisInstance, interfaceNumber,setupPkt );
2155:                                   
2156:                                }
2157:                                break;
2158:                            
2159:                            case USB_SETUP_RECIPIENT_OTHER:
2160:                                
2161:                                /* This is a SETUP request of Type Vendor to recipient Device.
2162:                                 * The device layer does not know how to Handle these requests.
2163:                                 * Forward this request to application. */
2164:                
2165:                                _USB_DEVICE_RedirectControlXfrToClient( usbDeviceThisInstance, USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST, setupPkt);
2166:                                break;
2167:                               
2168:                            default: 
2169:                                SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Unknown Control Transfer received from Host" );
2170:                                break;
2171:                        }
2172:                    }   
2173:                }
2174:                
2175:                // *****************************************************************************
2176:                /* Function:
2177:                    void _USB_DEVICE_ForwardControlXfrToFunction 
2178:                    (
2179:                        USB_DEVICE_OBJ * usbDeviceThisInstance,
2180:                        uint8_t interfaceNumber,
2181:                        USB_SETUP_PACKET * setupPkt
2182:                    )
2183:                
2184:                  Summary:
2185:                    This function forwards control transfers to registred function drivers.
2186:                
2187:                  Description:
2188:                    This function Forwards control transfers to registred function drivers. If
2189:                    control handler fucntion callback is null, then the control transfer is
2190:                    forwarded to client.
2191:                
2192:                  Remarks:
2193:                    This is local function. It should not be used directly by the client.
2194:                */
2195:                
2196:                void _USB_DEVICE_ForwardControlXfrToFunction 
2197:                (
2198:                    USB_DEVICE_OBJ * usbDeviceThisInstance,
2199:                    uint8_t interfaceNumber,
2200:                    USB_SETUP_PACKET * setupPkt
2201:                )
2202:                {
2203:                    USB_DEVICE_FUNCTION_REGISTRATION_TABLE * lFuncDriverRegTable;
2204:                    USB_DEVICE_CONTROL_TRANSFER_STRUCT * controlTransfer = &usbDeviceThisInstance->controlTransfer;
2205:                    USB_DEVICE_FUNCTION_DRIVER * driver;
2206:                    
2207:                    /* This is a function driver /vendor specific setup packet. The recipient
2208:                     * field is either interface or other. Check which function driver has to
2209:                     * handle this setup packet. This function is called from Setup packet
2210:                     * handling function. We first find out which function driver owns this
2211:                     * interface.  */
2212:                    
2213:                    lFuncDriverRegTable = _USB_DEVICE_GetFunctionDriverEntryByInterface( interfaceNumber, usbDeviceThisInstance);
2214:                    if (lFuncDriverRegTable != NULL)
2215:                    {
2216:                        if (lFuncDriverRegTable->driver != NULL)
2217:                        {
2218:                            driver = (USB_DEVICE_FUNCTION_DRIVER *)(lFuncDriverRegTable->driver);
2219:                            if (driver->controlTransferNotification != NULL)
2220:                            {
2221:                                /* The interface number is owned by one of the registered
2222:                                 * function driver. Pass the SETUP packet to the function
2223:                                 * driver. */
2224:                
2225:                                /* Save the callback and index for future use.  Here we change
2226:                                 * the handler to function driver specific handler.  All further
2227:                                 * control transfer stage must be handled by the function driver
2228:                                 * control transfer handler.*/
2229:                
2230:                                controlTransfer->handler = (void (*)(unsigned short, USB_DEVICE_EVENT, void *))driver->controlTransferNotification;
2231:                
2232:                                controlTransfer->handlerIndex = lFuncDriverRegTable->funcDriverIndex;
2233:                
2234:                                /* Forward the SETUP packet to the function driver */
2235:                                controlTransfer->handler( controlTransfer->handlerIndex, USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST, setupPkt);
2236:                            }
2237:                            else
2238:                            {
2239:                                /* There is no valid control Transfer Notification Handler found
2240:                                 * in the Function registration Table. This control transfer
2241:                                 * will be handled by the client */
2242:                
2243:                                _USB_DEVICE_RedirectControlXfrToClient (usbDeviceThisInstance, USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST, setupPkt );
2244:                            }
2245:                        }
2246:                        else
2247:                        {
2248:                            /* If the driver member of the function driver registration table
2249:                             * entry is NULL, this means that the device layer client will
2250:                             * handle the control transfer. Forward the request to the device
2251:                             * layer client. */
2252:                
2253:                            _USB_DEVICE_RedirectControlXfrToClient (usbDeviceThisInstance, USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST, setupPkt );
2254:                        }
2255:                    }
2256:                    else
2257:                    {
2258:                        /* The interface number specified in the SETUP Packet does not belong to
2259:                         * any of the registered function driver. Host should not have sent this
2260:                         * request. STALL this request */
2261:                
2262:                        USB_DEVICE_ControlStatus((USB_DEVICE_HANDLE)usbDeviceThisInstance, USB_DEVICE_CONTROL_STATUS_ERROR);
2263:                    }
2264:                }
2265:                
2266:                // *****************************************************************************
2267:                /* Function:
2268:                    void _USB_DEVICE_ProcessStandardEndpointRequest
2269:                    (
2270:                        USB_DEVICE_OBJ * usbDeviceThisInstance,
2271:                        uint8_t interfaceNumber,
2272:                        USB_SETUP_PACKET * setupPkt
2273:                    )
2274:                
2275:                  Summary:
2276:                    This function handles standard Endpoint requests.
2277:                
2278:                  Description:
2279:                    This function handles standard Endpoint requests. 
2280:                
2281:                  Remarks:
2282:                    This is local function. It should not be used directly by the client.
2283:                */
2284:                
2285:                void _USB_DEVICE_ProcessStandardEndpointRequest
2286:                (
2287:                    USB_DEVICE_OBJ * usbDeviceThisInstance,
2288:                    uint8_t interfaceNumber,
2289:                    USB_SETUP_PACKET * setupPkt
2290:                )
2291:                {
2292:                    USB_ENDPOINT usbEndpoint;
2293:                    usbEndpoint = setupPkt->bEPID;
2294:                
2295:                    if( setupPkt->bRequest == USB_REQUEST_GET_STATUS )
2296:                    {
2297:                        /* This is an Endpoint Get Status request. Send the status to the host.
2298:                         * */
2299:                        usbDeviceThisInstance->getStatusResponse.status = 0x00;
2300:                        usbDeviceThisInstance->getStatusResponse.endPointHalt =  usbDeviceThisInstance->driverInterface->deviceEndpointIsStalled(usbDeviceThisInstance->usbCDHandle, usbEndpoint );
2301:                
2302:                        USB_DEVICE_ControlSend( (USB_DEVICE_HANDLE)usbDeviceThisInstance, (uint8_t *)&usbDeviceThisInstance->getStatusResponse, 2 );
2303:                    }
2304:                    else if( setupPkt->bRequest == USB_REQUEST_CLEAR_FEATURE )
2305:                    {
2306:                        if( setupPkt->wValue == USB_FEATURE_SELECTOR_ENDPOINT_HALT )
2307:                        {
2308:                            /* This means the host has requested for the stall condition on an
2309:                             * endpoint to be cleared. */
2310:                            usbDeviceThisInstance->driverInterface->deviceEndpointStallClear(usbDeviceThisInstance->usbCDHandle, usbEndpoint );
2311:                            USB_DEVICE_ControlStatus((USB_DEVICE_HANDLE)usbDeviceThisInstance, USB_DEVICE_CONTROL_STATUS_OK );
2312:                        }
2313:                    }
2314:                    else if (setupPkt->bRequest == USB_REQUEST_SET_FEATURE )
2315:                    {
2316:                        if( setupPkt->wValue == USB_FEATURE_SELECTOR_ENDPOINT_HALT )
2317:                        {
2318:                            /* This means the host has requested for an endpoint to be stalled
2319:                             * */
2320:                            usbEndpoint = setupPkt->bEPID;
2321:                            usbDeviceThisInstance->driverInterface->deviceEndpointStall(usbDeviceThisInstance->usbCDHandle, usbEndpoint );
2322:                            USB_DEVICE_ControlStatus((USB_DEVICE_HANDLE)usbDeviceThisInstance, USB_DEVICE_CONTROL_STATUS_OK );
2323:                        }
2324:                    }
2325:                    else if (setupPkt->bRequest == USB_REQUEST_SYNCH_FRAME)
2326:                    {
2327:                        /* Forward this request to Function driver. */
2328:                        _USB_DEVICE_Handle_Synch_Frame_Request(usbDeviceThisInstance, interfaceNumber, setupPkt);
2329:                    }
2330:                }
2331:                
2332:                // ******************************************************************************
2333:                /* Function:
2334:                    void _USB_DEVICE_ProcessStandardGetRequests
2335:                    (
2336:                        USB_DEVICE_OBJ * usbDeviceThisInstance,
2337:                        USB_SETUP_PACKET * setupPkt 
2338:                    )
2339:                
2340:                  Summary:
2341:                    Processes the standard "get" requests received from the USB Controller driver.
2342:                
2343:                  Description:
2344:                    This function processes the standard "get" requests received from the USB 
2345:                    Controller driver.
2346:                   
2347:                  Remarks:
2348:                    This is local function and should not be called directly by the client.
2349:                */
2350:                void _USB_DEVICE_ProcessStandardDeviceGetRequests
2351:                (
2352:                    USB_DEVICE_OBJ * usbDeviceThisInstance,
2353:                    USB_SETUP_PACKET * setupPkt 
2354:                )
2355:                {
2356:                    USB_CONFIGURATION_DESCRIPTOR * lConfigDescriptor = NULL;
2357:                    uint16_t size = 0;
2358:                    void*  pData = NULL;
2359:                    USB_DEVICE_MASTER_DESCRIPTOR * ptrMasterDescTable ;
2360:                    bool serviceGetRequest = true; 
2361:                
2362:                    /* Copy the Master descriptor table to a local pointer. */
2363:                    ptrMasterDescTable = usbDeviceThisInstance->ptrMasterDescTable ;
2364:                    
2365:                    if(setupPkt->bRequest == USB_REQUEST_GET_DESCRIPTOR)
2366:                    {
2367:                        switch(setupPkt->bDescriptorType)
2368:                        {
2369:                            case USB_DESCRIPTOR_DEVICE:
2370:                                if(usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed == USB_SPEED_HIGH)
2371:                                {
2372:                                    /* High speed descriptor. */
2373:                                    if( ptrMasterDescTable->highSpeedDeviceDescriptor == NULL )
2374:                                    {
2375:                                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: High speed device descriptor is NULL" );
2376:                                    }
2377:                
2378:                                    /* Pointer to high speed device descriptor.*/
2379:                                    pData = ( (uint8_t*) ptrMasterDescTable->highSpeedDeviceDescriptor );
2380:                                }
2381:                                else
2382:                                {
2383:                                    /* Full/low speed descriptor.*/
2384:                                    if( ptrMasterDescTable->deviceDescriptor == NULL )
2385:                                    {   
2386:                                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Full/Low speed device descriptor is NULL");
2387:                                    }
2388:                
2389:                                    /* Full/low speed device descriptor points usbDeviceThisInstance->ptrMasterDescTabler */
2390:                                    pData = ( (uint8_t*) ptrMasterDescTable->deviceDescriptor );
2391:                                }
2392:                
2393:                                /* Total size of the device descriptor (Its always 18). */
2394:                                size = 18;
2395:                                break;
2396:                
2397:                            case USB_DESCRIPTOR_CONFIGURATION:                
2398:                
2399:                                /* Get correct pointer to the descriptor based on config value.
2400:                                 * setupPkt->bDscIndex indicates the host requested
2401:                                 * configuration index.  Make sure that the requested
2402:                                 * configuration index is with in the limits.*/
2403:                
2404:                                if( (setupPkt->bDscIndex) < usbDeviceThisInstance->maxConfigs )
2405:                                {
2406:                                    lConfigDescriptor = (USB_CONFIGURATION_DESCRIPTOR *)usbDeviceThisInstance->configDescriptorsPtr[setupPkt->bDscIndex];
2407:                                    if(lConfigDescriptor != NULL )
2408:                                    {
2409:                                        /* We have a valid specified configuration. Prepare the
2410:                                         * output variables */
2411:                                        pData  = (uint8_t *)lConfigDescriptor;
2412:                                        size = lConfigDescriptor->wTotalLength;
2413:                                    }
2414:                                    else
2415:                                    {
2416:                                        /* Configuration not found */
2417:                                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid pointer to configuration descriptor");
2418:                                        pData = NULL;
2419:                                    }
2420:                                }
2421:                                break;
2422:                
2423:                            case USB_DESCRIPTOR_OTHER_SPEED: 
2424:                                /* Host has requested for the other speed descriptor. Other Speed 
2425:                                * Descriptor requests are handled differently. Respond to Other 
2426:                                * Speed configuration descriptor request only if USB peripheral is 
2427:                                * configured for High Speed operation. If the USB peripheral is 
2428:                                * configured for Full Speed operation then the request shall be 
2429:                                * stalled.*/
2430:                                if (usbDeviceThisInstance->usbDeviceStatusStruct.usbConfiguredSpeed == USB_SPEED_HIGH)
2431:                                {
2432:                                    /* Service Other Speed Configuration descriptor request. The 
2433:                                       function will respond to Host */
2434:                                    serviceGetRequest = false;
2435:                                    _USB_DEVICE_OtherSpeedDescriptorRequestService(usbDeviceThisInstance, setupPkt); 
2436:                                }
2437:                                else
2438:                                {
2439:                                    /* USB Peripheral is not configured for High Speed. The 
2440:                                     * request will be stalled. */
2441:                                    serviceGetRequest = true;
2442:                                }
2443:                                break; 
2444:                    
2445:                            case USB_DESCRIPTOR_DEVICE_QUALIFIER:
2446:                                /* Respond to Device Qualifier request only if USB peripheral is
2447:                                   configured for High Speed operation. If the peripheral is 
2448:                                   configured for Full Speed operation request shall be stalled.
2449:                                 */
2450:                                if (usbDeviceThisInstance->usbDeviceStatusStruct.usbConfiguredSpeed == USB_SPEED_HIGH)
2451:                                {
2452:                                    if( usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed == USB_SPEED_HIGH )
2453:                                    {
2454:                                        /* For high speed, respond with the other speed (full speed) device_qualifier. */
2455:                                        pData = (uint8_t*) ptrMasterDescTable->fullSpeedDeviceQualifier;
2456:                                    }
2457:                                    else
2458:                                    {
2459:                                        /* For full speed, respond with the other speed (high speed) device_qualifier. */
2460:                                        pData = ((uint8_t*) ptrMasterDescTable->highSpeedDeviceQualifier );
2461:                                    } 
2462:                
2463:                                    /* Size of device_qualifier descriptor is always 10. */
2464:                                    size = 10;
2465:                                }
2466:                                break;
2467:                
2468:                            case USB_DESCRIPTOR_STRING:
2469:                
2470:                                /* A string descriptor was requested */
2471:                                size = _USB_DEVICE_GetStringDescriptorRequest(ptrMasterDescTable, setupPkt, &pData );
2472:                                break;
2473:                
2474:                            case USB_DESCRIPTOR_BOS:
2475:                
2476:                                /* A BOS descriptor was requested */
2477:                                _USB_DEVICE_GetBosDescriptorRequest(ptrMasterDescTable->bosDescriptor, pData, size );
2478:                                break; 
2479:                
2480:                            default:
2481:                                break;
2482:                        } 
2483:                    }
2484:                    else if (setupPkt->bRequest == USB_REQUEST_GET_CONFIGURATION)
2485:                    {
2486:                        /* Host wants to know what is current configuration */
2487:                        pData = &(usbDeviceThisInstance->activeConfiguration);
2488:                        size = 1;
2489:                    }
2490:                    else if (setupPkt->bRequest == USB_REQUEST_GET_STATUS)
2491:                    {
2492:                        /* The host want to know the power status and remote wakeup status of
2493:                         * the device. */
2494:                        usbDeviceThisInstance->getStatusResponse.status = 0;
2495:                        usbDeviceThisInstance->getStatusResponse.selfPowered = usbDeviceThisInstance->usbDeviceStatusStruct.powerState;
2496:                        usbDeviceThisInstance->getStatusResponse.remoteWakeup = usbDeviceThisInstance->remoteWakeupStatus;
2497:                        pData = (uint8_t *)&usbDeviceThisInstance->getStatusResponse;
2498:                        size = 2;
2499:                    }
2500:                    
2501:                    if (serviceGetRequest == true)
2502:                    {
2503:                        if(pData == NULL)
2504:                        {
2505:                            /* We don't have valid data to send. STALL the transfer */
2506:                            USB_DEVICE_ControlStatus((USB_DEVICE_HANDLE)usbDeviceThisInstance, USB_DEVICE_CONTROL_STATUS_ERROR );
2507:                        }
2508:                        else
2509:                        {
2510:                            /* Limit the size. */
2511:                            if( size > setupPkt->wLength )
2512:                            {
2513:                                size = setupPkt->wLength;
2514:                            }
2515:                
2516:                            /* Send the data stage */
2517:                            USB_DEVICE_ControlSend( (USB_DEVICE_HANDLE)usbDeviceThisInstance, pData, size );
2518:                        }
2519:                    }
2520:                }
2521:                
2522:                // ******************************************************************************
2523:                /* Function:
2524:                    USB_DEVICE_FUNCTION_REGISTRATION_TABLE * _USB_DEVICE_GetFunctionDriverEntryByInterface
2525:                    (
2526:                        uint8_t interfaceNumber,
2527:                        USB_DEVICE_OBJ * usbDeviceThisInstance
2528:                    )
2529:                
2530:                  Summary:
2531:                    This function gets the correct entry in the function driver registration
2532:                    table for a given interface.
2533:                
2534:                  Description:
2535:                    This function gets the correct entry in the function driver registration
2536:                    table for a given interface.
2537:                
2538:                  Remarks:
2539:                    This is an internal function and should not be called directly by the client.
2540:                */
2541:                
2542:                USB_DEVICE_FUNCTION_REGISTRATION_TABLE * _USB_DEVICE_GetFunctionDriverEntryByInterface
2543:                (
2544:                    uint8_t interfaceNumber,
2545:                    USB_DEVICE_OBJ * usbDeviceThisInstance
2546:                )
2547:                {
2548:                    uint8_t count;
2549:                    uint16_t maxFunctionCounts = usbDeviceThisInstance->registeredFuncDriverCount;
2550:                    USB_DEVICE_FUNCTION_REGISTRATION_TABLE * funcRegTable = usbDeviceThisInstance->registeredFuncDrivers;
2551:                    uint8_t speed = usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed ;
2552:                    uint8_t configValue = usbDeviceThisInstance->activeConfiguration ;
2553:                
2554:                    /* This loop finds the function driver that owns this interface */
2555:                    for(count = 0; count < maxFunctionCounts; count++ )
2556:                    {
2557:                        if( (funcRegTable->speed & speed) && (funcRegTable->configurationValue == configValue)
2558:                                && ( interfaceNumber >= funcRegTable->interfaceNumber ) &&
2559:                                (interfaceNumber < ( funcRegTable->interfaceNumber + funcRegTable->numberOfInterfaces )))
2560:                        {
2561:                            return(funcRegTable);
2562:                        }
2563:                        funcRegTable++;
2564:                    }
2565:                
2566:                    return NULL;
2567:                }
2568:                
2569:                // ******************************************************************************
2570:                /* Function:
2571:                    void _USB_DEVICE_ConfigureDevice( USB_DEVICE_OBJ* usbDeviceThisInstance )
2572:                
2573:                  Summary:
2574:                    This function configures the device. 
2575:                
2576:                  Description:
2577:                    The initialization of all the function drivers and opening of all endpoints
2578:                    are done here.
2579:                
2580:                  Returns:
2581:                    This is a local function and should not be called directly by the
2582:                    application.
2583:                */
2584:                
2585:                void _USB_DEVICE_ConfigureDevice( USB_DEVICE_OBJ* usbDeviceThisInstance )
2586:                {
2587:                    uint16_t parsedLength= 0;
2588:                    uint16_t confTotalLength;
2589:                    uint8_t * pDescriptor = usbDeviceThisInstance->pActiveConfigDesc;
2590:                    uint8_t descriptorType;
2591:                    uint8_t interfaceNumber = 0;
2592:                    uint8_t alternateSetting = 0;
2593:                    USB_DEVICE_FUNCTION_REGISTRATION_TABLE * pFunctionRegTable = NULL;
2594:                    USB_DEVICE_FUNCTION_DRIVER * driver;
2595:                   
2596:                    confTotalLength = ((USB_CONFIGURATION_DESCRIPTOR *)pDescriptor)->wTotalLength;
2597:                
2598:                    /* Start parsing the configuration desciptor. For each interface descriptor
2599:                     * that was found, find out the owning function driver and then initialize
2600:                     * the function driver. */
2601:                
2602:                    while(parsedLength < confTotalLength)
2603:                    {
2604:                        descriptorType = ((USB_DEVICE_SERVICE_DESCRIPTOR_HEAD *)pDescriptor)->bDescriptorType;
2605:                        if(descriptorType == USB_DESCRIPTOR_INTERFACE)
2606:                        {
2607:                            /* If this descriptor was an interface, find out which function
2608:                             * driver owns this interface */ 
2609:                            pFunctionRegTable = NULL;
2610:                            interfaceNumber = ((USB_INTERFACE_DESCRIPTOR * )pDescriptor)->bInterfaceNumber;
2611:                            alternateSetting = ((USB_INTERFACE_DESCRIPTOR * )pDescriptor)->bAlternateSetting;
2612:                            pFunctionRegTable = _USB_DEVICE_GetFunctionDriverEntryByInterface(interfaceNumber , usbDeviceThisInstance);
2613:                        } 
2614:                
2615:                        if( pFunctionRegTable != NULL )
2616:                        {
2617:                            driver = (USB_DEVICE_FUNCTION_DRIVER *)(pFunctionRegTable->driver);
2618:                            
2619:                            if (driver != NULL)
2620:                            {
2621:                                /* Call the driver intialize by descriptor function. This will
2622:                                 * let the function driver know that it should start running and
2623:                                 * be initialized. */
2624:                                driver->initializeByDescriptor(pFunctionRegTable->funcDriverIndex, (USB_DEVICE_HANDLE)usbDeviceThisInstance,
2625:                                              pFunctionRegTable->funcDriverInit, interfaceNumber, alternateSetting, descriptorType, pDescriptor);
2626:                            }
2627:                        }
2628:                
2629:                        parsedLength += ((USB_DEVICE_SERVICE_DESCRIPTOR_HEAD *)pDescriptor)->bLength;
2630:                        pDescriptor += ((USB_DEVICE_SERVICE_DESCRIPTOR_HEAD *)pDescriptor)->bLength;
2631:                    }
2632:                }
2633:                
2634:                // ******************************************************************************
2635:                /* Function:
2636:                    bool _USB_DEVICE_FindEndpoint
2637:                    ( 
2638:                        USB_DEVICE_OBJ* usbDeviceThisInstance,
2639:                        USB_ENDPOINT endpointNumber, 
2640:                        uint8_t* interfaceNumber
2641:                    )
2642:                
2643:                  Summary:
2644:                    This function takes an Endpoint Number as a parameter and finds the Endpoint
2645:                    belongs to which Interface.
2646:                
2647:                  Description:
2648:                    This function takes an Endpoint Number as a parameter and finds the Endpoint
2649:                    belongs to which Interface. This function finds the interface by parsing the
2650:                    USB descriptors. This is a local function and should not be called by
2651:                    applications directly.
2652:                
2653:                  Parameters:
2654:                    usbDeviceThisInstance   - This instance of the USB device layer.
2655:                    endpointNumber          - Endpoint Number .
2656:                    interfaceNumber         - pointer to Interface Number. This is an out parameter.
2657:                    
2658:                
2659:                  Returns:
2660:                    true - Returns true if the Endpoint number belongs to any of the registered
2661:                           interfaces. True indicates that a valid interface is found and user
2662:                           can read the interface number from the interfaceNumber parameter.
2663:                    false -Endpoint does not belong to any registered interface.
2664:                */
2665:                
2666:                bool _USB_DEVICE_FindEndpoint
2667:                (
2668:                    USB_DEVICE_OBJ* usbDeviceThisInstance, 
2669:                    USB_ENDPOINT endpointNumber,
2670:                    uint8_t* interfaceNum
2671:                )
2672:                {
2673:                    uint16_t parsedLength= 0;
2674:                    uint16_t confTotalLength;
2675:                    uint8_t * pDescriptor = usbDeviceThisInstance->pActiveConfigDesc;
2676:                    uint8_t descriptorType;
2677:                
2678:                    confTotalLength = ((USB_CONFIGURATION_DESCRIPTOR *)pDescriptor)->wTotalLength;
2679:                
2680:                    /* Parse the configuration descriptor. When an endpoint descriptor is found,
2681:                     * check if the endpoint number matches the input endpoint number. */
2682:                    while(parsedLength < confTotalLength)
2683:                    {
2684:                        descriptorType = ((USB_DEVICE_SERVICE_DESCRIPTOR_HEAD *)pDescriptor)->bDescriptorType;
2685:                        if(descriptorType == USB_DESCRIPTOR_INTERFACE)
2686:                        {
2687:                            *(interfaceNum) = ((USB_INTERFACE_DESCRIPTOR *)pDescriptor)->bInterfaceNumber;
2688:                        }
2689:                        else if (descriptorType == USB_DESCRIPTOR_ENDPOINT)
2690:                        {
2691:                            if(endpointNumber == ((USB_ENDPOINT_DESCRIPTOR * )pDescriptor)->bEndpointAddress)
2692:                            {
2693:                                return true;
2694:                            }
2695:                        }
2696:                
2697:                        parsedLength += ((USB_DEVICE_SERVICE_DESCRIPTOR_HEAD *)pDescriptor)->bLength;
2698:                        pDescriptor += ((USB_DEVICE_SERVICE_DESCRIPTOR_HEAD *)pDescriptor)->bLength;
2699:                    }
2700:                
2701:                    return false;
2702:                }
2703:                
2704:                // ******************************************************************************
2705:                /* Function:
2706:                    void _USB_DEVICE_ProcessStandardSetRequests
2707:                    (
2708:                        USB_DEVICE_OBJ * usbDeviceThisInstance,
2709:                        USB_SETUP_PACKET * setupPkt
2710:                    )
2711:                
2712:                  Summary:
2713:                    Processes the standard "set" requests received from the USB Controller driver.
2714:                
2715:                  Description:
2716:                    This function processes the standard "set" requests received from the USB 
2717:                    Controller driver.
2718:                   
2719:                  Remarks:
2720:                    This is a local function and should not be called directly by the client.
2721:                */
2722:                
2723:                void _USB_DEVICE_ProcessStandardDeviceSetRequests
2724:                (
2725:                    USB_DEVICE_OBJ * usbDeviceThisInstance,
2726:                    USB_SETUP_PACKET * setupPkt
2727:                )
2728:                {   
2729:                    uint8_t count;
2730:                    USB_DEVICE_EVENT_DATA_CONFIGURED configuredEventData;
2731:                    USB_DEVICE_CONTROL_STATUS controlStatus = USB_DEVICE_CONTROL_STATUS_ERROR;
2732:                    bool sendStatus = true;
2733:                    
2734:                    switch(setupPkt->bRequest)
2735:                    {
2736:                        case USB_REQUEST_SET_ADDRESS:
2737:                
2738:                            /* Got set address command. Change the address only after responding
2739:                               to the current request.*/
2740:                            
2741:                            usbDeviceThisInstance->usbDeviceStatusStruct.setAddressPending = true;
2742:                            usbDeviceThisInstance->deviceAddress = setupPkt->bDevADR;
2743:                            controlStatus = USB_DEVICE_CONTROL_STATUS_OK;
2744:                            
2745:                            break;
2746:                
2747:                        case USB_REQUEST_SET_CONFIGURATION: 
2748:                
2749:                            /* Device falls back to addressed state if configuration value is 0,
2750:                             * and if the device is already in configured state. */
2751:                            
2752:                            if((setupPkt->wValue == 0) && (usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState == USB_DEVICE_STATE_CONFIGURED))
2753:                            {
2754:                                /* Configuration value 0 means, host is trying to de configure
2755:                                 * the device.  Set a event here. USB device layer task will
2756:                                 * de initialize the function drivers later.*/
2757:                                usbDeviceThisInstance->event = USB_DEVICE_EVENT_DECONFIGURED;
2758:                
2759:                                /* Deinit all function drivers. */
2760:                                _USB_DEVICE_DeInitializeAllFunctionDrivers ( usbDeviceThisInstance );
2761:                
2762:                                /* Change the current active configuration to Zero */
2763:                                usbDeviceThisInstance->activeConfiguration = 0;
2764:                
2765:                                /* Change the state to Addressed   */
2766:                                usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_ADDRESSED;
2767:                            }  
2768:                            else
2769:                            {
2770:                                /* Proceed only if new configuration value is different from
2771:                                 * current configuration value. */
2772:                                if( usbDeviceThisInstance->activeConfiguration != (uint8_t)setupPkt->wValue)
2773:                                {
2774:                                    for(count = 0; count < usbDeviceThisInstance->maxConfigs; count++)
2775:                                    {
2776:                                        /* 5th byte in the configuration descriptor table
2777:                                         * specifies the configuration value. */
2778:                
2779:                                        if( usbDeviceThisInstance->configDescriptorsPtr[count][5] == setupPkt->bConfigurationValue )
2780:                                        {
2781:                                            /* Got a configuration match. Get the pointer to
2782:                                             * configuration descriptor. We have to pass this to
2783:                                             * function driver, so that function driver can
2784:                                             * parse configuration descriptor and get the
2785:                                             * required info. */
2786:                
2787:                                            usbDeviceThisInstance->pActiveConfigDesc = (uint8_t *)usbDeviceThisInstance->configDescriptorsPtr[count];
2788:                                        }
2789:                                    }
2790:                
2791:                                    /* Save the current active configuration.  This may be
2792:                                     * required for clients to know which configuration is
2793:                                     * presently active. */
2794:                
2795:                                    usbDeviceThisInstance->activeConfiguration = (uint8_t)setupPkt->wValue;
2796:                
2797:                                    /* In case the endpoint functions are enabled for Vendor operation,
2798:                                     * the endpoint queue sizes need to reset. */
2799:                                    _USB_DEVICE_EndpointCurrentQueueSizeReset(usbDeviceThisInstance->usbDevLayerIndex);
2800:                
2801:                                    /* Initialize all function drivers and change to configured
2802:                                     * state only if all function drivers are initialized
2803:                                     * successfully. */
2804:                                    _USB_DEVICE_ConfigureDevice(usbDeviceThisInstance);
2805:                
2806:                                    /* Change the state to configured. */
2807:                                    usbDeviceThisInstance->usbDeviceStatusStruct.usbDeviceState = USB_DEVICE_STATE_CONFIGURED;
2808:                
2809:                                    /* Set an event, so that application and function drivers
2810:                                     * are informed  about the same. */
2811:                                    configuredEventData.configurationValue = (uint8_t)setupPkt->wValue;
2812:                
2813:                                    /* Inform the client about the event */
2814:                                    if((usbDeviceThisInstance->clientState == USB_DEVICE_CLIENT_STATUS_READY) &&
2815:                                            (usbDeviceThisInstance->callBackFunc != NULL))
2816:                                    {
2817:                                        /* This means this client is valid and is a client of this device
2818:                                           layer instance. Pass event to application */
2819:                                        usbDeviceThisInstance->callBackFunc (USB_DEVICE_EVENT_CONFIGURED, &configuredEventData, usbDeviceThisInstance->context);
2820:                                    }
2821:                                }
2822:                            }
2823:                            
2824:                            controlStatus = USB_DEVICE_CONTROL_STATUS_OK;
2825:                            break;
2826:                
2827:                         case  USB_REQUEST_CLEAR_FEATURE:
2828:                
2829:                            if( setupPkt->wValue == USB_FEATURE_SELECTOR_DEVICE_REMOTE_WAKEUP )
2830:                            {
2831:                                /* The host is disabling the remote wakeup capability */
2832:                                usbDeviceThisInstance->remoteWakeupStatus = USB_DEVICE_REMOTE_WAKEUP_DISABLED ;
2833:                                controlStatus = USB_DEVICE_CONTROL_STATUS_OK;
2834:                            }
2835:                            break;
2836:                
2837:                        case USB_REQUEST_SET_FEATURE:
2838:                
2839:                            if (setupPkt->wValue == USB_FEATURE_SELECTOR_DEVICE_REMOTE_WAKEUP)
2840:                            {
2841:                                usbDeviceThisInstance->remoteWakeupStatus = USB_DEVICE_REMOTE_WAKEUP_ENABLED;
2842:                                controlStatus = USB_DEVICE_CONTROL_STATUS_OK;
2843:                            }
2844:                            else if (setupPkt->wValue == USB_FEATURE_SELECTOR_DEVICE_TEST_MODE)
2845:                            {
2846:                                /* Enable test mode only if the Device Speed is High Speed */
2847:                                if (usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed == USB_SPEED_HIGH)
2848:                                {
2849:                                    /* Send ACK to the Test Mode request. */
2850:                                    controlStatus = USB_DEVICE_CONTROL_STATUS_OK;
2851:                
2852:                                    /* Save the Test Selector from SETUP Packet */
2853:                                    usbDeviceThisInstance->usbDeviceStatusStruct.testSelector = setupPkt->W_Index.byte.HB;
2854:                
2855:                                    /* Switching to Test mode is done in the
2856:                                     * _USB_DEVICE_EP0_TransmitComplete function. */
2857:                                    usbDeviceThisInstance->usbDeviceStatusStruct.testModePending = true;
2858:                                }
2859:                                else
2860:                                {
2861:                                    /* Device is not High Speed. STALL the request. */
2862:                                    controlStatus = USB_DEVICE_CONTROL_STATUS_ERROR;
2863:                                }
2864:                            }
2865:                            break;
2866:                
2867:                        case USB_REQUEST_SET_DESCRIPTOR:      
2868:                
2869:                            /* All SET_DESCRIPTOR requests are directly forwarded to application */
2870:                            _USB_DEVICE_Handle_Set_Descriptor_Request ( usbDeviceThisInstance, USB_DEVICE_EVENT_SET_DESCRIPTOR, setupPkt);
2871:                            controlStatus = USB_DEVICE_CONTROL_STATUS_ERROR;
2872:                            break;
2873:                
2874:                        default:
2875:                            /* Respond with a request error. Stall the endpoint. Stall the EP0
2876:                             * TX. */
2877:                            controlStatus = USB_DEVICE_CONTROL_STATUS_ERROR;
2878:                            break;
2879:                    }
2880:                
2881:                    /* Send ZLP */
2882:                    if (sendStatus)
2883:                    {
2884:                        USB_DEVICE_ControlStatus( (USB_DEVICE_HANDLE)usbDeviceThisInstance, controlStatus);
2885:                    }
2886:                }
2887:                
2888:                // ******************************************************************************
2889:                /* Function:
2890:                    void _USB_DEVICE_RedirectControlXfrToClient
2891:                    (
2892:                        USB_DEVICE_OBJ* usbDeviceThisInstance ,
2893:                        USB_DEVICE_EVENT event,
2894:                        USB_SETUP_PACKET * setupPkt
2895:                    )
2896:                
2897:                  Summary:
2898:                    This function forwards control transfers to client.
2899:                
2900:                  Description:
2901:                    This function forwards control transfers to client.
2902:                
2903:                  Remarks:
2904:                    This is local function. It should not be used directly by the client.
2905:                */
2906:                
2907:                void _USB_DEVICE_RedirectControlXfrToClient
2908:                (
2909:                    USB_DEVICE_OBJ* usbDeviceThisInstance ,
2910:                    USB_DEVICE_EVENT event,
2911:                    USB_SETUP_PACKET * setupPkt
2912:                )
2913:                {
2914:                    USB_DEVICE_CONTROL_TRANSFER_STRUCT * controlTransfer = &usbDeviceThisInstance->controlTransfer;
2915:                    
2916:                    /* This control transfer will be handled by the client */
2917:                    controlTransfer->handler = (void (*)(unsigned short, USB_DEVICE_EVENT, void *))usbDeviceThisInstance->callBackFunc;
2918:                
2919:                    controlTransfer->handlerIndex = usbDeviceThisInstance->usbDevLayerIndex ;
2920:                
2921:                    /* Let app clients handle the SETUP packet. */
2922:                    if((usbDeviceThisInstance->clientState == USB_DEVICE_CLIENT_STATUS_READY) && (usbDeviceThisInstance->callBackFunc != NULL))
2923:                    {
2924:                        /* This means this is a valid client. Pass the control transfer
2925:                         * event to the client. */
2926:                        usbDeviceThisInstance->callBackFunc( event, setupPkt, usbDeviceThisInstance->context );
2927:                    }
2928:                
2929:                }
2930:                
2931:                // ******************************************************************************
2932:                /* Function:
2933:                    USB_DEVICE_CLIENT_HANDLE _USB_DEVICE_ClientHandleValidate
2934:                    (
2935:                        USB_DEVICE_HANDLE deviceHandle
2936:                    )
2937:                
2938:                  Summary:
2939:                    Validates the client device handle.
2940:                
2941:                  Description:
2942:                    This function validates a device handle. It returns NULL if the device
2943:                    handle is not valid. It returns the pointer to the client object associated
2944:                    with the handle otherwise.
2945:                
2946:                  Remarks:
2947:                    This is a local function and should not be called directly by the client.
2948:                */
2949:                
2950:                USB_DEVICE_OBJ* _USB_DEVICE_ClientHandleValidate(USB_DEVICE_HANDLE deviceHandle)
2951:                {
2952:                    /* This function validates the client handle and return NULL if the client
2953:                       handle is invalid or if the client has closed the device layer. */
2954:                
2955:                    USB_DEVICE_OBJ* client;
2956:                
2957:                    if((USB_DEVICE_HANDLE_INVALID == deviceHandle) || (0 == deviceHandle))
2958:                    {
2959:                        return (NULL);
2960:                    }
2961:                
2962:                    /* Check if the client object is in use */
2963:                    client = (USB_DEVICE_OBJ *) deviceHandle;
2964:                
2965:                    if(!client->inUse)
2966:                    {
2967:                        return(NULL);
2968:                    }
2969:                
2970:                    /* Return the client handle */
2971:                    return(client);
2972:                }
2973:                
2974:                // ******************************************************************************
2975:                /* Function:
2976:                    void _USB_DEVICE_EndpointMutexCreateFunction
2977:                    (
2978:                        USB_DEVICE_OBJ* usbDeviceThisInstance
2979:                    )
2980:                
2981:                  Summary:
2982:                    Creats mutex which is required for Endpoint read write functions.
2983:                
2984:                  Description:
2985:                    Creats mutex which is required for Endpoint read write functions.
2986:                
2987:                  Remarks:
2988:                    This is a local function and should not be called directly by the client.
2989:                */
2990:                
2991:                void _USB_DEVICE_EndpointMutexCreateFunction(USB_DEVICE_OBJ* usbDeviceThisInstance)
2992:                {
2993:                    
2994:                    OSAL_RESULT osalResult;
2995:                    
2996:                    if (usbDeviceThisInstance->isMutexEndpointIrpInitialized == false)
2997:                    {
2998:                        /* Use the OSAL to create Mutex */
2999:                        osalResult = OSAL_MUTEX_Create(&(usbDeviceThisInstance->mutexEndpointIRP));
3000:                    
3001:                    
3002:                        if(osalResult != OSAL_RESULT_TRUE)
3003:                        {
3004:                            /* Mutex creation failed*/
3005:                            usbDeviceThisInstance->isMutexEndpointIrpInitialized = false;
3006:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Mutex Create Failed");
3007:                        }
3008:                        else
3009:                        {
3010:                            /* Update the flag indicating that the Mutex has been created */
3011:                            usbDeviceThisInstance->isMutexEndpointIrpInitialized = true;
3012:                        }
3013:                    }
3014:                }
3015:                
3016:                // ******************************************************************************
3017:                /* Function:
3018:                    void _USB_DEVICE_EndpointMutexDeleteFunction
3019:                    (
3020:                        USB_DEVICE_OBJ* usbDeviceThisInstance
3021:                    )
3022:                
3023:                  Summary:
3024:                    Deletes mutex which is required for Endpoint read write functions.
3025:                
3026:                  Description:
3027:                    Deletes mutex which is required for Endpoint read write functions.
3028:                
3029:                  Remarks:
3030:                    This is a local function and should not be called directly by the client.
3031:                */
3032:                
3033:                void _USB_DEVICE_EndpointMutexDeleteFunction(USB_DEVICE_OBJ* usbDeviceThisInstance)
3034:                {
3035:                    OSAL_RESULT osalResult;
3036:                
3037:                    /* Use the OSAL to delete the Mutex */
3038:                    osalResult = OSAL_MUTEX_Delete(&(usbDeviceThisInstance->mutexEndpointIRP));
3039:                
3040:                    if(osalResult != OSAL_RESULT_TRUE)
3041:                    {
3042:                        /* Mutex delete failed */
3043:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Mutex Delete Failed");
3044:                    }
3045:                    else
3046:                    {
3047:                        /* Update the flag indicating that the mutex needs to be created again
3048:                         * */
3049:                        usbDeviceThisInstance->isMutexEndpointIrpInitialized = false;
3050:                    }
3051:                }
3052:                
3053:                // ******************************************************************************
3054:                /* Function:
3055:                    uint16_t _USB_DEVICE_GetStringDescriptorRequestProcess
3056:                    (
3057:                        USB_DEVICE_MASTER_DESCRIPTOR * ptrMasterDescTable,
3058:                        USB_SETUP_PACKET * setupPkt,
3059:                        void**  pDescriptorString
3060:                    )
3061:                  Summary:
3062:                    This function processes the Get Descriptor request received from Host.
3063:                
3064:                  Description:
3065:                    This function processes the Get Descriptor request received from Host.
3066:                    The USB Device Layer chooses this function when the macro
3067:                    USB_DEVICE_STRING_DESCRIPTOR_TABLE_ADVANCED_ENABLE is not defined.
3068:                
3069:                    This function is implemented based on the following String Descriptor 
3070:                    Table structure. 
3071:                    
3072:                    Following example assumes the Device supports 3 String Descriptors in 3 
3073:                    different Languages. 
3074:                    
3075:                        String Descriptor Index 0 -- Specifies Codes for all the Language 
3076:                                                     supported. 
3077:                        String -- Index 1 -- Language 1
3078:                        String -- Index 2 -- Language 1
3079:                        String -- Index 3 -- Language 1
3080:                        String -- Index 1 -- Language 2
3081:                        String -- Index 2 -- Language 2
3082:                        String -- Index 3 -- Language 2
3083:                        String -- Index 1 -- Language 3
3084:                        String -- Index 2 -- Language 3
3085:                        String -- Index 3 -- Language 3 
3086:                
3087:                  Remarks:
3088:                    This is a local function and should not be called directly by the client.
3089:                */
3090:                
3091:                uint16_t _USB_DEVICE_GetStringDescriptorRequestProcess
3092:                (
3093:                    USB_DEVICE_MASTER_DESCRIPTOR * ptrMasterDescTable,
3094:                    USB_SETUP_PACKET * setupPkt,
3095:                    void**  pDescriptorString
3096:                )
3097:                {
3098:                    uint8_t* stringDesc;
3099:                    uint8_t NumberLangSupported =0;
3100:                    uint16_t langID;
3101:                    uint16_t langIndex;
3102:                    uint16_t CurrentLangId;
3103:                    uint8_t stringIndex;
3104:                    uint16_t DescriptorStringSize = 0;
3105:                
3106:                    /* Get the string descriptor index from setup packet*/
3107:                    stringIndex = setupPkt->bDscIndex;
3108:                    uint8_t stringDescPerLang =0; 
3109:                    
3110:                    /* Find Number Languages supported from String Descriptor array index 0 */
3111:                    NumberLangSupported = (uint8_t)((ptrMasterDescTable->stringDescriptorTable[0][0]) - 2)/2;   
3112:                    
3113:                    if (NumberLangSupported)
3114:                    {
3115:                        /* Get Number of Strings per Language */
3116:                        stringDescPerLang = (ptrMasterDescTable->stringDescCount - 1)/NumberLangSupported; 
3117:                    }
3118:                    
3119:                    /* Check if the String Index requested by Host is with in the String
3120:                     * descriptor count specified in the Master descriptor Table */ 
3121:                
3122:                    if(setupPkt->bDscIndex <= stringDescPerLang)
3123:                    {
3124:                        /* This means the index is valid. Get correct string
3125:                         * descriptor and update the response variable */
3126:                
3127:                        if (stringIndex == 0)
3128:                        {
3129:                            /* Get pointer to String Descriptor */ 
3130:                            stringDesc = (uint8_t*)(ptrMasterDescTable->stringDescriptorTable[0] );
3131:                            *pDescriptorString = (uint8_t *)stringDesc;
3132:                
3133:                            /* Get Size of the String descriptor. Size is always the First
3134:                             * element in the String descriptor structure  */  
3135:                            DescriptorStringSize = stringDesc[0];
3136:                        }
3137:                        else
3138:                        {
3139:                            /* Retrieve Language ID from SETUP packet */
3140:                            langID = setupPkt->wLangID;
3141:                
3142:                            /* Search through the String Descriptor Array (Index Zero) to find
3143:                             * out Language ID Index*/
3144:                            for (langIndex = 1; langIndex <= NumberLangSupported; langIndex++)
3145:                            {
3146:                                /* Get the Language ID from String Descriptor Index 0 */ 
3147:                                CurrentLangId = *((uint16_t*)ptrMasterDescTable->stringDescriptorTable[0] + langIndex);
3148:                
3149:                                /* Check if the requested Language ID same as Current Language ID */ 
3150:                                if (CurrentLangId == langID)
3151:                                {
3152:                                    /* The Requested String Descriptor and Language was found.
3153:                                     * Get pointer to String Descriptor */ 
3154:                                    stringDesc = (uint8_t*)( ptrMasterDescTable->stringDescriptorTable[langIndex*stringIndex] );
3155:                                    *pDescriptorString = (uint8_t *)stringDesc;
3156:                                    
3157:                                    /* Get Size of the String descriptor. Size is always the
3158:                                     * First element in the String descriptor structure  */
3159:                                    DescriptorStringSize = stringDesc[0];
3160:                                    break;
3161:                                }
3162:                            }
3163:                        }
3164:                
3165:                        return DescriptorStringSize;
3166:                    }
3167:                
3168:                    /* We could not find the requested String Descriptor in the String 
3169:                       Descriptor Table. The request will be stalled. */  
3170:                    
3171:                    return 0; 
3172:                }
3173:                
3174:                // ******************************************************************************
3175:                /* Function:
3176:                    uint16_t _USB_DEVICE_GetStringDescriptorRequestProcessAdvanced
3177:                    (
3178:                        USB_DEVICE_MASTER_DESCRIPTOR * ptrMasterDescTable,
3179:                        USB_SETUP_PACKET * setupPkt,
3180:                        void**  pDescriptorString
3181:                    )
3182:                
3183:                  Summary:
3184:                    This function processes the Get Descriptor request received from Host.
3185:                
3186:                  Description:
3187:                    This function processes the Get Descriptor request received from Host.
3188:                    The USB Device Layer chooses this function when the macro
3189:                    USB_DEVICE_STRING_DESCRIPTOR_TABLE_ADVANCED_ENABLE is defined.
3190:                
3191:                    This function is implemented based on the following String Descriptor 
3192:                    Table structure. 
3193:                    
3194:                            |Size(Byte)|Type(Byte)|String Index 0(Byte)|0(Word)|Language ID 1(Word)|Language ID 2(Word)|...|Language ID n(Word)|
3195:                            |Size(Byte)|Type(Byte)|String Index x(Byte)|Language ID 1(Word)|String |
3196:                            |Size(Byte)|Type(Byte)|String Index x(Byte)|Language ID 1(Word)|String |
3197:                            .
3198:                            .
3199:                            .
3200:                            |Size(Byte)|Type(Byte)|String Index x(Byte)|Language ID n(Word)|String |
3201:                
3202:                  Remarks:
3203:                    This is a local function and should not be called directly by the client.
3204:                */
3205:                
3206:                uint16_t _USB_DEVICE_GetStringDescriptorRequestProcessAdvanced
3207:                (
3208:                    USB_DEVICE_MASTER_DESCRIPTOR * ptrMasterDescTable,
3209:                    USB_SETUP_PACKET * setupPkt,
3210:                    void**  pDescriptorString
3211:                )
3212:                {
3213:                    uint8_t* stringDesc;
3214:                    uint16_t langID;
3215:                    uint8_t stringIndexRequested;
3216:                    uint16_t DescriptorStringSize = 0;
3217:                    uint8_t count;
3218:                    uint8_t stringIndex;
3219:                     
3220:                     /* Get the string descriptor index from setup packet*/
3221:                    stringIndexRequested = setupPkt->bDscIndex;
3222:                
3223:                    if (stringIndexRequested == 0)
3224:                    {
3225:                        /* Get pointer to String Descriptor */ 
3226:                        stringDesc = (uint8_t*)&(ptrMasterDescTable->stringDescriptorTable[0][3] );
3227:                        *pDescriptorString = (uint8_t *)stringDesc;
3228:                
3229:                        /* Get Size of the String descriptor. Size is always the First element
3230:                         * in the String descriptor structure  */ 
3231:                
3232:                        DescriptorStringSize = stringDesc[0];
3233:                    }
3234:                    else
3235:                    {
3236:                        for (count = 1; count < ptrMasterDescTable->stringDescCount; count++ )
3237:                        {
3238:                            /* Get the string index from the String Descriptor.  String Index is
3239:                             * always the third element in the String Descriptor */  
3240:                            
3241:                            stringIndex = ptrMasterDescTable->stringDescriptorTable[count][0];
3242:                            
3243:                            /* Get Language ID from the string descriptor. Language ID is always
3244:                             * the Fourth element in the String Descriptor */ 
3245:                            
3246:                            langID = ((uint16_t)ptrMasterDescTable->stringDescriptorTable[count][2]<<8)
3247:                                               |ptrMasterDescTable->stringDescriptorTable[count][1];
3248:                
3249:                            /* Check if the Requested String Index and Language ID matches with
3250:                             * the values retrieved from String Descriptor */  
3251:                
3252:                            if ((stringIndex == stringIndexRequested) && (langID == setupPkt->wLangID))
3253:                            {
3254:                                    /* The Requested String Descriptor and Language was found.
3255:                                     * Get pointer to String Descriptor */ 
3256:                
3257:                                    stringDesc = (uint8_t*)&( ptrMasterDescTable->stringDescriptorTable[count][3] );
3258:                                    *pDescriptorString = (uint8_t *)stringDesc;
3259:                                    
3260:                                    /* Get Size of the String descriptor. Size is always the
3261:                                     * First element in the String descriptor structure  */
3262:                
3263:                                    DescriptorStringSize = stringDesc[0];
3264:                                    break;
3265:                            }
3266:                        }
3267:                    }
3268:                
3269:                    /* Return String descriptor size. USB device layer would stall the request
3270:                     * if the requested string descriptor was not found. If requested string was
3271:                     * not found the DescriptorStringSize would be zero and pDescriptorString
3272:                     * would be NULL.  */  
3273:                
3274:                    return DescriptorStringSize;
3275:                }
3276:                
3277:                // ******************************************************************************
3278:                /* Function:
3279:                    void _USB_DEVICE_Other_Speed_Descriptor_Request
3280:                    (
3281:                        USB_DEVICE_OBJ * usbDeviceThisInstance, 
3282:                        USB_SETUP_PACKET * setupPkt
3283:                    )
3284:                
3285:                  Summary:
3286:                    This function processes the Get Other Speed Configuration descriptor request
3287:                    from Host.
3288:                
3289:                  Description:
3290:                    This function processes the Get Other Speed Configuration descriptor request
3291:                    from Host. This function should be called only if the USB peripheral is 
3292:                    configured for High Speed operation. 
3293:                 
3294:                  Remarks:
3295:                    This is a local function and should not be called directly by the client.
3296:                */
3297:                void _USB_DEVICE_Other_Speed_Descriptor_Request
3298:                (
3299:                    USB_DEVICE_OBJ * usbDeviceThisInstance, 
3300:                    USB_SETUP_PACKET * setupPkt
3301:                )
3302:                {
3303:                    USB_CONFIGURATION_DESCRIPTOR * lConfigDescriptor = NULL;
3304:                    USB_DEVICE_MASTER_DESCRIPTOR * ptrMasterDescTable ;
3305:                    uint32_t size; 
3306:                    uint32_t pendingBytesOtherSpeedDescptr = 0; 
3307:                    
3308:                    /* Copy the Master descriptor table to a local pointer. */
3309:                    ptrMasterDescTable = usbDeviceThisInstance->ptrMasterDescTable ;
3310:                    
3311:                    /* Find out whether device is operating at full speed or high speed */
3312:                    if( usbDeviceThisInstance->usbDeviceStatusStruct.usbSpeed == USB_SPEED_HIGH )
3313:                    {
3314:                        if (((setupPkt->bDscIndex) < ptrMasterDescTable->configDescriptorCount) && (ptrMasterDescTable->configDescriptorTable != NULL))
3315:                        {
3316:                            /* If the Device is operating at High Speed, we send the full speed 
3317:                             * configuration descriptor */ 
3318:                            lConfigDescriptor = (USB_CONFIGURATION_DESCRIPTOR *)ptrMasterDescTable->configDescriptorTable[setupPkt->bDscIndex];
3319:                        }
3320:                    }
3321:                    else
3322:                    {
3323:                        if (((setupPkt->bDscIndex) < ptrMasterDescTable->highSpeedConfigDescriptorCount)
3324:                            && (ptrMasterDescTable->highSpeedConfigDescriptorTable != NULL))
3325:                        {
3326:                            /* If the device is operating at full speed, then send the high speed 
3327:                             * configuration descriptor */
3328:                            lConfigDescriptor = (USB_CONFIGURATION_DESCRIPTOR *)ptrMasterDescTable->highSpeedConfigDescriptorTable[setupPkt->bDscIndex];
3329:                        }
3330:                    }
3331:                
3332:                    if(lConfigDescriptor != NULL )
3333:                    { 
3334:                        /* Get the descriptor size */
3335:                        size = lConfigDescriptor->wTotalLength;
3336:                             
3337:                        /* Adjust data size as Host request */
3338:                        if( size > setupPkt->wLength )
3339:                        {
3340:                            
3341:                            size = setupPkt->wLength;  
3342:                        }
3343:                        
3344:                        /* Update IRP flag to complete the transfer initially */
3345:                        _USB_DEVICE_OtherSpeedDescriptorRequestIrpFlagsUpdate
3346:                        (
3347:                            &(usbDeviceThisInstance->irpEp0TxOtherSpeedDescriptor), 
3348:                            USB_DEVICE_IRP_FLAG_DATA_COMPLETE
3349:                        ); 
3350:                        
3351:                        /* We may have to submit two IRPs for the Other Speed Configuration 
3352:                           descriptor request. The Second IRP is only needed if the data size 
3353:                           requested by the Host is more than USB_DEVICE_EP0_BUFFER_SIZE. */
3354:                        if (size > USB_DEVICE_EP0_BUFFER_SIZE)
3355:                        {
3356:                            /* Update Pending Bytes. This data will go in the Second IRP */
3357:                            pendingBytesOtherSpeedDescptr = size - USB_DEVICE_EP0_BUFFER_SIZE;
3358:                            
3359:                            /* In the First IRP we will submit only EP0 Buffer Size worth of 
3360:                             * data. Remaining Bytes will be sent in the Second IRP */
3361:                            size = USB_DEVICE_EP0_BUFFER_SIZE; 
3362:                            
3363:                            /* Keep the IRP flags pending as we are going to submit another IRP. */
3364:                            _USB_DEVICE_OtherSpeedDescriptorRequestIrpFlagsUpdate
3365:                            (
3366:                                &(usbDeviceThisInstance->irpEp0TxOtherSpeedDescriptor), 
3367:                                USB_DEVICE_IRP_FLAG_DATA_PENDING
3368:                            );    
3369:                        }
3370:                        
3371:                        /* Copy Data into the EP0 Transmit buffer */
3372:                        _USB_DEVICE_OtherSpeedDescriptorRequestCopyData
3373:                        (
3374:                            usbDeviceThisInstance->ep0TxBuffer,
3375:                            lConfigDescriptor,
3376:                            size
3377:                        );
3378:                        
3379:                        /* Edit Descriptor type to OTHER_SPEED */
3380:                        _USB_DEVICE_OtherSpeedDescriptorRequestEditDescriptorType
3381:                        (
3382:                            usbDeviceThisInstance->ep0TxBuffer,
3383:                            1,
3384:                            USB_DESCRIPTOR_OTHER_SPEED
3385:                        ); 
3386:                        
3387:                        if (pendingBytesOtherSpeedDescptr == 0)
3388:                        {
3389:                            /* Fill in the Other Speed Descriptor IRP. */ 
3390:                            _USB_DEVICE_OtherSpeedDescriptorRequestIrpFill
3391:                            (
3392:                                &(usbDeviceThisInstance->irpEp0TxOtherSpeedDescriptor),
3393:                                usbDeviceThisInstance->ep0TxBuffer,
3394:                                size,
3395:                                _USB_DEVICE_Ep0TransmitCompleteCallback,
3396:                                (uintptr_t)usbDeviceThisInstance
3397:                            ); 
3398:                            
3399:                             /* Submit IRP */
3400:                            _USB_DEVICE_OtherSpeedDescriptorRequestIrpSubmit(usbDeviceThisInstance->usbCDHandle, controlEndpointTx, &usbDeviceThisInstance->irpEp0TxOtherSpeedDescriptor ); 
3401:                        }
3402:                        else
3403:                        {
3404:                            /* This means we have to submit two IRPs */   
3405:                            if (pendingBytesOtherSpeedDescptr % USB_DEVICE_EP0_BUFFER_SIZE == 0)
3406:                            {
3407:                                _USB_DEVICE_OtherSpeedDescriptorRequestIrpFlagsUpdate
3408:                                (
3409:                                    &(usbDeviceThisInstance->irpEp0Tx), 
3410:                                    USB_DEVICE_IRP_FLAG_DATA_PENDING
3411:                                ); 
3412:                            }
3413:                            else
3414:                            {
3415:                                _USB_DEVICE_OtherSpeedDescriptorRequestIrpFlagsUpdate
3416:                                (
3417:                                    &(usbDeviceThisInstance->irpEp0Tx), 
3418:                                    USB_DEVICE_IRP_FLAG_DATA_COMPLETE
3419:                                );
3420:                            }
3421:                            
3422:                            /* Fill in the Other Speed Descriptor IRP. Callback is NULL here. We
3423:                               do not want to be notified for first IRP */ 
3424:                            _USB_DEVICE_OtherSpeedDescriptorRequestIrpFill
3425:                            (
3426:                                &(usbDeviceThisInstance->irpEp0TxOtherSpeedDescriptor),
3427:                                usbDeviceThisInstance->ep0TxBuffer,
3428:                                size,
3429:                                NULL,
3430:                                (uintptr_t)usbDeviceThisInstance
3431:                            ); 
3432:                            
3433:                            /* Submit the first IRP */
3434:                            _USB_DEVICE_OtherSpeedDescriptorRequestIrpSubmit(usbDeviceThisInstance->usbCDHandle, controlEndpointTx, &usbDeviceThisInstance->irpEp0TxOtherSpeedDescriptor ); 
3435:                            
3436:                            /* Fill in the Second IRP for the pending data */
3437:                            _USB_DEVICE_OtherSpeedDescriptorRequestIrpFill
3438:                            (
3439:                                &(usbDeviceThisInstance->irpEp0Tx), 
3440:                                ((uint8_t*)lConfigDescriptor + USB_DEVICE_EP0_BUFFER_SIZE),
3441:                                pendingBytesOtherSpeedDescptr,
3442:                                _USB_DEVICE_Ep0TransmitCompleteCallback,
3443:                                (uintptr_t)usbDeviceThisInstance
3444:                            );   
3445:                       
3446:                            /* Submit second IRP */
3447:                            _USB_DEVICE_OtherSpeedDescriptorRequestIrpSubmit(usbDeviceThisInstance->usbCDHandle, controlEndpointTx, &usbDeviceThisInstance->irpEp0Tx); 
3448:                        }
3449:                        
3450:                    }
3451:                    else
3452:                    {
3453:                        /* Configuration not found */
3454:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Layer: Invalid pointer to configuration descriptor");
3455:                    }
3456:                }
3457:                
3458:                /********************End of file********************************/
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
00000024  00000000   NOP
00000028  00000000   NOP
0000002C  00000000   NOP
00000030  00000000   NOP
00000034  00000000   NOP
00000038  00000000   NOP
0000003C  00000000   NOP
00000040  00000000   NOP
00000044  00000000   NOP
00000048  00000000   NOP
0000004C  00000000   NOP
00000050  00000000   NOP
00000054  00000000   NOP
00000058  00000000   NOP
0000005C  00000000   NOP
00000060  00000000   NOP
00000064  00000000   NOP
00000068  00000000   NOP
0000006C  00000000   NOP
00000074  00000000   NOP
00000078  00000000   NOP
0000007C  00000000   NOP
00000080  00000000   NOP
00000084  00000000   NOP
00000088  00000000   NOP
0000008C  00000000   NOP
00000090  00000000   NOP
00000094  00000000   NOP
00000098  00000000   NOP
0000009C  00000000   NOP
000000A0  00000000   NOP
9D00B190  2482FFFF   ADDIU V0, A0, -1
9D00B194  2C42FFFE   SLTIU V0, V0, -2
9D00B1A0  908200DC   LBU V0, 220(A0)
9D00B1AC  8C8200EC   LW V0, 236(A0)
9D00B1B0  27BDFFE8   ADDIU SP, SP, -24
9D00B1B4  AFB00010   SW S0, 16(SP)
9D00B1B8  8C42001C   LW V0, 28(V0)
9D00B1BC  00808025   OR S0, A0, ZERO
9D00B1C0  8C84001C   LW A0, 28(A0)
9D00B1C4  AFBF0014   SW RA, 20(SP)
9D00B1C8  0040F809   JALR V0
9D00B1CC  00000000   NOP
9D00B1D0  96030000   LHU V1, 0(S0)
9D00B1D4  92020003   LBU V0, 3(S0)
9D00B1D8  7C035284   INS V1, ZERO, 10, 1
9D00B1DC  7C021004   INS V0, ZERO, 0, 3
9D00B1E0  A6030000   SH V1, 0(S0)
9D00B1E4  A2020003   SB V0, 3(S0)
9D00B1E8  8FBF0014   LW RA, 20(SP)
9D00B1EC  8FB00010   LW S0, 16(SP)
9D00B1F0  03E00008   JR RA
9D00B1F4  27BD0018   ADDIU SP, SP, 24
9D00B1F8  03E00008   JR RA
9D00B1FC  00000000   NOP
9D0107B0  2402000E   ADDIU V0, ZERO, 14
9D0107B4  10A20003   BEQ A1, V0, 0x9D0107C4
9D0107B8  00000000   NOP
9D0107BC  03E00008   JR RA
9D0107C0  00000000   NOP
9D0107C4  27BDFFD8   ADDIU SP, SP, -40
9D0107C8  AFB40020   SW S4, 32(SP)
9D0107CC  0004A100   SLL S4, A0, 4
9D0107D0  AFB00010   SW S0, 16(SP)
9D0107D4  02848023   SUBU S0, S4, A0
9D0107D8  00108080   SLL S0, S0, 2
9D0107DC  AFB3001C   SW S3, 28(SP)
9D0107E0  02048021   ADDU S0, S0, A0
9D0107E4  3C13A000   LUI S3, -24576
9D0107E8  00108080   SLL S0, S0, 2
9D0107EC  26732978   ADDIU S3, S3, 10616
9D0107F0  AFB20018   SW S2, 24(SP)
9D0107F4  AFB10014   SW S1, 20(SP)
9D0107F8  AFBF0024   SW RA, 36(SP)
9D0107FC  02708021   ADDU S0, S3, S0
9D010800  90C20007   LBU V0, 7(A2)
9D010804  8E0300EC   LW V1, 236(S0)
9D010808  90C50006   LBU A1, 6(A2)
9D01080C  00809025   OR S2, A0, ZERO
9D010810  8C630040   LW V1, 64(V1)
9D010814  8E04001C   LW A0, 28(S0)
9D010818  00021200   SLL V0, V0, 8
9D01081C  00451025   OR V0, V0, A1
9D010820  00C08825   OR S1, A2, ZERO
9D010824  A60200E8   SH V0, 232(S0)
9D010828  0060F809   JALR V1
9D01082C  24050080   ADDIU A1, ZERO, 128
9D010830  92270000   LBU A3, 0(S1)
9D010834  24040001   ADDIU A0, ZERO, 1
9D010838  7CE22000   EXT V0, A3, 0, 5
9D01083C  304300FF   ANDI V1, V0, 255
9D010840  10640055   BEQ V1, A0, 0x9D010998
9D010844  7C021420   SEB V0, V0
9D010848  1040003A   BEQ V0, ZERO, 0x9D010934
9D01084C  24020002   ADDIU V0, ZERO, 2
9D010850  1062001D   BEQ V1, V0, 0x9D0108C8
9D010854  24020003   ADDIU V0, ZERO, 3
9D010858  5062000A   BEQL V1, V0, 0x9D010884
9D01085C  8E1900E0   LW T9, 224(S0)
9D010860  8FBF0024   LW RA, 36(SP)
9D010864  8FB40020   LW S4, 32(SP)
9D010868  8FB3001C   LW S3, 28(SP)
9D01086C  8FB20018   LW S2, 24(SP)
9D010870  8FB10014   LW S1, 20(SP)
9D010874  8FB00010   LW S0, 16(SP)
9D010878  03E00008   JR RA
9D01087C  27BD0028   ADDIU SP, SP, 40
9D010880  8E1900E0   LW T9, 224(S0)
9D010884  96030018   LHU V1, 24(S0)
9D010888  8E0200D8   LW V0, 216(S0)
9D01088C  AE1900D0   SW T9, 208(S0)
9D010890  1444FFF3   BNE V0, A0, 0x9D010860
9D010894  A60300C8   SH V1, 200(S0)
9D010898  1320FFF1   BEQ T9, ZERO, 0x9D010860
9D01089C  8FBF0024   LW RA, 36(SP)
9D0108A0  8E0600E4   LW A2, 228(S0)
9D0108A4  02202825   OR A1, S1, ZERO
9D0108A8  8FB40020   LW S4, 32(SP)
9D0108AC  8FB3001C   LW S3, 28(SP)
9D0108B0  8FB20018   LW S2, 24(SP)
9D0108B4  8FB10014   LW S1, 20(SP)
9D0108B8  8FB00010   LW S0, 16(SP)
9D0108BC  2404000E   ADDIU A0, ZERO, 14
9D0108C0  03200008   JR T9
9D0108C4  27BD0028   ADDIU SP, SP, 40
9D0108C8  92250004   LBU A1, 4(S1)
9D0108CC  50A00049   BEQL A1, ZERO, 0x9D0109F4
9D0108D0  30E70060   ANDI A3, A3, 96
9D0108D4  8E0300B4   LW V1, 180(S0)
9D0108D8  90680003   LBU T0, 3(V1)
9D0108DC  90620002   LBU V0, 2(V1)
9D0108E0  00084200   SLL T0, T0, 8
9D0108E4  01024025   OR T0, T0, V0
9D0108E8  11000058   BEQ T0, ZERO, _USB_DEVICE_ControlTransferHandler::USB_DEVICE_ControlStatus
9D0108EC  00005825   OR T3, ZERO, ZERO
9D0108F0  00001025   OR V0, ZERO, ZERO
9D0108F4  24090004   ADDIU T1, ZERO, 4
9D0108F8  10000009   BEQ ZERO, ZERO, 0x9D010920
9D0108FC  240A0005   ADDIU T2, ZERO, 5
9D010900  508A0030   BEQL A0, T2, _USB_DEVICE_ControlTransferHandler::_USB_DEVICE_FindEndpoint
9D010904  90640002   LBU A0, 2(V1)
9D010908  90640000   LBU A0, 0(V1)
9D01090C  00441021   ADDU V0, V0, A0
9D010910  3042FFFF   ANDI V0, V0, -1
9D010914  0048302B   SLTU A2, V0, T0
9D010918  10C0004C   BEQ A2, ZERO, _USB_DEVICE_ControlTransferHandler::USB_DEVICE_ControlStatus
9D01091C  00641821   ADDU V1, V1, A0
9D010920  90640001   LBU A0, 1(V1)
9D010924  1489FFF6   BNE A0, T1, _USB_DEVICE_ControlTransferHandler::_USB_DEVICE_FindEndpoint
9D010928  00000000   NOP
9D01092C  1000FFF6   BEQ ZERO, ZERO, 0x9D010908
9D010930  906B0002   LBU T3, 2(V1)
9D010934  92220000   LBU V0, 0(S1)
9D010938  30430060   ANDI V1, V0, 96
9D01093C  10600038   BEQ V1, ZERO, 0x9D010A20
9D010940  7C021420   SEB V0, V0
9D010944  24020040   ADDIU V0, ZERO, 64
9D010948  1062FFCD   BEQ V1, V0, _USB_DEVICE_ControlTransferHandler::_USB_DEVICE_RedirectControlXfrToClient
9D01094C  24020020   ADDIU V0, ZERO, 32
9D010950  1462FFC4   BNE V1, V0, 0x9D010864
9D010954  8FBF0024   LW RA, 36(SP)
9D010958  920200DC   LBU V0, 220(S0)
9D010964  8E0200EC   LW V0, 236(S0)
9D010968  8E04001C   LW A0, 28(S0)
9D01096C  A20000C4   SB ZERO, 196(S0)
9D010970  8FBF0024   LW RA, 36(SP)
9D010974  8FB40020   LW S4, 32(SP)
9D010978  8FB3001C   LW S3, 28(SP)
9D01097C  8FB20018   LW S2, 24(SP)
9D010980  8FB10014   LW S1, 20(SP)
9D010984  8FB00010   LW S0, 16(SP)
9D010988  8C590028   LW T9, 40(V0)
9D01098C  24050080   ADDIU A1, ZERO, 128
9D010990  03200008   JR T9
9D010994  27BD0028   ADDIU SP, SP, 40
9D010998  92250004   LBU A1, 4(S1)
9D01099C  02203025   OR A2, S1, ZERO
9D0109A0  02002025   OR A0, S0, ZERO
9D0109A4  8FBF0024   LW RA, 36(SP)
9D0109A8  8FB40020   LW S4, 32(SP)
9D0109AC  8FB3001C   LW S3, 28(SP)
9D0109B0  8FB20018   LW S2, 24(SP)
9D0109B4  8FB10014   LW S1, 20(SP)
9D0109B8  8FB00010   LW S0, 16(SP)
9D0109BC  0B4057F0   J _USB_DEVICE_ForwardControlXfrToFunction
9D0109C0  27BD0028   ADDIU SP, SP, 40
9D0109C4  5485FFD1   BNEL A0, A1, 0x9D01090C
9D0109C8  90640000   LBU A0, 0(V1)
9D0109CC  02921023   SUBU V0, S4, S2
9D0109D0  00021080   SLL V0, V0, 2
9D0109D4  00521021   ADDU V0, V0, S2
9D0109D8  00021080   SLL V0, V0, 2
9D0109DC  02621021   ADDU V0, S3, V0
9D0109E0  90420003   LBU V0, 3(V0)
9D0109E4  30420007   ANDI V0, V0, 7
9D0109E8  144A0018   BNE V0, T2, _USB_DEVICE_ControlTransferHandler::USB_DEVICE_ControlStatus
9D0109EC  01602825   OR A1, T3, ZERO
9D0109F0  30E70060   ANDI A3, A3, 96
9D0109F4  02203025   OR A2, S1, ZERO
9D0109F8  14E0FFEA   BNE A3, ZERO, 0x9D0109A4
9D0109FC  02002025   OR A0, S0, ZERO
9D010A00  8FBF0024   LW RA, 36(SP)
9D010A04  8FB40020   LW S4, 32(SP)
9D010A08  8FB3001C   LW S3, 28(SP)
9D010A0C  8FB20018   LW S2, 24(SP)
9D010A10  8FB10014   LW S1, 20(SP)
9D010A14  8FB00010   LW S0, 16(SP)
9D010A18  0B4050A1   J _USB_DEVICE_ProcessStandardEndpointRequest
9D010A1C  27BD0028   ADDIU SP, SP, 40
9D010A20  02202825   OR A1, S1, ZERO
9D010A24  04400015   BLTZ V0, 0x9D010A7C
9D010A28  02002025   OR A0, S0, ZERO
9D010A2C  8FBF0024   LW RA, 36(SP)
9D010A30  8FB40020   LW S4, 32(SP)
9D010A34  8FB3001C   LW S3, 28(SP)
9D010A38  8FB20018   LW S2, 24(SP)
9D010A3C  8FB10014   LW S1, 20(SP)
9D010A40  8FB00010   LW S0, 16(SP)
9D010A44  0B4046DE   J _USB_DEVICE_ProcessStandardDeviceSetRequests
9D010A48  27BD0028   ADDIU SP, SP, 40
9D010A4C  0292A023   SUBU S4, S4, S2
9D010A60  926200DC   LBU V0, 220(S3)
9D010A6C  8E6200EC   LW V0, 236(S3)
9D010A70  8E64001C   LW A0, 28(S3)
9D010A74  1000FFBE   BEQ ZERO, ZERO, 0x9D010970
9D010A78  A26000C4   SB ZERO, 196(S3)
9D010A7C  8FBF0024   LW RA, 36(SP)
9D010A80  8FB40020   LW S4, 32(SP)
9D010A84  8FB3001C   LW S3, 28(SP)
9D010A88  8FB20018   LW S2, 24(SP)
9D010A8C  8FB10014   LW S1, 20(SP)
9D010A90  8FB00010   LW S0, 16(SP)
9D010A94  0B4047EA   J _USB_DEVICE_ProcessStandardDeviceGetRequests
9D010A98  27BD0028   ADDIU SP, SP, 40
9D010A9C  27BDFFD8   ADDIU SP, SP, -40
9D010AA0  AFB1001C   SW S1, 28(SP)
9D010D34  8C820008   LW V0, 8(A0)
9D010D38  18400034   BLEZ V0, 0x9D010E0C
9D010D3C  00000000   NOP
9D010D40  27BDFFD8   ADDIU SP, SP, -40
9D010D44  2CA2000A   SLTIU V0, A1, 10
9D010D48  AFB20020   SW S2, 32(SP)
9D010D4C  AFB1001C   SW S1, 28(SP)
9D010D50  AFB00018   SW S0, 24(SP)
9D010D54  AFBF0024   SW RA, 36(SP)
9D010D58  00808025   OR S0, A0, ZERO
9D010D5C  00A08825   OR S1, A1, ZERO
9D010D60  10400012   BEQ V0, ZERO, __jend__USB_DEVICE_EventHandler_273
9D010D64  00C09025   OR S2, A2, ZERO
9D010D68  3C029D01   LUI V0, -25343
9D010D6C  00051880   SLL V1, A1, 2
9D010D70  24420D84   ADDIU V0, V0, 3460
9D010D74  00431021   ADDU V0, V0, V1
9D010D78  8C420000   LW V0, 0(V0)
9D010D7C  00400008   JR V0
9D010D80  00000000   NOP
9D010DAC  5620000C   BNEL S1, ZERO, 0x9D010DE0
9D010DB4  8FBF0024   LW RA, 36(SP)
9D010DB8  8FB20020   LW S2, 32(SP)
9D010DBC  8FB1001C   LW S1, 28(SP)
9D010DC0  8FB00018   LW S0, 24(SP)
9D010DC4  03E00008   JR RA
9D010DC8  27BD0028   ADDIU SP, SP, 40
9D010DCC  94820000   LHU V0, 0(A0)
9D010DD0  24030001   ADDIU V1, ZERO, 1
9D010DD4  7C625284   INS V0, V1, 10, 1
9D010DD8  A4820000   SH V0, 0(A0)
9D010DDC  8E0300D8   LW V1, 216(S0)
9D010DE0  24020001   ADDIU V0, ZERO, 1
9D010DE4  1462FFF4   BNE V1, V0, 0x9D010DB8
9D010DE8  8FBF0024   LW RA, 36(SP)
9D010DEC  8E0200E0   LW V0, 224(S0)
9D010DF0  1040FFF0   BEQ V0, ZERO, 0x9D010DB4
9D010DF4  02402825   OR A1, S2, ZERO
9D010DF8  8E0600E4   LW A2, 228(S0)
9D010DFC  0040F809   JALR V0
9D010E00  02202025   OR A0, S1, ZERO
9D010E04  1000FFEC   BEQ ZERO, ZERO, 0x9D010DB8
9D010E08  8FBF0024   LW RA, 36(SP)
9D010E0C  03E00008   JR RA
9D010E10  00000000   NOP
9D010E14  94820000   LHU V0, 0(A0)
9D010E18  8C8300EC   LW V1, 236(A0)
9D010E1C  8C84001C   LW A0, 28(A0)
9D010E20  7C025284   INS V0, ZERO, 10, 1
9D010E24  A6020000   SH V0, 0(S0)
9D010E28  8C620040   LW V0, 64(V1)
9D010E2C  0040F809   JALR V0
9D010E30  00002825   OR A1, ZERO, ZERO
9D010E34  8E0200EC   LW V0, 236(S0)
9D010E38  8E04001C   LW A0, 28(S0)
9D010E3C  8C420040   LW V0, 64(V0)
9D010E40  0040F809   JALR V0
9D010E44  24050080   ADDIU A1, ZERO, 128
9D010E48  0F405976   JAL _USB_DEVICE_DeInitializeAllFunctionDrivers
9D010E4C  02002025   OR A0, S0, ZERO
9D010E50  8E0200EC   LW V0, 236(S0)
9D010E54  8E04001C   LW A0, 28(S0)
9D010E58  8C420024   LW V0, 36(V0)
9D010E5C  0040F809   JALR V0
9D010E60  24050010   ADDIU A1, ZERO, 16
9D010E64  8E0200EC   LW V0, 236(S0)
9D010E68  8E04001C   LW A0, 28(S0)
9D010E6C  24070040   ADDIU A3, ZERO, 64
9D010E70  8C420020   LW V0, 32(V0)
9D010E74  00003025   OR A2, ZERO, ZERO
9D010E78  0040F809   JALR V0
9D010E7C  24050080   ADDIU A1, ZERO, 128
9D010E80  8E020090   LW V0, 144(S0)
9D010E84  28420003   SLTI V0, V0, 3
9D010E88  50400008   BEQL V0, ZERO, 0x9D010EAC
9D010E8C  92020003   LBU V0, 3(S0)
9D010E90  8E0200EC   LW V0, 236(S0)
9D010E94  8E04001C   LW A0, 28(S0)
9D010E98  26060088   ADDIU A2, S0, 136
9D010E9C  8C420038   LW V0, 56(V0)
9D010EA0  0040F809   JALR V0
9D010EA4  00002825   OR A1, ZERO, ZERO
9D010EA8  92020003   LBU V0, 3(S0)
9D010EAC  8E0300EC   LW V1, 236(S0)
9D010EB0  24040003   ADDIU A0, ZERO, 3
9D010EB4  7C821004   INS V0, A0, 0, 3
9D010EB8  A2020003   SB V0, 3(S0)
9D010EBC  8C620010   LW V0, 16(V1)
9D010EC0  0040F809   JALR V0
9D010EC4  8E04001C   LW A0, 28(S0)
9D010EC8  96030000   LHU V1, 0(S0)
9D010ECC  24050002   ADDIU A1, ZERO, 2
9D010ED0  8E04000C   LW A0, 12(S0)
9D010ED4  7C431844   INS V1, V0, 1, 3
9D010ED8  3062000E   ANDI V0, V1, 14
9D010EDC  1045002F   BEQ V0, A1, 0x9D010F9C
9D010EE0  A6030000   SH V1, 0(S0)
9D010EE4  8C820008   LW V0, 8(A0)
9D010EE8  AE0200B0   SW V0, 176(S0)
9D010EEC  90820004   LBU V0, 4(A0)
9D010EF0  A20000AD   SB ZERO, 173(S0)
9D010EF4  A20200AE   SB V0, 174(S0)
9D010EF8  8E0300D8   LW V1, 216(S0)
9D010EFC  24020001   ADDIU V0, ZERO, 1
9D010F00  1462FFAD   BNE V1, V0, 0x9D010DB8
9D010F04  8FBF0024   LW RA, 36(SP)
9D010F08  1000FFB9   BEQ ZERO, ZERO, 0x9D010DF0
9D010F0C  8E0200E0   LW V0, 224(S0)
9D010F10  94820000   LHU V0, 0(A0)
9D010F14  7C025284   INS V0, ZERO, 10, 1
9D010F18  A4820000   SH V0, 0(A0)
9D010F1C  8E0300D8   LW V1, 216(S0)
9D010F20  24020001   ADDIU V0, ZERO, 1
9D010F24  1462FFA4   BNE V1, V0, 0x9D010DB8
9D010F28  8FBF0024   LW RA, 36(SP)
9D010F2C  1000FFB0   BEQ ZERO, ZERO, 0x9D010DF0
9D010F30  8E0200E0   LW V0, 224(S0)
9D010F34  90820003   LBU V0, 3(A0)
9D010F38  24030001   ADDIU V1, ZERO, 1
9D010F3C  7C621004   INS V0, V1, 0, 3
9D010F40  A0820003   SB V0, 3(A0)
9D010F44  8E0300D8   LW V1, 216(S0)
9D010F48  24020001   ADDIU V0, ZERO, 1
9D010F4C  1462FF9A   BNE V1, V0, 0x9D010DB8
9D010F50  8FBF0024   LW RA, 36(SP)
9D010F54  1000FFA6   BEQ ZERO, ZERO, 0x9D010DF0
9D010F58  8E0200E0   LW V0, 224(S0)
9D010F5C  90820003   LBU V0, 3(A0)
9D010F60  7C021004   INS V0, ZERO, 0, 3
9D010F64  A0820003   SB V0, 3(A0)
9D010F68  8E0300D8   LW V1, 216(S0)
9D010F6C  24020001   ADDIU V0, ZERO, 1
9D010F70  1462FF91   BNE V1, V0, 0x9D010DB8
9D010F74  8FBF0024   LW RA, 36(SP)
9D010F78  1000FF9D   BEQ ZERO, ZERO, 0x9D010DF0
9D010F7C  8E0200E0   LW V0, 224(S0)
9D010F80  8C8200EC   LW V0, 236(A0)
9D010F84  8C84001C   LW A0, 28(A0)
9D010F88  8C420014   LW V0, 20(V0)
9D010F8C  0040F809   JALR V0
9D010F90  27B20010   ADDIU S2, SP, 16
9D010F94  1000FF91   BEQ ZERO, ZERO, 0x9D010DDC
9D010F98  A7A20010   SH V0, 16(SP)
9D010F9C  8C820014   LW V0, 20(A0)
9D010FA0  AE0200B0   SW V0, 176(S0)
9D010FA4  90820010   LBU V0, 16(A0)
9D010FA8  A20000AD   SB ZERO, 173(S0)
9D010FAC  1000FFD2   BEQ ZERO, ZERO, 0x9D010EF8
9D010FB0  A20200AE   SB V0, 174(S0)
9D011B78  90A20001   LBU V0, 1(A1)
9D011B7C  27BDFFD8   ADDIU SP, SP, -40
9D011B80  24030003   ADDIU V1, ZERO, 3
9D011B84  AFB10020   SW S1, 32(SP)
9D011B88  AFB0001C   SW S0, 28(SP)
9D011B8C  AFBF0024   SW RA, 36(SP)
9D011B90  00A08825   OR S1, A1, ZERO
9D011B94  10430058   BEQ V0, V1, 0x9D011CF8
9D011B98  00808025   OR S0, A0, ZERO
9D011B9C  2C430004   SLTIU V1, V0, 4
9D011BA0  14600033   BNE V1, ZERO, 0x9D011C70
9D011BA4  24030005   ADDIU V1, ZERO, 5
9D011BA8  10430045   BEQ V0, V1, 0x9D011CC0
9D011BAC  24050009   ADDIU A1, ZERO, 9
9D011BB0  5445003C   BNEL V0, A1, 0x9D011CA4
9D011BB4  02002025   OR A0, S0, ZERO
9D011BB8  92220003   LBU V0, 3(S1)
9D011BBC  92250002   LBU A1, 2(S1)
9D011BC0  00021200   SLL V0, V0, 8
9D011BC4  00451025   OR V0, V0, A1
9D011BC8  5040005D   BEQL V0, ZERO, 0x9D011D40
9D011BCC  90850003   LBU A1, 3(A0)
9D011BD0  920300AD   LBU V1, 173(S0)
9D011BD4  304700FF   ANDI A3, V0, 255
9D011BD8  1067001E   BEQ V1, A3, 0x9D011C54
9D011BDC  00002825   OR A1, ZERO, ZERO
9D011BE0  920200AE   LBU V0, 174(S0)
9D011BE4  1040000E   BEQ V0, ZERO, 0x9D011C20
9D011BE8  2445FFFF   ADDIU A1, V0, -1
9D011BEC  8E0400B0   LW A0, 176(S0)
9D011BF0  30A500FF   ANDI A1, A1, 255
9D011BF4  00052880   SLL A1, A1, 2
9D011BF8  24820004   ADDIU V0, A0, 4
9D011BFC  92280002   LBU T0, 2(S1)
9D011C00  00A22821   ADDU A1, A1, V0
9D011C04  8C830000   LW V1, 0(A0)
9D011C08  90660005   LBU A2, 5(V1)
9D011C0C  14C80002   BNE A2, T0, 0x9D011C18
9D011C10  00402025   OR A0, V0, ZERO
9D011C14  AE0300B4   SW V1, 180(S0)
9D011C18  14A2FFFA   BNE A1, V0, 0x9D011C04
9D011C1C  24420004   ADDIU V0, V0, 4
9D011C20  02002025   OR A0, S0, ZERO
9D011C24  0F405503   JAL _USB_DEVICE_ConfigureDevice
9D011C28  A20700AD   SB A3, 173(S0)
9D011C2C  92020003   LBU V0, 3(S0)
9D011C30  24040005   ADDIU A0, ZERO, 5
9D011C34  8E0300D8   LW V1, 216(S0)
9D011C38  7C821004   INS V0, A0, 0, 3
9D011C3C  A2020003   SB V0, 3(S0)
9D011C40  92240002   LBU A0, 2(S1)
9D011C44  24020001   ADDIU V0, ZERO, 1
9D011C48  1062004D   BEQ V1, V0, 0x9D011D80
9D011C4C  A3A40010   SB A0, 16(SP)
9D011C50  00002825   OR A1, ZERO, ZERO
9D011C54  0F405CF7   JAL USB_DEVICE_ControlStatus
9D011C58  02002025   OR A0, S0, ZERO
9D011C5C  8FBF0024   LW RA, 36(SP)
9D011C60  8FB10020   LW S1, 32(SP)
9D011C64  8FB0001C   LW S0, 28(SP)
9D011C68  03E00008   JR RA
9D011C6C  27BD0028   ADDIU SP, SP, 40
9D011C70  24030001   ADDIU V1, ZERO, 1
9D011C74  5443000B   BNEL V0, V1, 0x9D011CA4
9D011C78  02002025   OR A0, S0, ZERO
9D011C7C  90A20003   LBU V0, 3(A1)
9D011C80  90A30002   LBU V1, 2(A1)
9D011C84  24050001   ADDIU A1, ZERO, 1
9D011C88  00021200   SLL V0, V0, 8
9D011C8C  00431025   OR V0, V0, V1
9D011C90  1445FFF0   BNE V0, A1, 0x9D011C54
9D011C94  00000000   NOP
9D011C98  AC8000C0   SW ZERO, 192(A0)
9D011C9C  1000FFED   BEQ ZERO, ZERO, 0x9D011C54
9D011CA0  00002825   OR A1, ZERO, ZERO
9D011CA4  0F405CF7   JAL USB_DEVICE_ControlStatus
9D011CA8  24050001   ADDIU A1, ZERO, 1
9D011CAC  8FBF0024   LW RA, 36(SP)
9D011CB0  8FB10020   LW S1, 32(SP)
9D011CB4  8FB0001C   LW S0, 28(SP)
9D011CB8  03E00008   JR RA
9D011CBC  27BD0028   ADDIU SP, SP, 40
9D011CC0  94820000   LHU V0, 0(A0)
9D011CC4  24030001   ADDIU V1, ZERO, 1
9D011CC8  00002825   OR A1, ZERO, ZERO
9D011CCC  7C6239C4   INS V0, V1, 7, 1
9D011CD0  A4820000   SH V0, 0(A0)
9D011CD4  92220002   LBU V0, 2(S1)
9D011CD8  A08200AC   SB V0, 172(A0)
9D011CDC  0F405CF7   JAL USB_DEVICE_ControlStatus
9D011CE0  02002025   OR A0, S0, ZERO
9D011CE4  8FBF0024   LW RA, 36(SP)
9D011CE8  8FB10020   LW S1, 32(SP)
9D011CEC  8FB0001C   LW S0, 28(SP)
9D011CF0  03E00008   JR RA
9D011CF4  27BD0028   ADDIU SP, SP, 40
9D011CF8  90A20003   LBU V0, 3(A1)
9D011CFC  90A40002   LBU A0, 2(A1)
9D011D00  24030001   ADDIU V1, ZERO, 1
9D011D04  00021200   SLL V0, V0, 8
9D011D08  00441025   OR V0, V0, A0
9D011D0C  10430019   BEQ V0, V1, 0x9D011D74
9D011D10  24030002   ADDIU V1, ZERO, 2
9D011D14  1443FFCF   BNE V0, V1, 0x9D011C54
9D011D18  24050001   ADDIU A1, ZERO, 1
9D011D1C  96030000   LHU V1, 0(S0)
9D011D20  3064000E   ANDI A0, V1, 14
9D011D24  1482FFCB   BNE A0, V0, 0x9D011C54
9D011D28  7CA34204   INS V1, A1, 8, 1
9D011D2C  92220005   LBU V0, 5(S1)
9D011D30  A6030000   SH V1, 0(S0)
9D011D34  A2020002   SB V0, 2(S0)
9D011D38  1000FFC6   BEQ ZERO, ZERO, 0x9D011C54
9D011D3C  00002825   OR A1, ZERO, ZERO
9D011D40  30A50007   ANDI A1, A1, 7
9D011D44  54A3FFA3   BNEL A1, V1, 0x9D011BD4
9D011D48  920300AD   LBU V1, 173(S0)
9D011D4C  2402000B   ADDIU V0, ZERO, 11
9D011D50  0F405976   JAL _USB_DEVICE_DeInitializeAllFunctionDrivers
9D011D54  AC8200B8   SW V0, 184(A0)
9D011D58  92020003   LBU V0, 3(S0)
9D011D5C  24030004   ADDIU V1, ZERO, 4
9D011D60  A20000AD   SB ZERO, 173(S0)
9D011D64  7C621004   INS V0, V1, 0, 3
9D011D68  A2020003   SB V0, 3(S0)
9D011D6C  1000FFB9   BEQ ZERO, ZERO, 0x9D011C54
9D011D70  00002825   OR A1, ZERO, ZERO
9D011D74  AE0200C0   SW V0, 192(S0)
9D011D78  1000FFB6   BEQ ZERO, ZERO, 0x9D011C54
9D011D7C  00002825   OR A1, ZERO, ZERO
9D011D80  8E0200E0   LW V0, 224(S0)
9D011D84  1040FFB2   BEQ V0, ZERO, 0x9D011C50
9D011D88  27A50010   ADDIU A1, SP, 16
9D011D8C  8E0600E4   LW A2, 228(S0)
9D011D90  0040F809   JALR V0
9D011D94  2404000A   ADDIU A0, ZERO, 10
9D011D98  1000FFAE   BEQ ZERO, ZERO, 0x9D011C54
9D011D9C  00002825   OR A1, ZERO, ZERO
9D011FA8  90A20001   LBU V0, 1(A1)
9D011FAC  27BDFFE0   ADDIU SP, SP, -32
9D011FB0  24030006   ADDIU V1, ZERO, 6
9D011FB4  AFBF001C   SW RA, 28(SP)
9D011FB8  00A06825   OR T5, A1, ZERO
9D011FBC  00806025   OR T4, A0, ZERO
9D011FC0  10430033   BEQ V0, V1, 0x9D012090
9D011FC4  AFA00010   SW ZERO, 16(SP)
9D011FC8  24030008   ADDIU V1, ZERO, 8
9D011FCC  50430019   BEQL V0, V1, 0x9D012034
9D011FD0  248500AD   ADDIU A1, A0, 173
9D011FD4  54400020   BNEL V0, ZERO, 0x9D012058
9D011FD8  2402FFFF   ADDIU V0, ZERO, -1
9D011FDC  8C830000   LW V1, 0(A0)
9D011FE0  8C8400C0   LW A0, 192(A0)
9D011FE4  258500BC   ADDIU A1, T4, 188
9D011FE8  7C630000   EXT V1, V1, 0, 1
9D011FEC  7C620004   INS V0, V1, 0, 1
9D011FF0  7C820844   INS V0, A0, 1, 1
9D011FF4  A58200BC   SH V0, 188(T4)
9D011FF8  AFA50010   SW A1, 16(SP)
9D011FFC  24020002   ADDIU V0, ZERO, 2
9D012000  91A60007   LBU A2, 7(T5)
9D012004  91A30006   LBU V1, 6(T5)
9D012008  00063200   SLL A2, A2, 8
9D01200C  00C33025   OR A2, A2, V1
9D012010  0046182B   SLTU V1, V0, A2
9D012014  54600001   BNEL V1, ZERO, 0x9D01201C
9D012018  00403025   OR A2, V0, ZERO
9D01201C  30C6FFFF   ANDI A2, A2, -1
9D012020  0F405B29   JAL USB_DEVICE_ControlSend
9D012024  01802025   OR A0, T4, ZERO
9D012028  8FBF001C   LW RA, 28(SP)
9D01202C  03E00008   JR RA
9D012030  27BD0020   ADDIU SP, SP, 32
9D012034  AFA50010   SW A1, 16(SP)
9D012038  1000FFF1   BEQ ZERO, ZERO, 0x9D012000
9D01203C  24020001   ADDIU V0, ZERO, 1
9D012040  0F405756   JAL _USB_DEVICE_GetStringDescriptorRequestProcess
9D012044  27A60010   ADDIU A2, SP, 16
9D012048  8FA50010   LW A1, 16(SP)
9D01204C  54A0FFED   BNEL A1, ZERO, 0x9D012004
9D012050  91A60007   LBU A2, 7(T5)
9D012054  2402FFFF   ADDIU V0, ZERO, -1
9D012060  918200DC   LBU V0, 220(T4)
9D01206C  8D8200EC   LW V0, 236(T4)
9D012070  8D84001C   LW A0, 28(T4)
9D012074  A18000C4   SB ZERO, 196(T4)
9D012078  8C420028   LW V0, 40(V0)
9D012084  8FBF001C   LW RA, 28(SP)
9D012088  03E00008   JR RA
9D01208C  27BD0020   ADDIU SP, SP, 32
9D012090  90A20003   LBU V0, 3(A1)
9D012094  2C430008   SLTIU V1, V0, 8
9D012098  1060FFEE   BEQ V1, ZERO, _USB_DEVICE_ProcessStandardDeviceGetRequests::USB_DEVICE_ControlStatus
9D01209C  8C84000C   LW A0, 12(A0)
9D0120A0  00021880   SLL V1, V0, 2
9D0120A4  3C029D01   LUI V0, -25343
9D0120A8  244220BC   ADDIU V0, V0, 8380
9D0120AC  00431021   ADDU V0, V0, V1
9D0120B0  8C420000   LW V0, 0(V0)
9D0120B4  00400008   JR V0
9D0120B8  00000000   NOP
9D0120DC  95820000   LHU V0, 0(T4)
9D0120E0  24030010   ADDIU V1, ZERO, 16
9D0120E4  30420070   ANDI V0, V0, 112
9D0120E8  1443FFDB   BNE V0, V1, 0x9D012058
9D0120EC  2402FFFF   ADDIU V0, ZERO, -1
9D0120F0  1000FFCE   BEQ ZERO, ZERO, 0x9D01202C
9D0120F4  8FBF001C   LW RA, 28(SP)
9D0120F8  95820000   LHU V0, 0(T4)
9D0120FC  24030010   ADDIU V1, ZERO, 16
9D012100  30450070   ANDI A1, V0, 112
9D012104  54A3FFD4   BNEL A1, V1, 0x9D012058
9D012108  2402FFFF   ADDIU V0, ZERO, -1
9D01210C  3042000E   ANDI V0, V0, 14
9D012110  24030002   ADDIU V1, ZERO, 2
9D012114  50430022   BEQL V0, V1, 0x9D0121A0
9D012118  8C850020   LW A1, 32(A0)
9D01211C  8C850024   LW A1, 36(A0)
9D012120  2402000A   ADDIU V0, ZERO, 10
9D012124  1000FFC9   BEQ ZERO, ZERO, 0x9D01204C
9D012128  AFA50010   SW A1, 16(SP)
9D01212C  90A30002   LBU V1, 2(A1)
9D012130  918200AE   LBU V0, 174(T4)
9D012134  0062102B   SLTU V0, V1, V0
9D012138  1040FFC7   BEQ V0, ZERO, 0x9D012058
9D01213C  2402FFFF   ADDIU V0, ZERO, -1
9D012140  8D8200B0   LW V0, 176(T4)
9D012144  00031880   SLL V1, V1, 2
9D012148  00431821   ADDU V1, V0, V1
9D01214C  8C650000   LW A1, 0(V1)
9D012150  50A0FFC1   BEQL A1, ZERO, 0x9D012058
9D012154  2402FFFF   ADDIU V0, ZERO, -1
9D012158  AFA50010   SW A1, 16(SP)
9D01215C  90A20003   LBU V0, 3(A1)
9D012160  90A30002   LBU V1, 2(A1)
9D012164  00021200   SLL V0, V0, 8
9D012168  1000FFA5   BEQ ZERO, ZERO, 0x9D012000
9D01216C  00431025   OR V0, V0, V1
9D012170  95820000   LHU V0, 0(T4)
9D012174  24030002   ADDIU V1, ZERO, 2
9D012178  3042000E   ANDI V0, V0, 14
9D01217C  50430005   BEQL V0, V1, 0x9D012194
9D012180  8C85000C   LW A1, 12(A0)
9D012184  8C850000   LW A1, 0(A0)
9D012188  24020012   ADDIU V0, ZERO, 18
9D01218C  1000FFAF   BEQ ZERO, ZERO, 0x9D01204C
9D012190  AFA50010   SW A1, 16(SP)
9D012194  24020012   ADDIU V0, ZERO, 18
9D012198  1000FFAC   BEQ ZERO, ZERO, 0x9D01204C
9D01219C  AFA50010   SW A1, 16(SP)
9D0121A0  2402000A   ADDIU V0, ZERO, 10
9D0121A4  1000FFA9   BEQ ZERO, ZERO, 0x9D01204C
9D0121A8  AFA50010   SW A1, 16(SP)
9D01275C  8C820008   LW V0, 8(A0)
9D012760  2403FFFE   ADDIU V1, ZERO, -2
9D012764  10430053   BEQ V0, V1, 0x9D0128B4
9D012768  00000000   NOP
9D01276C  27BDFFE0   ADDIU SP, SP, -32
9D012770  24030002   ADDIU V1, ZERO, 2
9D012774  AFB10018   SW S1, 24(SP)
9D012778  AFB00014   SW S0, 20(SP)
9D01277C  AFBF001C   SW RA, 28(SP)
9D012780  00808825   OR S1, A0, ZERO
9D012784  10430026   BEQ V0, V1, 0x9D012820
9D012788  8C900014   LW S0, 20(A0)
9D01278C  8C860004   LW A2, 4(A0)
9D012790  54C00018   BNEL A2, ZERO, 0x9D0127F4
9D012794  920200C4   LBU V0, 196(S0)
9D012798  8E0200D0   LW V0, 208(S0)
9D01279C  8E0300E0   LW V1, 224(S0)
9D0127A0  A20000C4   SB ZERO, 196(S0)
9D0127A4  00002825   OR A1, ZERO, ZERO
9D0127A8  2407000F   ADDIU A3, ZERO, 15
9D0127AC  50430033   BEQL V0, V1, 0x9D01287C
9D0127B0  8E0600E4   LW A2, 228(S0)
9D0127B4  960400C8   LHU A0, 200(S0)
9D0127B8  00A03025   OR A2, A1, ZERO
9D0127BC  0040F809   JALR V0
9D0127C0  00E02825   OR A1, A3, ZERO
9D0127C4  8E0200EC   LW V0, 236(S0)
9D0127C8  8E04001C   LW A0, 28(S0)
9D0127CC  26060088   ADDIU A2, S0, 136
9D0127D0  8C590038   LW T9, 56(V0)
9D0127D4  24020040   ADDIU V0, ZERO, 64
9D0127D8  AE02008C   SW V0, 140(S0)
9D0127DC  8FBF001C   LW RA, 28(SP)
9D0127E0  8FB10018   LW S1, 24(SP)
9D0127E4  8FB00014   LW S0, 20(SP)
9D0127E8  00002825   OR A1, ZERO, ZERO
9D0127EC  03200008   JR T9
9D0127F0  27BD0020   ADDIU SP, SP, 32
9D0127F4  50400031   BEQL V0, ZERO, 0x9D0128BC
9D0127F8  8E0200D0   LW V0, 208(S0)
9D0127FC  920300C5   LBU V1, 197(S0)
9D012800  920200C6   LBU V0, 198(S0)
9D012804  0062102B   SLTU V0, V1, V0
9D012808  14400030   BNE V0, ZERO, 0x9D0128CC
9D01280C  00002825   OR A1, ZERO, ZERO
9D012810  8E0200D0   LW V0, 208(S0)
9D012814  8E0300E0   LW V1, 224(S0)
9D012818  1000FFE4   BEQ ZERO, ZERO, 0x9D0127AC
9D01281C  2407000D   ADDIU A3, ZERO, 13
9D012820  920200C4   LBU V0, 196(S0)
9D012824  1040000A   BEQ V0, ZERO, 0x9D012850
9D012828  8E0300E0   LW V1, 224(S0)
9D01282C  8E0200D0   LW V0, 208(S0)
9D012830  50400008   BEQL V0, ZERO, 0x9D012854
9D012834  96040018   LHU A0, 24(S0)
9D012838  10430035   BEQ V0, V1, 0x9D012910
9D01283C  00003025   OR A2, ZERO, ZERO
9D012840  960400C8   LHU A0, 200(S0)
9D012844  0040F809   JALR V0
9D012848  2405000C   ADDIU A1, ZERO, 12
9D01284C  8E0300E0   LW V1, 224(S0)
9D012850  96040018   LHU A0, 24(S0)
9D012854  3C029D01   LUI V0, -25343
9D012858  24050001   ADDIU A1, ZERO, 1
9D01285C  244207B0   ADDIU V0, V0, 1968
9D012860  A20500C4   SB A1, 196(S0)
9D012864  AE0200D0   SW V0, 208(S0)
9D012868  A60400C8   SH A0, 200(S0)
9D01286C  26050024   ADDIU A1, S0, 36
9D012870  1443FFD0   BNE V0, V1, 0x9D0127B4
9D012874  2407000E   ADDIU A3, ZERO, 14
9D012878  8E0600E4   LW A2, 228(S0)
9D01287C  0040F809   JALR V0
9D012880  00E02025   OR A0, A3, ZERO
9D012884  8E0200EC   LW V0, 236(S0)
9D012888  8E04001C   LW A0, 28(S0)
9D01288C  26060088   ADDIU A2, S0, 136
9D012890  8C590038   LW T9, 56(V0)
9D012894  24020040   ADDIU V0, ZERO, 64
9D012898  AE02008C   SW V0, 140(S0)
9D01289C  8FBF001C   LW RA, 28(SP)
9D0128A0  8FB10018   LW S1, 24(SP)
9D0128A4  8FB00014   LW S0, 20(SP)
9D0128A8  00002825   OR A1, ZERO, ZERO
9D0128AC  03200008   JR T9
9D0128B0  27BD0020   ADDIU SP, SP, 32
9D0128B4  03E00008   JR RA
9D0128B8  00000000   NOP
9D0128BC  8E0300E0   LW V1, 224(S0)
9D0128C0  00002825   OR A1, ZERO, ZERO
9D0128C4  1000FFB9   BEQ ZERO, ZERO, 0x9D0127AC
9D0128C8  24070001   ADDIU A3, ZERO, 1
9D0128CC  8E0400CC   LW A0, 204(S0)
9D0128D0  26050024   ADDIU A1, S0, 36
9D0128D4  0F404CCF   JAL memcpy
9D0128D8  00832021   ADDU A0, A0, V1
9D0128DC  8E220004   LW V0, 4(S1)
9D0128E0  920400C5   LBU A0, 197(S0)
9D0128E4  920300C6   LBU V1, 198(S0)
9D0128E8  00441021   ADDU V0, V0, A0
9D0128EC  304200FF   ANDI V0, V0, 255
9D0128F0  0043182B   SLTU V1, V0, V1
9D0128F4  A20200C5   SB V0, 197(S0)
9D0128F8  1060000B   BEQ V1, ZERO, 0x9D012928
9D0128FC  8E0200D0   LW V0, 208(S0)
9D012900  8E0300E0   LW V1, 224(S0)
9D012904  00002825   OR A1, ZERO, ZERO
9D012908  1000FFA8   BEQ ZERO, ZERO, 0x9D0127AC
9D01290C  24070001   ADDIU A3, ZERO, 1
9D012910  8E0600E4   LW A2, 228(S0)
9D012914  00002825   OR A1, ZERO, ZERO
9D012918  0060F809   JALR V1
9D01291C  2404000C   ADDIU A0, ZERO, 12
9D012920  1000FFCB   BEQ ZERO, ZERO, 0x9D012850
9D012924  8E0300E0   LW V1, 224(S0)
9D012928  8E0300E0   LW V1, 224(S0)
9D01292C  00002825   OR A1, ZERO, ZERO
9D012930  1000FF9E   BEQ ZERO, ZERO, 0x9D0127AC
9D012934  2407000D   ADDIU A3, ZERO, 13
9D013764  27BDFFD0   ADDIU SP, SP, -48
9D013768  AFB00014   SW S0, 20(SP)
9D01376C  2410FFFF   ADDIU S0, ZERO, -1
9D013770  AFBF002C   SW RA, 44(SP)
9D013774  AFB50028   SW S5, 40(SP)
9D013778  AFB40024   SW S4, 36(SP)
9D01377C  AFB30020   SW S3, 32(SP)
9D013780  AFB2001C   SW S2, 28(SP)
9D013784  10900042   BEQ A0, S0, 0x9D013890
9D013788  AFB10018   SW S1, 24(SP)
9D01378C  00041100   SLL V0, A0, 4
9D013790  00441023   SUBU V0, V0, A0
9D013794  00021080   SLL V0, V0, 2
9D013798  00441021   ADDU V0, V0, A0
9D01379C  3C11A000   LUI S1, -24576
9D0137A0  00021080   SLL V0, V0, 2
9D0137A4  26312978   ADDIU S1, S1, 10616
9D0137A8  02228821   ADDU S1, S1, V0
9D0137AC  8E220008   LW V0, 8(S1)
9D0137B0  58400038   BLEZL V0, 0x9D013894
9D0137B4  8FBF002C   LW RA, 44(SP)
9D0137B8  8E2200D4   LW V0, 212(S1)
9D0137BC  10400029   BEQ V0, ZERO, 0x9D013864
9D0137C0  24030001   ADDIU V1, ZERO, 1
9D0137C4  54430033   BNEL V0, V1, 0x9D013894
9D0137C8  8FBF002C   LW RA, 44(SP)
9D0137CC  96340010   LHU S4, 16(S1)
9D0137D0  1280002F   BEQ S4, ZERO, 0x9D013890
9D0137D4  00008025   OR S0, ZERO, ZERO
9D0137D8  8E330000   LW S3, 0(S1)
9D0137DC  923500AD   LBU S5, 173(S1)
9D0137E0  8E320014   LW S2, 20(S1)
9D0137E4  10000005   BEQ ZERO, ZERO, 0x9D0137FC
9D0137E8  7E731040   EXT S3, S3, 1, 3
9D0137EC  321000FF   ANDI S0, S0, 255
9D0137F0  0214102B   SLTU V0, S0, S4
9D0137F4  10400026   BEQ V0, ZERO, 0x9D013890
9D0137F8  26520014   ADDIU S2, S2, 20
9D0137FC  8E420000   LW V0, 0(S2)
9D013800  02621024   AND V0, S3, V0
9D013804  5040FFF9   BEQL V0, ZERO, 0x9D0137EC
9D013808  26100001   ADDIU S0, S0, 1
9D01380C  92420004   LBU V0, 4(S2)
9D013810  5455FFF6   BNEL V0, S5, 0x9D0137EC
9D013814  26100001   ADDIU S0, S0, 1
9D013818  92220003   LBU V0, 3(S1)
9D01381C  24030005   ADDIU V1, ZERO, 5
9D013820  30420007   ANDI V0, V0, 7
9D013824  5443FFF1   BNEL V0, V1, 0x9D0137EC
9D013828  26100001   ADDIU S0, S0, 1
9D01382C  8E220000   LW V0, 0(S1)
9D013830  7C420280   EXT V0, V0, 10, 1
9D013834  5440FFED   BNEL V0, ZERO, 0x9D0137EC
9D013838  26100001   ADDIU S0, S0, 1
9D01383C  8E420010   LW V0, 16(S2)
9D013840  5040FFEA   BEQL V0, ZERO, 0x9D0137EC
9D013844  26100001   ADDIU S0, S0, 1
9D013848  8C42000C   LW V0, 12(V0)
9D01384C  5040FFE7   BEQL V0, ZERO, 0x9D0137EC
9D013850  26100001   ADDIU S0, S0, 1
9D013854  0040F809   JALR V0
9D013858  96440008   LHU A0, 8(S2)
9D01385C  1000FFE3   BEQ ZERO, ZERO, 0x9D0137EC
9D013860  26100001   ADDIU S0, S0, 1
9D013864  8E2200EC   LW V0, 236(S1)
9D013868  962400F0   LHU A0, 240(S1)
9D01386C  8C420000   LW V0, 0(V0)
9D013870  0040F809   JALR V0
9D013874  2405000F   ADDIU A1, ZERO, 15
9D013878  10500005   BEQ V0, S0, 0x9D013890
9D01387C  AE22001C   SW V0, 28(S1)
9D013880  24020001   ADDIU V0, ZERO, 1
9D013884  AE2200D4   SW V0, 212(S1)
9D013888  24020002   ADDIU V0, ZERO, 2
9D01388C  AE220008   SW V0, 8(S1)
9D013890  8FBF002C   LW RA, 44(SP)
9D013894  8FB50028   LW S5, 40(SP)
9D013898  8FB40024   LW S4, 36(SP)
9D01389C  8FB30020   LW S3, 32(SP)
9D0138A0  8FB2001C   LW S2, 28(SP)
9D0138A4  8FB10018   LW S1, 24(SP)
9D0138A8  8FB00014   LW S0, 20(SP)
9D0138AC  03E00008   JR RA
9D0138B0  27BD0030   ADDIU SP, SP, 48
9D013EFC  14800049   BNE A0, ZERO, 0x9D014024
9D013F00  00000000   NOP
9D013F04  10A00047   BEQ A1, ZERO, 0x9D014024
9D013F08  00000000   NOP
9D013F0C  8CA60020   LW A2, 32(A1)
9D013F10  10C00044   BEQ A2, ZERO, 0x9D014024
9D013F14  3C03A000   LUI V1, -24576
9D013F18  27BDFFE0   ADDIU SP, SP, -32
9D013F1C  AFB10014   SW S1, 20(SP)
9D013F20  24712978   ADDIU S1, V1, 10616
9D013F24  92240003   LBU A0, 3(S1)
9D013F28  94622978   LHU V0, 10616(V1)
9D013F2C  AFB20018   SW S2, 24(SP)
9D013F30  7C041004   INS A0, ZERO, 0, 3
9D013F34  A2240003   SB A0, 3(S1)
9D013F38  8CA40024   LW A0, 36(A1)
9D013F3C  94A70018   LHU A3, 24(A1)
9D013F40  8CB2001C   LW S2, 28(A1)
9D013F44  8CA90030   LW T1, 48(A1)
9D013F48  94A8002C   LHU T0, 44(A1)
9D013F4C  3C05A000   LUI A1, -24576
9D013F50  24A5299C   ADDIU A1, A1, 10652
9D013F54  AE250088   SW A1, 136(S1)
9D013F58  24050040   ADDIU A1, ZERO, 64
9D013F5C  AE25008C   SW A1, 140(S1)
9D013F60  3C059D01   LUI A1, -25343
9D013F64  24A5275C   ADDIU A1, A1, 10076
9D013F68  7C823104   INS V0, A0, 4, 3
9D013F6C  AE250094   SW A1, 148(S1)
9D013F70  3C059D01   LUI A1, -25343
9D013F74  24040001   ADDIU A0, ZERO, 1
9D013F78  3042FA7E   ANDI V0, V0, -1410
9D013F7C  24A56520   ADDIU A1, A1, 25888
9D013F80  AFB00010   SW S0, 16(SP)
9D013F84  AFBF001C   SW RA, 28(SP)
9D013F88  AE240008   SW A0, 8(S1)
9D013F8C  A6200018   SH ZERO, 24(S1)
9D013F90  AE26000C   SW A2, 12(S1)
9D013F94  A6270010   SH A3, 16(S1)
9D013F98  AE320014   SW S2, 20(S1)
9D013F9C  AE2000C0   SW ZERO, 192(S1)
9D013FA0  AE240098   SW A0, 152(S1)
9D013FA4  AE200090   SW ZERO, 144(S1)
9D013FA8  AE31009C   SW S1, 156(S1)
9D013FAC  AE250070   SW A1, 112(S1)
9D013FB0  AE310078   SW S1, 120(S1)
9D013FB4  AE240074   SW A0, 116(S1)
9D013FB8  A4622978   SH V0, 10616(V1)
9D013FBC  AE2000D4   SW ZERO, 212(S1)
9D013FC0  AE2900EC   SW T1, 236(S1)
9D013FC4  A62800F0   SH T0, 240(S1)
9D013FC8  10E0000F   BEQ A3, ZERO, 0x9D014008
9D013FCC  00008025   OR S0, ZERO, ZERO
9D013FD0  8E420010   LW V0, 16(S2)
9D013FD4  10400006   BEQ V0, ZERO, 0x9D013FF0
9D013FD8  26520014   ADDIU S2, S2, 20
9D013FDC  8C420010   LW V0, 16(V0)
9D013FE0  50400004   BEQL V0, ZERO, 0x9D013FF4
9D013FE4  96220010   LHU V0, 16(S1)
9D013FE8  0040F809   JALR V0
9D013FEC  00000000   NOP
9D013FF0  96220010   LHU V0, 16(S1)
9D013FF4  26100001   ADDIU S0, S0, 1
9D013FF8  321000FF   ANDI S0, S0, 255
9D013FFC  0202102B   SLTU V0, S0, V0
9D014000  5440FFF4   BNEL V0, ZERO, 0x9D013FD4
9D014004  8E420010   LW V0, 16(S2)
9D014008  8FBF001C   LW RA, 28(SP)
9D01400C  00001025   OR V0, ZERO, ZERO
9D014010  8FB20018   LW S2, 24(SP)
9D014014  8FB10014   LW S1, 20(SP)
9D014018  8FB00010   LW S0, 16(SP)
9D01401C  03E00008   JR RA
9D014020  27BD0020   ADDIU SP, SP, 32
9D014024  03E00008   JR RA
9D014028  2402FFFF   ADDIU V0, ZERO, -1
9D014284  90C20001   LBU V0, 1(A2)
9D014288  27BDFFE8   ADDIU SP, SP, -24
9D01428C  AFB00010   SW S0, 16(SP)
9D014290  AFBF0014   SW RA, 20(SP)
9D014294  00808025   OR S0, A0, ZERO
9D014298  14400010   BNE V0, ZERO, 0x9D0142DC
9D01429C  90C50004   LBU A1, 4(A2)
9D0142A0  8C8200EC   LW V0, 236(A0)
9D0142A4  8C84001C   LW A0, 28(A0)
9D0142A8  8C420034   LW V0, 52(V0)
9D0142AC  0040F809   JALR V0
9D0142B0  A60000BC   SH ZERO, 188(S0)
9D0142B4  960300BC   LHU V1, 188(S0)
9D0142B8  260500BC   ADDIU A1, S0, 188
9D0142BC  02002025   OR A0, S0, ZERO
9D0142C0  7C430004   INS V1, V0, 0, 1
9D0142C4  A60300BC   SH V1, 188(S0)
9D0142C8  8FBF0014   LW RA, 20(SP)
9D0142CC  8FB00010   LW S0, 16(SP)
9D0142D0  24060002   ADDIU A2, ZERO, 2
9D0142D4  0B405B29   J USB_DEVICE_ControlSend
9D0142D8  27BD0018   ADDIU SP, SP, 24
9D0142DC  24030001   ADDIU V1, ZERO, 1
9D0142E0  10430017   BEQ V0, V1, 0x9D014340
9D0142E4  24030003   ADDIU V1, ZERO, 3
9D0142E8  10430026   BEQ V0, V1, 0x9D014384
9D0142EC  2403000C   ADDIU V1, ZERO, 12
9D0142F0  10430005   BEQ V0, V1, _USB_DEVICE_ProcessStandardEndpointRequest::USB_DEVICE_ControlStatus
9D0142F4  2482FFFF   ADDIU V0, A0, -1
9D0142F8  8FBF0014   LW RA, 20(SP)
9D0142FC  8FB00010   LW S0, 16(SP)
9D014300  03E00008   JR RA
9D014304  27BD0018   ADDIU SP, SP, 24
9D014308  2C42FFFE   SLTIU V0, V0, -2
9D014314  908200DC   LBU V0, 220(A0)
9D014320  8C8200EC   LW V0, 236(A0)
9D014324  8C84001C   LW A0, 28(A0)
9D014328  8C590028   LW T9, 40(V0)
9D01432C  A20000C4   SB ZERO, 196(S0)
9D014330  8FB00010   LW S0, 16(SP)
9D014334  24050080   ADDIU A1, ZERO, 128
9D014338  03200008   JR T9
9D01433C  27BD0018   ADDIU SP, SP, 24
9D014340  90C20003   LBU V0, 3(A2)
9D014344  90C30002   LBU V1, 2(A2)
9D014348  00021200   SLL V0, V0, 8
9D01434C  00431025   OR V0, V0, V1
9D014350  1440FFEA   BNE V0, ZERO, 0x9D0142FC
9D014354  8FBF0014   LW RA, 20(SP)
9D014358  8C8200EC   LW V0, 236(A0)
9D01435C  8C84001C   LW A0, 28(A0)
9D014360  8C42002C   LW V0, 44(V0)
9D014364  0040F809   JALR V0
9D014368  00000000   NOP
9D01436C  02002025   OR A0, S0, ZERO
9D014370  8FBF0014   LW RA, 20(SP)
9D014374  8FB00010   LW S0, 16(SP)
9D014378  00002825   OR A1, ZERO, ZERO
9D01437C  0B405CF7   J USB_DEVICE_ControlStatus
9D014380  27BD0018   ADDIU SP, SP, 24
9D014384  90C20003   LBU V0, 3(A2)
9D014388  90C30002   LBU V1, 2(A2)
9D01438C  00021200   SLL V0, V0, 8
9D014390  00431025   OR V0, V0, V1
9D014394  1440FFD9   BNE V0, ZERO, 0x9D0142FC
9D014398  8FBF0014   LW RA, 20(SP)
9D01439C  8C8200EC   LW V0, 236(A0)
9D0143A0  8C84001C   LW A0, 28(A0)
9D0143A4  1000FFEF   BEQ ZERO, ZERO, 0x9D014364
9D0143A8  8C420028   LW V0, 40(V0)
9D01540C  27BDFFB8   ADDIU SP, SP, -72
9D015410  AFB00024   SW S0, 36(SP)
9D015414  8C9000B4   LW S0, 180(A0)
9D015418  AFBF0044   SW RA, 68(SP)
9D01541C  AFB70040   SW S7, 64(SP)
9D015420  AFB6003C   SW S6, 60(SP)
9D015424  AFB50038   SW S5, 56(SP)
9D015428  AFB40034   SW S4, 52(SP)
9D01542C  AFB30030   SW S3, 48(SP)
9D015430  AFB2002C   SW S2, 44(SP)
9D015434  AFB10028   SW S1, 40(SP)
9D015438  92130003   LBU S3, 3(S0)
9D01543C  92020002   LBU V0, 2(S0)
9D015440  00139A00   SLL S3, S3, 8
9D015444  02629825   OR S3, S3, V0
9D015448  12600025   BEQ S3, ZERO, 0x9D0154E0
9D01544C  0080A025   OR S4, A0, ZERO
9D015450  00009025   OR S2, ZERO, ZERO
9D015454  0000B025   OR S6, ZERO, ZERO
9D015458  0000B825   OR S7, ZERO, ZERO
9D01545C  00008825   OR S1, ZERO, ZERO
9D015460  10000015   BEQ ZERO, ZERO, 0x9D0154B8
9D015464  24150004   ADDIU S5, ZERO, 4
9D015468  02E03825   OR A3, S7, ZERO
9D01546C  1240000C   BEQ S2, ZERO, 0x9D0154A0
9D015470  02802825   OR A1, S4, ZERO
9D015474  8E420010   LW V0, 16(S2)
9D015478  5040000A   BEQL V0, ZERO, 0x9D0154A4
9D01547C  92030000   LBU V1, 0(S0)
9D015480  8E46000C   LW A2, 12(S2)
9D015484  96440008   LHU A0, 8(S2)
9D015488  AFB00018   SW S0, 24(SP)
9D01548C  AFAB0014   SW T3, 20(SP)
9D015490  AFB60010   SW S6, 16(SP)
9D015494  8C420000   LW V0, 0(V0)
9D015498  0040F809   JALR V0
9D01549C  00000000   NOP
9D0154A0  92030000   LBU V1, 0(S0)
9D0154A4  02238821   ADDU S1, S1, V1
9D0154A8  3231FFFF   ANDI S1, S1, -1
9D0154AC  0233102B   SLTU V0, S1, S3
9D0154B0  1040000B   BEQ V0, ZERO, 0x9D0154E0
9D0154B4  02038021   ADDU S0, S0, V1
9D0154B8  920B0001   LBU T3, 1(S0)
9D0154BC  1575FFEB   BNE T3, S5, 0x9D01546C
9D0154C0  02E03825   OR A3, S7, ZERO
9D0154C4  92170002   LBU S7, 2(S0)
9D0154C8  02802825   OR A1, S4, ZERO
9D0154CC  92160003   LBU S6, 3(S0)
9D0154D0  0F405D18   JAL _USB_DEVICE_GetFunctionDriverEntryByInterface
9D0154D4  02E02025   OR A0, S7, ZERO
9D0154D8  1000FFE3   BEQ ZERO, ZERO, 0x9D015468
9D0154DC  00409025   OR S2, V0, ZERO
9D0154E0  8FBF0044   LW RA, 68(SP)
9D0154E4  8FB70040   LW S7, 64(SP)
9D0154E8  8FB6003C   LW S6, 60(SP)
9D0154EC  8FB50038   LW S5, 56(SP)
9D0154F0  8FB40034   LW S4, 52(SP)
9D0154F4  8FB30030   LW S3, 48(SP)
9D0154F8  8FB2002C   LW S2, 44(SP)
9D0154FC  8FB10028   LW S1, 40(SP)
9D015500  8FB00024   LW S0, 36(SP)
9D015504  03E00008   JR RA
9D015508  27BD0048   ADDIU SP, SP, 72
9D015D58  8C8A001C   LW T2, 28(A0)
9D015D5C  90A90002   LBU T1, 2(A1)
9D015D60  00003825   OR A3, ZERO, ZERO
9D015D64  8D480000   LW T0, 0(T2)
9D015D68  91020000   LBU V0, 0(T0)
9D015D6C  2442FFFE   ADDIU V0, V0, -2
9D015D70  304200FF   ANDI V0, V0, 255
9D015D74  2C4B0002   SLTIU T3, V0, 2
9D015D78  15600007   BNE T3, ZERO, 0x9D015D98
9D015D7C  00021842   SRL V1, V0, 1
9D015D80  90870018   LBU A3, 24(A0)
9D015D84  24E7FFFF   ADDIU A3, A3, -1
9D015D88  00E3001A   DIV A3, V1
9D015D8C  006001F4   TEQ V1, ZERO
9D015D90  00003812   MFLO A3
9D015D94  30E700FF   ANDI A3, A3, 255
9D015D98  00E9382B   SLTU A3, A3, T1
9D015D9C  10E00003   BEQ A3, ZERO, 0x9D015DAC
9D015DA0  00001025   OR V0, ZERO, ZERO
9D015DA4  03E00008   JR RA
9D015DA8  00000000   NOP
9D015DAC  51200015   BEQL T1, ZERO, 0x9D015E04
9D015DB0  ACC80000   SW T0, 0(A2)
9D015DB4  90A40005   LBU A0, 5(A1)
9D015DB8  90A70004   LBU A3, 4(A1)
9D015DBC  306BFFFF   ANDI T3, V1, -1
9D015DC0  00042200   SLL A0, A0, 8
9D015DC4  1060FFF7   BEQ V1, ZERO, 0x9D015DA4
9D015DC8  00873825   OR A3, A0, A3
9D015DCC  95020002   LHU V0, 2(T0)
9D015DD0  1047000E   BEQ V0, A3, 0x9D015E0C
9D015DD4  24040001   ADDIU A0, ZERO, 1
9D015DD8  10000004   BEQ ZERO, ZERO, 0x9D015DEC
9D015DDC  25020004   ADDIU V0, T0, 4
9D015DE0  9445FFFE   LHU A1, -2(V0)
9D015DE4  10A70009   BEQ A1, A3, 0x9D015E0C
9D015DE8  00602025   OR A0, V1, ZERO
9D015DEC  24830001   ADDIU V1, A0, 1
9D015DF0  24420002   ADDIU V0, V0, 2
9D015DF4  1564FFFA   BNE T3, A0, 0x9D015DE0
9D015DF8  3063FFFF   ANDI V1, V1, -1
9D015DFC  03E00008   JR RA
9D015E00  00001025   OR V0, ZERO, ZERO
9D015E04  03E00008   JR RA
9D015E08  91020000   LBU V0, 0(T0)
9D015E0C  71241002   MUL V0, T1, A0
9D015E10  00021080   SLL V0, V0, 2
9D015E14  01421021   ADDU V0, T2, V0
9D015E18  8C420000   LW V0, 0(V0)
9D015E1C  ACC20000   SW V0, 0(A2)
9D015E20  03E00008   JR RA
9D015E24  90420000   LBU V0, 0(V0)
9D015FC0  00805825   OR T3, A0, ZERO
9D015FC4  27BDFFE8   ADDIU SP, SP, -24
9D015FC8  00A02025   OR A0, A1, ZERO
9D015FCC  01602825   OR A1, T3, ZERO
9D015FD0  AFBF0014   SW RA, 20(SP)
9D015FD4  0F405D18   JAL _USB_DEVICE_GetFunctionDriverEntryByInterface
9D015FD8  00C06025   OR T4, A2, ZERO
9D015FDC  50400018   BEQL V0, ZERO, _USB_DEVICE_ForwardControlXfrToFunction::USB_DEVICE_ControlStatus
9D015FE0  2562FFFF   ADDIU V0, T3, -1
9D015FE4  8C430010   LW V1, 16(V0)
9D015FE8  5060000C   BEQL V1, ZERO, 0x9D01601C
9D015FEC  8D7900E0   LW T9, 224(T3)
9D015FF0  8C790008   LW T9, 8(V1)
9D015FF4  13200008   BEQ T9, ZERO, _USB_DEVICE_ForwardControlXfrToFunction::_USB_DEVICE_RedirectControlXfrToClient
9D015FF8  8FBF0014   LW RA, 20(SP)
9D015FFC  94440008   LHU A0, 8(V0)
9D016000  AD7900D0   SW T9, 208(T3)
9D016004  01803025   OR A2, T4, ZERO
9D016008  A56400C8   SH A0, 200(T3)
9D01600C  2405000E   ADDIU A1, ZERO, 14
9D016010  03200008   JR T9
9D016014  27BD0018   ADDIU SP, SP, 24
9D016018  8D7900E0   LW T9, 224(T3)
9D01601C  95640018   LHU A0, 24(T3)
9D016020  8D6300D8   LW V1, 216(T3)
9D016024  24020001   ADDIU V0, ZERO, 1
9D016028  AD7900D0   SW T9, 208(T3)
9D01602C  10620010   BEQ V1, V0, _USB_DEVICE_ForwardControlXfrToFunction::_USB_DEVICE_RedirectControlXfrToClient
9D016030  A56400C8   SH A0, 200(T3)
9D016034  8FBF0014   LW RA, 20(SP)
9D016038  03E00008   JR RA
9D01603C  27BD0018   ADDIU SP, SP, 24
9D016040  2C42FFFE   SLTIU V0, V0, -2
9D01604C  916200DC   LBU V0, 220(T3)
9D016058  8D6200EC   LW V0, 236(T3)
9D01605C  8D64001C   LW A0, 28(T3)
9D016064  A16000C4   SB ZERO, 196(T3)
9D016068  03200008   JR T9
9D016070  1320FFF0   BEQ T9, ZERO, 0x9D016034
9D016074  8FBF0014   LW RA, 20(SP)
9D016078  8D6600E4   LW A2, 228(T3)
9D01607C  01802825   OR A1, T4, ZERO
9D016080  2404000E   ADDIU A0, ZERO, 14
9D016084  03200008   JR T9
9D016088  27BD0018   ADDIU SP, SP, 24
9D01608C  8C830008   LW V1, 8(A0)
9D016520  8C820008   LW V0, 8(A0)
9D016524  27BDFFE0   ADDIU SP, SP, -32
9D016528  2403FFFE   ADDIU V1, ZERO, -2
9D01652C  AFB10018   SW S1, 24(SP)
9D016530  AFBF001C   SW RA, 28(SP)
9D016534  AFB00014   SW S0, 20(SP)
9D016538  10430018   BEQ V0, V1, 0x9D01659C
9D01653C  8C910014   LW S1, 20(A0)
9D016540  96230000   LHU V1, 0(S1)
9D016544  00808025   OR S0, A0, ZERO
9D016548  30640080   ANDI A0, V1, 128
9D01654C  10800018   BEQ A0, ZERO, 0x9D0165B0
9D016550  30640100   ANDI A0, V1, 256
9D016554  8E2200EC   LW V0, 236(S1)
9D016558  8E24001C   LW A0, 28(S1)
9D01655C  8C42000C   LW V0, 12(V0)
9D016560  0040F809   JALR V0
9D016564  922500AC   LBU A1, 172(S1)
9D016568  96230000   LHU V1, 0(S1)
9D01656C  92220003   LBU V0, 3(S1)
9D016570  24040004   ADDIU A0, ZERO, 4
9D016574  7C0339C4   INS V1, ZERO, 7, 1
9D016578  7C821004   INS V0, A0, 0, 3
9D01657C  A6230000   SH V1, 0(S1)
9D016580  A2220003   SB V0, 3(S1)
9D016584  8E020008   LW V0, 8(S0)
9D016588  14400005   BNE V0, ZERO, 0x9D0165A0
9D01658C  8FBF001C   LW RA, 28(SP)
9D016590  8E020004   LW V0, 4(S0)
9D016594  50400001   BEQL V0, ZERO, 0x9D01659C
9D016598  A22000C4   SB ZERO, 196(S1)
9D01659C  8FBF001C   LW RA, 28(SP)
9D0165A0  8FB10018   LW S1, 24(SP)
9D0165A4  8FB00014   LW S0, 20(SP)
9D0165A8  03E00008   JR RA
9D0165AC  27BD0020   ADDIU SP, SP, 32
9D0165B0  1080FFF5   BEQ A0, ZERO, 0x9D016588
9D0165B4  7C034204   INS V1, ZERO, 8, 1
9D0165B8  8E2200EC   LW V0, 236(S1)
9D0165BC  A6230000   SH V1, 0(S1)
9D0165C0  8C42004C   LW V0, 76(V0)
9D0165C4  92250002   LBU A1, 2(S1)
9D0165C8  0040F809   JALR V0
9D0165CC  8E24001C   LW A0, 28(S1)
9D0165D0  1000FFED   BEQ ZERO, ZERO, 0x9D016588
9D0165D4  8E020008   LW V0, 8(S0)
9D0165D8  27BDFFD8   ADDIU SP, SP, -40
9D0165DC  AFB3001C   SW S3, 28(SP)
9D0165E0  AFB10014   SW S1, 20(SP)
9D0165E4  AFBF0024   SW RA, 36(SP)
9D0165E8  AFB40020   SW S4, 32(SP)
9D0165EC  AFB20018   SW S2, 24(SP)
9D0165F0  AFB00010   SW S0, 16(SP)
9D0165F4  8C920000   LW S2, 0(A0)
9D0165F8  94930010   LHU S3, 16(A0)
9D0165FC  909400AD   LBU S4, 173(A0)
9D016600  7E521040   EXT S2, S2, 1, 3
9D016604  1260001A   BEQ S3, ZERO, 0x9D016670
9D016608  8C910014   LW S1, 20(A0)
9D01660C  10000005   BEQ ZERO, ZERO, 0x9D016624
9D016610  00008025   OR S0, ZERO, ZERO
9D016614  321000FF   ANDI S0, S0, 255
9D016618  0213102B   SLTU V0, S0, S3
9D01661C  10400014   BEQ V0, ZERO, 0x9D016670
9D016620  26310014   ADDIU S1, S1, 20
9D016624  8E220000   LW V0, 0(S1)
9D016628  02421024   AND V0, S2, V0
9D01662C  5040FFF9   BEQL V0, ZERO, 0x9D016614
9D016630  26100001   ADDIU S0, S0, 1
9D016634  92220004   LBU V0, 4(S1)
9D016638  5454FFF6   BNEL V0, S4, 0x9D016614
9D01663C  26100001   ADDIU S0, S0, 1
9D016640  8E220010   LW V0, 16(S1)
9D016644  1040FFF3   BEQ V0, ZERO, 0x9D016614
9D016648  26100001   ADDIU S0, S0, 1
9D01664C  8C420004   LW V0, 4(V0)
9D016650  1040FFF0   BEQ V0, ZERO, 0x9D016614
9D016654  00000000   NOP
9D016658  96240008   LHU A0, 8(S1)
9D01665C  0040F809   JALR V0
9D016660  321000FF   ANDI S0, S0, 255
9D016664  0213102B   SLTU V0, S0, S3
9D016668  1440FFEE   BNE V0, ZERO, 0x9D016624
9D01666C  26310014   ADDIU S1, S1, 20
9D016670  8FBF0024   LW RA, 36(SP)
9D016674  8FB40020   LW S4, 32(SP)
9D016678  8FB3001C   LW S3, 28(SP)
9D01667C  8FB20018   LW S2, 24(SP)
9D016680  8FB10014   LW S1, 20(SP)
9D016684  8FB00010   LW S0, 16(SP)
9D016688  03E00008   JR RA
9D01668C  27BD0028   ADDIU SP, SP, 40
9D016CA4  2482FFFF   ADDIU V0, A0, -1
9D016CA8  2C42FFFE   SLTIU V0, V0, -2
9D016CB4  908200DC   LBU V0, 220(A0)
9D016CC0  948200E8   LHU V0, 232(A0)
9D016CC4  27BDFFE8   ADDIU SP, SP, -24
9D016CC8  AFBF0014   SW RA, 20(SP)
9D016CCC  AC850064   SW A1, 100(A0)
9D016CD0  10460010   BEQ V0, A2, 0x9D016D14
9D016CD4  AC860068   SW A2, 104(A0)
9D016CD8  00C2102B   SLTU V0, A2, V0
9D016CDC  50400004   BEQL V0, ZERO, 0x9D016CF0
9D016CE0  8C8200EC   LW V0, 236(A0)
9D016CE4  24020001   ADDIU V0, ZERO, 1
9D016CE8  AC820074   SW V0, 116(A0)
9D016CEC  8C8200EC   LW V0, 236(A0)
9D016CF0  8C84001C   LW A0, 28(A0)
9D016CF4  00603025   OR A2, V1, ZERO
9D016CF8  8C420038   LW V0, 56(V0)
9D016CFC  0040F809   JALR V0
9D016D00  24050080   ADDIU A1, ZERO, 128
9D016D04  8FBF0014   LW RA, 20(SP)
9D016D08  00001025   OR V0, ZERO, ZERO
9D016D0C  03E00008   JR RA
9D016D10  27BD0018   ADDIU SP, SP, 24
9D016D14  24020002   ADDIU V0, ZERO, 2
9D016D18  AC820074   SW V0, 116(A0)
9D016D1C  8C8200EC   LW V0, 236(A0)
9D016D20  8C84001C   LW A0, 28(A0)
9D016D24  00603025   OR A2, V1, ZERO
9D016D28  8C420038   LW V0, 56(V0)
9D016D2C  0040F809   JALR V0
9D016D30  24050080   ADDIU A1, ZERO, 128
9D016D34  8FBF0014   LW RA, 20(SP)
9D016D38  00001025   OR V0, ZERO, ZERO
9D016D3C  03E00008   JR RA
9D016D40  27BD0018   ADDIU SP, SP, 24
9D016D44  03E00008   JR RA
9D016D48  2402FF8B   ADDIU V0, ZERO, -117
9D0173DC  2482FFFF   ADDIU V0, A0, -1
9D0173E0  2C42FFFE   SLTIU V0, V0, -2
9D0173EC  908200DC   LBU V0, 220(A0)
9D0173F8  27BDFFE8   ADDIU SP, SP, -24
9D0173FC  AFBF0014   SW RA, 20(SP)
9D017400  00803025   OR A2, A0, ZERO
9D017404  A08000C4   SB ZERO, 196(A0)
9D017408  8C8200EC   LW V0, 236(A0)
9D01740C  10A3000B   BEQ A1, V1, USB_DEVICE_ControlStatus
9D017410  8C84001C   LW A0, 28(A0)
9D017414  8C420038   LW V0, 56(V0)
9D017418  24C60064   ADDIU A2, A2, 100
9D01741C  ACC00000   SW ZERO, 0(A2)
9D017420  ACC00004   SW ZERO, 4(A2)
9D017424  0040F809   JALR V0
9D017428  24050080   ADDIU A1, ZERO, 128
9D01742C  8FBF0014   LW RA, 20(SP)
9D017430  00001025   OR V0, ZERO, ZERO
9D017434  03E00008   JR RA
9D017438  27BD0018   ADDIU SP, SP, 24
9D01743C  8C420028   LW V0, 40(V0)
9D017440  0040F809   JALR V0
9D017444  24050080   ADDIU A1, ZERO, 128
9D017448  8FBF0014   LW RA, 20(SP)
9D01744C  00001025   OR V0, ZERO, ZERO
9D017450  03E00008   JR RA
9D017454  27BD0018   ADDIU SP, SP, 24
9D017458  03E00008   JR RA
9D01745C  2402FF8B   ADDIU V0, ZERO, -117
9D017460  8CA70000   LW A3, 0(A1)
9D017464  94A80010   LHU T0, 16(A1)
9D017468  8CA20014   LW V0, 20(A1)
9D01746C  7CE71040   EXT A3, A3, 1, 3
9D017470  11000019   BEQ T0, ZERO, 0x9D0174D8
9D017474  90A900AD   LBU T1, 173(A1)
9D017478  10000003   BEQ ZERO, ZERO, 0x9D017488
9D01747C  00001825   OR V1, ZERO, ZERO
9D017480  10C00015   BEQ A2, ZERO, 0x9D0174D8
9D017484  24420014   ADDIU V0, V0, 20
9D017488  8C450000   LW A1, 0(V0)
9D01748C  24630001   ADDIU V1, V1, 1
9D017490  306300FF   ANDI V1, V1, 255
9D017494  00E52824   AND A1, A3, A1
9D017498  10A0FFF9   BEQ A1, ZERO, 0x9D017480
9D01749C  0068302B   SLTU A2, V1, T0
9D0174A0  90450004   LBU A1, 4(V0)
9D0174A4  14A9FFF6   BNE A1, T1, 0x9D017480
9D0174A8  00000000   NOP
9D0174AC  904A0005   LBU T2, 5(V0)
9D0174B0  008A282B   SLTU A1, A0, T2
9D0174B4  14A0FFF2   BNE A1, ZERO, 0x9D017480
9D0174B8  00000000   NOP
9D0174BC  90450006   LBU A1, 6(V0)
9D0174C0  00AA2821   ADDU A1, A1, T2
9D0174C4  0085282A   SLT A1, A0, A1
9D0174C8  10A0FFED   BEQ A1, ZERO, 0x9D017480
9D0174CC  00000000   NOP
9D0174D0  03E00008   JR RA
9D0174D4  00000000   NOP
9D0174D8  03E00008   JR RA
9D0174DC  00001025   OR V0, ZERO, ZERO
9D017A00  2482FFFF   ADDIU V0, A0, -1
9D017A04  2C42FFFE   SLTIU V0, V0, -2
9D017A10  908200DC   LBU V0, 220(A0)
9D017A1C  8C8200EC   LW V0, 236(A0)
9D017A20  27BDFFE8   ADDIU SP, SP, -24
9D017A24  AFB00010   SW S0, 16(SP)
9D017A28  8C420018   LW V0, 24(V0)
9D017A2C  00808025   OR S0, A0, ZERO
9D017A30  8C84001C   LW A0, 28(A0)
9D017A34  AFBF0014   SW RA, 20(SP)
9D017A38  0040F809   JALR V0
9D017A3C  00000000   NOP
9D017A40  92020003   LBU V0, 3(S0)
9D017A44  24030002   ADDIU V1, ZERO, 2
9D017A48  7C621004   INS V0, V1, 0, 3
9D017A4C  A2020003   SB V0, 3(S0)
9D017A50  8FBF0014   LW RA, 20(SP)
9D017A54  8FB00010   LW S0, 16(SP)
9D017A58  03E00008   JR RA
9D017A5C  27BD0018   ADDIU SP, SP, 24
9D017A60  03E00008   JR RA
9D017A64  00000000   NOP
9D01811C  14800011   BNE A0, ZERO, 0x9D018164
9D018120  3C03A000   LUI V1, -24576
9D018124  24632978   ADDIU V1, V1, 10616
9D018128  8C640008   LW A0, 8(V1)
9D01812C  24020002   ADDIU V0, ZERO, 2
9D018130  1482000C   BNE A0, V0, 0x9D018164
9D018134  00000000   NOP
9D018138  906400DC   LBU A0, 220(V1)
9D01813C  10800003   BEQ A0, ZERO, 0x9D01814C
9D018140  2402FFFF   ADDIU V0, ZERO, -1
9D018144  03E00008   JR RA
9D018148  00000000   NOP
9D01814C  24020001   ADDIU V0, ZERO, 1
9D018150  A06200DC   SB V0, 220(V1)
9D018154  24020001   ADDIU V0, ZERO, 1
9D018158  AC6200D8   SW V0, 216(V1)
9D01815C  03E00008   JR RA
9D018160  00601025   OR V0, V1, ZERO
9D018164  03E00008   JR RA
9D018168  2402FFFF   ADDIU V0, ZERO, -1
9D0182A4  2483FFFF   ADDIU V1, A0, -1
9D0182A8  2C63FFFE   SLTIU V1, V1, -2
9D0182AC  1060000D   BEQ V1, ZERO, 0x9D0182E4
9D0182B4  908300DC   LBU V1, 220(A0)
9D0182C0  8C8300EC   LW V1, 236(A0)
9D0182C4  8C84001C   LW A0, 28(A0)
9D0182C8  8C790008   LW T9, 8(V1)
9D0182CC  AC4600E4   SW A2, 228(V0)
9D0182D0  3C069D01   LUI A2, -25343
9D0182D4  AC4500E0   SW A1, 224(V0)
9D0182D8  24C60D34   ADDIU A2, A2, 3380
9D0182DC  03200008   JR T9
9D0182E0  00402825   OR A1, V0, ZERO
9D0182E4  03E00008   JR RA
9D0182E8  00000000   NOP
9D018554  2482FFFF   ADDIU V0, A0, -1
9D018558  2C42FFFE   SLTIU V0, V0, -2
9D01855C  00C02825   OR A1, A2, ZERO
9D018560  00E03025   OR A2, A3, ZERO
9D018564  10400009   BEQ V0, ZERO, 0x9D01858C
9D018568  8FA70010   LW A3, 16(SP)
9D01856C  908200DC   LBU V0, 220(A0)
9D018570  10400006   BEQ V0, ZERO, 0x9D01858C
9D018574  00000000   NOP
9D018578  8C8200EC   LW V0, 236(A0)
9D01857C  8C84001C   LW A0, 28(A0)
9D018580  8C590020   LW T9, 32(V0)
9D018584  03200008   JR T9
9D018588  30E7FFFF   ANDI A3, A3, -1
9D01858C  03E00008   JR RA
9D018590  2402FF84   ADDIU V0, ZERO, -124
9D018770  2482FFFF   ADDIU V0, A0, -1
9D018774  2C42FFFE   SLTIU V0, V0, -2
9D018780  908200DC   LBU V0, 220(A0)
9D01878C  AC8500CC   SW A1, 204(A0)
9D018790  A08000C5   SB ZERO, 197(A0)
9D018794  A08600C6   SB A2, 198(A0)
9D018798  03E00008   JR RA
9D01879C  00001025   OR V0, ZERO, ZERO
9D0187A0  03E00008   JR RA
9D0187A4  2402FF8B   ADDIU V0, ZERO, -117
9D018848  2482FFFF   ADDIU V0, A0, -1
9D01884C  2C42FFFE   SLTIU V0, V0, -2
9D018850  10400008   BEQ V0, ZERO, 0x9D018874
9D018854  00000000   NOP
9D018858  908200DC   LBU V0, 220(A0)
9D01885C  10400005   BEQ V0, ZERO, 0x9D018874
9D018860  00000000   NOP
9D018864  8C8200EC   LW V0, 236(A0)
9D018868  8C590024   LW T9, 36(V0)
9D01886C  03200008   JR T9
9D018870  8C84001C   LW A0, 28(A0)
9D018874  03E00008   JR RA
9D018878  2402FF84   ADDIU V0, ZERO, -124
9D01887C  2482FFFF   ADDIU V0, A0, -1
9D018880  2C42FFFE   SLTIU V0, V0, -2
9D01888C  908200DC   LBU V0, 220(A0)
9D018898  8C8200EC   LW V0, 236(A0)
9D01889C  8C590038   LW T9, 56(V0)
9D0188A0  03200008   JR T9
9D0188A4  8C84001C   LW A0, 28(A0)
9D0188A8  03E00008   JR RA
9D0188AC  2402FF83   ADDIU V0, ZERO, -125
9D0188B0  2482FFFF   ADDIU V0, A0, -1
9D0188B4  2C42FFFE   SLTIU V0, V0, -2
9D0188C0  908200DC   LBU V0, 220(A0)
9D0188CC  8C8200EC   LW V0, 236(A0)
9D0188D0  8C590040   LW T9, 64(V0)
9D0188D4  03200008   JR T9
9D0188D8  8C84001C   LW A0, 28(A0)
9D0188DC  03E00008   JR RA
9D0188E0  2402FF83   ADDIU V0, ZERO, -125
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/tasks.c  -----------------------------------
1:                   /*******************************************************************************
2:                    System Tasks File
3:                   
4:                     File Name:
5:                       tasks.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to maintain system's polled tasks.
9:                   
10:                    Description:
11:                      This file contains source code necessary to maintain system's polled tasks.
12:                      It implements the "SYS_Tasks" function that calls the individual "Tasks"
13:                      functions for all polled MPLAB Harmony modules in the system.
14:                  
15:                    Remarks:
16:                      This file requires access to the systemObjects global data structure that
17:                      contains the object handles to all MPLAB Harmony module objects executing
18:                      polled in the system.  These handles are passed into the individual module
19:                      "Tasks" functions to identify the instance of the module to maintain.
20:                   *******************************************************************************/
21:                  
22:                  // DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
25:                  *
26:                  * Subject to your compliance with these terms, you may use Microchip software
27:                  * and any derivatives exclusively with Microchip products. It is your
28:                  * responsibility to comply with third party license terms applicable to your
29:                  * use of third party software (including open source software) that may
30:                  * accompany Microchip software.
31:                  *
32:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
33:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
34:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
35:                  * PARTICULAR PURPOSE.
36:                  *
37:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
38:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
39:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
40:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
41:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
42:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
43:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
44:                   *******************************************************************************/
45:                  // DOM-IGNORE-END
46:                  
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  // Section: Included Files
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  
53:                  #include "configuration.h"
54:                  #include "definitions.h"
55:                  
56:                  bool taskBusy = false;
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: System "Tasks" Routine
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  /*******************************************************************************
65:                    Function:
66:                      void SYS_Tasks ( void )
67:                  
68:                    Remarks:
69:                      See prototype in system/common/sys_module.h.
70:                  */
71:                  void SYS_Tasks ( void )
72:                  {
73:                      taskBusy = false;
74:                      
75:                      /* Maintain system services */
76:                      
77:                  
78:                      /* Maintain Device Drivers */
79:                      
80:                  
81:                      /* Maintain Middleware & Other Libraries */
82:                          /* USB Device layer tasks routine */ 
83:                      USB_DEVICE_Tasks(sysObj.usbDevObject0);
84:                  
85:                  
86:                  
87:                  
88:                      /* Maintain the application's state machine. */
89:                          /* Call Application task APP. */
90:                      APP_Tasks();
91:                  
92:                      /* Call Application task APP_USB. */
93:                      APP_USB_Tasks();
94:                  
95:                      /* Call Application task APP_BLE. */
96:                      APP_BLE_Tasks();
97:                      
98:                      /* Call Application task APP_X1TXO. */
99:                      APP_X1TXO_Tasks();
100:                     
101:                     /* If tasks are not busy enter idle mode */
102:                         /* Will wake up upon core timer event */
103:                         /* For now always stay in normal mode, optimize later */
104:                     taskBusy = true;
105:                     if (!taskBusy) {
106:                         POWER_LowPowerModeEnter(LOW_POWER_IDLE_MODE);
107:                     }
108:                 }
109:                 
110:                 /*******************************************************************************
111:                  End of File
112:                  */
113:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0182EC  8F848028   LW A0, -32728(GP)
9D0182F0  27BDFFE8   ADDIU SP, SP, -24
9D0182F4  AFBF0014   SW RA, 20(SP)
9D0182F8  0F404DD9   JAL USB_DEVICE_Tasks
9D0182FC  A3808026   SB ZERO, -32730(GP)
9D018300  0F402DDA   JAL APP_Tasks
9D018304  00000000   NOP
9D018308  0F4042A7   JAL APP_USB_Tasks
9D01830C  00000000   NOP
9D018310  0F404E81   JAL APP_BLE_Tasks
9D018314  00000000   NOP
9D018318  0F404D83   JAL APP_X1TXO_Tasks
9D01831C  00000000   NOP
9D018320  8FBF0014   LW RA, 20(SP)
9D018324  24020001   ADDIU V0, ZERO, 1
9D018328  A3828026   SB V0, -32730(GP)
9D01832C  03E00008   JR RA
9D018330  27BD0018   ADDIU SP, SP, 24
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/system/int/src/sys_int.c  ------------------
1:                   /*******************************************************************************
2:                     Interrupt System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_int.c
9:                   
10:                    Summary:
11:                      Interrupt System Service APIs.
12:                  
13:                    Description:
14:                      This file contains functions related to the Interrupt System Service for PIC32
15:                      devices.
16:                  *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
21:                  *
22:                  * Subject to your compliance with these terms, you may use Microchip software
23:                  * and any derivatives exclusively with Microchip products. It is your
24:                  * responsibility to comply with third party license terms applicable to your
25:                  * use of third party software (including open source software) that may
26:                  * accompany Microchip software.
27:                  *
28:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                  * PARTICULAR PURPOSE.
32:                  *
33:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                  *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  // *****************************************************************************
44:                  // *****************************************************************************
45:                  // Section: Included Files
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  
49:                  #include "system/int/sys_int.h"
50:                  #include "peripheral/evic/plib_evic.h"
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Function Definitions
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  void SYS_INT_Enable( void )
59:                  {
60:                      EVIC_INT_Enable();
61:                  }
62:                  
63:                  bool SYS_INT_Disable( void )
64:                  {
65:                      /* return the interrupt status */
66:                      return EVIC_INT_Disable();
67:                  }
68:                  
69:                  void SYS_INT_Restore( bool state )
70:                  {
71:                      EVIC_INT_Restore(state);
72:                  }
73:                  
74:                  bool SYS_INT_SourceDisable( INT_SOURCE source )
75:                  {
76:                      bool intSrcStatus;
77:                      bool interruptStatus;
78:                  
79:                      /* Save the interrupt status and then Disable the global interrupt */
80:                      interruptStatus = (bool)(( uint32_t )__builtin_disable_interrupts() & 0x01);
81:                  
82:                      /* get the interrupt status of this source before disable is called */
83:                      intSrcStatus = SYS_INT_SourceIsEnabled(source);
84:                  
85:                      /* disable the interrupts */
86:                      EVIC_SourceDisable(source);
87:                  
88:                      SYS_INT_Restore(interruptStatus);
89:                  
90:                      /* return the source status */
91:                      return intSrcStatus;
92:                  }
93:                  
94:                  void SYS_INT_SourceRestore( INT_SOURCE source, bool status )
95:                  {
96:                      if( status )
97:                      {
98:                          SYS_INT_SourceEnable( source );
99:                      }
100:                 }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000008  00000000   NOP
00000010  00000000   NOP
00000018  00000000   NOP
9D00B3B8  0B406389   J EVIC_INT_Disable
9D00B3BC  00000000   NOP
9D00B3D8  0B406325   J EVIC_INT_Restore
9D00B3DC  00000000   NOP
9D00B3E0  0B4060DF   J _DefaultInterrupt
9D0180CC  27BDFFD8   ADDIU SP, SP, -40
9D0180D0  AFB10020   SW S1, 32(SP)
9D0180D4  00808825   OR S1, A0, ZERO
9D0180D8  AFBF0024   SW RA, 36(SP)
9D0180DC  AFB0001C   SW S0, 28(SP)
9D0180E0  41706000   DI S0
9D0180E4  000000C0   EHB
9D0180E8  0F406380   JAL EVIC_SourceIsEnabled
9D0180EC  00000000   NOP
9D0180F0  02202025   OR A0, S1, ZERO
9D0180F4  0F406311   JAL EVIC_SourceDisable
9D0180F8  AFA20010   SW V0, 16(SP)
9D0180FC  0F406325   JAL EVIC_INT_Restore
9D018104  8FBF0024   LW RA, 36(SP)
9D018108  8FA20010   LW V0, 16(SP)
9D01810C  8FB10020   LW S1, 32(SP)
9D018110  8FB0001C   LW S0, 28(SP)
9D018114  03E00008   JR RA
9D018118  27BD0028   ADDIU SP, SP, 40
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/stdio/xc32_monitor.c  ----------------------
1:                   /*******************************************************************************
2:                    Debug Console Source file
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       xc32_monitor.c
9:                   
10:                    Summary:
11:                      debug console Source File
12:                  
13:                    Description:
14:                      None
15:                  
16:                  *******************************************************************************/
17:                  
18:                  /*******************************************************************************
19:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
20:                  *
21:                  * Subject to your compliance with these terms, you may use Microchip software
22:                  * and any derivatives exclusively with Microchip products. It is your
23:                  * responsibility to comply with third party license terms applicable to your
24:                  * use of third party software (including open source software) that may
25:                  * accompany Microchip software.
26:                  *
27:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                  * PARTICULAR PURPOSE.
31:                  *
32:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
33:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
34:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
35:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
36:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
37:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
38:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
39:                  *******************************************************************************/
40:                  #include <stddef.h>
41:                  
42:                  extern int read(int handle, void *buffer, unsigned int len);
43:                  extern int write(int handle, void * buffer, size_t count);
44:                  
45:                  
46:                  int read(int handle, void *buffer, unsigned int len)
47:                  {
48:                     return -1;
49:                  }
50:                  
51:                  int write(int handle, void * buffer, size_t count)
52:                  {
53:                     return -1;
54:                  }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/peripheral/uart/plib_uart2.c  --------------
1:                   /*******************************************************************************
2:                     UART2 PLIB
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_uart2.c
9:                   
10:                    Summary:
11:                      UART2 PLIB Implementation File
12:                  
13:                    Description:
14:                      None
15:                  
16:                  *******************************************************************************/
17:                  
18:                  /*******************************************************************************
19:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
20:                  *
21:                  * Subject to your compliance with these terms, you may use Microchip software
22:                  * and any derivatives exclusively with Microchip products. It is your
23:                  * responsibility to comply with third party license terms applicable to your
24:                  * use of third party software (including open source software) that may
25:                  * accompany Microchip software.
26:                  *
27:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                  * PARTICULAR PURPOSE.
31:                  *
32:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
33:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
34:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
35:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
36:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
37:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
38:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
39:                  *******************************************************************************/
40:                  
41:                  #include "device.h"
42:                  #include "plib_uart2.h"
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Section: UART2 Implementation
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  
50:                  UART_RING_BUFFER_OBJECT uart2Obj;
51:                  
52:                  #define UART2_READ_BUFFER_SIZE      128
53:                  #define UART2_READ_BUFFER_SIZE_9BIT (128 >> 1)
54:                  #define UART2_RX_INT_DISABLE()      IEC1CLR = _IEC1_U2RXIE_MASK;
55:                  #define UART2_RX_INT_ENABLE()       IEC1SET = _IEC1_U2RXIE_MASK;
56:                  
57:                  static uint8_t UART2_ReadBuffer[UART2_READ_BUFFER_SIZE];
58:                  
59:                  #define UART2_WRITE_BUFFER_SIZE     128
60:                  #define UART2_WRITE_BUFFER_SIZE_9BIT       (128 >> 1)
61:                  #define UART2_TX_INT_DISABLE()      IEC1CLR = _IEC1_U2TXIE_MASK;
62:                  #define UART2_TX_INT_ENABLE()       IEC1SET = _IEC1_U2TXIE_MASK;
63:                  
64:                  static uint8_t UART2_WriteBuffer[UART2_WRITE_BUFFER_SIZE];
65:                  
66:                  #define UART2_IS_9BIT_MODE_ENABLED()    ( U2MODE & (_U2MODE_PDSEL0_MASK | _U2MODE_PDSEL1_MASK)) == (_U2MODE_PDSEL0_MASK | _U2MODE_PDSEL1_MASK) ? true:false
67:                  
68:                  void static UART2_ErrorClear( void )
69:                  {
70:                      UART_ERROR errors = UART_ERROR_NONE;
71:                      uint8_t dummyData = 0u;
72:                  
73:                      errors = (UART_ERROR)(U2STA & (_U2STA_OERR_MASK | _U2STA_FERR_MASK | _U2STA_PERR_MASK));
74:                  
75:                      if(errors != UART_ERROR_NONE)
76:                      {
77:                          /* If it's a overrun error then clear it to flush FIFO */
78:                          if(U2STA & _U2STA_OERR_MASK)
79:                          {
80:                              U2STACLR = _U2STA_OERR_MASK;
81:                          }
82:                  
83:                          /* Read existing error bytes from FIFO to clear parity and framing error flags */
84:                          while(U2STA & _U2STA_URXDA_MASK)
85:                          {
86:                              dummyData = U2RXREG;
87:                          }
88:                  
89:                          /* Clear error interrupt flag */
90:                          IFS1CLR = _IFS1_U2EIF_MASK;
91:                  
92:                          /* Clear up the receive interrupt flag so that RX interrupt is not
93:                           * triggered for error bytes */
94:                          IFS1CLR = _IFS1_U2RXIF_MASK;
95:                  
96:                      }
97:                  
98:                      // Ignore the warning
99:                      (void)dummyData;
100:                 }
101:                 
102:                 void UART2_Initialize( void )
103:                 {
104:                     /* Set up UxMODE bits */
105:                     /* STSEL  = 0*/
106:                     /* PDSEL = 0 */
107:                     /* BRGH = 1 */
108:                     /* RXINV = 0 */
109:                     /* ABAUD = 0 */
110:                     /* LPBACK = 0 */
111:                     /* WAKE = 0 */
112:                     /* SIDL = 0 */
113:                     /* RUNOVF = 0 */
114:                     /* CLKSEL = 0 */
115:                     /* SLPEN = 0 */
116:                     U2MODE = 0x8;
117:                 
118:                     /* Enable UART2 Receiver, Transmitter and TX Interrupt selection */
119:                     U2STASET = (_U2STA_UTXEN_MASK | _U2STA_URXEN_MASK | _U2STA_UTXISEL1_MASK );
120:                 
121:                     /* BAUD Rate register Setup */
122:                     U2BRG = 143;
123:                 
124:                     IEC1CLR = _IEC1_U2TXIE_MASK;
125:                 
126:                     /* Initialize instance object */
127:                     uart2Obj.rdCallback = NULL;
128:                     uart2Obj.rdInIndex = 0;
129:                     uart2Obj.rdOutIndex = 0;
130:                     uart2Obj.isRdNotificationEnabled = false;
131:                     uart2Obj.isRdNotifyPersistently = false;
132:                     uart2Obj.rdThreshold = 0;
133:                 
134:                     uart2Obj.wrCallback = NULL;
135:                     uart2Obj.wrInIndex = 0;
136:                     uart2Obj.wrOutIndex = 0;
137:                     uart2Obj.isWrNotificationEnabled = false;
138:                     uart2Obj.isWrNotifyPersistently = false;
139:                     uart2Obj.wrThreshold = 0;
140:                 
141:                     uart2Obj.errors = UART_ERROR_NONE;
142:                 
143:                     if (UART2_IS_9BIT_MODE_ENABLED())
144:                     {
145:                         uart2Obj.rdBufferSize = UART2_READ_BUFFER_SIZE_9BIT;
146:                         uart2Obj.wrBufferSize = UART2_WRITE_BUFFER_SIZE_9BIT;
147:                     }
148:                     else
149:                     {
150:                         uart2Obj.rdBufferSize = UART2_READ_BUFFER_SIZE;
151:                         uart2Obj.wrBufferSize = UART2_WRITE_BUFFER_SIZE;
152:                     }
153:                 
154:                 
155:                     /* Turn ON UART2 */
156:                     U2MODESET = _U2MODE_ON_MASK;
157:                 
158:                     /* Enable UART2_FAULT Interrupt */
159:                     IEC1SET = _IEC1_U2EIE_MASK;
160:                 
161:                     /* Enable UART2_RX Interrupt */
162:                     IEC1SET = _IEC1_U2RXIE_MASK;
163:                 }
164:                 
165:                 bool UART2_SerialSetup( UART_SERIAL_SETUP *setup, uint32_t srcClkFreq )
166:                 {
167:                     bool status = false;
168:                     uint32_t baud;
169:                     uint32_t status_ctrl;
170:                     uint8_t brgh = 1;
171:                     int32_t uxbrg = 0;
172:                 
173:                     if (setup != NULL)
174:                     {
175:                         baud = setup->baudRate;
176:                 
177:                         if ((baud == 0) || ((setup->dataWidth == UART_DATA_9_BIT) && (setup->parity != UART_PARITY_NONE)))
178:                         {
179:                             return status;
180:                         }
181:                 
182:                         if(srcClkFreq == 0)
183:                         {
184:                             srcClkFreq = UART2_FrequencyGet();
185:                         }
186:                 
187:                          /* Calculate BRG value */
188:                         if (brgh == 0)
189:                         {
190:                             uxbrg = (((srcClkFreq >> 4) + (baud >> 1)) / baud ) - 1;
191:                         }
192:                         else
193:                         {
194:                             uxbrg = (((srcClkFreq >> 2) + (baud >> 1)) / baud ) - 1;
195:                         }
196:                 
197:                         /* Check if the baud value can be set with low baud settings */
198:                         if((uxbrg < 0) || (uxbrg > UINT16_MAX))
199:                         {
200:                             return status;
201:                         }
202:                 
203:                         /* Turn OFF UART2. Save UTXEN, URXEN and UTXBRK bits as these are cleared upon disabling UART */
204:                 
205:                         status_ctrl = U2STA & (_U2STA_UTXEN_MASK | _U2STA_URXEN_MASK | _U2STA_UTXBRK_MASK);
206:                 
207:                         U2MODECLR = _U2MODE_ON_MASK;
208:                 
209:                         if(setup->dataWidth == UART_DATA_9_BIT)
210:                         {
211:                             /* Configure UART2 mode */
212:                             U2MODE = (U2MODE & (~_U2MODE_PDSEL_MASK)) | setup->dataWidth;
213:                         }
214:                         else
215:                         {
216:                             /* Configure UART2 mode */
217:                             U2MODE = (U2MODE & (~_U2MODE_PDSEL_MASK)) | setup->parity;
218:                         }
219:                 
220:                         /* Configure UART2 mode */
221:                         U2MODE = (U2MODE & (~_U2MODE_STSEL_MASK)) | setup->stopBits;
222:                 
223:                         /* Configure UART2 Baud Rate */
224:                         U2BRG = uxbrg;
225:                 
226:                         if (UART2_IS_9BIT_MODE_ENABLED())
227:                         {
228:                             uart2Obj.rdBufferSize = UART2_READ_BUFFER_SIZE_9BIT;
229:                             uart2Obj.wrBufferSize = UART2_WRITE_BUFFER_SIZE_9BIT;
230:                         }
231:                         else
232:                         {
233:                             uart2Obj.rdBufferSize = UART2_READ_BUFFER_SIZE;
234:                             uart2Obj.wrBufferSize = UART2_WRITE_BUFFER_SIZE;
235:                         }
236:                 
237:                         U2MODESET = _U2MODE_ON_MASK;
238:                 
239:                         /* Restore UTXEN, URXEN and UTXBRK bits. */
240:                         U2STASET = status_ctrl;
241:                 
242:                         status = true;
243:                     }
244:                 
245:                     return status;
246:                 }
247:                 
248:                 /* This routine is only called from ISR. Hence do not disable/enable USART interrupts. */
249:                 static inline bool UART2_RxPushByte(uint16_t rdByte)
250:                 {
251:                     uint32_t tempInIndex;
252:                     bool isSuccess = false;
253:                 
254:                     tempInIndex = uart2Obj.rdInIndex + 1;
255:                 
256:                     if (tempInIndex >= uart2Obj.rdBufferSize)
257:                     {
258:                         tempInIndex = 0;
259:                     }
260:                 
261:                     if (tempInIndex == uart2Obj.rdOutIndex)
262:                     {
263:                         /* Queue is full - Report it to the application. Application gets a chance to free up space by reading data out from the RX ring buffer */
264:                         if(uart2Obj.rdCallback != NULL)
265:                         {
266:                             uart2Obj.rdCallback(UART_EVENT_READ_BUFFER_FULL, uart2Obj.rdContext);
267:                 
268:                             /* Read the indices again in case application has freed up space in RX ring buffer */
269:                             tempInIndex = uart2Obj.rdInIndex + 1;
270:                 
271:                             if (tempInIndex >= uart2Obj.rdBufferSize)
272:                             {
273:                                 tempInIndex = 0;
274:                             }
275:                         }
276:                     }
277:                 
278:                     /* Attempt to push the data into the ring buffer */
279:                     if (tempInIndex != uart2Obj.rdOutIndex)
280:                     {
281:                         if (UART2_IS_9BIT_MODE_ENABLED())
282:                         {
283:                             ((uint16_t*)&UART2_ReadBuffer)[uart2Obj.rdInIndex] = rdByte;
284:                         }
285:                         else
286:                         {
287:                             UART2_ReadBuffer[uart2Obj.rdInIndex] = (uint8_t)rdByte;
288:                         }
289:                 
290:                         uart2Obj.rdInIndex = tempInIndex;
291:                 
292:                         isSuccess = true;
293:                     }
294:                     else
295:                     {
296:                         /* Queue is full. Data will be lost. */
297:                     }
298:                 
299:                     return isSuccess;
300:                 }
301:                 
302:                 /* This routine is only called from ISR. Hence do not disable/enable USART interrupts. */
303:                 static void UART2_ReadNotificationSend(void)
304:                 {
305:                     uint32_t nUnreadBytesAvailable;
306:                 
307:                     if (uart2Obj.isRdNotificationEnabled == true)
308:                     {
309:                         nUnreadBytesAvailable = UART2_ReadCountGet();
310:                 
311:                         if(uart2Obj.rdCallback != NULL)
312:                         {
313:                             if (uart2Obj.isRdNotifyPersistently == true)
314:                             {
315:                                 if (nUnreadBytesAvailable >= uart2Obj.rdThreshold)
316:                                 {
317:                                     uart2Obj.rdCallback(UART_EVENT_READ_THRESHOLD_REACHED, uart2Obj.rdContext);
318:                                 }
319:                             }
320:                             else
321:                             {
322:                                 if (nUnreadBytesAvailable == uart2Obj.rdThreshold)
323:                                 {
324:                                     uart2Obj.rdCallback(UART_EVENT_READ_THRESHOLD_REACHED, uart2Obj.rdContext);
325:                                 }
326:                             }
327:                         }
328:                     }
329:                 }
330:                 
331:                 size_t UART2_Read(uint8_t* pRdBuffer, const size_t size)
332:                 {
333:                     size_t nBytesRead = 0;
334:                     uint32_t rdOutIndex = 0;
335:                     uint32_t rdInIndex = 0;
336:                 
337:                     /* Take a snapshot of indices to avoid creation of critical section */
338:                     rdOutIndex = uart2Obj.rdOutIndex;
339:                     rdInIndex = uart2Obj.rdInIndex;
340:                 
341:                     while (nBytesRead < size)
342:                     {
343:                         if (rdOutIndex != rdInIndex)
344:                         {
345:                             if (UART2_IS_9BIT_MODE_ENABLED())
346:                             {
347:                                 ((uint16_t*)pRdBuffer)[nBytesRead++] = ((uint16_t*)&UART2_ReadBuffer)[rdOutIndex++];
348:                             }
349:                             else
350:                             {
351:                                 pRdBuffer[nBytesRead++] = UART2_ReadBuffer[rdOutIndex++];
352:                             }
353:                 
354:                             if (rdOutIndex >= uart2Obj.rdBufferSize)
355:                             {
356:                                 rdOutIndex = 0;
357:                             }
358:                         }
359:                         else
360:                         {
361:                             /* No more data available in the RX buffer */
362:                             break;
363:                         }
364:                     }
365:                 
366:                     uart2Obj.rdOutIndex = rdOutIndex;
367:                 
368:                     return nBytesRead;
369:                 }
370:                 
371:                 size_t UART2_ReadCountGet(void)
372:                 {
373:                     size_t nUnreadBytesAvailable;
374:                     uint32_t rdInIndex;
375:                     uint32_t rdOutIndex;
376:                 
377:                     /* Take a snapshot of indices to avoid processing in critical section */
378:                     rdInIndex = uart2Obj.rdInIndex;
379:                     rdOutIndex = uart2Obj.rdOutIndex;
380:                 
381:                     if ( rdInIndex >=  rdOutIndex)
382:                     {
383:                         nUnreadBytesAvailable =  rdInIndex -  rdOutIndex;
384:                     }
385:                     else
386:                     {
387:                         nUnreadBytesAvailable =  (uart2Obj.rdBufferSize -  rdOutIndex) + rdInIndex;
388:                     }
389:                 
390:                     return nUnreadBytesAvailable;
391:                 }
392:                 
393:                 size_t UART2_ReadFreeBufferCountGet(void)
394:                 {
395:                     return (uart2Obj.rdBufferSize - 1) - UART2_ReadCountGet();
396:                 }
397:                 
398:                 size_t UART2_ReadBufferSizeGet(void)
399:                 {
400:                     return (uart2Obj.rdBufferSize - 1);
401:                 }
402:                 
403:                 bool UART2_ReadNotificationEnable(bool isEnabled, bool isPersistent)
404:                 {
405:                     bool previousStatus = uart2Obj.isRdNotificationEnabled;
406:                 
407:                     uart2Obj.isRdNotificationEnabled = isEnabled;
408:                 
409:                     uart2Obj.isRdNotifyPersistently = isPersistent;
410:                 
411:                     return previousStatus;
412:                 }
413:                 
414:                 void UART2_ReadThresholdSet(uint32_t nBytesThreshold)
415:                 {
416:                     if (nBytesThreshold > 0)
417:                     {
418:                         uart2Obj.rdThreshold = nBytesThreshold;
419:                     }
420:                 }
421:                 
422:                 void UART2_ReadCallbackRegister( UART_RING_BUFFER_CALLBACK callback, uintptr_t context)
423:                 {
424:                     uart2Obj.rdCallback = callback;
425:                 
426:                     uart2Obj.rdContext = context;
427:                 }
428:                 
429:                 /* This routine is only called from ISR. Hence do not disable/enable USART interrupts. */
430:                 static bool UART2_TxPullByte(uint16_t* pWrByte)
431:                 {
432:                     bool isSuccess = false;
433:                     uint32_t wrOutIndex = uart2Obj.wrOutIndex;
434:                     uint32_t wrInIndex = uart2Obj.wrInIndex;
435:                 
436:                     if (wrOutIndex != wrInIndex)
437:                     {
438:                         if (UART2_IS_9BIT_MODE_ENABLED())
439:                         {
440:                             *pWrByte = ((uint16_t*)&UART2_WriteBuffer)[wrOutIndex++];
441:                         }
442:                         else
443:                         {
444:                             *pWrByte = UART2_WriteBuffer[wrOutIndex++];
445:                         }
446:                 
447:                         if (wrOutIndex >= uart2Obj.wrBufferSize)
448:                         {
449:                             wrOutIndex = 0;
450:                         }
451:                 
452:                         uart2Obj.wrOutIndex = wrOutIndex;
453:                 
454:                         isSuccess = true;
455:                     }
456:                 
457:                     return isSuccess;
458:                 }
459:                 
460:                 static inline bool UART2_TxPushByte(uint16_t wrByte)
461:                 {
462:                     uint32_t tempInIndex;
463:                     bool isSuccess = false;
464:                 
465:                     uint32_t wrOutIndex = uart2Obj.wrOutIndex;
466:                     uint32_t wrInIndex = uart2Obj.wrInIndex;
467:                 
468:                     tempInIndex = wrInIndex + 1;
469:                 
470:                     if (tempInIndex >= uart2Obj.wrBufferSize)
471:                     {
472:                         tempInIndex = 0;
473:                     }
474:                     if (tempInIndex != wrOutIndex)
475:                     {
476:                         if (UART2_IS_9BIT_MODE_ENABLED())
477:                         {
478:                             ((uint16_t*)&UART2_WriteBuffer)[wrInIndex] = wrByte;
479:                         }
480:                         else
481:                         {
482:                             UART2_WriteBuffer[wrInIndex] = (uint8_t)wrByte;
483:                         }
484:                 
485:                         uart2Obj.wrInIndex = tempInIndex;
486:                 
487:                         isSuccess = true;
488:                     }
489:                     else
490:                     {
491:                         /* Queue is full. Report Error. */
492:                     }
493:                 
494:                     return isSuccess;
495:                 }
496:                 
497:                 /* This routine is only called from ISR. Hence do not disable/enable USART interrupts. */
498:                 static void UART2_WriteNotificationSend(void)
499:                 {
500:                     uint32_t nFreeWrBufferCount;
501:                 
502:                     if (uart2Obj.isWrNotificationEnabled == true)
503:                     {
504:                         nFreeWrBufferCount = UART2_WriteFreeBufferCountGet();
505:                 
506:                         if(uart2Obj.wrCallback != NULL)
507:                         {
508:                             if (uart2Obj.isWrNotifyPersistently == true)
509:                             {
510:                                 if (nFreeWrBufferCount >= uart2Obj.wrThreshold)
511:                                 {
512:                                     uart2Obj.wrCallback(UART_EVENT_WRITE_THRESHOLD_REACHED, uart2Obj.wrContext);
513:                                 }
514:                             }
515:                             else
516:                             {
517:                                 if (nFreeWrBufferCount == uart2Obj.wrThreshold)
518:                                 {
519:                                     uart2Obj.wrCallback(UART_EVENT_WRITE_THRESHOLD_REACHED, uart2Obj.wrContext);
520:                                 }
521:                             }
522:                         }
523:                     }
524:                 }
525:                 
526:                 static size_t UART2_WritePendingBytesGet(void)
527:                 {
528:                     size_t nPendingTxBytes;
529:                 
530:                     /* Take a snapshot of indices to avoid processing in critical section */
531:                 
532:                     uint32_t wrOutIndex = uart2Obj.wrOutIndex;
533:                     uint32_t wrInIndex = uart2Obj.wrInIndex;
534:                 
535:                     if ( wrInIndex >=  wrOutIndex)
536:                     {
537:                         nPendingTxBytes =  wrInIndex - wrOutIndex;
538:                     }
539:                     else
540:                     {
541:                         nPendingTxBytes =  (uart2Obj.wrBufferSize -  wrOutIndex) + wrInIndex;
542:                     }
543:                 
544:                     return nPendingTxBytes;
545:                 }
546:                 
547:                 size_t UART2_WriteCountGet(void)
548:                 {
549:                     size_t nPendingTxBytes;
550:                 
551:                     nPendingTxBytes = UART2_WritePendingBytesGet();
552:                 
553:                     return nPendingTxBytes;
554:                 }
555:                 
556:                 size_t UART2_Write(uint8_t* pWrBuffer, const size_t size )
557:                 {
558:                     size_t nBytesWritten  = 0;
559:                 
560:                     while (nBytesWritten < size)
561:                     {
562:                         if (UART2_IS_9BIT_MODE_ENABLED())
563:                         {
564:                             if (UART2_TxPushByte(((uint16_t*)pWrBuffer)[nBytesWritten]) == true)
565:                             {
566:                                 nBytesWritten++;
567:                             }
568:                             else
569:                             {
570:                                 /* Queue is full, exit the loop */
571:                                 break;
572:                             }
573:                         }
574:                         else
575:                         {
576:                             if (UART2_TxPushByte(pWrBuffer[nBytesWritten]) == true)
577:                             {
578:                                 nBytesWritten++;
579:                             }
580:                             else
581:                             {
582:                                 /* Queue is full, exit the loop */
583:                                 break;
584:                             }
585:                         }
586:                 
587:                     }
588:                 
589:                     /* Check if any data is pending for transmission */
590:                     if (UART2_WritePendingBytesGet() > 0)
591:                     {
592:                         /* Enable TX interrupt as data is pending for transmission */
593:                         UART2_TX_INT_ENABLE();
594:                     }
595:                 
596:                     return nBytesWritten;
597:                 }
598:                 
599:                 size_t UART2_WriteFreeBufferCountGet(void)
600:                 {
601:                     return (uart2Obj.wrBufferSize - 1) - UART2_WriteCountGet();
602:                 }
603:                 
604:                 size_t UART2_WriteBufferSizeGet(void)
605:                 {
606:                     return (uart2Obj.wrBufferSize - 1);
607:                 }
608:                 
609:                 bool UART2_TransmitComplete(void)
610:                 {
611:                     if((U2STA & _U2STA_TRMT_MASK))
612:                     {
613:                         return true;
614:                     }
615:                     else
616:                     {
617:                         return false;
618:                     }
619:                 }
620:                 
621:                 bool UART2_WriteNotificationEnable(bool isEnabled, bool isPersistent)
622:                 {
623:                     bool previousStatus = uart2Obj.isWrNotificationEnabled;
624:                 
625:                     uart2Obj.isWrNotificationEnabled = isEnabled;
626:                 
627:                     uart2Obj.isWrNotifyPersistently = isPersistent;
628:                 
629:                     return previousStatus;
630:                 }
631:                 
632:                 void UART2_WriteThresholdSet(uint32_t nBytesThreshold)
633:                 {
634:                     if (nBytesThreshold > 0)
635:                     {
636:                         uart2Obj.wrThreshold = nBytesThreshold;
637:                     }
638:                 }
639:                 
640:                 void UART2_WriteCallbackRegister( UART_RING_BUFFER_CALLBACK callback, uintptr_t context)
641:                 {
642:                     uart2Obj.wrCallback = callback;
643:                 
644:                     uart2Obj.wrContext = context;
645:                 }
646:                 
647:                 UART_ERROR UART2_ErrorGet( void )
648:                 {
649:                     UART_ERROR errors = uart2Obj.errors;
650:                 
651:                     uart2Obj.errors = UART_ERROR_NONE;
652:                 
653:                     /* All errors are cleared, but send the previous error state */
654:                     return errors;
655:                 }
656:                 
657:                 bool UART2_AutoBaudQuery( void )
658:                 {
659:                     if(U2MODE & _U2MODE_ABAUD_MASK)
660:                         return true;
661:                     else
662:                         return false;
663:                 }
664:                 
665:                 void UART2_AutoBaudSet( bool enable )
666:                 {
667:                     if( enable == true )
668:                     {
669:                         U2MODESET = _U2MODE_ABAUD_MASK;
670:                     }
671:                 
672:                     /* Turning off ABAUD if it was on can lead to unpredictable behavior, so that
673:                        direction of control is not allowed in this function.                      */
674:                 }
675:                 
676:                 static void UART2_FAULT_InterruptHandler (void)
677:                 {
678:                     /* Save the error to be reported later */
679:                     uart2Obj.errors = (UART_ERROR)(U2STA & (_U2STA_OERR_MASK | _U2STA_FERR_MASK | _U2STA_PERR_MASK));
680:                 
681:                     UART2_ErrorClear();
682:                 
683:                     /* Client must call UARTx_ErrorGet() function to clear the errors */
684:                     if( uart2Obj.rdCallback != NULL )
685:                     {
686:                         uart2Obj.rdCallback(UART_EVENT_READ_ERROR, uart2Obj.rdContext);
687:                     }
688:                 }
689:                 
690:                 static void UART2_RX_InterruptHandler (void)
691:                 {
692:                     /* Keep reading until there is a character availabe in the RX FIFO */
693:                     while((U2STA & _U2STA_URXDA_MASK) == _U2STA_URXDA_MASK)
694:                     {
695:                         if (UART2_RxPushByte(  (uint16_t )(U2RXREG) ) == true)
696:                         {
697:                             UART2_ReadNotificationSend();
698:                         }
699:                         else
700:                         {
701:                             /* UART RX buffer is full */
702:                         }
703:                     }
704:                 
705:                     /* Clear UART2 RX Interrupt flag */
706:                     IFS1CLR = _IFS1_U2RXIF_MASK;
707:                 }
708:                 
709:                 static void UART2_TX_InterruptHandler (void)
710:                 {
711:                     uint16_t wrByte;
712:                 
713:                     /* Check if any data is pending for transmission */
714:                     if (UART2_WritePendingBytesGet() > 0)
715:                     {
716:                         /* Keep writing to the TX FIFO as long as there is space */
717:                         while(!(U2STA & _U2STA_UTXBF_MASK))
718:                         {
719:                             if (UART2_TxPullByte(&wrByte) == true)
720:                             {
721:                                 if (UART2_IS_9BIT_MODE_ENABLED())
722:                                 {
723:                                     U2TXREG = wrByte;
724:                                 }
725:                                 else
726:                                 {
727:                                     U2TXREG = (uint8_t)wrByte;
728:                                 }
729:                 
730:                                 /* Send notification */
731:                                 UART2_WriteNotificationSend();
732:                             }
733:                             else
734:                             {
735:                                 /* Nothing to transmit. Disable the data register empty interrupt. */
736:                                 UART2_TX_INT_DISABLE();
737:                                 break;
738:                             }
739:                         }
740:                 
741:                         /* Clear UART2TX Interrupt flag */
742:                         IFS1CLR = _IFS1_U2TXIF_MASK;
743:                 
744:                     }
745:                     else
746:                     {
747:                         /* Nothing to transmit. Disable the data register empty interrupt. */
748:                         UART2_TX_INT_DISABLE();
749:                     }
750:                 }
751:                 
752:                 void UART_2_InterruptHandler (void)
753:                 {
754:                     /* Call Error handler if Error interrupt flag is set */
755:                     if ((IFS1 & _IFS1_U2EIF_MASK) && (IEC1 & _IEC1_U2EIE_MASK))
756:                     {
757:                         UART2_FAULT_InterruptHandler();
758:                     }
759:                     /* Call RX handler if RX interrupt flag is set */
760:                     if ((IFS1 & _IFS1_U2RXIF_MASK) && (IEC1 & _IEC1_U2RXIE_MASK))
761:                     {
762:                         UART2_RX_InterruptHandler();
763:                     }
764:                     /* Call TX handler if TX interrupt flag is set */
765:                     if ((IFS1 & _IFS1_U2TXIF_MASK) && (IEC1 & _IEC1_U2TXIE_MASK))
766:                     {
767:                         UART2_TX_InterruptHandler();
768:                     }
769:                 
770:                 }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
00000024  00000000   NOP
00000028  00000000   NOP
0000002C  00000000   NOP
00000030  00000000   NOP
00000034  00000000   NOP
00000038  00000000   NOP
0000003C  00000000   NOP
00000040  00000000   NOP
00000044  00000000   NOP
00000048  00000000   NOP
0000004C  00000000   NOP
00000050  00000000   NOP
00000054  00000000   NOP
00000058  00000000   NOP
0000005C  00000000   NOP
00000060  00000000   NOP
00000064  00000000   NOP
00000068  00000000   NOP
0000006C  00000000   NOP
00000074  00000000   NOP
00000078  00000000   NOP
0000007C  00000000   NOP
00000080  00000000   NOP
00000084  00000000   NOP
00000088  00000000   NOP
0000008C  00000000   NOP
00000090  00000000   NOP
00000094  00000000   NOP
00000098  00000000   NOP
0000009C  00000000   NOP
000000A0  00000000   NOP
000000A4  00000000   NOP
000000A8  00000000   NOP
000000AC  00000000   NOP
000000B0  00000000   NOP
000000B4  00000000   NOP
000000B8  00000000   NOP
000000BC  00000000   NOP
000000C0  00000000   NOP
000000C4  00000000   NOP
000000C8  00000000   NOP
000000CC  00000000   NOP
000000D0  00000000   NOP
000000D4  00000000   NOP
000000DC  00000000   NOP
000000E4  00000000   NOP
000000EC  00000000   NOP
000000F0  00000000   NOP
000000F4  00000000   NOP
00000100  00000000   NOP
00000110  00000000   NOP
9D00FD38  27BDFFD0   ADDIU SP, SP, -48
9D00FD3C  AFB2001C   SW S2, 28(SP)
9D00FD40  3C12BF88   LUI S2, -16504
9D00FD44  8E421040   LW V0, 4160(S2)
9D00FD48  3C030020   LUI V1, 32
9D00FD4C  AFBF002C   SW RA, 44(SP)
9D00FD50  00431024   AND V0, V0, V1
9D00FD54  AFB50028   SW S5, 40(SP)
9D00FD58  AFB40024   SW S4, 36(SP)
9D00FD5C  AFB30020   SW S3, 32(SP)
9D00FD60  AFB10018   SW S1, 24(SP)
9D00FD64  10400005   BEQ V0, ZERO, 0x9D00FD7C
9D00FD68  AFB00014   SW S0, 20(SP)
9D00FD6C  8E421070   LW V0, 4208(S2)
9D00FD70  00431824   AND V1, V0, V1
9D00FD74  1460005E   BNE V1, ZERO, UART_2_InterruptHandler::UART2_FAULT_InterruptHandler
9D00FD78  3C11BF80   LUI S1, -16512
9D00FD7C  8E421040   LW V0, 4160(S2)
9D00FD80  3C030040   LUI V1, 64
9D00FD84  00431024   AND V0, V0, V1
9D00FD88  10400005   BEQ V0, ZERO, 0x9D00FDA0
9D00FD8C  00000000   NOP
9D00FD90  8E421070   LW V0, 4208(S2)
9D00FD94  00431824   AND V1, V0, V1
9D00FD98  54600075   BNEL V1, ZERO, UART_2_InterruptHandler::UART2_RX_InterruptHandler
9D00FD9C  3C10A000   LUI S0, -24576
9D00FDA0  8E421040   LW V0, 4160(S2)
9D00FDA4  3C030080   LUI V1, 128
9D00FDA8  00431024   AND V0, V0, V1
9D00FDAC  10400005   BEQ V0, ZERO, 0x9D00FDC4
9D00FDB0  8FBF002C   LW RA, 44(SP)
9D00FDB4  8E421070   LW V0, 4208(S2)
9D00FDB8  00431824   AND V1, V0, V1
9D00FDBC  14600009   BNE V1, ZERO, UART_2_InterruptHandler::UART2_TX_InterruptHandler
9D00FDC0  3C14A000   LUI S4, -24576
9D00FDC4  8FB50028   LW S5, 40(SP)
9D00FDC8  8FB40024   LW S4, 36(SP)
9D00FDCC  8FB30020   LW S3, 32(SP)
9D00FDD0  8FB2001C   LW S2, 28(SP)
9D00FDD4  8FB10018   LW S1, 24(SP)
9D00FDD8  8FB00014   LW S0, 20(SP)
9D00FDDC  03E00008   JR RA
9D00FDE0  27BD0030   ADDIU SP, SP, 48
9D00FDE4  26902D9C   ADDIU S0, S4, 11676
9D00FDEC  8E030008   LW V1, 8(S0)
9D00FDF0  0062202B   SLTU A0, V1, V0
9D00FDFC  8E040018   LW A0, 24(S0)
9D00FE04  00621023   SUBU V0, V1, V0
9D00FE08  104000AC   BEQ V0, ZERO, UART_2_InterruptHandler::UART2_TX_InterruptHandler
9D00FE0C  3C020080   LUI V0, 128
9D00FE10  3C15A000   LUI S5, -24576
9D00FE14  3C11BF80   LUI S1, -16512
9D00FE18  24130006   ADDIU S3, ZERO, 6
9D00FE1C  26B52B6C   ADDIU S5, S5, 11116
9D00FE20  8E226210   LW V0, 25104(S1)
9D00FE24  30420200   ANDI V0, V0, 512
9D00FE28  1440002E   BNE V0, ZERO, 0x9D00FEE4
9D00FE2C  3C020080   LUI V0, 128
9D00FE30  8E02000C   LW V0, 12(S0)
9D00FE34  8E030008   LW V1, 8(S0)
9D00FE38  50430090   BEQL V0, V1, UART_2_InterruptHandler::UART2_TX_InterruptHandler
9D00FE3C  3C020080   LUI V0, 128
9D00FE40  8E246200   LW A0, 25088(S1)
9D00FE44  30840006   ANDI A0, A0, 6
9D00FE48  10930094   BEQ A0, S3, UART_2_InterruptHandler::UART2_TX_InterruptHandler
9D00FE4C  24430001   ADDIU V1, V0, 1
9D00FE50  00551021   ADDU V0, V0, S5
9D00FE54  90440000   LBU A0, 0(V0)
9D00FE58  8E020018   LW V0, 24(S0)
9D00FE5C  0062282B   SLTU A1, V1, V0
9D00FE60  0005180A   MOVZ V1, ZERO, A1
9D00FE64  AE03000C   SW V1, 12(S0)
9D00FE68  8E236200   LW V1, 25088(S1)
9D00FE6C  30630006   ANDI V1, V1, 6
9D00FE70  54730001   BNEL V1, S3, UART2_WriteNotificationSend
9D00FE74  308400FF   ANDI A0, A0, 255
9D00FE78  92030014   LBU V1, 20(S0)
9D00FE7C  AE246220   SW A0, 25120(S1)
9D00FE80  1060FFE7   BEQ V1, ZERO, 0x9D00FE20
9D00FE84  00000000   NOP
9D00FE88  8E03000C   LW V1, 12(S0)
9D00FE8C  8E040008   LW A0, 8(S0)
9D00FE90  0083282B   SLTU A1, A0, V1
9D00FE94  54A00001   BNEL A1, ZERO, 0x9D00FE9C
9D00FE98  00442021   ADDU A0, V0, A0
9D00FE9C  8E862D9C   LW A2, 11676(S4)
9D00FEA0  10C0FFDF   BEQ A2, ZERO, 0x9D00FE20
9D00FEA4  00831823   SUBU V1, A0, V1
9D00FEA8  92040015   LBU A0, 21(S0)
9D00FEAC  2442FFFF   ADDIU V0, V0, -1
9D00FEB0  00431023   SUBU V0, V0, V1
9D00FEB4  1080007D   BEQ A0, ZERO, UART_2_InterruptHandler::UART2_TX_InterruptHandler
9D00FEB8  8E030010   LW V1, 16(S0)
9D00FEBC  0043102B   SLTU V0, V0, V1
9D00FEC0  1440FFD7   BNE V0, ZERO, 0x9D00FE20
9D00FEC4  00000000   NOP
9D00FEC8  8E050004   LW A1, 4(S0)
9D00FECC  00C0F809   JALR A2
9D00FED0  24040003   ADDIU A0, ZERO, 3
9D00FED4  8E226210   LW V0, 25104(S1)
9D00FED8  30420200   ANDI V0, V0, 512
9D00FEDC  1040FFD4   BEQ V0, ZERO, UART2_TxPullByte
9D00FEE0  3C020080   LUI V0, 128
9D00FEE4  AE421044   SW V0, 4164(S2)
9D00FEE8  1000FFB6   BEQ ZERO, ZERO, 0x9D00FDC4
9D00FEEC  8FBF002C   LW RA, 44(SP)
9D00FEF0  8E226210   LW V0, 25104(S1)
9D00FEF4  3C14A000   LUI S4, -24576
9D00FEFC  3042000E   ANDI V0, V0, 14
9D00FF00  AE02003C   SW V0, 60(S0)
9D00FF04  8E226210   LW V0, 25104(S1)
9D00FF08  3042000E   ANDI V0, V0, 14
9D00FF0C  50400011   BEQL V0, ZERO, 0x9D00FF54
9D00FF14  8E226210   LW V0, 25104(S1)
9D00FF18  30420002   ANDI V0, V0, 2
9D00FF1C  10400005   BEQ V0, ZERO, 0x9D00FF34
9D00FF24  AE226214   SW V0, 25108(S1)
9D00FF30  8E226230   LW V0, 25136(S1)
9D00FF34  8E226210   LW V0, 25104(S1)
9D00FF3C  1440FFFC   BNE V0, ZERO, 0x9D00FF30
9D00FF44  AE421044   SW V0, 4164(S2)
9D00FF48  3C020040   LUI V0, 64
9D00FF50  8E02001C   LW V0, 28(S0)
9D00FF54  1040FF89   BEQ V0, ZERO, 0x9D00FD7C
9D00FF5C  8E050020   LW A1, 32(S0)
9D00FF70  3C14A000   LUI S4, -24576
9D00FF74  3C11BF80   LUI S1, -16512
9D00FF78  26102D9C   ADDIU S0, S0, 11676
9D00FF7C  26942BEC   ADDIU S4, S4, 11244
9D00FF80  8E226210   LW V0, 25104(S1)
9D00FF84  30420001   ANDI V0, V0, 1
9D00FF88  10400041   BEQ V0, ZERO, UART_2_InterruptHandler::UART2_RX_InterruptHandler
9D00FF8C  3C020040   LUI V0, 64
9D00FF90  8E336230   LW S3, 25136(S1)
9D00FF94  8E020024   LW V0, 36(S0)
9D00FF98  8E03002C   LW V1, 44(S0)
9D00FF9C  8E040028   LW A0, 40(S0)
9D00FFA0  24420001   ADDIU V0, V0, 1
9D00FFA4  0043182B   SLTU V1, V0, V1
9D00FFA8  0003100A   MOVZ V0, ZERO, V1
9D00FFAC  50820023   BEQL A0, V0, UART_2_InterruptHandler::UART2_RX_InterruptHandler::UART2_RxPushByte
9D00FFB0  8E03001C   LW V1, 28(S0)
9D00FFB4  8E030028   LW V1, 40(S0)
9D00FFB8  1062FFF1   BEQ V1, V0, 0x9D00FF80
9D00FFBC  00000000   NOP
9D00FFC0  8E236200   LW V1, 25088(S1)
9D00FFC4  24040006   ADDIU A0, ZERO, 6
9D00FFC8  30630006   ANDI V1, V1, 6
9D00FFCC  10640026   BEQ V1, A0, UART_2_InterruptHandler::UART2_RX_InterruptHandler
9D00FFD0  00000000   NOP
9D00FFD4  8E030024   LW V1, 36(S0)
9D00FFD8  00741821   ADDU V1, V1, S4
9D00FFDC  A0730000   SB S3, 0(V1)
9D00FFE0  92030030   LBU V1, 48(S0)
9D00FFE4  AE020024   SW V0, 36(S0)
9D00FFE8  1060FFE5   BEQ V1, ZERO, 0x9D00FF80
9D00FFEC  00000000   NOP
9D00FFF0  8E030024   LW V1, 36(S0)
9D00FFF4  8E020028   LW V0, 40(S0)
9D00FFF8  0062202B   SLTU A0, V1, V0
9D00FFFC  54800032   BNEL A0, ZERO, 0x9D0100C8
9D010000  8E04002C   LW A0, 44(S0)
9D010004  00621023   SUBU V0, V1, V0
9D010008  8E03001C   LW V1, 28(S0)
9D01000C  1060FFDC   BEQ V1, ZERO, 0x9D00FF80
9D010010  00000000   NOP
9D010014  92050038   LBU A1, 56(S0)
9D010018  14A0002D   BNE A1, ZERO, UART_2_InterruptHandler::UART2_RX_InterruptHandler
9D01001C  8E040034   LW A0, 52(S0)
9D010020  1444FFD7   BNE V0, A0, 0x9D00FF80
9D010024  00000000   NOP
9D010028  8E050020   LW A1, 32(S0)
9D01002C  0060F809   JALR V1
9D010030  00002025   OR A0, ZERO, ZERO
9D010034  1000FFD2   BEQ ZERO, ZERO, 0x9D00FF80
9D010038  00000000   NOP
9D01003C  1060FFDD   BEQ V1, ZERO, 0x9D00FFB4
9D010040  00000000   NOP
9D010044  8E050020   LW A1, 32(S0)
9D010048  0060F809   JALR V1
9D01004C  24040001   ADDIU A0, ZERO, 1
9D010050  8E020024   LW V0, 36(S0)
9D010054  8E03002C   LW V1, 44(S0)
9D010058  24420001   ADDIU V0, V0, 1
9D01005C  0043182B   SLTU V1, V0, V1
9D010060  1000FFD4   BEQ ZERO, ZERO, 0x9D00FFB4
9D010064  0003100A   MOVZ V0, ZERO, V1
9D010068  8E030024   LW V1, 36(S0)
9D01006C  00031840   SLL V1, V1, 1
9D010070  02831821   ADDU V1, S4, V1
9D010074  1000FFDA   BEQ ZERO, ZERO, UART_2_InterruptHandler::UART2_RX_InterruptHandler::UART2_ReadNotificationSend
9D010078  A4730000   SH S3, 0(V1)
9D01007C  AE421074   SW V0, 4212(S2)
9D010080  3C020080   LUI V0, 128
9D010084  AE421044   SW V0, 4164(S2)
9D010088  1000FF4E   BEQ ZERO, ZERO, 0x9D00FDC4
9D01008C  8FBF002C   LW RA, 44(SP)
9D010090  AE421044   SW V0, 4164(S2)
9D010094  1000FF42   BEQ ZERO, ZERO, 0x9D00FDA0
9D010098  00000000   NOP
9D01009C  00021040   SLL V0, V0, 1
9D0100A0  02A21021   ADDU V0, S5, V0
9D0100A4  1000FF6C   BEQ ZERO, ZERO, 0x9D00FE58
9D0100A8  94440000   LHU A0, 0(V0)
9D0100AC  1462FF5C   BNE V1, V0, 0x9D00FE20
9D0100B0  00000000   NOP
9D0100B4  1000FF85   BEQ ZERO, ZERO, 0x9D00FECC
9D0100B8  8E050004   LW A1, 4(S0)
9D0100BC  AE421074   SW V0, 4212(S2)
9D0100C0  1000FF40   BEQ ZERO, ZERO, 0x9D00FDC4
9D0100C4  8FBF002C   LW RA, 44(SP)
9D0100C8  1000FFCE   BEQ ZERO, ZERO, 0x9D010004
9D0100CC  00641821   ADDU V1, V1, A0
9D0100D0  0044102B   SLTU V0, V0, A0
9D0100D4  1440FFAA   BNE V0, ZERO, 0x9D00FF80
9D0100D8  00000000   NOP
9D0100DC  1000FFD3   BEQ ZERO, ZERO, 0x9D01002C
9D0100E0  8E050020   LW A1, 32(S0)
9D0150F4  10A0003E   BEQ A1, ZERO, 0x9D0151F0
9D0150F8  3C03A000   LUI V1, -24576
9D0150FC  24632D9C   ADDIU V1, V1, 11676
9D015100  8C6C0018   LW T4, 24(V1)
9D015104  3C0AA000   LUI T2, -24576
9D015108  00001025   OR V0, ZERO, ZERO
9D01510C  3C09BF80   LUI T1, -16512
9D015110  24080006   ADDIU T0, ZERO, 6
9D015114  254A2B6C   ADDIU T2, T2, 11116
9D015118  8D266200   LW A2, 25088(T1)
9D01511C  8C6B000C   LW T3, 12(V1)
9D015120  8C670008   LW A3, 8(V1)
9D015124  30C60006   ANDI A2, A2, 6
9D015128  10C8001D   BEQ A2, T0, UART2_Write::UART2_TxPushByte
9D01512C  24E60001   ADDIU A2, A3, 1
9D015130  00CC682B   SLTU T5, A2, T4
9D015134  000D300A   MOVZ A2, ZERO, T5
9D015138  1166000D   BEQ T3, A2, UART2_Write::UART2_WritePendingBytesGet
9D01513C  00000000   NOP
9D015140  8D2B6200   LW T3, 25088(T1)
9D015144  00826821   ADDU T5, A0, V0
9D015148  316B0006   ANDI T3, T3, 6
9D01514C  1168001E   BEQ T3, T0, UART2_Write::UART2_TxPushByte
9D015150  91AD0000   LBU T5, 0(T5)
9D015154  00EA3821   ADDU A3, A3, T2
9D015158  A0ED0000   SB T5, 0(A3)
9D01515C  24420001   ADDIU V0, V0, 1
9D015160  AC660008   SW A2, 8(V1)
9D015164  0045302B   SLTU A2, V0, A1
9D015168  14C0FFEB   BNE A2, ZERO, 0x9D015118
9D01516C  00000000   NOP
9D015170  8C64000C   LW A0, 12(V1)
9D015174  8C650008   LW A1, 8(V1)
9D015178  00A4302B   SLTU A2, A1, A0
9D01517C  54C00016   BNEL A2, ZERO, UART2_Write::UART2_WritePendingBytesGet
9D015180  8C630018   LW V1, 24(V1)
9D015184  00A42023   SUBU A0, A1, A0
9D015188  10800003   BEQ A0, ZERO, 0x9D015198
9D01518C  3C03BF88   LUI V1, -16504
9D015190  3C040080   LUI A0, 128
9D015194  AC641078   SW A0, 4216(V1)
9D015198  03E00008   JR RA
9D01519C  00000000   NOP
9D0151A0  00CC682B   SLTU T5, A2, T4
9D0151A4  000D300A   MOVZ A2, ZERO, T5
9D0151A8  1166FFF1   BEQ T3, A2, UART2_Write::UART2_WritePendingBytesGet
9D0151AC  00000000   NOP
9D0151B0  8D2B6200   LW T3, 25088(T1)
9D0151B4  00026840   SLL T5, V0, 1
9D0151B8  008D6821   ADDU T5, A0, T5
9D0151BC  316B0006   ANDI T3, T3, 6
9D0151C0  1568FFE4   BNE T3, T0, 0x9D015154
9D0151C4  95AD0000   LHU T5, 0(T5)
9D0151C8  00073840   SLL A3, A3, 1
9D0151CC  01473821   ADDU A3, T2, A3
9D0151D0  1000FFE2   BEQ ZERO, ZERO, 0x9D01515C
9D0151D4  A4ED0000   SH T5, 0(A3)
9D0151D8  00A32821   ADDU A1, A1, V1
9D0151DC  00A42023   SUBU A0, A1, A0
9D0151E0  1080FFED   BEQ A0, ZERO, 0x9D015198
9D0151E4  3C03BF88   LUI V1, -16504
9D0151E8  1000FFEA   BEQ ZERO, ZERO, 0x9D015194
9D0151EC  3C040080   LUI A0, 128
9D0151F0  00001025   OR V0, ZERO, ZERO
9D0151F4  1000FFDE   BEQ ZERO, ZERO, UART2_Write::UART2_WritePendingBytesGet
9D0151F8  24632D9C   ADDIU V1, V1, 11676
9D015EF4  3C09A000   LUI T1, -24576
9D015EF8  25292D9C   ADDIU T1, T1, 11676
9D015EFC  00A01025   OR V0, A1, ZERO
9D015F00  8D230028   LW V1, 40(T1)
9D015F04  8D250024   LW A1, 36(T1)
9D015F08  50400025   BEQL V0, ZERO, 0x9D015FA0
9D015F0C  00602825   OR A1, V1, ZERO
9D015F10  50650023   BEQL V1, A1, 0x9D015FA0
9D015F14  00001025   OR V0, ZERO, ZERO
9D015F18  3C0CA000   LUI T4, -24576
9D015F1C  00003025   OR A2, ZERO, ZERO
9D015F20  3C0EBF80   LUI T6, -16512
9D015F24  258C2BEC   ADDIU T4, T4, 11244
9D015F28  1000000A   BEQ ZERO, ZERO, 0x9D015F54
9D015F2C  240D0006   ADDIU T5, ZERO, 6
9D015F30  91630000   LBU V1, 0(T3)
9D015F34  A143FFFF   SB V1, -1(T2)
9D015F38  8D23002C   LW V1, 44(T1)
9D015F3C  0103182B   SLTU V1, T0, V1
9D015F40  0003400A   MOVZ T0, ZERO, V1
9D015F44  10C20015   BEQ A2, V0, 0x9D015F9C
9D015F48  01001825   OR V1, T0, ZERO
9D015F4C  50650017   BEQL V1, A1, 0x9D015FAC
9D015F50  00C01025   OR V0, A2, ZERO
9D015F54  8DC76200   LW A3, 25088(T6)
9D015F58  24C60001   ADDIU A2, A2, 1
9D015F5C  01835821   ADDU T3, T4, V1
9D015F60  30E70006   ANDI A3, A3, 6
9D015F64  00865021   ADDU T2, A0, A2
9D015F68  14EDFFF1   BNE A3, T5, 0x9D015F30
9D015F6C  24680001   ADDIU T0, V1, 1
9D015F70  00031840   SLL V1, V1, 1
9D015F74  01831821   ADDU V1, T4, V1
9D015F78  94670000   LHU A3, 0(V1)
9D015F7C  00061840   SLL V1, A2, 1
9D015F80  00831821   ADDU V1, A0, V1
9D015F84  A467FFFE   SH A3, -2(V1)
9D015F88  8D23002C   LW V1, 44(T1)
9D015F8C  0103182B   SLTU V1, T0, V1
9D015F90  0003400A   MOVZ T0, ZERO, V1
9D015F94  14C2FFED   BNE A2, V0, 0x9D015F4C
9D015F98  01001825   OR V1, T0, ZERO
9D015F9C  01002825   OR A1, T0, ZERO
9D015FA0  AD250028   SW A1, 40(T1)
9D015FA4  03E00008   JR RA
9D015FA8  00000000   NOP
9D015FAC  AD250028   SW A1, 40(T1)
9D015FB0  03E00008   JR RA
9D015FB4  00000000   NOP
9D015FB8  1000FFF9   BEQ ZERO, ZERO, 0x9D015FA0
9D015FBC  00001025   OR V0, ZERO, ZERO
9D016220  3C03BF80   LUI V1, -16512
9D016224  24050008   ADDIU A1, ZERO, 8
9D016228  AC656200   SW A1, 25088(V1)
9D01622C  34059400   ORI A1, ZERO, -27648
9D016230  AC656218   SW A1, 25112(V1)
9D016234  3C06A000   LUI A2, -24576
9D016238  2405008F   ADDIU A1, ZERO, 143
9D01623C  24C22D9C   ADDIU V0, A2, 11676
9D016240  AC656240   SW A1, 25152(V1)
9D016244  3C04BF88   LUI A0, -16504
9D016248  3C050080   LUI A1, 128
9D01624C  AC851074   SW A1, 4212(A0)
9D016250  AC400024   SW ZERO, 36(V0)
9D016254  AC400028   SW ZERO, 40(V0)
9D016258  AC400008   SW ZERO, 8(V0)
9D01625C  AC40000C   SW ZERO, 12(V0)
9D016260  AC40003C   SW ZERO, 60(V0)
9D016264  8C656200   LW A1, 25088(V1)
9D016268  24070006   ADDIU A3, ZERO, 6
9D01626C  AC40001C   SW ZERO, 28(V0)
9D016270  30A50006   ANDI A1, A1, 6
9D016274  A0400030   SB ZERO, 48(V0)
9D016278  A0400038   SB ZERO, 56(V0)
9D01627C  AC400034   SW ZERO, 52(V0)
9D016280  ACC02D9C   SW ZERO, 11676(A2)
9D016284  AC400010   SW ZERO, 16(V0)
9D016288  10A7000C   BEQ A1, A3, 0x9D0162BC
9D01628C  A4400014   SH ZERO, 20(V0)
9D016290  24050080   ADDIU A1, ZERO, 128
9D016294  AC45002C   SW A1, 44(V0)
9D016298  AC450018   SW A1, 24(V0)
9D01629C  34028000   ORI V0, ZERO, -32768
9D0162A0  AC626208   SW V0, 25096(V1)
9D0162A4  3C020020   LUI V0, 32
9D0162A8  AC821078   SW V0, 4216(A0)
9D0162AC  3C020040   LUI V0, 64
9D0162B0  AC821078   SW V0, 4216(A0)
9D0162B4  03E00008   JR RA
9D0162B8  00000000   NOP
9D0162BC  24050040   ADDIU A1, ZERO, 64
9D0162C0  AC45002C   SW A1, 44(V0)
9D0162C4  AC450018   SW A1, 24(V0)
9D0162C8  34028000   ORI V0, ZERO, -32768
9D0162CC  AC626208   SW V0, 25096(V1)
9D0162D0  3C020020   LUI V0, 32
9D0162D4  AC821078   SW V0, 4216(A0)
9D0162D8  3C020040   LUI V0, 64
9D0162DC  AC821078   SW V0, 4216(A0)
9D0162E0  03E00008   JR RA
9D0162E4  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/peripheral/uart/plib_uart1.c  --------------
1:                   /*******************************************************************************
2:                     UART1 PLIB
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_uart1.c
9:                   
10:                    Summary:
11:                      UART1 PLIB Implementation File
12:                  
13:                    Description:
14:                      None
15:                  
16:                  *******************************************************************************/
17:                  
18:                  /*******************************************************************************
19:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
20:                  *
21:                  * Subject to your compliance with these terms, you may use Microchip software
22:                  * and any derivatives exclusively with Microchip products. It is your
23:                  * responsibility to comply with third party license terms applicable to your
24:                  * use of third party software (including open source software) that may
25:                  * accompany Microchip software.
26:                  *
27:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                  * PARTICULAR PURPOSE.
31:                  *
32:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
33:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
34:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
35:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
36:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
37:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
38:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
39:                  *******************************************************************************/
40:                  
41:                  #include "device.h"
42:                  #include "plib_uart1.h"
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Section: UART1 Implementation
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  
50:                  UART_RING_BUFFER_OBJECT uart1Obj;
51:                  
52:                  #define UART1_READ_BUFFER_SIZE      128
53:                  #define UART1_READ_BUFFER_SIZE_9BIT (128 >> 1)
54:                  #define UART1_RX_INT_DISABLE()      IEC1CLR = _IEC1_U1RXIE_MASK;
55:                  #define UART1_RX_INT_ENABLE()       IEC1SET = _IEC1_U1RXIE_MASK;
56:                  
57:                  static uint8_t UART1_ReadBuffer[UART1_READ_BUFFER_SIZE];
58:                  
59:                  #define UART1_WRITE_BUFFER_SIZE     128
60:                  #define UART1_WRITE_BUFFER_SIZE_9BIT       (128 >> 1)
61:                  #define UART1_TX_INT_DISABLE()      IEC1CLR = _IEC1_U1TXIE_MASK;
62:                  #define UART1_TX_INT_ENABLE()       IEC1SET = _IEC1_U1TXIE_MASK;
63:                  
64:                  static uint8_t UART1_WriteBuffer[UART1_WRITE_BUFFER_SIZE];
65:                  
66:                  #define UART1_IS_9BIT_MODE_ENABLED()    ( U1MODE & (_U1MODE_PDSEL0_MASK | _U1MODE_PDSEL1_MASK)) == (_U1MODE_PDSEL0_MASK | _U1MODE_PDSEL1_MASK) ? true:false
67:                  
68:                  void static UART1_ErrorClear( void )
69:                  {
70:                      UART_ERROR errors = UART_ERROR_NONE;
71:                      uint8_t dummyData = 0u;
72:                  
73:                      errors = (UART_ERROR)(U1STA & (_U1STA_OERR_MASK | _U1STA_FERR_MASK | _U1STA_PERR_MASK));
74:                  
75:                      if(errors != UART_ERROR_NONE)
76:                      {
77:                          /* If it's a overrun error then clear it to flush FIFO */
78:                          if(U1STA & _U1STA_OERR_MASK)
79:                          {
80:                              U1STACLR = _U1STA_OERR_MASK;
81:                          }
82:                  
83:                          /* Read existing error bytes from FIFO to clear parity and framing error flags */
84:                          while(U1STA & _U1STA_URXDA_MASK)
85:                          {
86:                              dummyData = U1RXREG;
87:                          }
88:                  
89:                          /* Clear error interrupt flag */
90:                          IFS1CLR = _IFS1_U1EIF_MASK;
91:                  
92:                          /* Clear up the receive interrupt flag so that RX interrupt is not
93:                           * triggered for error bytes */
94:                          IFS1CLR = _IFS1_U1RXIF_MASK;
95:                  
96:                      }
97:                  
98:                      // Ignore the warning
99:                      (void)dummyData;
100:                 }
101:                 
102:                 void UART1_Initialize( void )
103:                 {
104:                     /* Set up UxMODE bits */
105:                     /* STSEL  = 0*/
106:                     /* PDSEL = 0 */
107:                     /* BRGH = 1 */
108:                     /* RXINV = 0 */
109:                     /* ABAUD = 0 */
110:                     /* LPBACK = 0 */
111:                     /* WAKE = 0 */
112:                     /* SIDL = 0 */
113:                     /* RUNOVF = 0 */
114:                     /* CLKSEL = 0 */
115:                     /* SLPEN = 0 */
116:                     U1MODE = 0x8;
117:                 
118:                     /* Enable UART1 Receiver, Transmitter and TX Interrupt selection */
119:                     U1STASET = (_U1STA_UTXEN_MASK | _U1STA_URXEN_MASK | _U1STA_UTXISEL1_MASK );
120:                 
121:                     /* BAUD Rate register Setup */
122:                     U1BRG = 155;
123:                 
124:                     IEC1CLR = _IEC1_U1TXIE_MASK;
125:                 
126:                     /* Initialize instance object */
127:                     uart1Obj.rdCallback = NULL;
128:                     uart1Obj.rdInIndex = 0;
129:                     uart1Obj.rdOutIndex = 0;
130:                     uart1Obj.isRdNotificationEnabled = false;
131:                     uart1Obj.isRdNotifyPersistently = false;
132:                     uart1Obj.rdThreshold = 0;
133:                 
134:                     uart1Obj.wrCallback = NULL;
135:                     uart1Obj.wrInIndex = 0;
136:                     uart1Obj.wrOutIndex = 0;
137:                     uart1Obj.isWrNotificationEnabled = false;
138:                     uart1Obj.isWrNotifyPersistently = false;
139:                     uart1Obj.wrThreshold = 0;
140:                 
141:                     uart1Obj.errors = UART_ERROR_NONE;
142:                 
143:                     if (UART1_IS_9BIT_MODE_ENABLED())
144:                     {
145:                         uart1Obj.rdBufferSize = UART1_READ_BUFFER_SIZE_9BIT;
146:                         uart1Obj.wrBufferSize = UART1_WRITE_BUFFER_SIZE_9BIT;
147:                     }
148:                     else
149:                     {
150:                         uart1Obj.rdBufferSize = UART1_READ_BUFFER_SIZE;
151:                         uart1Obj.wrBufferSize = UART1_WRITE_BUFFER_SIZE;
152:                     }
153:                 
154:                 
155:                     /* Turn ON UART1 */
156:                     U1MODESET = _U1MODE_ON_MASK;
157:                 
158:                     /* Enable UART1_FAULT Interrupt */
159:                     IEC1SET = _IEC1_U1EIE_MASK;
160:                 
161:                     /* Enable UART1_RX Interrupt */
162:                     IEC1SET = _IEC1_U1RXIE_MASK;
163:                 }
164:                 
165:                 bool UART1_SerialSetup( UART_SERIAL_SETUP *setup, uint32_t srcClkFreq )
166:                 {
167:                     bool status = false;
168:                     uint32_t baud;
169:                     uint32_t status_ctrl;
170:                     uint8_t brgh = 1;
171:                     int32_t uxbrg = 0;
172:                 
173:                     if (setup != NULL)
174:                     {
175:                         baud = setup->baudRate;
176:                 
177:                         if ((baud == 0) || ((setup->dataWidth == UART_DATA_9_BIT) && (setup->parity != UART_PARITY_NONE)))
178:                         {
179:                             return status;
180:                         }
181:                 
182:                         if(srcClkFreq == 0)
183:                         {
184:                             srcClkFreq = UART1_FrequencyGet();
185:                         }
186:                 
187:                          /* Calculate BRG value */
188:                         if (brgh == 0)
189:                         {
190:                             uxbrg = (((srcClkFreq >> 4) + (baud >> 1)) / baud ) - 1;
191:                         }
192:                         else
193:                         {
194:                             uxbrg = (((srcClkFreq >> 2) + (baud >> 1)) / baud ) - 1;
195:                         }
196:                 
197:                         /* Check if the baud value can be set with low baud settings */
198:                         if((uxbrg < 0) || (uxbrg > UINT16_MAX))
199:                         {
200:                             return status;
201:                         }
202:                 
203:                         /* Turn OFF UART1. Save UTXEN, URXEN and UTXBRK bits as these are cleared upon disabling UART */
204:                 
205:                         status_ctrl = U1STA & (_U1STA_UTXEN_MASK | _U1STA_URXEN_MASK | _U1STA_UTXBRK_MASK);
206:                 
207:                         U1MODECLR = _U1MODE_ON_MASK;
208:                 
209:                         if(setup->dataWidth == UART_DATA_9_BIT)
210:                         {
211:                             /* Configure UART1 mode */
212:                             U1MODE = (U1MODE & (~_U1MODE_PDSEL_MASK)) | setup->dataWidth;
213:                         }
214:                         else
215:                         {
216:                             /* Configure UART1 mode */
217:                             U1MODE = (U1MODE & (~_U1MODE_PDSEL_MASK)) | setup->parity;
218:                         }
219:                 
220:                         /* Configure UART1 mode */
221:                         U1MODE = (U1MODE & (~_U1MODE_STSEL_MASK)) | setup->stopBits;
222:                 
223:                         /* Configure UART1 Baud Rate */
224:                         U1BRG = uxbrg;
225:                 
226:                         if (UART1_IS_9BIT_MODE_ENABLED())
227:                         {
228:                             uart1Obj.rdBufferSize = UART1_READ_BUFFER_SIZE_9BIT;
229:                             uart1Obj.wrBufferSize = UART1_WRITE_BUFFER_SIZE_9BIT;
230:                         }
231:                         else
232:                         {
233:                             uart1Obj.rdBufferSize = UART1_READ_BUFFER_SIZE;
234:                             uart1Obj.wrBufferSize = UART1_WRITE_BUFFER_SIZE;
235:                         }
236:                 
237:                         U1MODESET = _U1MODE_ON_MASK;
238:                 
239:                         /* Restore UTXEN, URXEN and UTXBRK bits. */
240:                         U1STASET = status_ctrl;
241:                 
242:                         status = true;
243:                     }
244:                 
245:                     return status;
246:                 }
247:                 
248:                 /* This routine is only called from ISR. Hence do not disable/enable USART interrupts. */
249:                 static inline bool UART1_RxPushByte(uint16_t rdByte)
250:                 {
251:                     uint32_t tempInIndex;
252:                     bool isSuccess = false;
253:                 
254:                     tempInIndex = uart1Obj.rdInIndex + 1;
255:                 
256:                     if (tempInIndex >= uart1Obj.rdBufferSize)
257:                     {
258:                         tempInIndex = 0;
259:                     }
260:                 
261:                     if (tempInIndex == uart1Obj.rdOutIndex)
262:                     {
263:                         /* Queue is full - Report it to the application. Application gets a chance to free up space by reading data out from the RX ring buffer */
264:                         if(uart1Obj.rdCallback != NULL)
265:                         {
266:                             uart1Obj.rdCallback(UART_EVENT_READ_BUFFER_FULL, uart1Obj.rdContext);
267:                 
268:                             /* Read the indices again in case application has freed up space in RX ring buffer */
269:                             tempInIndex = uart1Obj.rdInIndex + 1;
270:                 
271:                             if (tempInIndex >= uart1Obj.rdBufferSize)
272:                             {
273:                                 tempInIndex = 0;
274:                             }
275:                         }
276:                     }
277:                 
278:                     /* Attempt to push the data into the ring buffer */
279:                     if (tempInIndex != uart1Obj.rdOutIndex)
280:                     {
281:                         if (UART1_IS_9BIT_MODE_ENABLED())
282:                         {
283:                             ((uint16_t*)&UART1_ReadBuffer)[uart1Obj.rdInIndex] = rdByte;
284:                         }
285:                         else
286:                         {
287:                             UART1_ReadBuffer[uart1Obj.rdInIndex] = (uint8_t)rdByte;
288:                         }
289:                 
290:                         uart1Obj.rdInIndex = tempInIndex;
291:                 
292:                         isSuccess = true;
293:                     }
294:                     else
295:                     {
296:                         /* Queue is full. Data will be lost. */
297:                     }
298:                 
299:                     return isSuccess;
300:                 }
301:                 
302:                 /* This routine is only called from ISR. Hence do not disable/enable USART interrupts. */
303:                 static void UART1_ReadNotificationSend(void)
304:                 {
305:                     uint32_t nUnreadBytesAvailable;
306:                 
307:                     if (uart1Obj.isRdNotificationEnabled == true)
308:                     {
309:                         nUnreadBytesAvailable = UART1_ReadCountGet();
310:                 
311:                         if(uart1Obj.rdCallback != NULL)
312:                         {
313:                             if (uart1Obj.isRdNotifyPersistently == true)
314:                             {
315:                                 if (nUnreadBytesAvailable >= uart1Obj.rdThreshold)
316:                                 {
317:                                     uart1Obj.rdCallback(UART_EVENT_READ_THRESHOLD_REACHED, uart1Obj.rdContext);
318:                                 }
319:                             }
320:                             else
321:                             {
322:                                 if (nUnreadBytesAvailable == uart1Obj.rdThreshold)
323:                                 {
324:                                     uart1Obj.rdCallback(UART_EVENT_READ_THRESHOLD_REACHED, uart1Obj.rdContext);
325:                                 }
326:                             }
327:                         }
328:                     }
329:                 }
330:                 
331:                 size_t UART1_Read(uint8_t* pRdBuffer, const size_t size)
332:                 {
333:                     size_t nBytesRead = 0;
334:                     uint32_t rdOutIndex = 0;
335:                     uint32_t rdInIndex = 0;
336:                 
337:                     /* Take a snapshot of indices to avoid creation of critical section */
338:                     rdOutIndex = uart1Obj.rdOutIndex;
339:                     rdInIndex = uart1Obj.rdInIndex;
340:                 
341:                     while (nBytesRead < size)
342:                     {
343:                         if (rdOutIndex != rdInIndex)
344:                         {
345:                             if (UART1_IS_9BIT_MODE_ENABLED())
346:                             {
347:                                 ((uint16_t*)pRdBuffer)[nBytesRead++] = ((uint16_t*)&UART1_ReadBuffer)[rdOutIndex++];
348:                             }
349:                             else
350:                             {
351:                                 pRdBuffer[nBytesRead++] = UART1_ReadBuffer[rdOutIndex++];
352:                             }
353:                 
354:                             if (rdOutIndex >= uart1Obj.rdBufferSize)
355:                             {
356:                                 rdOutIndex = 0;
357:                             }
358:                         }
359:                         else
360:                         {
361:                             /* No more data available in the RX buffer */
362:                             break;
363:                         }
364:                     }
365:                 
366:                     uart1Obj.rdOutIndex = rdOutIndex;
367:                 
368:                     return nBytesRead;
369:                 }
370:                 
371:                 size_t UART1_ReadCountGet(void)
372:                 {
373:                     size_t nUnreadBytesAvailable;
374:                     uint32_t rdInIndex;
375:                     uint32_t rdOutIndex;
376:                 
377:                     /* Take a snapshot of indices to avoid processing in critical section */
378:                     rdInIndex = uart1Obj.rdInIndex;
379:                     rdOutIndex = uart1Obj.rdOutIndex;
380:                 
381:                     if ( rdInIndex >=  rdOutIndex)
382:                     {
383:                         nUnreadBytesAvailable =  rdInIndex -  rdOutIndex;
384:                     }
385:                     else
386:                     {
387:                         nUnreadBytesAvailable =  (uart1Obj.rdBufferSize -  rdOutIndex) + rdInIndex;
388:                     }
389:                 
390:                     return nUnreadBytesAvailable;
391:                 }
392:                 
393:                 size_t UART1_ReadFreeBufferCountGet(void)
394:                 {
395:                     return (uart1Obj.rdBufferSize - 1) - UART1_ReadCountGet();
396:                 }
397:                 
398:                 size_t UART1_ReadBufferSizeGet(void)
399:                 {
400:                     return (uart1Obj.rdBufferSize - 1);
401:                 }
402:                 
403:                 bool UART1_ReadNotificationEnable(bool isEnabled, bool isPersistent)
404:                 {
405:                     bool previousStatus = uart1Obj.isRdNotificationEnabled;
406:                 
407:                     uart1Obj.isRdNotificationEnabled = isEnabled;
408:                 
409:                     uart1Obj.isRdNotifyPersistently = isPersistent;
410:                 
411:                     return previousStatus;
412:                 }
413:                 
414:                 void UART1_ReadThresholdSet(uint32_t nBytesThreshold)
415:                 {
416:                     if (nBytesThreshold > 0)
417:                     {
418:                         uart1Obj.rdThreshold = nBytesThreshold;
419:                     }
420:                 }
421:                 
422:                 void UART1_ReadCallbackRegister( UART_RING_BUFFER_CALLBACK callback, uintptr_t context)
423:                 {
424:                     uart1Obj.rdCallback = callback;
425:                 
426:                     uart1Obj.rdContext = context;
427:                 }
428:                 
429:                 /* This routine is only called from ISR. Hence do not disable/enable USART interrupts. */
430:                 static bool UART1_TxPullByte(uint16_t* pWrByte)
431:                 {
432:                     bool isSuccess = false;
433:                     uint32_t wrOutIndex = uart1Obj.wrOutIndex;
434:                     uint32_t wrInIndex = uart1Obj.wrInIndex;
435:                 
436:                     if (wrOutIndex != wrInIndex)
437:                     {
438:                         if (UART1_IS_9BIT_MODE_ENABLED())
439:                         {
440:                             *pWrByte = ((uint16_t*)&UART1_WriteBuffer)[wrOutIndex++];
441:                         }
442:                         else
443:                         {
444:                             *pWrByte = UART1_WriteBuffer[wrOutIndex++];
445:                         }
446:                 
447:                         if (wrOutIndex >= uart1Obj.wrBufferSize)
448:                         {
449:                             wrOutIndex = 0;
450:                         }
451:                 
452:                         uart1Obj.wrOutIndex = wrOutIndex;
453:                 
454:                         isSuccess = true;
455:                     }
456:                 
457:                     return isSuccess;
458:                 }
459:                 
460:                 static inline bool UART1_TxPushByte(uint16_t wrByte)
461:                 {
462:                     uint32_t tempInIndex;
463:                     bool isSuccess = false;
464:                 
465:                     uint32_t wrOutIndex = uart1Obj.wrOutIndex;
466:                     uint32_t wrInIndex = uart1Obj.wrInIndex;
467:                 
468:                     tempInIndex = wrInIndex + 1;
469:                 
470:                     if (tempInIndex >= uart1Obj.wrBufferSize)
471:                     {
472:                         tempInIndex = 0;
473:                     }
474:                     if (tempInIndex != wrOutIndex)
475:                     {
476:                         if (UART1_IS_9BIT_MODE_ENABLED())
477:                         {
478:                             ((uint16_t*)&UART1_WriteBuffer)[wrInIndex] = wrByte;
479:                         }
480:                         else
481:                         {
482:                             UART1_WriteBuffer[wrInIndex] = (uint8_t)wrByte;
483:                         }
484:                 
485:                         uart1Obj.wrInIndex = tempInIndex;
486:                 
487:                         isSuccess = true;
488:                     }
489:                     else
490:                     {
491:                         /* Queue is full. Report Error. */
492:                     }
493:                 
494:                     return isSuccess;
495:                 }
496:                 
497:                 /* This routine is only called from ISR. Hence do not disable/enable USART interrupts. */
498:                 static void UART1_WriteNotificationSend(void)
499:                 {
500:                     uint32_t nFreeWrBufferCount;
501:                 
502:                     if (uart1Obj.isWrNotificationEnabled == true)
503:                     {
504:                         nFreeWrBufferCount = UART1_WriteFreeBufferCountGet();
505:                 
506:                         if(uart1Obj.wrCallback != NULL)
507:                         {
508:                             if (uart1Obj.isWrNotifyPersistently == true)
509:                             {
510:                                 if (nFreeWrBufferCount >= uart1Obj.wrThreshold)
511:                                 {
512:                                     uart1Obj.wrCallback(UART_EVENT_WRITE_THRESHOLD_REACHED, uart1Obj.wrContext);
513:                                 }
514:                             }
515:                             else
516:                             {
517:                                 if (nFreeWrBufferCount == uart1Obj.wrThreshold)
518:                                 {
519:                                     uart1Obj.wrCallback(UART_EVENT_WRITE_THRESHOLD_REACHED, uart1Obj.wrContext);
520:                                 }
521:                             }
522:                         }
523:                     }
524:                 }
525:                 
526:                 static size_t UART1_WritePendingBytesGet(void)
527:                 {
528:                     size_t nPendingTxBytes;
529:                 
530:                     /* Take a snapshot of indices to avoid processing in critical section */
531:                 
532:                     uint32_t wrOutIndex = uart1Obj.wrOutIndex;
533:                     uint32_t wrInIndex = uart1Obj.wrInIndex;
534:                 
535:                     if ( wrInIndex >=  wrOutIndex)
536:                     {
537:                         nPendingTxBytes =  wrInIndex - wrOutIndex;
538:                     }
539:                     else
540:                     {
541:                         nPendingTxBytes =  (uart1Obj.wrBufferSize -  wrOutIndex) + wrInIndex;
542:                     }
543:                 
544:                     return nPendingTxBytes;
545:                 }
546:                 
547:                 size_t UART1_WriteCountGet(void)
548:                 {
549:                     size_t nPendingTxBytes;
550:                 
551:                     nPendingTxBytes = UART1_WritePendingBytesGet();
552:                 
553:                     return nPendingTxBytes;
554:                 }
555:                 
556:                 size_t UART1_Write(uint8_t* pWrBuffer, const size_t size )
557:                 {
558:                     size_t nBytesWritten  = 0;
559:                 
560:                     while (nBytesWritten < size)
561:                     {
562:                         if (UART1_IS_9BIT_MODE_ENABLED())
563:                         {
564:                             if (UART1_TxPushByte(((uint16_t*)pWrBuffer)[nBytesWritten]) == true)
565:                             {
566:                                 nBytesWritten++;
567:                             }
568:                             else
569:                             {
570:                                 /* Queue is full, exit the loop */
571:                                 break;
572:                             }
573:                         }
574:                         else
575:                         {
576:                             if (UART1_TxPushByte(pWrBuffer[nBytesWritten]) == true)
577:                             {
578:                                 nBytesWritten++;
579:                             }
580:                             else
581:                             {
582:                                 /* Queue is full, exit the loop */
583:                                 break;
584:                             }
585:                         }
586:                 
587:                     }
588:                 
589:                     /* Check if any data is pending for transmission */
590:                     if (UART1_WritePendingBytesGet() > 0)
591:                     {
592:                         /* Enable TX interrupt as data is pending for transmission */
593:                         UART1_TX_INT_ENABLE();
594:                     }
595:                 
596:                     return nBytesWritten;
597:                 }
598:                 
599:                 size_t UART1_WriteFreeBufferCountGet(void)
600:                 {
601:                     return (uart1Obj.wrBufferSize - 1) - UART1_WriteCountGet();
602:                 }
603:                 
604:                 size_t UART1_WriteBufferSizeGet(void)
605:                 {
606:                     return (uart1Obj.wrBufferSize - 1);
607:                 }
608:                 
609:                 bool UART1_TransmitComplete(void)
610:                 {
611:                     if((U1STA & _U1STA_TRMT_MASK))
612:                     {
613:                         return true;
614:                     }
615:                     else
616:                     {
617:                         return false;
618:                     }
619:                 }
620:                 
621:                 bool UART1_WriteNotificationEnable(bool isEnabled, bool isPersistent)
622:                 {
623:                     bool previousStatus = uart1Obj.isWrNotificationEnabled;
624:                 
625:                     uart1Obj.isWrNotificationEnabled = isEnabled;
626:                 
627:                     uart1Obj.isWrNotifyPersistently = isPersistent;
628:                 
629:                     return previousStatus;
630:                 }
631:                 
632:                 void UART1_WriteThresholdSet(uint32_t nBytesThreshold)
633:                 {
634:                     if (nBytesThreshold > 0)
635:                     {
636:                         uart1Obj.wrThreshold = nBytesThreshold;
637:                     }
638:                 }
639:                 
640:                 void UART1_WriteCallbackRegister( UART_RING_BUFFER_CALLBACK callback, uintptr_t context)
641:                 {
642:                     uart1Obj.wrCallback = callback;
643:                 
644:                     uart1Obj.wrContext = context;
645:                 }
646:                 
647:                 UART_ERROR UART1_ErrorGet( void )
648:                 {
649:                     UART_ERROR errors = uart1Obj.errors;
650:                 
651:                     uart1Obj.errors = UART_ERROR_NONE;
652:                 
653:                     /* All errors are cleared, but send the previous error state */
654:                     return errors;
655:                 }
656:                 
657:                 bool UART1_AutoBaudQuery( void )
658:                 {
659:                     if(U1MODE & _U1MODE_ABAUD_MASK)
660:                         return true;
661:                     else
662:                         return false;
663:                 }
664:                 
665:                 void UART1_AutoBaudSet( bool enable )
666:                 {
667:                     if( enable == true )
668:                     {
669:                         U1MODESET = _U1MODE_ABAUD_MASK;
670:                     }
671:                 
672:                     /* Turning off ABAUD if it was on can lead to unpredictable behavior, so that
673:                        direction of control is not allowed in this function.                      */
674:                 }
675:                 
676:                 static void UART1_FAULT_InterruptHandler (void)
677:                 {
678:                     /* Save the error to be reported later */
679:                     uart1Obj.errors = (UART_ERROR)(U1STA & (_U1STA_OERR_MASK | _U1STA_FERR_MASK | _U1STA_PERR_MASK));
680:                 
681:                     UART1_ErrorClear();
682:                 
683:                     /* Client must call UARTx_ErrorGet() function to clear the errors */
684:                     if( uart1Obj.rdCallback != NULL )
685:                     {
686:                         uart1Obj.rdCallback(UART_EVENT_READ_ERROR, uart1Obj.rdContext);
687:                     }
688:                 }
689:                 
690:                 static void UART1_RX_InterruptHandler (void)
691:                 {
692:                     /* Keep reading until there is a character availabe in the RX FIFO */
693:                     while((U1STA & _U1STA_URXDA_MASK) == _U1STA_URXDA_MASK)
694:                     {
695:                         if (UART1_RxPushByte(  (uint16_t )(U1RXREG) ) == true)
696:                         {
697:                             UART1_ReadNotificationSend();
698:                         }
699:                         else
700:                         {
701:                             /* UART RX buffer is full */
702:                         }
703:                     }
704:                 
705:                     /* Clear UART1 RX Interrupt flag */
706:                     IFS1CLR = _IFS1_U1RXIF_MASK;
707:                 }
708:                 
709:                 static void UART1_TX_InterruptHandler (void)
710:                 {
711:                     uint16_t wrByte;
712:                 
713:                     /* Check if any data is pending for transmission */
714:                     if (UART1_WritePendingBytesGet() > 0)
715:                     {
716:                         /* Keep writing to the TX FIFO as long as there is space */
717:                         while(!(U1STA & _U1STA_UTXBF_MASK))
718:                         {
719:                             if (UART1_TxPullByte(&wrByte) == true)
720:                             {
721:                                 if (UART1_IS_9BIT_MODE_ENABLED())
722:                                 {
723:                                     U1TXREG = wrByte;
724:                                 }
725:                                 else
726:                                 {
727:                                     U1TXREG = (uint8_t)wrByte;
728:                                 }
729:                 
730:                                 /* Send notification */
731:                                 UART1_WriteNotificationSend();
732:                             }
733:                             else
734:                             {
735:                                 /* Nothing to transmit. Disable the data register empty interrupt. */
736:                                 UART1_TX_INT_DISABLE();
737:                                 break;
738:                             }
739:                         }
740:                 
741:                         /* Clear UART1TX Interrupt flag */
742:                         IFS1CLR = _IFS1_U1TXIF_MASK;
743:                 
744:                     }
745:                     else
746:                     {
747:                         /* Nothing to transmit. Disable the data register empty interrupt. */
748:                         UART1_TX_INT_DISABLE();
749:                     }
750:                 }
751:                 
752:                 void UART_1_InterruptHandler (void)
753:                 {
754:                     /* Call Error handler if Error interrupt flag is set */
755:                     if ((IFS1 & _IFS1_U1EIF_MASK) && (IEC1 & _IEC1_U1EIE_MASK))
756:                     {
757:                         UART1_FAULT_InterruptHandler();
758:                     }
759:                     /* Call RX handler if RX interrupt flag is set */
760:                     if ((IFS1 & _IFS1_U1RXIF_MASK) && (IEC1 & _IEC1_U1RXIE_MASK))
761:                     {
762:                         UART1_RX_InterruptHandler();
763:                     }
764:                     /* Call TX handler if TX interrupt flag is set */
765:                     if ((IFS1 & _IFS1_U1TXIF_MASK) && (IEC1 & _IEC1_U1TXIE_MASK))
766:                     {
767:                         UART1_TX_InterruptHandler();
768:                     }
769:                 
770:                 }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
00000024  00000000   NOP
00000028  00000000   NOP
0000002C  00000000   NOP
00000030  00000000   NOP
00000034  00000000   NOP
00000038  00000000   NOP
00000040  00000000   NOP
00000044  00000000   NOP
00000048  00000000   NOP
0000004C  00000000   NOP
00000058  00000000   NOP
0000005C  00000000   NOP
00000060  00000000   NOP
00000064  00000000   NOP
00000068  00000000   NOP
0000006C  00000000   NOP
00000074  00000000   NOP
00000078  00000000   NOP
0000007C  00000000   NOP
00000080  00000000   NOP
00000084  00000000   NOP
00000088  00000000   NOP
0000008C  00000000   NOP
00000090  00000000   NOP
00000094  00000000   NOP
00000098  00000000   NOP
0000009C  00000000   NOP
000000A0  00000000   NOP
000000A4  00000000   NOP
000000AC  00000000   NOP
000000B4  00000000   NOP
000000C0  00000000   NOP
000000C4  00000000   NOP
000000CC  00000000   NOP
000000D0  00000000   NOP
000000D4  00000000   NOP
000000DC  00000000   NOP
000000E4  00000000   NOP
000000EC  00000000   NOP
000000F0  00000000   NOP
000000F4  00000000   NOP
00000100  00000000   NOP
00000110  00000000   NOP
9D00B228  3C03A000   LUI V1, -24576
9D00B22C  24632D5C   ADDIU V1, V1, 11612
9D00B230  8C62003C   LW V0, 60(V1)
9D00B234  AC60003C   SW ZERO, 60(V1)
9D00B238  03E00008   JR RA
9D00B23C  00000000   NOP
9D0100E4  27BDFFD0   ADDIU SP, SP, -48
9D0100E8  AFB2001C   SW S2, 28(SP)
9D0100EC  3C12BF88   LUI S2, -16504
9D0100F0  8E421040   LW V0, 4160(S2)
9D0100F4  AFBF002C   SW RA, 44(SP)
9D0100F8  AFB50028   SW S5, 40(SP)
9D0100FC  30420080   ANDI V0, V0, 128
9D010100  AFB40024   SW S4, 36(SP)
9D010104  AFB30020   SW S3, 32(SP)
9D010108  AFB10018   SW S1, 24(SP)
9D01010C  10400005   BEQ V0, ZERO, 0x9D010124
9D010110  AFB00014   SW S0, 20(SP)
9D010114  8E421070   LW V0, 4208(S2)
9D010118  30420080   ANDI V0, V0, 128
9D01011C  1440005C   BNE V0, ZERO, UART_1_InterruptHandler::UART1_FAULT_InterruptHandler
9D010120  3C11BF80   LUI S1, -16512
9D010124  8E421040   LW V0, 4160(S2)
9D010128  30420100   ANDI V0, V0, 256
9D01012C  10400005   BEQ V0, ZERO, 0x9D010144
9D010130  00000000   NOP
9D010134  8E421070   LW V0, 4208(S2)
9D010138  30420100   ANDI V0, V0, 256
9D01013C  54400074   BNEL V0, ZERO, UART_1_InterruptHandler::UART1_RX_InterruptHandler
9D010140  3C10A000   LUI S0, -24576
9D010144  8E421040   LW V0, 4160(S2)
9D010148  30420200   ANDI V0, V0, 512
9D01014C  10400005   BEQ V0, ZERO, 0x9D010164
9D010150  8FBF002C   LW RA, 44(SP)
9D010154  8E421070   LW V0, 4208(S2)
9D010158  30420200   ANDI V0, V0, 512
9D01015C  14400009   BNE V0, ZERO, UART_1_InterruptHandler::UART1_TX_InterruptHandler
9D010160  3C14A000   LUI S4, -24576
9D010164  8FB50028   LW S5, 40(SP)
9D010168  8FB40024   LW S4, 36(SP)
9D01016C  8FB30020   LW S3, 32(SP)
9D010170  8FB2001C   LW S2, 28(SP)
9D010174  8FB10018   LW S1, 24(SP)
9D010178  8FB00014   LW S0, 20(SP)
9D01017C  03E00008   JR RA
9D010180  27BD0030   ADDIU SP, SP, 48
9D010184  26902D5C   ADDIU S0, S4, 11612
9D01018C  8E030008   LW V1, 8(S0)
9D010190  0062202B   SLTU A0, V1, V0
9D01019C  8E040018   LW A0, 24(S0)
9D0101A4  00621023   SUBU V0, V1, V0
9D0101A8  104000AC   BEQ V0, ZERO, UART_1_InterruptHandler::UART1_TX_InterruptHandler
9D0101AC  24020200   ADDIU V0, ZERO, 512
9D0101B0  3C15A000   LUI S5, -24576
9D0101B4  3C11BF80   LUI S1, -16512
9D0101B8  24130006   ADDIU S3, ZERO, 6
9D0101BC  26B52A6C   ADDIU S5, S5, 10860
9D0101C0  8E226010   LW V0, 24592(S1)
9D0101C4  30420200   ANDI V0, V0, 512
9D0101C8  1440002E   BNE V0, ZERO, 0x9D010284
9D0101CC  24020200   ADDIU V0, ZERO, 512
9D0101D0  8E02000C   LW V0, 12(S0)
9D0101D4  8E030008   LW V1, 8(S0)
9D0101D8  50430090   BEQL V0, V1, UART_1_InterruptHandler::UART1_TX_InterruptHandler
9D0101DC  24020200   ADDIU V0, ZERO, 512
9D0101E0  8E246000   LW A0, 24576(S1)
9D0101E4  30840006   ANDI A0, A0, 6
9D0101E8  10930094   BEQ A0, S3, UART_1_InterruptHandler::UART1_TX_InterruptHandler
9D0101EC  24430001   ADDIU V1, V0, 1
9D0101F0  00551021   ADDU V0, V0, S5
9D0101F4  90440000   LBU A0, 0(V0)
9D0101F8  8E020018   LW V0, 24(S0)
9D0101FC  0062282B   SLTU A1, V1, V0
9D010200  0005180A   MOVZ V1, ZERO, A1
9D010204  AE03000C   SW V1, 12(S0)
9D010208  8E236000   LW V1, 24576(S1)
9D01020C  30630006   ANDI V1, V1, 6
9D010210  54730001   BNEL V1, S3, UART1_WriteNotificationSend
9D010214  308400FF   ANDI A0, A0, 255
9D010218  92030014   LBU V1, 20(S0)
9D01021C  AE246020   SW A0, 24608(S1)
9D010220  1060FFE7   BEQ V1, ZERO, 0x9D0101C0
9D010224  00000000   NOP
9D010228  8E03000C   LW V1, 12(S0)
9D01022C  8E040008   LW A0, 8(S0)
9D010230  0083282B   SLTU A1, A0, V1
9D010234  54A00001   BNEL A1, ZERO, 0x9D01023C
9D010238  00442021   ADDU A0, V0, A0
9D01023C  8E862D5C   LW A2, 11612(S4)
9D010240  10C0FFDF   BEQ A2, ZERO, 0x9D0101C0
9D010244  00831823   SUBU V1, A0, V1
9D010248  92040015   LBU A0, 21(S0)
9D01024C  2442FFFF   ADDIU V0, V0, -1
9D010250  00431023   SUBU V0, V0, V1
9D010254  1080007D   BEQ A0, ZERO, UART_1_InterruptHandler::UART1_TX_InterruptHandler
9D010258  8E030010   LW V1, 16(S0)
9D01025C  0043102B   SLTU V0, V0, V1
9D010260  1440FFD7   BNE V0, ZERO, 0x9D0101C0
9D010264  00000000   NOP
9D010268  8E050004   LW A1, 4(S0)
9D01026C  00C0F809   JALR A2
9D010270  24040003   ADDIU A0, ZERO, 3
9D010274  8E226010   LW V0, 24592(S1)
9D010278  30420200   ANDI V0, V0, 512
9D01027C  1040FFD4   BEQ V0, ZERO, UART1_TxPullByte
9D010280  24020200   ADDIU V0, ZERO, 512
9D010284  AE421044   SW V0, 4164(S2)
9D010288  1000FFB6   BEQ ZERO, ZERO, 0x9D010164
9D01028C  8FBF002C   LW RA, 44(SP)
9D010290  8E226010   LW V0, 24592(S1)
9D010294  3C14A000   LUI S4, -24576
9D01029C  3042000E   ANDI V0, V0, 14
9D0102A0  AE02003C   SW V0, 60(S0)
9D0102A4  8E226010   LW V0, 24592(S1)
9D0102A8  3042000E   ANDI V0, V0, 14
9D0102AC  50400011   BEQL V0, ZERO, 0x9D0102F4
9D0102B4  8E226010   LW V0, 24592(S1)
9D0102B8  30420002   ANDI V0, V0, 2
9D0102BC  10400005   BEQ V0, ZERO, 0x9D0102D4
9D0102C4  AE226014   SW V0, 24596(S1)
9D0102D0  8E226030   LW V0, 24624(S1)
9D0102D4  8E226010   LW V0, 24592(S1)
9D0102DC  1440FFFC   BNE V0, ZERO, 0x9D0102D0
9D0102E4  AE421044   SW V0, 4164(S2)
9D0102E8  24020100   ADDIU V0, ZERO, 256
9D0102F0  8E02001C   LW V0, 28(S0)
9D0102F4  1040FF8B   BEQ V0, ZERO, 0x9D010124
9D0102FC  8E050020   LW A1, 32(S0)
9D010310  3C14A000   LUI S4, -24576
9D010314  3C11BF80   LUI S1, -16512
9D010318  26102D5C   ADDIU S0, S0, 11612
9D01031C  26942AEC   ADDIU S4, S4, 10988
9D010320  8E226010   LW V0, 24592(S1)
9D010324  30420001   ANDI V0, V0, 1
9D010328  10400041   BEQ V0, ZERO, UART_1_InterruptHandler::UART1_RX_InterruptHandler
9D01032C  24020100   ADDIU V0, ZERO, 256
9D010330  8E336030   LW S3, 24624(S1)
9D010334  8E020024   LW V0, 36(S0)
9D010338  8E03002C   LW V1, 44(S0)
9D01033C  8E040028   LW A0, 40(S0)
9D010340  24420001   ADDIU V0, V0, 1
9D010344  0043182B   SLTU V1, V0, V1
9D010348  0003100A   MOVZ V0, ZERO, V1
9D01034C  50820023   BEQL A0, V0, UART_1_InterruptHandler::UART1_RX_InterruptHandler::UART1_RxPushByte
9D010350  8E03001C   LW V1, 28(S0)
9D010354  8E030028   LW V1, 40(S0)
9D010358  1062FFF1   BEQ V1, V0, 0x9D010320
9D01035C  00000000   NOP
9D010360  8E236000   LW V1, 24576(S1)
9D010364  24040006   ADDIU A0, ZERO, 6
9D010368  30630006   ANDI V1, V1, 6
9D01036C  10640026   BEQ V1, A0, UART_1_InterruptHandler::UART1_RX_InterruptHandler
9D010370  00000000   NOP
9D010374  8E030024   LW V1, 36(S0)
9D010378  00741821   ADDU V1, V1, S4
9D01037C  A0730000   SB S3, 0(V1)
9D010380  92030030   LBU V1, 48(S0)
9D010384  AE020024   SW V0, 36(S0)
9D010388  1060FFE5   BEQ V1, ZERO, 0x9D010320
9D01038C  00000000   NOP
9D010390  8E030024   LW V1, 36(S0)
9D010394  8E020028   LW V0, 40(S0)
9D010398  0062202B   SLTU A0, V1, V0
9D01039C  54800032   BNEL A0, ZERO, 0x9D010468
9D0103A0  8E04002C   LW A0, 44(S0)
9D0103A4  00621023   SUBU V0, V1, V0
9D0103A8  8E03001C   LW V1, 28(S0)
9D0103AC  1060FFDC   BEQ V1, ZERO, 0x9D010320
9D0103B0  00000000   NOP
9D0103B4  92050038   LBU A1, 56(S0)
9D0103B8  14A0002D   BNE A1, ZERO, UART_1_InterruptHandler::UART1_RX_InterruptHandler
9D0103BC  8E040034   LW A0, 52(S0)
9D0103C0  1444FFD7   BNE V0, A0, 0x9D010320
9D0103C4  00000000   NOP
9D0103C8  8E050020   LW A1, 32(S0)
9D0103CC  0060F809   JALR V1
9D0103D0  00002025   OR A0, ZERO, ZERO
9D0103D4  1000FFD2   BEQ ZERO, ZERO, 0x9D010320
9D0103D8  00000000   NOP
9D0103DC  1060FFDD   BEQ V1, ZERO, 0x9D010354
9D0103E0  00000000   NOP
9D0103E4  8E050020   LW A1, 32(S0)
9D0103E8  0060F809   JALR V1
9D0103EC  24040001   ADDIU A0, ZERO, 1
9D0103F0  8E020024   LW V0, 36(S0)
9D0103F4  8E03002C   LW V1, 44(S0)
9D0103F8  24420001   ADDIU V0, V0, 1
9D0103FC  0043182B   SLTU V1, V0, V1
9D010400  1000FFD4   BEQ ZERO, ZERO, 0x9D010354
9D010404  0003100A   MOVZ V0, ZERO, V1
9D010408  8E030024   LW V1, 36(S0)
9D01040C  00031840   SLL V1, V1, 1
9D010410  02831821   ADDU V1, S4, V1
9D010414  1000FFDA   BEQ ZERO, ZERO, UART_1_InterruptHandler::UART1_RX_InterruptHandler::UART1_ReadNotificationSend
9D010418  A4730000   SH S3, 0(V1)
9D01041C  AE421074   SW V0, 4212(S2)
9D010420  24020200   ADDIU V0, ZERO, 512
9D010424  AE421044   SW V0, 4164(S2)
9D010428  1000FF4E   BEQ ZERO, ZERO, 0x9D010164
9D01042C  8FBF002C   LW RA, 44(SP)
9D010430  AE421044   SW V0, 4164(S2)
9D010434  1000FF43   BEQ ZERO, ZERO, 0x9D010144
9D010438  00000000   NOP
9D01043C  00021040   SLL V0, V0, 1
9D010440  02A21021   ADDU V0, S5, V0
9D010444  1000FF6C   BEQ ZERO, ZERO, 0x9D0101F8
9D010448  94440000   LHU A0, 0(V0)
9D01044C  1462FF5C   BNE V1, V0, 0x9D0101C0
9D010450  00000000   NOP
9D010454  1000FF85   BEQ ZERO, ZERO, 0x9D01026C
9D010458  8E050004   LW A1, 4(S0)
9D01045C  AE421074   SW V0, 4212(S2)
9D010460  1000FF40   BEQ ZERO, ZERO, 0x9D010164
9D010464  8FBF002C   LW RA, 44(SP)
9D010468  1000FFCE   BEQ ZERO, ZERO, 0x9D0103A4
9D01046C  00641821   ADDU V1, V1, A0
9D010470  0044102B   SLTU V0, V0, A0
9D010474  1440FFAA   BNE V0, ZERO, 0x9D010320
9D010478  00000000   NOP
9D01047C  1000FFD3   BEQ ZERO, ZERO, 0x9D0103CC
9D010480  8E050020   LW A1, 32(S0)
9D014FEC  10A0003E   BEQ A1, ZERO, 0x9D0150E8
9D014FF0  3C03A000   LUI V1, -24576
9D014FF4  24632D5C   ADDIU V1, V1, 11612
9D014FF8  8C6C0018   LW T4, 24(V1)
9D014FFC  3C0AA000   LUI T2, -24576
9D015000  00001025   OR V0, ZERO, ZERO
9D015004  3C09BF80   LUI T1, -16512
9D015008  24080006   ADDIU T0, ZERO, 6
9D01500C  254A2A6C   ADDIU T2, T2, 10860
9D015010  8D266000   LW A2, 24576(T1)
9D015014  8C6B000C   LW T3, 12(V1)
9D015018  8C670008   LW A3, 8(V1)
9D01501C  30C60006   ANDI A2, A2, 6
9D015020  10C8001D   BEQ A2, T0, UART1_Write::UART1_TxPushByte
9D015024  24E60001   ADDIU A2, A3, 1
9D015028  00CC682B   SLTU T5, A2, T4
9D01502C  000D300A   MOVZ A2, ZERO, T5
9D015030  1166000D   BEQ T3, A2, UART1_Write::UART1_WritePendingBytesGet
9D015034  00000000   NOP
9D015038  8D2B6000   LW T3, 24576(T1)
9D01503C  00826821   ADDU T5, A0, V0
9D015040  316B0006   ANDI T3, T3, 6
9D015044  1168001E   BEQ T3, T0, UART1_Write::UART1_TxPushByte
9D015048  91AD0000   LBU T5, 0(T5)
9D01504C  00EA3821   ADDU A3, A3, T2
9D015050  A0ED0000   SB T5, 0(A3)
9D015054  24420001   ADDIU V0, V0, 1
9D015058  AC660008   SW A2, 8(V1)
9D01505C  0045302B   SLTU A2, V0, A1
9D015060  14C0FFEB   BNE A2, ZERO, 0x9D015010
9D015064  00000000   NOP
9D015068  8C64000C   LW A0, 12(V1)
9D01506C  8C650008   LW A1, 8(V1)
9D015070  00A4302B   SLTU A2, A1, A0
9D015074  54C00016   BNEL A2, ZERO, UART1_Write::UART1_WritePendingBytesGet
9D015078  8C630018   LW V1, 24(V1)
9D01507C  00A42023   SUBU A0, A1, A0
9D015080  10800003   BEQ A0, ZERO, 0x9D015090
9D015084  3C03BF88   LUI V1, -16504
9D015088  24040200   ADDIU A0, ZERO, 512
9D01508C  AC641078   SW A0, 4216(V1)
9D015090  03E00008   JR RA
9D015094  00000000   NOP
9D015098  00CC682B   SLTU T5, A2, T4
9D01509C  000D300A   MOVZ A2, ZERO, T5
9D0150A0  1166FFF1   BEQ T3, A2, UART1_Write::UART1_WritePendingBytesGet
9D0150A4  00000000   NOP
9D0150A8  8D2B6000   LW T3, 24576(T1)
9D0150AC  00026840   SLL T5, V0, 1
9D0150B0  008D6821   ADDU T5, A0, T5
9D0150B4  316B0006   ANDI T3, T3, 6
9D0150B8  1568FFE4   BNE T3, T0, 0x9D01504C
9D0150BC  95AD0000   LHU T5, 0(T5)
9D0150C0  00073840   SLL A3, A3, 1
9D0150C4  01473821   ADDU A3, T2, A3
9D0150C8  1000FFE2   BEQ ZERO, ZERO, 0x9D015054
9D0150CC  A4ED0000   SH T5, 0(A3)
9D0150D0  00A32821   ADDU A1, A1, V1
9D0150D4  00A42023   SUBU A0, A1, A0
9D0150D8  1080FFED   BEQ A0, ZERO, 0x9D015090
9D0150DC  3C03BF88   LUI V1, -16504
9D0150E0  1000FFEA   BEQ ZERO, ZERO, 0x9D01508C
9D0150E4  24040200   ADDIU A0, ZERO, 512
9D0150E8  00001025   OR V0, ZERO, ZERO
9D0150EC  1000FFDE   BEQ ZERO, ZERO, UART1_Write::UART1_WritePendingBytesGet
9D0150F0  24632D5C   ADDIU V1, V1, 11612
9D015E28  3C09A000   LUI T1, -24576
9D015E2C  25292D5C   ADDIU T1, T1, 11612
9D015E30  00A01025   OR V0, A1, ZERO
9D015E34  8D230028   LW V1, 40(T1)
9D015E38  8D250024   LW A1, 36(T1)
9D015E3C  50400025   BEQL V0, ZERO, 0x9D015ED4
9D015E40  00602825   OR A1, V1, ZERO
9D015E44  50650023   BEQL V1, A1, 0x9D015ED4
9D015E48  00001025   OR V0, ZERO, ZERO
9D015E4C  3C0CA000   LUI T4, -24576
9D015E50  00003025   OR A2, ZERO, ZERO
9D015E54  3C0EBF80   LUI T6, -16512
9D015E58  258C2AEC   ADDIU T4, T4, 10988
9D015E5C  1000000A   BEQ ZERO, ZERO, 0x9D015E88
9D015E60  240D0006   ADDIU T5, ZERO, 6
9D015E64  91630000   LBU V1, 0(T3)
9D015E68  A143FFFF   SB V1, -1(T2)
9D015E6C  8D23002C   LW V1, 44(T1)
9D015E70  0103182B   SLTU V1, T0, V1
9D015E74  0003400A   MOVZ T0, ZERO, V1
9D015E78  10C20015   BEQ A2, V0, 0x9D015ED0
9D015E7C  01001825   OR V1, T0, ZERO
9D015E80  50650017   BEQL V1, A1, 0x9D015EE0
9D015E84  00C01025   OR V0, A2, ZERO
9D015E88  8DC76000   LW A3, 24576(T6)
9D015E8C  24C60001   ADDIU A2, A2, 1
9D015E90  01835821   ADDU T3, T4, V1
9D015E94  30E70006   ANDI A3, A3, 6
9D015E98  00865021   ADDU T2, A0, A2
9D015E9C  14EDFFF1   BNE A3, T5, 0x9D015E64
9D015EA0  24680001   ADDIU T0, V1, 1
9D015EA4  00031840   SLL V1, V1, 1
9D015EA8  01831821   ADDU V1, T4, V1
9D015EAC  94670000   LHU A3, 0(V1)
9D015EB0  00061840   SLL V1, A2, 1
9D015EB4  00831821   ADDU V1, A0, V1
9D015EB8  A467FFFE   SH A3, -2(V1)
9D015EBC  8D23002C   LW V1, 44(T1)
9D015EC0  0103182B   SLTU V1, T0, V1
9D015EC4  0003400A   MOVZ T0, ZERO, V1
9D015EC8  14C2FFED   BNE A2, V0, 0x9D015E80
9D015ECC  01001825   OR V1, T0, ZERO
9D015ED0  01002825   OR A1, T0, ZERO
9D015ED4  AD250028   SW A1, 40(T1)
9D015ED8  03E00008   JR RA
9D015EDC  00000000   NOP
9D015EE0  AD250028   SW A1, 40(T1)
9D015EE4  03E00008   JR RA
9D015EE8  00000000   NOP
9D015EEC  1000FFF9   BEQ ZERO, ZERO, 0x9D015ED4
9D015EF0  00001025   OR V0, ZERO, ZERO
9D016158  3C03BF80   LUI V1, -16512
9D01615C  24050008   ADDIU A1, ZERO, 8
9D016160  AC656000   SW A1, 24576(V1)
9D016164  34059400   ORI A1, ZERO, -27648
9D016168  AC656018   SW A1, 24600(V1)
9D01616C  3C06A000   LUI A2, -24576
9D016170  2405009B   ADDIU A1, ZERO, 155
9D016174  24C22D5C   ADDIU V0, A2, 11612
9D016178  AC656040   SW A1, 24640(V1)
9D01617C  3C04BF88   LUI A0, -16504
9D016180  24050200   ADDIU A1, ZERO, 512
9D016184  AC851074   SW A1, 4212(A0)
9D016188  AC400024   SW ZERO, 36(V0)
9D01618C  AC400028   SW ZERO, 40(V0)
9D016190  AC400008   SW ZERO, 8(V0)
9D016194  AC40000C   SW ZERO, 12(V0)
9D016198  AC40003C   SW ZERO, 60(V0)
9D01619C  8C656000   LW A1, 24576(V1)
9D0161A0  24070006   ADDIU A3, ZERO, 6
9D0161A4  AC40001C   SW ZERO, 28(V0)
9D0161A8  30A50006   ANDI A1, A1, 6
9D0161AC  A0400030   SB ZERO, 48(V0)
9D0161B0  A0400038   SB ZERO, 56(V0)
9D0161B4  AC400034   SW ZERO, 52(V0)
9D0161B8  ACC02D5C   SW ZERO, 11612(A2)
9D0161BC  AC400010   SW ZERO, 16(V0)
9D0161C0  10A7000C   BEQ A1, A3, 0x9D0161F4
9D0161C4  A4400014   SH ZERO, 20(V0)
9D0161C8  24050080   ADDIU A1, ZERO, 128
9D0161CC  AC45002C   SW A1, 44(V0)
9D0161D0  AC450018   SW A1, 24(V0)
9D0161D4  34028000   ORI V0, ZERO, -32768
9D0161D8  AC626008   SW V0, 24584(V1)
9D0161DC  24020080   ADDIU V0, ZERO, 128
9D0161E0  AC821078   SW V0, 4216(A0)
9D0161E4  24020100   ADDIU V0, ZERO, 256
9D0161E8  AC821078   SW V0, 4216(A0)
9D0161EC  03E00008   JR RA
9D0161F0  00000000   NOP
9D0161F4  24050040   ADDIU A1, ZERO, 64
9D0161F8  AC45002C   SW A1, 44(V0)
9D0161FC  AC450018   SW A1, 24(V0)
9D016200  34028000   ORI V0, ZERO, -32768
9D016204  AC626008   SW V0, 24584(V1)
9D016208  24020080   ADDIU V0, ZERO, 128
9D01620C  AC821078   SW V0, 4216(A0)
9D016210  24020100   ADDIU V0, ZERO, 256
9D016214  AC821078   SW V0, 4216(A0)
9D016218  03E00008   JR RA
9D01621C  00000000   NOP
9D018A10  3C03A000   LUI V1, -24576
9D018A14  24632D5C   ADDIU V1, V1, 11612
9D018A18  8C62000C   LW V0, 12(V1)
9D018A1C  8C640008   LW A0, 8(V1)
9D018A20  0082282B   SLTU A1, A0, V0
9D018A2C  00642021   ADDU A0, V1, A0
9D018A30  00821023   SUBU V0, A0, V0
9D018A34  2463FFFF   ADDIU V1, V1, -1
9D018A38  03E00008   JR RA
9D018A3C  00621023   SUBU V0, V1, V0
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/peripheral/tmr/plib_tmr2.c  ----------------
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Interface Source File
3:                   
4:                     Company
5:                       Microchip Technology Inc.
6:                   
7:                     File Name
8:                       plib_tmr2.c
9:                   
10:                    Summary
11:                      TMR2 peripheral library source file.
12:                  
13:                    Description
14:                      This file implements the interface to the TMR peripheral library.  This
15:                      library provides access to and control of the associated peripheral
16:                      instance.
17:                  
18:                  *******************************************************************************/
19:                  
20:                  // DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
23:                  *
24:                  * Subject to your compliance with these terms, you may use Microchip software
25:                  * and any derivatives exclusively with Microchip products. It is your
26:                  * responsibility to comply with third party license terms applicable to your
27:                  * use of third party software (including open source software) that may
28:                  * accompany Microchip software.
29:                  *
30:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
31:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
32:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
33:                  * PARTICULAR PURPOSE.
34:                  *
35:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
36:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
37:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
38:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
39:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
40:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
41:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
42:                  *******************************************************************************/
43:                  // DOM-IGNORE-END
44:                  
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Included Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include "device.h"
53:                  #include "plib_tmr2.h"
54:                  
55:                  
56:                  static TMR_TIMER_OBJECT tmr2Obj;
57:                  
58:                  
59:                  void TMR2_Initialize(void)
60:                  {
61:                      /* Disable Timer */
62:                      T2CONCLR = _T2CON_ON_MASK;
63:                  
64:                      /*
65:                      SIDL = 0
66:                      TCKPS =7
67:                      T32   = 1
68:                      TCS = 0
69:                      */
70:                      T2CONSET = 0x78;
71:                  
72:                      /* Clear counter */
73:                      TMR2 = 0x0;
74:                  
75:                      /*Set period */
76:                      PR2 = 4294967295U;
77:                  
78:                      /* Enable TMR Interrupt of odd numbered timer in 32-bit mode */
79:                      IEC0SET = _IEC0_T3IE_MASK;
80:                  
81:                  }
82:                  
83:                  
84:                  void TMR2_Start(void)
85:                  {
86:                      T2CONSET = _T2CON_ON_MASK;
87:                  }
88:                  
89:                  
90:                  void TMR2_Stop (void)
91:                  {
92:                      T2CONCLR = _T2CON_ON_MASK;
93:                  }
94:                  
95:                  void TMR2_PeriodSet(uint32_t period)
96:                  {
97:                      PR2  = period;
98:                  }
99:                  
100:                 uint32_t TMR2_PeriodGet(void)
101:                 {
102:                     return PR2;
103:                 }
104:                 
105:                 uint32_t TMR2_CounterGet(void)
106:                 {
107:                     return (TMR2);
108:                 }
109:                 
110:                 
111:                 uint32_t TMR2_FrequencyGet(void)
112:                 {
113:                     return (281250);
114:                 }
115:                 
116:                 
117:                 void TIMER_3_InterruptHandler (void)
118:                 {
119:                     uint32_t status  = 0U;
120:                     status = IFS0bits.T3IF;
121:                     IFS0CLR = _IFS0_T3IF_MASK;
122:                 
123:                     if((tmr2Obj.callback_fn != NULL))
124:                     {
125:                         tmr2Obj.callback_fn(status, tmr2Obj.context);
126:                     }
127:                 }
128:                 
129:                 
130:                 void TMR2_InterruptEnable(void)
131:                 {
132:                     IEC0SET = _IEC0_T3IE_MASK;
133:                 }
134:                 
135:                 
136:                 void TMR2_InterruptDisable(void)
137:                 {
138:                     IEC0CLR = _IEC0_T3IE_MASK;
139:                 }
140:                 
141:                 
142:                 void TMR2_CallbackRegister( TMR_CALLBACK callback_fn, uintptr_t context )
143:                 {
144:                     /* Save callback_fn and context in local memory */
145:                     tmr2Obj.callback_fn = callback_fn;
146:                     tmr2Obj.context = context;
147:                 }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
9D018814  3C02BF80   LUI V0, -16512
9D018818  34038000   ORI V1, ZERO, -32768
9D01881C  AC430804   SW V1, 2052(V0)
9D018820  24030078   ADDIU V1, ZERO, 120
9D018824  AC430808   SW V1, 2056(V0)
9D018828  2403FFFF   ADDIU V1, ZERO, -1
9D01882C  AC400810   SW ZERO, 2064(V0)
9D018830  AC430820   SW V1, 2080(V0)
9D018834  3C02BF88   LUI V0, -16504
9D018838  24034000   ADDIU V1, ZERO, 16384
9D01883C  AC431068   SW V1, 4200(V0)
9D018840  03E00008   JR RA
9D018844  00000000   NOP
9D0189E0  3C02BF88   LUI V0, -16504
9D0189E4  8C441030   LW A0, 4144(V0)
9D0189E8  8F99801C   LW T9, -32740(GP)
9D0189EC  24034000   ADDIU V1, ZERO, 16384
9D0189F0  7C840380   EXT A0, A0, 14, 1
9D0189F4  AC431034   SW V1, 4148(V0)
9D0189F8  13200003   BEQ T9, ZERO, 0x9D018A08
9D0189FC  00000000   NOP
9D018A00  03200008   JR T9
9D018A04  8F858020   LW A1, -32736(GP)
9D018A08  03E00008   JR RA
9D018A0C  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/peripheral/spi/spi_master/plib_spi1_master.c
1:                   /*******************************************************************************
2:                     SPI PLIB
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_spi1_master.c
9:                   
10:                    Summary:
11:                      SPI1 Master Source File
12:                  
13:                    Description:
14:                      This file has implementation of all the interfaces provided for particular
15:                      SPI peripheral.
16:                  
17:                  *******************************************************************************/
18:                  
19:                  /*******************************************************************************
20:                  * Copyright (C) 2018-2019 Microchip Technology Inc. and its subsidiaries.
21:                  *
22:                  * Subject to your compliance with these terms, you may use Microchip software
23:                  * and any derivatives exclusively with Microchip products. It is your
24:                  * responsibility to comply with third party license terms applicable to your
25:                  * use of third party software (including open source software) that may
26:                  * accompany Microchip software.
27:                  *
28:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                  * PARTICULAR PURPOSE.
32:                  *
33:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                  *******************************************************************************/
41:                  
42:                  #include "plib_spi1_master.h"
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Section: SPI1 Implementation
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  
50:                  
51:                  #define SPI1_CON_MSTEN                      (1 << _SPI1CON_MSTEN_POSITION)
52:                  #define SPI1_CON_CKP                        (1 << _SPI1CON_CKP_POSITION)
53:                  #define SPI1_CON_CKE                        (0 << _SPI1CON_CKE_POSITION)
54:                  #define SPI1_CON_MODE_32_MODE_16            (0 << _SPI1CON_MODE16_POSITION)
55:                  #define SPI1_CON_ENHBUF                     (1 << _SPI1CON_ENHBUF_POSITION)
56:                  #define SPI1_CON_MCLKSEL                    (0 << _SPI1CON_MCLKSEL_POSITION)
57:                  #define SPI1_CON_MSSEN                      (0 << _SPI1CON_MSSEN_POSITION)
58:                  #define SPI1_CON_SMP                        (0 << _SPI1CON_SMP_POSITION)
59:                  
60:                  void SPI1_Initialize ( void )
61:                  {
62:                      uint32_t rdata = 0U;
63:                  
64:                      /* Disable SPI1 Interrupts */
65:                      IEC1CLR = 0x10;
66:                      IEC1CLR = 0x20;
67:                      IEC1CLR = 0x40;
68:                  
69:                      /* STOP and Reset the SPI */
70:                      SPI1CON = 0;
71:                  
72:                      /* Clear the Receiver buffer */
73:                      rdata = SPI1BUF;
74:                      rdata = rdata;
75:                  
76:                      /* Clear SPI1 Interrupt flags */
77:                      IFS1CLR = 0x10;
78:                      IFS1CLR = 0x20;
79:                      IFS1CLR = 0x40;
80:                  
81:                      /* BAUD Rate register Setup */
82:                      SPI1BRG = 3;
83:                  
84:                      /* CLear the Overflow */
85:                      SPI1STATCLR = _SPI1STAT_SPIROV_MASK;
86:                  
87:                      /*
88:                      MSTEN = 1
89:                      CKP = 1
90:                      CKE = 0
91:                      MODE<32,16> = 0
92:                      ENHBUF = 1
93:                      MSSEN = 0
94:                      MCLKSEL = 0
95:                      */
96:                      SPI1CONSET = (SPI1_CON_MSSEN | SPI1_CON_MCLKSEL | SPI1_CON_ENHBUF | SPI1_CON_MODE_32_MODE_16 | SPI1_CON_CKE | SPI1_CON_CKP | SPI1_CON_MSTEN | SPI1_CON_SMP);
97:                  
98:                      /* Enable transmit interrupt when transmit buffer is completely empty (STXISEL = '01') */
99:                      /* Enable receive interrupt when the receive buffer is not empty (SRXISEL = '01') */
100:                     SPI1CONSET = 0x00000005;
101:                 
102:                 
103:                     /* Enable SPI1 */
104:                     SPI1CONSET = _SPI1CON_ON_MASK;
105:                 }
106:                 
107:                 bool SPI1_TransferSetup (SPI_TRANSFER_SETUP* setup, uint32_t spiSourceClock )
108:                 {
109:                     uint32_t t_brg;
110:                     uint32_t baudHigh;
111:                     uint32_t baudLow;
112:                     uint32_t errorHigh;
113:                     uint32_t errorLow;
114:                 
115:                     if ((setup == NULL) || (setup->clockFrequency == 0))
116:                     {
117:                         return false;
118:                     }
119:                 
120:                     if(spiSourceClock == 0)
121:                     {
122:                         // Use Master Clock Frequency set in GUI
123:                         spiSourceClock = 72000000;
124:                     }
125:                 
126:                     t_brg = (((spiSourceClock / (setup->clockFrequency)) / 2u) - 1u);
127:                     baudHigh = spiSourceClock / (2u * (t_brg + 1u));
128:                     baudLow = spiSourceClock / (2u * (t_brg + 2u));
129:                     errorHigh = baudHigh - setup->clockFrequency;
130:                     errorLow = setup->clockFrequency - baudLow;
131:                 
132:                     if (errorHigh > errorLow)
133:                     {
134:                         t_brg++;
135:                     }
136:                 
137:                     if(t_brg > 8191)
138:                     {
139:                         return false;
140:                     }
141:                 
142:                     SPI1BRG = t_brg;
143:                     SPI1CON = (SPI1CON & (~(_SPI1CON_MODE16_MASK | _SPI1CON_MODE32_MASK | _SPI1CON_CKP_MASK | _SPI1CON_CKE_MASK))) |
144:                                             (setup->clockPolarity | setup->clockPhase | setup->dataBits);
145:                 
146:                     return true;
147:                 }
148:                 
149:                 bool SPI1_Write(void* pTransmitData, size_t txSize)
150:                 {
151:                     return(SPI1_WriteRead(pTransmitData, txSize, NULL, 0));
152:                 }
153:                 
154:                 bool SPI1_Read(void* pReceiveData, size_t rxSize)
155:                 {
156:                     return(SPI1_WriteRead(NULL, 0, pReceiveData, rxSize));
157:                 }
158:                 
159:                 bool SPI1_IsTransmitterBusy (void)
160:                 {
161:                     return ((SPI1STAT & _SPI1STAT_SRMT_MASK) == 0)? true : false;
162:                 }
163:                 
164:                 bool SPI1_WriteRead(void* pTransmitData, size_t txSize, void* pReceiveData, size_t rxSize)
165:                 {
166:                     size_t txCount = 0;
167:                     size_t rxCount = 0;
168:                     size_t dummySize = 0;
169:                     size_t dummyRxCntr = 0;
170:                     size_t receivedData;
171:                     bool isSuccess = false;
172:                 
173:                     /* Verify the request */
174:                     if (((txSize > 0) && (pTransmitData != NULL)) || ((rxSize > 0) && (pReceiveData != NULL)))
175:                     {
176:                         if (pTransmitData == NULL)
177:                         {
178:                             txSize = 0;
179:                         }
180:                         if (pReceiveData == NULL)
181:                         {
182:                             rxSize = 0;
183:                         }
184:                 
185:                         /* Clear the receive overflow error if any */
186:                         SPI1STATCLR = _SPI1STAT_SPIROV_MASK;
187:                 
188:                         /* Flush out any unread data in SPI read buffer from the previous transfer */
189:                         while ((bool)(SPI1STAT & _SPI1STAT_SPIRBE_MASK) == false)
190:                         {
191:                             receivedData = SPI1BUF;
192:                         }
193:                 
194:                         if (rxSize > txSize)
195:                         {
196:                             dummySize = rxSize - txSize;
197:                         }
198:                 
199:                         /* If dataBit size is 32 bits */
200:                         if (_SPI1CON_MODE32_MASK == (SPI1CON & _SPI1CON_MODE32_MASK))
201:                         {
202:                             rxSize >>= 2;
203:                             txSize >>= 2;
204:                             dummySize >>= 2;
205:                         }
206:                         /* If dataBit size is 16 bits */
207:                         else if (_SPI1CON_MODE16_MASK == (SPI1CON & _SPI1CON_MODE16_MASK))
208:                         {
209:                             rxSize >>= 1;
210:                             txSize >>= 1;
211:                             dummySize >>= 1;
212:                         }
213:                 
214:                         /* Make sure transmit buffer is empty */
215:                         while((bool)(SPI1STAT & _SPI1STAT_SPITBE_MASK) == false);
216:                 
217:                         while ((txCount != txSize) || (dummySize != 0))
218:                         {
219:                             if (txCount != txSize)
220:                             {
221:                                 if((_SPI1CON_MODE32_MASK) == (SPI1CON & (_SPI1CON_MODE32_MASK)))
222:                                 {
223:                                     SPI1BUF = ((uint32_t*)pTransmitData)[txCount++];
224:                                 }
225:                                 else if((_SPI1CON_MODE16_MASK) == (SPI1CON & (_SPI1CON_MODE16_MASK)))
226:                                 {
227:                                     SPI1BUF = ((uint16_t*)pTransmitData)[txCount++];
228:                                 }
229:                                 else
230:                                 {
231:                                     SPI1BUF = ((uint8_t*)pTransmitData)[txCount++];
232:                                 }
233:                             }
234:                             else if (dummySize > 0)
235:                             {
236:                                 SPI1BUF = 0xff;
237:                                 dummySize--;
238:                             }
239:                 
240:                             if (rxCount == rxSize)
241:                             {
242:                                 /* If inside this if condition, then it means that txSize > rxSize and all RX bytes are received */
243:                 
244:                                 /* For transmit only request, wait for buffer to become empty */
245:                                 while((bool)(SPI1STAT & _SPI1STAT_SPITBE_MASK) == false);
246:                 
247:                                 /* Read until the receive buffer is not empty */
248:                                 while ((bool)(SPI1STAT & _SPI1STAT_SPIRBE_MASK) == false)
249:                                 {
250:                                     receivedData = SPI1BUF;
251:                                     dummyRxCntr++;
252:                                 }
253:                             }
254:                             else
255:                             {
256:                                 /* If data is read, wait for the Receiver Data the data to become available */
257:                                 while((SPI1STAT & _SPI1STAT_SPIRBE_MASK) == _SPI1STAT_SPIRBE_MASK);
258:                 
259:                                 /* We have data waiting in the SPI buffer */
260:                                 receivedData = SPI1BUF;
261:                 
262:                                 if (rxCount < rxSize)
263:                                 {
264:                                     if((_SPI1CON_MODE32_MASK) == (SPI1CON & (_SPI1CON_MODE32_MASK)))
265:                                     {
266:                                         ((uint32_t*)pReceiveData)[rxCount++]  = receivedData;
267:                                     }
268:                                     else if((_SPI1CON_MODE16_MASK) == (SPI1CON & (_SPI1CON_MODE16_MASK)))
269:                                     {
270:                                         ((uint16_t*)pReceiveData)[rxCount++]  = receivedData;
271:                                     }
272:                                     else
273:                                     {
274:                                         ((uint8_t*)pReceiveData)[rxCount++]  = receivedData;
275:                                     }
276:                                 }
277:                             }
278:                         }
279:                 
280:                         /* Make sure no data is pending in the shift register */
281:                         while ((bool)((SPI1STAT & _SPI1STAT_SRMT_MASK) == false));
282:                 
283:                         /* Make sure for every character transmitted a character is also received back.
284:                          * If this is not done, we may prematurely exit this routine with the last bit still being
285:                          * transmitted out. As a result, the application may prematurely deselect the CS line and also
286:                          * the next request can receive last character of previous request as its first character.
287:                          */
288:                         if (txSize > rxSize)
289:                         {
290:                             while (dummyRxCntr != (txSize - rxSize))
291:                             {
292:                                 /* Wait for all the RX bytes to be received. */
293:                                 while ((bool)(SPI1STAT & _SPI1STAT_SPIRBE_MASK) == false)
294:                                 {
295:                                     receivedData = SPI1BUF;
296:                                     dummyRxCntr++;
297:                                 }
298:                             }
299:                         }
300:                 
301:                         isSuccess = true;
302:                     }
303:                 
304:                     return isSuccess;
305:                 }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
00000024  00000000   NOP
00000030  00000000   NOP
00000034  00000000   NOP
00000038  00000000   NOP
00000040  00000000   NOP
00000044  00000000   NOP
00000048  00000000   NOP
0000004C  00000000   NOP
00000050  00000000   NOP
0000005C  00000000   NOP
00000060  00000000   NOP
00000064  00000000   NOP
0000006C  00000000   NOP
00000078  00000000   NOP
0000007C  00000000   NOP
00000080  00000000   NOP
00000084  00000000   NOP
00000088  00000000   NOP
0000008C  00000000   NOP
00000090  00000000   NOP
00000094  00000000   NOP
00000098  00000000   NOP
000000A0  00000000   NOP
000000A4  00000000   NOP
000000A8  00000000   NOP
000000AC  00000000   NOP
9D00B2C8  3C02BF80   LUI V0, -16512
9D00B2CC  8C425810   LW V0, 22544(V0)
9D00B2D0  38420080   XORI V0, V0, 128
9D00B2D4  03E00008   JR RA
9D00B2D8  7C4201C0   EXT V0, V0, 7, 1
9D0116D8  3C03BF80   LUI V1, -16512
9D0116E0  0004280A   MOVZ A1, ZERO, A0
9D0116E4  AC625814   SW V0, 22548(V1)
9D0116E8  10C00089   BEQ A2, ZERO, SPI1_WriteRead.part.0
9D0116EC  00000000   NOP
9D0116F0  8C625810   LW V0, 22544(V1)
9D0116F4  30420020   ANDI V0, V0, 32
9D0116F8  14400006   BNE V0, ZERO, SPI1_WriteRead.part.0
9D0116FC  00A7582B   SLTU T3, A1, A3
9D011700  8C625820   LW V0, 22560(V1)
9D011704  8C625810   LW V0, 22544(V1)
9D011708  30420020   ANDI V0, V0, 32
9D01170C  1040FFFC   BEQ V0, ZERO, SPI1_WriteRead.part.0
9D011710  00A7582B   SLTU T3, A1, A3
9D011714  00E51023   SUBU V0, A3, A1
9D011718  000B100A   MOVZ V0, ZERO, T3
9D01171C  00405825   OR T3, V0, ZERO
9D011720  8C625800   LW V0, 22528(V1)
9D011724  30420800   ANDI V0, V0, 2048
9D011728  1040006D   BEQ V0, ZERO, SPI1_WriteRead.part.0
9D01172C  00000000   NOP
9D011730  00073882   SRL A3, A3, 2
9D011734  00052882   SRL A1, A1, 2
9D011738  000B5882   SRL T3, T3, 2
9D01173C  8C625810   LW V0, 22544(V1)
9D011740  30420008   ANDI V0, V0, 8
9D011744  1040FFFD   BEQ V0, ZERO, SPI1_WriteRead.part.0
9D011748  00004025   OR T0, ZERO, ZERO
9D01174C  00005025   OR T2, ZERO, ZERO
9D011750  00004825   OR T1, ZERO, ZERO
9D011754  240C00FF   ADDIU T4, ZERO, 255
9D011758  1125001C   BEQ T1, A1, SPI1_WriteRead.part.0
9D01175C  00000000   NOP
9D011760  8C625800   LW V0, 22528(V1)
9D011764  30420800   ANDI V0, V0, 2048
9D011768  10400041   BEQ V0, ZERO, SPI1_WriteRead.part.0
9D01176C  252D0001   ADDIU T5, T1, 1
9D011770  00094880   SLL T1, T1, 2
9D011774  00894821   ADDU T1, A0, T1
9D011778  8D220000   LW V0, 0(T1)
9D01177C  01A04825   OR T1, T5, ZERO
9D011780  AC625820   SW V0, 22560(V1)
9D011784  11470016   BEQ T2, A3, SPI1_WriteRead.part.0
9D011788  00000000   NOP
9D01178C  8C625810   LW V0, 22544(V1)
9D011790  30420020   ANDI V0, V0, 32
9D011794  1440FFFD   BNE V0, ZERO, SPI1_WriteRead.part.0
9D011798  0147102B   SLTU V0, T2, A3
9D01179C  8C6D5820   LW T5, 22560(V1)
9D0117A0  1040FFED   BEQ V0, ZERO, SPI1_WriteRead.part.0
9D0117A4  00000000   NOP
9D0117A8  8C625800   LW V0, 22528(V1)
9D0117AC  30420800   ANDI V0, V0, 2048
9D0117B0  1040003A   BEQ V0, ZERO, SPI1_WriteRead.part.0
9D0117B4  254E0001   ADDIU T6, T2, 1
9D0117B8  000A5080   SLL T2, T2, 2
9D0117BC  00CA5021   ADDU T2, A2, T2
9D0117C0  AD4D0000   SW T5, 0(T2)
9D0117C4  1525FFE6   BNE T1, A1, SPI1_WriteRead.part.0
9D0117C8  01C05025   OR T2, T6, ZERO
9D0117CC  11600013   BEQ T3, ZERO, SPI1_WriteRead.part.0
9D0117D0  00000000   NOP
9D0117D4  AC6C5820   SW T4, 22560(V1)
9D0117D8  1547FFEC   BNE T2, A3, SPI1_WriteRead.part.0
9D0117DC  256BFFFF   ADDIU T3, T3, -1
9D0117E0  8C625810   LW V0, 22544(V1)
9D0117E4  30420008   ANDI V0, V0, 8
9D0117E8  1040FFFD   BEQ V0, ZERO, SPI1_WriteRead.part.0
9D0117EC  00000000   NOP
9D0117F0  8C625810   LW V0, 22544(V1)
9D0117F4  30420020   ANDI V0, V0, 32
9D0117F8  1440FFD7   BNE V0, ZERO, SPI1_WriteRead.part.0
9D0117FC  00000000   NOP
9D011800  8C625820   LW V0, 22560(V1)
9D011804  8C625810   LW V0, 22544(V1)
9D011808  30420020   ANDI V0, V0, 32
9D01180C  1040FFFC   BEQ V0, ZERO, SPI1_WriteRead.part.0
9D011810  25080001   ADDIU T0, T0, 1
9D011814  1000FFD0   BEQ ZERO, ZERO, SPI1_WriteRead.part.0
9D011818  00000000   NOP
9D01181C  8C625810   LW V0, 22544(V1)
9D011820  30420080   ANDI V0, V0, 128
9D011824  1040FFFD   BEQ V0, ZERO, SPI1_WriteRead.part.0
9D011828  00E5102B   SLTU V0, A3, A1
9D01182C  1040000E   BEQ V0, ZERO, SPI1_WriteRead.part.0
9D011830  00A72823   SUBU A1, A1, A3
9D011834  1105000C   BEQ T0, A1, SPI1_WriteRead.part.0
9D011838  00000000   NOP
9D01183C  8C625810   LW V0, 22544(V1)
9D011840  30420020   ANDI V0, V0, 32
9D011844  1440FFFB   BNE V0, ZERO, SPI1_WriteRead.part.0
9D011848  00000000   NOP
9D01184C  8C625820   LW V0, 22560(V1)
9D011850  8C625810   LW V0, 22544(V1)
9D011854  30420020   ANDI V0, V0, 32
9D011858  1040FFFC   BEQ V0, ZERO, SPI1_WriteRead.part.0
9D01185C  25080001   ADDIU T0, T0, 1
9D011860  1505FFF6   BNE T0, A1, SPI1_WriteRead.part.0
9D011864  00000000   NOP
9D011868  03E00008   JR RA
9D01186C  24020001   ADDIU V0, ZERO, 1
9D011870  8C625800   LW V0, 22528(V1)
9D011874  30420400   ANDI V0, V0, 1024
9D011878  50400011   BEQL V0, ZERO, SPI1_WriteRead.part.0
9D01187C  00894821   ADDU T1, A0, T1
9D011880  00094840   SLL T1, T1, 1
9D011884  00894821   ADDU T1, A0, T1
9D011888  95220000   LHU V0, 0(T1)
9D01188C  01A04825   OR T1, T5, ZERO
9D011890  AC625820   SW V0, 22560(V1)
9D011894  1000FFBB   BEQ ZERO, ZERO, SPI1_WriteRead.part.0
9D011898  00000000   NOP
9D01189C  8C625800   LW V0, 22528(V1)
9D0118A0  30420400   ANDI V0, V0, 1024
9D0118A4  5040000B   BEQL V0, ZERO, SPI1_WriteRead.part.0
9D0118A8  00CA5021   ADDU T2, A2, T2
9D0118AC  000A1040   SLL V0, T2, 1
9D0118B0  00C21021   ADDU V0, A2, V0
9D0118B4  A44D0000   SH T5, 0(V0)
9D0118B8  1000FFA7   BEQ ZERO, ZERO, SPI1_WriteRead.part.0
9D0118BC  01C05025   OR T2, T6, ZERO
9D0118C0  91220000   LBU V0, 0(T1)
9D0118C4  01A04825   OR T1, T5, ZERO
9D0118C8  AC625820   SW V0, 22560(V1)
9D0118CC  1000FFAD   BEQ ZERO, ZERO, SPI1_WriteRead.part.0
9D0118D0  00000000   NOP
9D0118D4  A14D0000   SB T5, 0(T2)
9D0118D8  1000FF9F   BEQ ZERO, ZERO, SPI1_WriteRead.part.0
9D0118DC  01C05025   OR T2, T6, ZERO
9D0118E0  8C625800   LW V0, 22528(V1)
9D0118E4  30420400   ANDI V0, V0, 1024
9D0118E8  1040FF94   BEQ V0, ZERO, SPI1_WriteRead.part.0
9D0118EC  00000000   NOP
9D0118F0  8C625810   LW V0, 22544(V1)
9D0118F4  00073842   SRL A3, A3, 1
9D0118F8  00052842   SRL A1, A1, 1
9D0118FC  30420008   ANDI V0, V0, 8
9D011900  1040FF8E   BEQ V0, ZERO, SPI1_WriteRead.part.0
9D011904  000B5842   SRL T3, T3, 1
9D011908  1000FF90   BEQ ZERO, ZERO, SPI1_WriteRead.part.0
9D01190C  00004025   OR T0, ZERO, ZERO
9D011910  8C675810   LW A3, 22544(V1)
9D011914  30E70020   ANDI A3, A3, 32
9D011918  10E0FF79   BEQ A3, ZERO, SPI1_WriteRead.part.0
9D01191C  00005825   OR T3, ZERO, ZERO
9D011920  1000FF7F   BEQ ZERO, ZERO, SPI1_WriteRead.part.0
9D011924  00003825   OR A3, ZERO, ZERO
9D017B34  3C02BF80   LUI V0, -16512
9D017B38  3C03BF88   LUI V1, -16504
9D017B3C  24040040   ADDIU A0, ZERO, 64
9D017B40  24060010   ADDIU A2, ZERO, 16
9D017B44  24050020   ADDIU A1, ZERO, 32
9D017B48  AC661074   SW A2, 4212(V1)
9D017B4C  AC651074   SW A1, 4212(V1)
9D017B50  AC641074   SW A0, 4212(V1)
9D017B54  AC405800   SW ZERO, 22528(V0)
9D017B58  8C475820   LW A3, 22560(V0)
9D017B5C  AC661044   SW A2, 4164(V1)
9D017B60  AC651044   SW A1, 4164(V1)
9D017B64  AC641044   SW A0, 4164(V1)
9D017B68  24030003   ADDIU V1, ZERO, 3
9D017B6C  AC435830   SW V1, 22576(V0)
9D017B70  3C030001   LUI V1, 1
9D017B74  24630060   ADDIU V1, V1, 96
9D017B78  AC445814   SW A0, 22548(V0)
9D017B7C  AC435808   SW V1, 22536(V0)
9D017B80  24030005   ADDIU V1, ZERO, 5
9D017B84  AC435808   SW V1, 22536(V0)
9D017B88  34038000   ORI V1, ZERO, -32768
9D017B8C  AC435808   SW V1, 22536(V0)
9D017B90  03E00008   JR RA
9D017B94  00000000   NOP
9D0189B0  10A00005   BEQ A1, ZERO, SPI1_WriteRead
9D0189B4  00000000   NOP
9D0189B8  10800003   BEQ A0, ZERO, SPI1_WriteRead
9D0189BC  00000000   NOP
9D0189C0  0B4045B6   J SPI1_WriteRead
9D0189C4  00000000   NOP
9D0189C8  10E00003   BEQ A3, ZERO, SPI1_WriteRead
9D0189CC  00000000   NOP
9D0189D0  14C0FFFB   BNE A2, ZERO, SPI1_WriteRead
9D0189D4  00000000   NOP
9D0189D8  03E00008   JR RA
9D0189DC  00001025   OR V0, ZERO, ZERO
9D018E44  10A00005   BEQ A1, ZERO, 0x9D018E5C
9D018E48  00000000   NOP
9D018E4C  10800003   BEQ A0, ZERO, 0x9D018E5C
9D018E5C  03E00008   JR RA
9D018E60  00001025   OR V0, ZERO, ZERO
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/peripheral/power/plib_power.c  -------------
1:                   /*******************************************************************************
2:                     Resets (Power) PLIB
3:                   
4:                     Company
5:                       Microchip Technology Inc.
6:                   
7:                     File Name
8:                       plib_power.c
9:                   
10:                    Summary
11:                      Power PLIB Implementation File.
12:                  
13:                    Description
14:                      This file defines the interface to the DSCTRL peripheral library.
15:                      This library provides access to and control of the associated Resets.
16:                  
17:                    Remarks:
18:                      None.
19:                  
20:                  *******************************************************************************/
21:                  
22:                  // DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
25:                  *
26:                  * Subject to your compliance with these terms, you may use Microchip software
27:                  * and any derivatives exclusively with Microchip products. It is your
28:                  * responsibility to comply with third party license terms applicable to your
29:                  * use of third party software (including open source software) that may
30:                  * accompany Microchip software.
31:                  *
32:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
33:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
34:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
35:                  * PARTICULAR PURPOSE.
36:                  *
37:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
38:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
39:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER SOURCED, EVEN IF MICROCHIP HAS
40:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
41:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
42:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
43:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
44:                  *******************************************************************************/
45:                  // DOM-IGNORE-END
46:                  
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  // Section: Included Files
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  
53:                  #include "plib_power.h"
54:                  
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  // Section: Power Implementation
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  void POWER_Initialize( void )
61:                  {
62:                      /* Unlock system */
63:                      SYSKEY = 0x00000000;
64:                      SYSKEY = 0xAA996655;
65:                      SYSKEY = 0x556699AA;
66:                  
67:                      DSCON = 0x1100;
68:                      DSCON = 0x1100;
69:                  
70:                      /* Lock system */
71:                      SYSKEY = 0;
72:                  }
73:                  void POWER_LowPowerModeEnter (POWER_LOW_POWER_MODE mode)
74:                  {
75:                      /* Unlock system */
76:                      SYSKEY = 0x00000000;
77:                      SYSKEY = 0xAA996655;
78:                      SYSKEY = 0x556699AA;
79:                  
80:                      switch(mode)
81:                      {
82:                          case LOW_POWER_IDLE_MODE:
83:                                          OSCCONCLR = _OSCCON_SLPEN_MASK;
84:                                          break;
85:                          case LOW_POWER_SLEEP_MODE:
86:                                          OSCCONSET = _OSCCON_SLPEN_MASK;
87:                                          break;
88:                          case LOW_POWER_DREAM_MODE:
89:                                          OSCCONSET = _OSCCON_SLPEN_MASK | _OSCCON_DRMEN_MASK;
90:                                          break;
91:                          case LOW_POWER_DEEP_SLEEP_MODE:
92:                                          OSCCONSET = _OSCCON_SLPEN_MASK;
93:                                          DSCONbits.DSEN = 1;
94:                                          DSCONbits.DSEN = 1;
95:                                          break;
96:                          default:
97:                                          return;
98:                      }
99:                  
100:                     /* Lock system */
101:                     SYSKEY = 0x0;
102:                 
103:                     /* enter into selected low power mode */
104:                     asm volatile("wait");
105:                 }
106:                 
107:                 POWER_DS_WAKEUP_SOURCE POWER_DS_WakeupSourceGet( void )
108:                 {
109:                     return (POWER_DS_WAKEUP_SOURCE)(DSWAKE);
110:                 }
111:                 
112:                 void POWER_DS_ReleaseGPIO(void)
113:                 {
114:                     /* Unlock system */
115:                     SYSKEY = 0x00000000;
116:                     SYSKEY = 0xAA996655;
117:                     SYSKEY = 0x556699AA;
118:                 
119:                     DSCONbits.RELEASE = 0;
120:                     DSCONbits.RELEASE = 0;
121:                 
122:                     /* Lock system */
123:                     SYSKEY = 0;
124:                 }
125:                 
126:                 void POWER_DS_WakeupSourceClear( POWER_DS_WAKEUP_SOURCE wakeupSource )
127:                 {
128:                     DSWAKE &= ~wakeupSource;
129:                 }
130:                 
131:                 void POWER_DS_GPR_Enable(void)
132:                 {
133:                     /* Unlock system */
134:                     SYSKEY = 0x00000000;
135:                     SYSKEY = 0xAA996655;
136:                     SYSKEY = 0x556699AA;
137:                 
138:                     DSCONbits.DSGPREN = 1;
139:                     DSCONbits.DSGPREN = 1;
140:                 
141:                     /* Lock system */
142:                     SYSKEY = 0x00000000;
143:                 }
144:                 void POWER_DS_GPR_Disable(void)
145:                 {
146:                     /* Unlock system */
147:                     SYSKEY = 0x00000000;
148:                     SYSKEY = 0xAA996655;
149:                     SYSKEY = 0x556699AA;
150:                 
151:                     DSCONbits.DSGPREN = 0;
152:                     DSCONbits.DSGPREN = 0;
153:                 
154:                     /* Lock system */
155:                     SYSKEY = 0x00000000;
156:                 }
157:                 void POWER_DS_RTCC_Enable(void)
158:                 {
159:                     /* Unlock system */
160:                     SYSKEY = 0x00000000;
161:                     SYSKEY = 0xAA996655;
162:                     SYSKEY = 0x556699AA;
163:                 
164:                     DSCONbits.RTCDIS = 0;
165:                     DSCONbits.RTCDIS = 0;
166:                 
167:                     /* Lock system */
168:                     SYSKEY = 0x00000000;
169:                 }
170:                 void POWER_DS_RTCC_Disable(void)
171:                 {
172:                     /* Unlock system */
173:                     SYSKEY = 0x00000000;
174:                     SYSKEY = 0xAA996655;
175:                     SYSKEY = 0x556699AA;
176:                 
177:                     DSCONbits.RTCDIS = 1;
178:                     DSCONbits.RTCDIS = 1;
179:                 
180:                     /* Lock system */
181:                     SYSKEY = 0x00000000;
182:                 }
183:                 void POWER_DS_RTCC_WakeupEnable(void)
184:                 {
185:                     /* Unlock system */
186:                     SYSKEY = 0x00000000;
187:                     SYSKEY = 0xAA996655;
188:                     SYSKEY = 0x556699AA;
189:                 
190:                     DSCONbits.RTCCWDIS = 0;
191:                     DSCONbits.RTCCWDIS = 0;
192:                 
193:                     /* Lock system */
194:                     SYSKEY = 0x00000000;
195:                 }
196:                 void POWER_DS_RTCC_WakeupDisable(void)
197:                 {
198:                     /* Unlock system */
199:                     SYSKEY = 0x00000000;
200:                     SYSKEY = 0xAA996655;
201:                     SYSKEY = 0x556699AA;
202:                 
203:                     DSCONbits.RTCCWDIS = 1;
204:                     DSCONbits.RTCCWDIS = 1;
205:                 
206:                     /* Lock system */
207:                     SYSKEY = 0x00000000;
208:                 }
209:                 
210:                 void POWER_DS_GPR_Write(POWER_DS_GPR gprNumb, uint32_t gprValue)
211:                 {
212:                     /* Unlock system */
213:                     SYSKEY = 0x00000000;
214:                     SYSKEY = 0xAA996655;
215:                     SYSKEY = 0x556699AA;
216:                 
217:                     if (gprNumb == POWER_DS_GPR0)
218:                     {
219:                         DSGPR0 = gprValue;
220:                         DSGPR0 = gprValue;
221:                     }
222:                     else
223:                     {
224:                         *((volatile uint32_t *)(&DSGPR1)+ gprNumb-1) = gprValue;
225:                         *((volatile uint32_t *)(&DSGPR1)+ gprNumb-1) = gprValue;
226:                     }
227:                 
228:                     /* Lock system */
229:                     SYSKEY = 0x00000000;
230:                 }
231:                 
232:                 uint32_t POWER_DS_GPR_Read(POWER_DS_GPR gprNumb)
233:                 {
234:                     if (gprNumb == POWER_DS_GPR0)
235:                     {
236:                         return DSGPR0;
237:                     }
238:                     else
239:                     {
240:                         return (*((volatile uint32_t *)(&DSGPR1)+ gprNumb-1));
241:                     }
242:                 }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
00000024  00000000   NOP
00000028  00000000   NOP
0000002C  00000000   NOP
00000030  00000000   NOP
00000034  00000000   NOP
00000038  00000000   NOP
0000003C  00000000   NOP
00000040  00000000   NOP
00000044  00000000   NOP
00000048  00000000   NOP
00000050  00000000   NOP
00000054  00000000   NOP
00000058  00000000   NOP
0000005C  00000000   NOP
00000064  00000000   NOP
00000068  00000000   NOP
0000006C  00000000   NOP
00000074  00000000   NOP
00000078  00000000   NOP
0000007C  00000000   NOP
00000080  00000000   NOP
00000088  00000000   NOP
00000094  00000000   NOP
00000098  00000000   NOP
0000009C  00000000   NOP
000000A4  00000000   NOP
000000AC  00000000   NOP
000000B0  00000000   NOP
000000B4  00000000   NOP
9D0185D4  3C03AA99   LUI V1, -21863
9D0185D8  3C02BF81   LUI V0, -16511
9D0185DC  24636655   ADDIU V1, V1, 26197
9D0185E0  AC40F230   SW ZERO, -3536(V0)
9D0185E4  AC43F230   SW V1, -3536(V0)
9D0185E8  3C035566   LUI V1, 21862
9D0185EC  3C04BF80   LUI A0, -16512
9D0185F0  24051100   ADDIU A1, ZERO, 4352
9D0185F4  346399AA   ORI V1, V1, -26198
9D0185F8  AC43F230   SW V1, -3536(V0)
9D0185FC  AC850000   SW A1, 0(A0)
9D018600  AC850000   SW A1, 0(A0)
9D018604  AC40F230   SW ZERO, -3536(V0)
9D018608  03E00008   JR RA
9D01860C  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/peripheral/nvm/plib_nvm.c  -----------------
1:                   /*******************************************************************************
2:                     Non-Volatile Memory Controller(NVM) PLIB.
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_nvm.c
9:                   
10:                    Summary:
11:                      Interface definition of NVM Plib.
12:                  
13:                    Description:
14:                      This file defines the interface for the NVM Plib.
15:                      It allows user to Program, Erase and lock the on-chip Non Volatile Flash
16:                      Memory.
17:                  *******************************************************************************/
18:                  
19:                  // DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
22:                  *
23:                  * Subject to your compliance with these terms, you may use Microchip software
24:                  * and any derivatives exclusively with Microchip products. It is your
25:                  * responsibility to comply with third party license terms applicable to your
26:                  * use of third party software (including open source software) that may
27:                  * accompany Microchip software.
28:                  *
29:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
31:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
32:                  * PARTICULAR PURPOSE.
33:                  *
34:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                  *******************************************************************************/
42:                  // DOM-IGNORE-END
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Section: Included Files
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  
50:                  #include <string.h>
51:                  #include "sys/kmem.h"
52:                  #include "plib_nvm.h"
53:                  
54:                  /* ************************************************************************** */
55:                  /* ************************************************************************** */
56:                  /* Section: File Scope or Global Data                                         */
57:                  /* ************************************************************************** */
58:                  /* ************************************************************************** */
59:                  // *****************************************************************************
60:                  
61:                  /*******************************************
62:                   * Internal operation type
63:                   ******************************************/
64:                  typedef enum
65:                  {
66:                      PROGRAM_ERASE_OPERATION         = 0x5,
67:                      PAGE_ERASE_OPERATION            = 0x4,
68:                      ROW_PROGRAM_OPERATION           = 0x3,
69:                      WORD_PROGRAM_OPERATION          = 0x1,
70:                      NO_OPERATION                    = 0x0,
71:                  } NVM_OPERATION_MODE;
72:                  
73:                  /*******************************************
74:                   * Internal Flash Programming Unlock Keys
75:                   ******************************************/
76:                  typedef enum
77:                  {
78:                      NVM_UNLOCK_KEY1 = 0xAA996655,
79:                      NVM_UNLOCK_KEY2 = 0x556699AA
80:                  } NVM_UNLOCK_KEYS;
81:                  
82:                  #define NVM_INTERRUPT_ENABLE_MASK   0x80000000L
83:                  #define NVM_INTERRUPT_FLAG_MASK     0x80000000L
84:                  
85:                  /* ************************************************************************** */
86:                  /* ************************************************************************** */
87:                  // Section: Local Functions                                                   */
88:                  /* ************************************************************************** */
89:                  /* ************************************************************************** */
90:                  
91:                  // *****************************************************************************
92:                  // *****************************************************************************
93:                  // Section: NVM Implementation
94:                  // *****************************************************************************
95:                  // *****************************************************************************
96:                  
97:                  NVM_CALLBACK nvmCallbackFunc;
98:                  
99:                  uintptr_t nvmContext;
100:                 
101:                 void NVM_CallbackRegister( NVM_CALLBACK callback, uintptr_t context )
102:                 {
103:                     /* Register callback function */
104:                     nvmCallbackFunc    = callback;
105:                     nvmContext         = context;
106:                 }
107:                 
108:                 void NVM_InterruptHandler( void )
109:                 {
110:                     IFS0CLR = NVM_INTERRUPT_FLAG_MASK;
111:                 
112:                     if(nvmCallbackFunc != NULL)
113:                     {
114:                         nvmCallbackFunc(nvmContext);
115:                     }
116:                 }
117:                 
118:                 static void NVM_StartOperationAtAddress( uint32_t address,  NVM_OPERATION_MODE operation )
119:                 {
120:                     volatile uint32_t processorStatus;
121:                 
122:                     processorStatus = __builtin_disable_interrupts();
123:                 
124:                     // Set the target Flash address to be operated on (destination).
125:                     NVMADDR = KVA_TO_PA(address);
126:                 
127:                     // NVMOP can be written only when WREN is zero. So, clear WREN.
128:                     NVMCONCLR = _NVMCON_WREN_MASK;
129:                 
130:                     NVMCONCLR = _NVMCON_NVMOP_MASK;
131:                     NVMCONSET = ( _NVMCON_NVMOP_MASK & (((uint32_t)operation) << _NVMCON_NVMOP_POSITION) );
132:                 
133:                     // Set WREN to enable writes to the WR bit and to prevent NVMOP modification
134:                     NVMCONSET = _NVMCON_WREN_MASK;
135:                 
136:                     // Write the unlock key sequence
137:                     NVMKEY = 0x0;
138:                     NVMKEY = NVM_UNLOCK_KEY1;
139:                     NVMKEY = NVM_UNLOCK_KEY2;
140:                 
141:                     // Start the operation
142:                     NVMCONSET = _NVMCON_WR_MASK;
143:                 
144:                     __builtin_mtc0(12, 0, processorStatus);
145:                 
146:                     IEC0SET   = NVM_INTERRUPT_ENABLE_MASK;
147:                 }
148:                 
149:                 /* ************************************************************************** */
150:                 /* ************************************************************************** */
151:                 // Section: Interface Functions                                               */
152:                 /* ************************************************************************** */
153:                 /* ************************************************************************** */
154:                 
155:                 void NVM_Initialize( void )
156:                 {
157:                     NVM_StartOperationAtAddress( NVMADDR,  NO_OPERATION );
158:                 }
159:                 
160:                 bool NVM_Read( uint32_t *data, uint32_t length, const uint32_t address )
161:                 {
162:                     memcpy((void *)data, (void *)KVA0_TO_KVA1(address), length);
163:                 
164:                     return true;
165:                 }
166:                 
167:                 bool NVM_WordWrite( uint32_t data, uint32_t address )
168:                 {
169:                     NVMDATA = (uint32_t )data;
170:                 
171:                     NVM_StartOperationAtAddress( address,  WORD_PROGRAM_OPERATION);
172:                 
173:                     return true;
174:                 }
175:                 
176:                 bool NVM_RowWrite( uint32_t *data, uint32_t address )
177:                 {
178:                    NVMSRCADDR = (uint32_t )KVA_TO_PA(data);
179:                 
180:                    NVM_StartOperationAtAddress( address,  ROW_PROGRAM_OPERATION);
181:                 
182:                    return true;
183:                 }
184:                 
185:                 bool NVM_PageErase( uint32_t address )
186:                 {
187:                    NVM_StartOperationAtAddress(address,  PAGE_ERASE_OPERATION);
188:                 
189:                    return true;
190:                 }
191:                 
192:                 NVM_ERROR NVM_ErrorGet( void )
193:                 {
194:                     // mask for WRERR and LVDERR bits
195:                     return (NVMCON & (_NVMCON_LVDERR_MASK | _NVMCON_WRERR_MASK));
196:                 }
197:                 
198:                 bool NVM_IsBusy( void )
199:                 {
200:                     return (bool)NVMCONbits.WR;
201:                 }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
00000024  00000000   NOP
00000028  00000000   NOP
0000002C  00000000   NOP
00000030  00000000   NOP
00000034  00000000   NOP
00000038  00000000   NOP
0000003C  00000000   NOP
00000040  00000000   NOP
00000044  00000000   NOP
00000048  00000000   NOP
0000004C  00000000   NOP
00000050  00000000   NOP
00000054  00000000   NOP
00000058  00000000   NOP
0000005C  00000000   NOP
00000060  00000000   NOP
00000064  00000000   NOP
00000068  00000000   NOP
0000006C  00000000   NOP
00000070  00000000   NOP
00000074  00000000   NOP
00000078  00000000   NOP
0000007C  00000000   NOP
00000080  00000000   NOP
00000084  00000000   NOP
9D017358  3C02BF81   LUI V0, -16511
9D01735C  8C43F420   LW V1, -3040(V0)
9D017360  27BDFFF0   ADDIU SP, SP, -16
9D017364  AFBF000C   SW RA, 12(SP)
9D017368  41656000   DI A1
9D01736C  000000C0   EHB
9D017370  7C63E000   EXT V1, V1, 0, 29
9D017374  AFA50000   SW A1, 0(SP)
9D017378  24044000   ADDIU A0, ZERO, 16384
9D01737C  AC43F420   SW V1, -3040(V0)
9D017380  2403000F   ADDIU V1, ZERO, 15
9D017384  AC44F404   SW A0, -3068(V0)
9D017388  AC43F404   SW V1, -3068(V0)
9D01738C  3C03AA99   LUI V1, -21863
9D017390  24636655   ADDIU V1, V1, 26197
9D017394  AC40F408   SW ZERO, -3064(V0)
9D017398  AC44F408   SW A0, -3064(V0)
9D01739C  AC40F410   SW ZERO, -3056(V0)
9D0173A0  AC43F410   SW V1, -3056(V0)
9D0173A4  3C035566   LUI V1, 21862
9D0173A8  346399AA   ORI V1, V1, -26198
9D0173AC  AC43F410   SW V1, -3056(V0)
9D0173B0  34038000   ORI V1, ZERO, -32768
9D0173B4  AC43F408   SW V1, -3064(V0)
9D0173B8  8FA20000   LW V0, 0(SP)
9D0173BC  40826000   MTC0 V0, Status
9D0173C0  000000C0   EHB
9D0173C4  8FBF000C   LW RA, 12(SP)
9D0173C8  3C02BF88   LUI V0, -16504
9D0173CC  3C038000   LUI V1, -32768
9D0173D0  AC431068   SW V1, 4200(V0)
9D0173D4  03E00008   JR RA
9D0173D8  27BD0010   ADDIU SP, SP, 16
9D018CBC  8F998018   LW T9, -32744(GP)
9D018CC0  3C02BF88   LUI V0, -16504
9D018CC4  3C038000   LUI V1, -32768
9D018CC8  AC431034   SW V1, 4148(V0)
9D018CCC  13200003   BEQ T9, ZERO, 0x9D018CDC
9D018CD0  00000000   NOP
9D018CD4  03200008   JR T9
9D018CD8  8F848014   LW A0, -32748(GP)
9D018CDC  03E00008   JR RA
9D018CE0  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/peripheral/gpio/plib_gpio.c  ---------------
1:                   /*******************************************************************************
2:                     SYS PORTS Static Functions for PORTS System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_gpio.c
9:                   
10:                    Summary:
11:                      GPIO function implementations for the GPIO PLIB.
12:                  
13:                    Description:
14:                      The GPIO PLIB provides a simple interface to manage peripheral
15:                      input-output controller.
16:                  
17:                  *******************************************************************************/
18:                  
19:                  //DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
22:                  *
23:                  * Subject to your compliance with these terms, you may use Microchip software
24:                  * and any derivatives exclusively with Microchip products. It is your
25:                  * responsibility to comply with third party license terms applicable to your
26:                  * use of third party software (including open source software) that may
27:                  * accompany Microchip software.
28:                  *
29:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
31:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
32:                  * PARTICULAR PURPOSE.
33:                  *
34:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                  *******************************************************************************/
42:                  //DOM-IGNORE-END
43:                  
44:                  #include "plib_gpio.h"
45:                  
46:                  
47:                  
48:                  /******************************************************************************
49:                    Function:
50:                      GPIO_Initialize ( void )
51:                  
52:                    Summary:
53:                      Initialize the GPIO library.
54:                  
55:                    Remarks:
56:                      See plib_gpio.h for more details.
57:                  */
58:                  void GPIO_Initialize ( void )
59:                  {
60:                      /* PORTA Initialization */
61:                      LATA = 0x400; /* Initial Latch Value */
62:                      TRISACLR = 0x410; /* Direction Control */
63:                      CNPUASET = 0x80; /* Pull-Up Enable */
64:                      CNPDASET = 0x200; /* Pull-Down Enable */
65:                  
66:                      /* PORTB Initialization */
67:                      ANSELBCLR = 0x4000; /* Digital Mode Enable */
68:                  
69:                      /* PORTC Initialization */
70:                      LATC = 0x60; /* Initial Latch Value */
71:                      TRISCCLR = 0x74; /* Direction Control */
72:                      ANSELCCLR = 0xd; /* Digital Mode Enable */
73:                  
74:                  
75:                  
76:                      /* PPS Input Remapping */
77:                      SDI1R = 7;
78:                      U1CTSR = 5;
79:                      U1RXR = 2;
80:                      U2RXR = 6;
81:                  
82:                      /* PPS Output Remapping */
83:                      RPA3R = 1;
84:                      RPC0R = 1;
85:                      RPC3R = 3;
86:                      RPB9R = 2;
87:                  
88:                  
89:                  }
90:                  
91:                  // *****************************************************************************
92:                  // *****************************************************************************
93:                  // Section: GPIO APIs which operates on multiple pins of a port
94:                  // *****************************************************************************
95:                  // *****************************************************************************
96:                  
97:                  // *****************************************************************************
98:                  /* Function:
99:                      uint32_t GPIO_PortRead ( GPIO_PORT port )
100:                 
101:                   Summary:
102:                     Read all the I/O lines of the selected port.
103:                 
104:                   Description:
105:                     This function reads the live data values on all the I/O lines of the
106:                     selected port.  Bit values returned in each position indicate corresponding
107:                     pin levels.
108:                     1 = Pin is high.
109:                     0 = Pin is low.
110:                 
111:                     This function reads the value regardless of pin configuration, whether it is
112:                     set as as an input, driven by the GPIO Controller, or driven by a peripheral.
113:                 
114:                   Remarks:
115:                     If the port has less than 32-bits, unimplemented pins will read as
116:                     low (0).
117:                     Implemented pins are Right aligned in the 32-bit return value.
118:                 */
119:                 uint32_t GPIO_PortRead(GPIO_PORT port)
120:                 {
121:                     return (*(volatile uint32_t *)(&PORTA + (port * 0x40)));
122:                 }
123:                 
124:                 // *****************************************************************************
125:                 /* Function:
126:                     void GPIO_PortWrite (GPIO_PORT port, uint32_t mask, uint32_t value);
127:                 
128:                   Summary:
129:                     Write the value on the masked I/O lines of the selected port.
130:                 
131:                   Remarks:
132:                     See plib_gpio.h for more details.
133:                 */
134:                 void GPIO_PortWrite(GPIO_PORT port, uint32_t mask, uint32_t value)
135:                 {
136:                     *(volatile uint32_t *)(&LATA + (port * 0x40)) = (*(volatile uint32_t *)(&LATA + (port * 0x40)) & (~mask)) | (mask & value);
137:                 }
138:                 
139:                 // *****************************************************************************
140:                 /* Function:
141:                     uint32_t GPIO_PortLatchRead ( GPIO_PORT port )
142:                 
143:                   Summary:
144:                     Read the latched value on all the I/O lines of the selected port.
145:                 
146:                   Remarks:
147:                     See plib_gpio.h for more details.
148:                 */
149:                 uint32_t GPIO_PortLatchRead(GPIO_PORT port)
150:                 {
151:                     return (*(volatile uint32_t *)(&LATA + (port * 0x40)));
152:                 }
153:                 
154:                 // *****************************************************************************
155:                 /* Function:
156:                     void GPIO_PortSet ( GPIO_PORT port, uint32_t mask )
157:                 
158:                   Summary:
159:                     Set the selected IO pins of a port.
160:                 
161:                   Remarks:
162:                     See plib_gpio.h for more details.
163:                 */
164:                 void GPIO_PortSet(GPIO_PORT port, uint32_t mask)
165:                 {
166:                     *(volatile uint32_t *)(&LATASET + (port * 0x40)) = mask;
167:                 }
168:                 
169:                 // *****************************************************************************
170:                 /* Function:
171:                     void GPIO_PortClear ( GPIO_PORT port, uint32_t mask )
172:                 
173:                   Summary:
174:                     Clear the selected IO pins of a port.
175:                 
176:                   Remarks:
177:                     See plib_gpio.h for more details.
178:                 */
179:                 void GPIO_PortClear(GPIO_PORT port, uint32_t mask)
180:                 {
181:                     *(volatile uint32_t *)(&LATACLR + (port * 0x40)) = mask;
182:                 }
183:                 
184:                 // *****************************************************************************
185:                 /* Function:
186:                     void GPIO_PortToggle ( GPIO_PORT port, uint32_t mask )
187:                 
188:                   Summary:
189:                     Toggles the selected IO pins of a port.
190:                 
191:                   Remarks:
192:                     See plib_gpio.h for more details.
193:                 */
194:                 void GPIO_PortToggle(GPIO_PORT port, uint32_t mask)
195:                 {
196:                     *(volatile uint32_t *)(&LATAINV + (port * 0x40))= mask;
197:                 }
198:                 
199:                 // *****************************************************************************
200:                 /* Function:
201:                     void GPIO_PortInputEnable ( GPIO_PORT port, uint32_t mask )
202:                 
203:                   Summary:
204:                     Enables selected IO pins of a port as input.
205:                 
206:                   Remarks:
207:                     See plib_gpio.h for more details.
208:                 */
209:                 void GPIO_PortInputEnable(GPIO_PORT port, uint32_t mask)
210:                 {
211:                     *(volatile uint32_t *)(&TRISASET + (port * 0x40)) = mask;
212:                 }
213:                 
214:                 // *****************************************************************************
215:                 /* Function:
216:                     void GPIO_PortOutputEnable ( GPIO_PORT port, uint32_t mask )
217:                 
218:                   Summary:
219:                     Enables selected IO pins of a port as output(s).
220:                 
221:                   Remarks:
222:                     See plib_gpio.h for more details.
223:                 */
224:                 void GPIO_PortOutputEnable(GPIO_PORT port, uint32_t mask)
225:                 {
226:                     *(volatile uint32_t *)(&TRISACLR + (port * 0x40)) = mask;
227:                 }
228:                 
229:                 
230:                 
231:                 
232:                 /*******************************************************************************
233:                  End of File
234:                 */
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
00000024  00000000   NOP
9D0172D0  3C03BF88   LUI V1, -16504
9D0172D4  24060400   ADDIU A2, ZERO, 1024
9D0172D8  AC666030   SW A2, 24624(V1)
9D0172DC  24060410   ADDIU A2, ZERO, 1040
9D0172E0  AC666014   SW A2, 24596(V1)
9D0172E4  24060080   ADDIU A2, ZERO, 128
9D0172E8  AC666058   SW A2, 24664(V1)
9D0172EC  24060200   ADDIU A2, ZERO, 512
9D0172F0  AC666068   SW A2, 24680(V1)
9D0172F4  24064000   ADDIU A2, ZERO, 16384
9D0172F8  AC666104   SW A2, 24836(V1)
9D0172FC  24060060   ADDIU A2, ZERO, 96
9D017300  AC666230   SW A2, 25136(V1)
9D017304  24060074   ADDIU A2, ZERO, 116
9D017308  AC666214   SW A2, 25108(V1)
9D01730C  2406000D   ADDIU A2, ZERO, 13
9D017310  AC666204   SW A2, 25092(V1)
9D017314  3C02BF81   LUI V0, -16511
9D017318  24030007   ADDIU V1, ZERO, 7
9D01731C  AC43FA84   SW V1, -1404(V0)
9D017320  24030005   ADDIU V1, ZERO, 5
9D017324  AC43FA54   SW V1, -1452(V0)
9D017328  24040002   ADDIU A0, ZERO, 2
9D01732C  24030006   ADDIU V1, ZERO, 6
9D017330  AC44FA50   SW A0, -1456(V0)
9D017334  24050001   ADDIU A1, ZERO, 1
9D017338  AC43FA58   SW V1, -1448(V0)
9D01733C  24030003   ADDIU V1, ZERO, 3
9D017340  AC45FB0C   SW A1, -1268(V0)
9D017344  AC45FB6C   SW A1, -1172(V0)
9D017348  AC43FB78   SW V1, -1160(V0)
9D01734C  AC44FB50   SW A0, -1200(V0)
9D017350  03E00008   JR RA
9D017354  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/peripheral/evic/plib_evic.c  ---------------
1:                   /*******************************************************************************
2:                     EVIC PLIB Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_evic.c
9:                   
10:                    Summary:
11:                      EVIC PLIB Source File
12:                  
13:                    Description:
14:                      None
15:                  
16:                  *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
21:                  *
22:                  * Subject to your compliance with these terms, you may use Microchip software
23:                  * and any derivatives exclusively with Microchip products. It is your
24:                  * responsibility to comply with third party license terms applicable to your
25:                  * use of third party software (including open source software) that may
26:                  * accompany Microchip software.
27:                  *
28:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                  * PARTICULAR PURPOSE.
32:                  *
33:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                  *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  #include "device.h"
44:                  #include "plib_evic.h"
45:                  
46:                  
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  // Section: IRQ Implementation
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  
53:                  void EVIC_Initialize( void )
54:                  {
55:                      INTCONSET = _INTCON_MVEC_MASK;
56:                  
57:                      /* Set up priority and subpriority of enabled interrupts */
58:                      IPC0SET = 0x4 | 0x0;  /* CORE_TIMER:  Priority 1 / Subpriority 0 */
59:                      IPC3SET = 0x4 | 0x0;  /* TIMER_3:  Priority 1 / Subpriority 0 */
60:                      IPC6SET = 0x40000 | 0x0;  /* FCE:  Priority 1 / Subpriority 0 */
61:                      IPC7SET = 0x40000 | 0x0;  /* USB_1:  Priority 1 / Subpriority 0 */
62:                      IPC8SET = 0x4 | 0x0;  /* UART_1:  Priority 1 / Subpriority 0 */
63:                      IPC9SET = 0x400 | 0x0;  /* UART_2:  Priority 1 / Subpriority 0 */
64:                  
65:                  
66:                  }
67:                  
68:                  void EVIC_SourceEnable( INT_SOURCE source )
69:                  {
70:                      volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
71:                      volatile uint32_t *IECxSET = (volatile uint32_t *)(IECx + 2);
72:                  
73:                      *IECxSET = 1 << (source & 0x1f);
74:                  }
75:                  
76:                  void EVIC_SourceDisable( INT_SOURCE source )
77:                  {
78:                      volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
79:                      volatile uint32_t *IECxCLR = (volatile uint32_t *)(IECx + 1);
80:                  
81:                      *IECxCLR = 1 << (source & 0x1f);
82:                  }
83:                  
84:                  bool EVIC_SourceIsEnabled( INT_SOURCE source )
85:                  {
86:                      volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
87:                  
88:                      return (bool)((*IECx >> (source & 0x1f)) & 0x01);
89:                  }
90:                  
91:                  bool EVIC_SourceStatusGet( INT_SOURCE source )
92:                  {
93:                      volatile uint32_t *IFSx = (volatile uint32_t *)(&IFS0 + ((0x10 * (source / 32)) / 4));
94:                  
95:                      return (bool)((*IFSx >> (source & 0x1f)) & 0x1);
96:                  }
97:                  
98:                  void EVIC_SourceStatusSet( INT_SOURCE source )
99:                  {
100:                     volatile uint32_t *IFSx = (volatile uint32_t *) (&IFS0 + ((0x10 * (source / 32)) / 4));
101:                     volatile uint32_t *IFSxSET = (volatile uint32_t *)(IFSx + 2);
102:                 
103:                     *IFSxSET = 1 << (source & 0x1f);
104:                 }
105:                 
106:                 void EVIC_SourceStatusClear( INT_SOURCE source )
107:                 {
108:                     volatile uint32_t *IFSx = (volatile uint32_t *) (&IFS0 + ((0x10 * (source / 32)) / 4));
109:                     volatile uint32_t *IFSxCLR = (volatile uint32_t *)(IFSx + 1);
110:                 
111:                     *IFSxCLR = 1 << (source & 0x1f);
112:                 }
113:                 
114:                 void EVIC_INT_Enable( void )
115:                 {
116:                     __builtin_enable_interrupts();
117:                 }
118:                 
119:                 bool EVIC_INT_Disable( void )
120:                 {
121:                     uint32_t processorStatus;
122:                 
123:                     /* Save the processor status and then Disable the global interrupt */
124:                     processorStatus = ( uint32_t )__builtin_disable_interrupts();
125:                 
126:                     /* return the interrupt status */
127:                     return (bool)(processorStatus & 0x01);
128:                 }
129:                 
130:                 void EVIC_INT_Restore( bool state )
131:                 {
132:                     if (state)
133:                     {
134:                         /* restore the state of CP0 Status register before the disable occurred */
135:                         __builtin_enable_interrupts();
136:                     }
137:                 }
138:                 
139:                 
140:                 /* End of file */
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
9D018700  3C02BF88   LUI V0, -16504
9D018704  24030004   ADDIU V1, ZERO, 4
9D018708  3C040004   LUI A0, 4
9D01870C  24051000   ADDIU A1, ZERO, 4096
9D018710  AC451008   SW A1, 4104(V0)
9D018714  AC431098   SW V1, 4248(V0)
9D018718  AC4310C8   SW V1, 4296(V0)
9D01871C  AC4410F8   SW A0, 4344(V0)
9D018720  AC441108   SW A0, 4360(V0)
9D018724  AC431118   SW V1, 4376(V0)
9D018728  24030400   ADDIU V1, ZERO, 1024
9D01872C  AC431128   SW V1, 4392(V0)
9D018730  03E00008   JR RA
9D018734  00000000   NOP
9D018C1C  00041142   SRL V0, A0, 5
9D018C20  00022900   SLL A1, V0, 4
9D018C24  3C02BF88   LUI V0, -16504
9D018C28  24421060   ADDIU V0, V0, 4192
9D018C2C  24030001   ADDIU V1, ZERO, 1
9D018C30  00451021   ADDU V0, V0, A1
9D018C34  00831804   SLLV V1, V1, A0
9D018C38  AC430008   SW V1, 8(V0)
9D018C3C  03E00008   JR RA
9D018C40  00000000   NOP
9D018C44  00041142   SRL V0, A0, 5
9D018C48  00022900   SLL A1, V0, 4
9D018C4C  3C02BF88   LUI V0, -16504
9D018C50  24421060   ADDIU V0, V0, 4192
9D018C54  24030001   ADDIU V1, ZERO, 1
9D018C58  00451021   ADDU V0, V0, A1
9D018C5C  00831804   SLLV V1, V1, A0
9D018C60  AC430004   SW V1, 4(V0)
9D018C64  03E00008   JR RA
9D018C68  00000000   NOP
9D018C6C  00041142   SRL V0, A0, 5
9D018C70  00022900   SLL A1, V0, 4
9D018C74  3C02BF88   LUI V0, -16504
9D018C78  24421030   ADDIU V0, V0, 4144
9D018C7C  24030001   ADDIU V1, ZERO, 1
9D018C80  00451021   ADDU V0, V0, A1
9D018C84  00831804   SLLV V1, V1, A0
9D018C88  AC430004   SW V1, 4(V0)
9D018C8C  03E00008   JR RA
9D018C90  00000000   NOP
9D018C94  10800007   BEQ A0, ZERO, 0x9D018CB4
9D018C98  00000000   NOP
9D018C9C  27BDFFF8   ADDIU SP, SP, -8
9D018CA0  AFBF0004   SW RA, 4(SP)
9D018CA4  41626020   EI V0
9D018CA8  8FBF0004   LW RA, 4(SP)
9D018CAC  03E00008   JR RA
9D018CB0  27BD0008   ADDIU SP, SP, 8
9D018CB4  03E00008   JR RA
9D018CB8  00000000   NOP
9D018E00  00041942   SRL V1, A0, 5
9D018E04  00032900   SLL A1, V1, 4
9D018E08  3C03BF88   LUI V1, -16504
9D018E0C  24631060   ADDIU V1, V1, 4192
9D018E10  00651821   ADDU V1, V1, A1
9D018E14  8C620000   LW V0, 0(V1)
9D018E18  00821006   SRLV V0, V0, A0
9D018E1C  03E00008   JR RA
9D018E20  30420001   ANDI V0, V0, 1
9D018E24  27BDFFF8   ADDIU SP, SP, -8
9D018E28  AFBF0004   SW RA, 4(SP)
9D018E2C  41626000   DI V0
9D018E30  000000C0   EHB
9D018E34  8FBF0004   LW RA, 4(SP)
9D018E38  30420001   ANDI V0, V0, 1
9D018E3C  03E00008   JR RA
9D018E40  27BD0008   ADDIU SP, SP, 8
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/peripheral/coretimer/plib_coretimer.c  -----
1:                   /*******************************************************************************
2:                     Core Timer Peripheral Library
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_coretimer.c
9:                   
10:                    Summary:
11:                      Core timer Source File
12:                  
13:                    Description:
14:                      None
15:                  
16:                  *******************************************************************************/
17:                  
18:                  /*******************************************************************************
19:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
20:                  *
21:                  * Subject to your compliance with these terms, you may use Microchip software
22:                  * and any derivatives exclusively with Microchip products. It is your
23:                  * responsibility to comply with third party license terms applicable to your
24:                  * use of third party software (including open source software) that may
25:                  * accompany Microchip software.
26:                  *
27:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                  * PARTICULAR PURPOSE.
31:                  *
32:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
33:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
34:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
35:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
36:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
37:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
38:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
39:                  *******************************************************************************/
40:                  
41:                  #include "device.h"
42:                  #include "peripheral/coretimer/plib_coretimer.h"
43:                  
44:                  CORETIMER_OBJECT coreTmr;
45:                  void CORETIMER_Initialize()
46:                  {
47:                      // Disable Timer by setting Disable Count (DC) bit
48:                      _CP0_SET_CAUSE(_CP0_GET_CAUSE() | _CP0_CAUSE_DC_MASK);
49:                      coreTmr.period=CORE_TIMER_INTERRUPT_PERIOD_VALUE;
50:                      coreTmr.tickCounter = 0;
51:                      coreTmr.callback = NULL;
52:                  }
53:                  void CORETIMER_CallbackSet ( CORETIMER_CALLBACK callback, uintptr_t context )
54:                  {
55:                      coreTmr.callback = callback;
56:                      coreTmr.context = context;
57:                  }
58:                  void CORETIMER_PeriodSet ( uint32_t period )
59:                  {
60:                      coreTmr.period=period;
61:                  }
62:                  void CORETIMER_Start()
63:                  {
64:                      // Disable Timer by setting Disable Count (DC) bit
65:                      _CP0_SET_CAUSE(_CP0_GET_CAUSE() | _CP0_CAUSE_DC_MASK);
66:                      // Disable Interrupt
67:                      IEC0CLR=0x1;
68:                      // Clear Core Timer
69:                      _CP0_SET_COUNT(0);
70:                      _CP0_SET_COMPARE(coreTmr.period);
71:                      // Enable Timer by clearing Disable Count (DC) bit
72:                      _CP0_SET_CAUSE(_CP0_GET_CAUSE() & (~_CP0_CAUSE_DC_MASK));
73:                      // Enable Interrupt
74:                      IEC0SET=0x1;
75:                  }
76:                  void CORETIMER_Stop()
77:                  {
78:                      // Disable Timer by setting Disable Count (DC) bit
79:                      _CP0_SET_CAUSE(_CP0_GET_CAUSE() | _CP0_CAUSE_DC_MASK);
80:                      // Disable Interrupt
81:                      IEC0CLR=0x1;
82:                  }
83:                  uint32_t CORETIMER_FrequencyGet ( void )
84:                  {
85:                      return (CORE_TIMER_FREQUENCY);
86:                  }
87:                  void CORE_TIMER_InterruptHandler (void)
88:                  {
89:                      uint32_t count, newCompare;
90:                      uint32_t status = IFS0bits.CTIF;
91:                      IFS0CLR = 0x1;
92:                      // Start Critical Section
93:                      __builtin_disable_interrupts();
94:                      count=_CP0_GET_COUNT();
95:                      newCompare=_CP0_GET_COMPARE() + coreTmr.period;
96:                      if (count<newCompare-50)
97:                          _CP0_SET_COMPARE(newCompare);
98:                      else
99:                          _CP0_SET_COMPARE(count+50);
100:                     // End Critical Section
101:                     __builtin_enable_interrupts();
102:                     coreTmr.tickCounter++;
103:                     if(coreTmr.callback != NULL)
104:                     {
105:                         coreTmr.callback(status, coreTmr.context);
106:                     }
107:                 }
108:                 
109:                 
110:                 
111:                 void CORETIMER_DelayMs ( uint32_t delay_ms)
112:                 {
113:                     uint32_t startCount, endCount;
114:                 
115:                     /* Calculate the end count for the given delay */
116:                     endCount=(CORE_TIMER_FREQUENCY/1000)*delay_ms;
117:                 
118:                     startCount=_CP0_GET_COUNT();
119:                     while((_CP0_GET_COUNT()-startCount)<endCount);
120:                 
121:                 }
122:                 
123:                 void CORETIMER_DelayUs ( uint32_t delay_us)
124:                 {
125:                     uint32_t startCount, endCount;
126:                 
127:                     /* Calculate the end count for the given delay */
128:                     endCount=(CORE_TIMER_FREQUENCY/1000000)*delay_us;
129:                 
130:                     startCount=_CP0_GET_COUNT();
131:                     while((_CP0_GET_COUNT()-startCount)<endCount);
132:                 
133:                 }
134:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
0000002C  00000000   NOP
9D016A04  3C02BF88   LUI V0, -16504
9D016A08  8C441030   LW A0, 4144(V0)
9D016A0C  27BDFFF8   ADDIU SP, SP, -8
9D016A10  24030001   ADDIU V1, ZERO, 1
9D016A14  30840001   ANDI A0, A0, 1
9D016A18  AFBF0004   SW RA, 4(SP)
9D016A1C  AC431034   SW V1, 4148(V0)
9D016A20  41626000   DI V0
9D016A24  000000C0   EHB
9D016A28  40064800   MFC0 A2, Count
9D016A2C  40035800   MFC0 V1, Compare
9D016A30  3C07A000   LUI A3, -24576
9D016A34  24E22E24   ADDIU V0, A3, 11812
9D016A38  8C45000C   LW A1, 12(V0)
9D016A3C  00651821   ADDU V1, V1, A1
9D016A40  2465FFCE   ADDIU A1, V1, -50
9D016A44  00C5282B   SLTU A1, A2, A1
9D016A48  50A0000D   BEQL A1, ZERO, 0x9D016A80
9D016A4C  24C60032   ADDIU A2, A2, 50
9D016A50  40835800   MTC0 V1, Compare
9D016A54  000000C0   EHB
9D016A58  41636020   EI V1
9D016A5C  8C430008   LW V1, 8(V0)
9D016A60  8CF92E24   LW T9, 11812(A3)
9D016A64  24630001   ADDIU V1, V1, 1
9D016A68  AC430008   SW V1, 8(V0)
9D016A6C  1320000D   BEQ T9, ZERO, 0x9D016AA4
9D016A70  8FBF0004   LW RA, 4(SP)
9D016A74  8C450004   LW A1, 4(V0)
9D016A78  03200008   JR T9
9D016A7C  27BD0008   ADDIU SP, SP, 8
9D016A80  40865800   MTC0 A2, Compare
9D016A84  000000C0   EHB
9D016A88  41636020   EI V1
9D016A8C  8C430008   LW V1, 8(V0)
9D016A90  8CF92E24   LW T9, 11812(A3)
9D016A94  24630001   ADDIU V1, V1, 1
9D016A98  AC430008   SW V1, 8(V0)
9D016A9C  1720FFF5   BNE T9, ZERO, 0x9D016A74
9D016AA0  8FBF0004   LW RA, 4(SP)
9D016AA4  03E00008   JR RA
9D016AA8  27BD0008   ADDIU SP, SP, 8
9D017AD0  27BDFFF8   ADDIU SP, SP, -8
9D017AD4  AFBF0004   SW RA, 4(SP)
9D017AD8  40026800   MFC0 V0, Cause
9D017ADC  3C030800   LUI V1, 2048
9D017AE0  00431025   OR V0, V0, V1
9D017AE4  40826800   MTC0 V0, Cause
9D017AE8  000000C0   EHB
9D017AEC  3C03BF88   LUI V1, -16504
9D017AF0  24040001   ADDIU A0, ZERO, 1
9D017AF4  AC641064   SW A0, 4196(V1)
9D017AF8  00001025   OR V0, ZERO, ZERO
9D017AFC  40824800   MTC0 V0, Count
9D017B00  000000C0   EHB
9D017B04  3C02A000   LUI V0, -24576
9D017B08  8C422E30   LW V0, 11824(V0)
9D017B0C  40825800   MTC0 V0, Compare
9D017B10  000000C0   EHB
9D017B14  40026800   MFC0 V0, Cause
9D017B18  7C02DEC4   INS V0, ZERO, 27, 1
9D017B1C  40826800   MTC0 V0, Cause
9D017B20  000000C0   EHB
9D017B24  8FBF0004   LW RA, 4(SP)
9D017B28  AC641068   SW A0, 4200(V1)
9D017B2C  03E00008   JR RA
9D017B30  27BD0008   ADDIU SP, SP, 8
9D0183C4  00041880   SLL V1, A0, 2
9D0183C8  00642021   ADDU A0, V1, A0
9D0183CC  00041900   SLL V1, A0, 4
9D0183D0  00642023   SUBU A0, V1, A0
9D0183D4  00041900   SLL V1, A0, 4
9D0183D8  00641823   SUBU V1, V1, A0
9D0183DC  27BDFFF8   ADDIU SP, SP, -8
9D0183E0  00031940   SLL V1, V1, 5
9D0183E4  AFBF0004   SW RA, 4(SP)
9D0183E8  40044800   MFC0 A0, Count
9D0183EC  40024800   MFC0 V0, Count
9D0183F0  00441023   SUBU V0, V0, A0
9D0183F4  0043102B   SLTU V0, V0, V1
9D0183F8  1440FFFC   BNE V0, ZERO, 0x9D0183EC
9D0183FC  8FBF0004   LW RA, 4(SP)
9D018400  03E00008   JR RA
9D018404  27BD0008   ADDIU SP, SP, 8
9D018514  27BDFFF8   ADDIU SP, SP, -8
9D018518  AFBF0004   SW RA, 4(SP)
9D01851C  40026800   MFC0 V0, Cause
9D018520  3C030800   LUI V1, 2048
9D018524  00431025   OR V0, V0, V1
9D018528  40826800   MTC0 V0, Cause
9D01852C  000000C0   EHB
9D018530  8FBF0004   LW RA, 4(SP)
9D018534  3C02A000   LUI V0, -24576
9D018538  24432E24   ADDIU V1, V0, 11812
9D01853C  34048CA0   ORI A0, ZERO, -29536
9D018540  AC64000C   SW A0, 12(V1)
9D018544  AC600008   SW ZERO, 8(V1)
9D018548  AC402E24   SW ZERO, 11812(V0)
9D01854C  03E00008   JR RA
9D018550  27BD0008   ADDIU SP, SP, 8
9D0187E0  000410C0   SLL V0, A0, 3
9D0187E4  00442021   ADDU A0, V0, A0
9D0187E8  27BDFFF8   ADDIU SP, SP, -8
9D0187EC  00042080   SLL A0, A0, 2
9D0187F0  AFBF0004   SW RA, 4(SP)
9D0187F4  40034800   MFC0 V1, Count
9D0187F8  40024800   MFC0 V0, Count
9D0187FC  00431023   SUBU V0, V0, V1
9D018800  0044102B   SLTU V0, V0, A0
9D018804  1440FFFC   BNE V0, ZERO, 0x9D0187F8
9D018808  8FBF0004   LW RA, 4(SP)
9D01880C  03E00008   JR RA
9D018810  27BD0008   ADDIU SP, SP, 8
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/peripheral/clk/plib_clk.c  -----------------
1:                   /*******************************************************************************
2:                     SYS CLK Static Functions for Clock System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_clk.c
9:                   
10:                    Summary:
11:                      SYS CLK static function implementations for the Clock System Service.
12:                  
13:                    Description:
14:                      The Clock System Service provides a simple interface to manage the
15:                      oscillators on Microchip microcontrollers. This file defines the static
16:                      implementation for the Clock System Service.
17:                  
18:                    Remarks:
19:                      Static functions incorporate all system clock configuration settings as
20:                      determined by the user via the Microchip Harmony Configurator GUI.
21:                      It provides static version of the routines, eliminating the need for an
22:                      object ID or object handle.
23:                  
24:                      Static single-open interfaces also eliminate the need for the open handle.
25:                  
26:                  *******************************************************************************/
27:                  
28:                  /*******************************************************************************
29:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
30:                  *
31:                  * Subject to your compliance with these terms, you may use Microchip software
32:                  * and any derivatives exclusively with Microchip products. It is your
33:                  * responsibility to comply with third party license terms applicable to your
34:                  * use of third party software (including open source software) that may
35:                  * accompany Microchip software.
36:                  *
37:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
38:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
39:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
40:                  * PARTICULAR PURPOSE.
41:                  *
42:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
43:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
44:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
45:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
46:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
47:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
48:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
49:                  *******************************************************************************/
50:                  
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  // Section: Include Files
54:                  // *****************************************************************************
55:                  // *****************************************************************************
56:                  
57:                  #include "device.h"
58:                  #include "plib_clk.h"
59:                  
60:                  // *****************************************************************************
61:                  // *****************************************************************************
62:                  // Section: File Scope Functions
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  
66:                  // *****************************************************************************
67:                  /* Function:
68:                      void CLK_Initialize( void )
69:                  
70:                    Summary:
71:                      Initializes hardware and internal data structure of the System Clock.
72:                  
73:                    Description:
74:                      This function initializes the hardware and internal data structure of System
75:                      Clock Service.
76:                  
77:                    Remarks:
78:                      This is configuration values for the static version of the Clock System
79:                      Service module is determined by the user via the MHC GUI.
80:                  
81:                      The objective is to eliminate the user's need to be knowledgeable in the
82:                      function of the 'configuration bits' to configure the system oscillators.
83:                  */
84:                  
85:                  void CLK_Initialize( void )
86:                  {
87:                  
88:                      /* Code for fuse settings can be found in "initialization.c" */
89:                      
90:                  
91:                  
92:                      /* Peripheral Module Disable Configuration */
93:                      PMD1 = 0x101100;
94:                      PMD2 = 0x7;
95:                      PMD3 = 0x1f001f;
96:                      PMD4 = 0x19;
97:                      PMD5 = 0x30200;
98:                      PMD6 = 0x10001;
99:                  }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D018258  3C030010   LUI V1, 16
9D01825C  3C02BF81   LUI V0, -16511
9D018260  24631100   ADDIU V1, V1, 4352
9D018264  AC43F240   SW V1, -3520(V0)
9D018268  24030007   ADDIU V1, ZERO, 7
9D01826C  AC43F250   SW V1, -3504(V0)
9D018270  3C03001F   LUI V1, 31
9D018274  2463001F   ADDIU V1, V1, 31
9D018278  AC43F260   SW V1, -3488(V0)
9D01827C  24030019   ADDIU V1, ZERO, 25
9D018280  AC43F270   SW V1, -3472(V0)
9D018284  3C030003   LUI V1, 3
9D018288  24630200   ADDIU V1, V1, 512
9D01828C  AC43F280   SW V1, -3456(V0)
9D018290  3C030001   LUI V1, 1
9D018294  24630001   ADDIU V1, V1, 1
9D018298  AC43F290   SW V1, -3440(V0)
9D01829C  03E00008   JR RA
9D0182A0  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/peripheral/adc/plib_adc.c  -----------------
1:                   /*******************************************************************************
2:                     ADC Peripheral Library Interface Source File
3:                   
4:                     Company
5:                       Microchip Technology Inc.
6:                   
7:                     File Name
8:                       plib_adc.c
9:                   
10:                    Summary
11:                      ADC peripheral library source.
12:                  
13:                    Description
14:                      This file implements the ADC peripheral library.
15:                  
16:                  *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
21:                  *
22:                  * Subject to your compliance with these terms, you may use Microchip software
23:                  * and any derivatives exclusively with Microchip products. It is your
24:                  * responsibility to comply with third party license terms applicable to your
25:                  * use of third party software (including open source software) that may
26:                  * accompany Microchip software.
27:                  *
28:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                  * PARTICULAR PURPOSE.
32:                  *
33:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                  *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  #include "device.h"
43:                  #include "plib_adc.h"
44:                  
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  // Section: ADC Implementation
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  
51:                  
52:                  void ADC_Initialize(void)
53:                  {
54:                      AD1CON1CLR = _AD1CON1_ON_MASK;
55:                  
56:                      AD1CON1 = 0xe4;
57:                      AD1CON2 = 0x418;
58:                      AD1CON3 = 0x1fff;
59:                      AD1CHS = 0x90000;
60:                      /* Input Scan */
61:                      AD1CSSL = 0xa8f;
62:                  
63:                  
64:                      /* Turn ON ADC */
65:                      AD1CON1SET = _AD1CON1_ON_MASK;
66:                  }
67:                  
68:                  void ADC_Enable(void)
69:                  {
70:                      AD1CON1SET = _AD1CON1_ON_MASK;
71:                  }
72:                  
73:                  void ADC_Disable(void)
74:                  {
75:                      AD1CON1CLR = _AD1CON1_ON_MASK;
76:                  }
77:                  
78:                  void ADC_SamplingStart(void)
79:                  {
80:                      AD1CON1CLR = _AD1CON1_DONE_MASK;
81:                      AD1CON1SET = _AD1CON1_SAMP_MASK;
82:                  }
83:                  
84:                  void ADC_ConversionStart(void)
85:                  {
86:                      AD1CON1CLR = _AD1CON1_SAMP_MASK;
87:                  }
88:                  
89:                  void ADC_InputSelect(ADC_MUX muxType, ADC_INPUT_POSITIVE positiveInput, ADC_INPUT_NEGATIVE negativeInput)
90:                  {
91:                  	if (muxType == ADC_MUX_B)
92:                  	{
93:                      	AD1CHSbits.CH0SB = positiveInput;
94:                          AD1CHSbits.CH0NB = negativeInput;
95:                  	}
96:                  	else
97:                  	{
98:                      	AD1CHSbits.CH0SA = positiveInput;
99:                          AD1CHSbits.CH0NA = negativeInput;
100:                 	}
101:                 }
102:                 
103:                 void ADC_InputScanSelect(ADC_INPUTS_SCAN scanInputs)
104:                 {
105:                     AD1CSSL = scanInputs;
106:                 }
107:                 
108:                 /*Check if conversion result is available */
109:                 bool ADC_ResultIsReady(void)
110:                 {
111:                     return AD1CON1bits.DONE;
112:                 }
113:                 
114:                 
115:                 /* Read the conversion result */
116:                 uint32_t ADC_ResultGet(ADC_RESULT_BUFFER bufferNumber)
117:                 {
118:                     return (*((&ADC1BUF0) + (bufferNumber << 2)));
119:                 }
120:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000020  00000000   NOP
0000002C  00000000   NOP
00000034  00000000   NOP
00000044  00000000   NOP
9D0184D4  3C02BF81   LUI V0, -16511
9D0184D8  34038000   ORI V1, ZERO, -32768
9D0184DC  240400E4   ADDIU A0, ZERO, 228
9D0184E0  AC439004   SW V1, -28668(V0)
9D0184E4  AC449000   SW A0, -28672(V0)
9D0184E8  24040418   ADDIU A0, ZERO, 1048
9D0184EC  AC449010   SW A0, -28656(V0)
9D0184F0  24041FFF   ADDIU A0, ZERO, 8191
9D0184F4  AC449020   SW A0, -28640(V0)
9D0184F8  3C040009   LUI A0, 9
9D0184FC  AC449040   SW A0, -28608(V0)
9D018500  24040A8F   ADDIU A0, ZERO, 2703
9D018504  AC449050   SW A0, -28592(V0)
9D018508  AC439008   SW V1, -28664(V0)
9D01850C  03E00008   JR RA
9D018510  00000000   NOP
9D018F28  3C02BF81   LUI V0, -16511
9D018F2C  00042100   SLL A0, A0, 4
9D018F30  24429070   ADDIU V0, V0, -28560
9D018F34  00441021   ADDU V0, V0, A0
9D018F38  8C420000   LW V0, 0(V0)
9D018F3C  03E00008   JR RA
9D018F40  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/osal/osal_impl_basic.h  --------------------
1:                   /*******************************************************************************
2:                     Operating System Abstraction Layer Basic Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       osal_impl_basic.h
9:                   
10:                    Summary:
11:                      Header file for the OSAL Basic implementation.
12:                  
13:                    Description:
14:                      This file defines the additions or variations to the OSAL base implementation.
15:                   Where it is logical or possible to implement an OSAL function in a simple form
16:                   without an RTOS being present then the function has been defined here and
17:                   implemented either here as an inline or #define. Longer functions that are part
18:                   of the basic implementation may also be found in the file osal.c
19:                   The best way to consider this file is detailing any deviations from the osal.h
20:                   definitions OR as the complete implementation of those functions when pretending
21:                   to support BASIC operations.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
27:                  *
28:                  * Subject to your compliance with these terms, you may use Microchip software
29:                  * and any derivatives exclusively with Microchip products. It is your
30:                  * responsibility to comply with third party license terms applicable to your
31:                  * use of third party software (including open source software) that may
32:                  * accompany Microchip software.
33:                  *
34:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
35:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
36:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
37:                  * PARTICULAR PURPOSE.
38:                  *
39:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
40:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
41:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
42:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
43:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
44:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
45:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  #ifndef OSAL_IMPL_BASIC_H
50:                  #define OSAL_IMPL_BASIC_H
51:                  
52:                  #ifdef __cplusplus
53:                  extern "C" {
54:                  #endif
55:                  
56:                  // *****************************************************************************
57:                  // *****************************************************************************
58:                  // Section: Included Files
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  #include <stdint.h>
62:                  #include <stdbool.h>
63:                  #include <stdlib.h>
64:                  #include "system/int/sys_int.h"
65:                  #include "device.h"
66:                  
67:                  
68:                  typedef uint8_t                     OSAL_SEM_HANDLE_TYPE;
69:                  typedef uint8_t                     OSAL_MUTEX_HANDLE_TYPE;
70:                  typedef uint32_t                    OSAL_CRITSECT_DATA_TYPE;
71:                  #define OSAL_WAIT_FOREVER           (uint16_t) 0xFFFF
72:                  
73:                  #define OSAL_SEM_DECLARE(semID)         uint8_t    semID
74:                  #define OSAL_MUTEX_DECLARE(mutexID)     uint8_t    mutexID
75:                  
76:                  // *****************************************************************************
77:                  /* Macro: OSAL_ASSERT
78:                   */
79:                  
80:                  #define OSAL_ASSERT(test, message)      test
81:                  
82:                  // *****************************************************************************
83:                  /* OSAL Result type
84:                  
85:                    Summary:
86:                      Enumerated type representing the general return value from OSAL functions.
87:                  
88:                    Description:
89:                      This enum represents possible return types from OSAL functions.
90:                  
91:                    Remarks:
92:                      These enum values are the possible return values from OSAL functions
93:                      where a standard success/fail type response is required. The majority
94:                      of OSAL functions will return this type with a few exceptions.
95:                  */
96:                  
97:                  typedef enum OSAL_SEM_TYPE
98:                  {
99:                    OSAL_SEM_TYPE_BINARY,
100:                   OSAL_SEM_TYPE_COUNTING
101:                 } OSAL_SEM_TYPE;
102:                 
103:                 typedef enum OSAL_CRIT_TYPE
104:                 {
105:                   OSAL_CRIT_TYPE_LOW,
106:                   OSAL_CRIT_TYPE_HIGH
107:                 } OSAL_CRIT_TYPE;
108:                 
109:                 typedef enum OSAL_RESULT
110:                 {
111:                   OSAL_RESULT_NOT_IMPLEMENTED = -1,
112:                   OSAL_RESULT_FALSE = 0,
113:                   OSAL_RESULT_TRUE = 1
114:                 } OSAL_RESULT;
115:                 
116:                 // *****************************************************************************
117:                 // *****************************************************************************
118:                 // Section: Section: Interface Routines Group Declarations
119:                 // *****************************************************************************
120:                 // *****************************************************************************
121:                 __STATIC_INLINE OSAL_RESULT OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE* semID, OSAL_SEM_TYPE type, uint8_t maxCount, uint8_t initialCount);
122:                 __STATIC_INLINE OSAL_RESULT OSAL_SEM_Delete(OSAL_SEM_HANDLE_TYPE* semID);
123:                 __STATIC_INLINE OSAL_RESULT OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE* semID, uint16_t waitMS);
124:                 __STATIC_INLINE OSAL_RESULT OSAL_SEM_Post(OSAL_SEM_HANDLE_TYPE* semID);
125:                 __STATIC_INLINE OSAL_RESULT OSAL_SEM_PostISR(OSAL_SEM_HANDLE_TYPE* semID);
126:                 __STATIC_INLINE uint8_t OSAL_SEM_GetCount(OSAL_SEM_HANDLE_TYPE* semID);
127:                 
128:                 __STATIC_INLINE OSAL_CRITSECT_DATA_TYPE OSAL_CRIT_Enter(OSAL_CRIT_TYPE severity);
129:                 __STATIC_INLINE void OSAL_CRIT_Leave(OSAL_CRIT_TYPE severity, OSAL_CRITSECT_DATA_TYPE status);
130:                 
131:                 __STATIC_INLINE OSAL_RESULT OSAL_MUTEX_Create(OSAL_MUTEX_HANDLE_TYPE* mutexID);
132:                 __STATIC_INLINE OSAL_RESULT OSAL_MUTEX_Delete(OSAL_MUTEX_HANDLE_TYPE* mutexID);
133:                 __STATIC_INLINE OSAL_RESULT OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE* mutexID, uint16_t waitMS);
134:                 __STATIC_INLINE OSAL_RESULT OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE* mutexID);
135:                 
136:                 __STATIC_INLINE void* OSAL_Malloc(size_t size);
137:                 __STATIC_INLINE void OSAL_Free(void* pData);
138:                 
139:                 OSAL_RESULT OSAL_Initialize(void);
140:                 
141:                 __STATIC_INLINE const char* OSAL_Name(void);
142:                 
143:                 // *****************************************************************************
144:                 // *****************************************************************************
145:                 // Section: Interface Routines Group Defintions
146:                 // *****************************************************************************
147:                 // *****************************************************************************
148:                 
149:                 /* Critical Section group */
150:                 // *****************************************************************************
151:                 /* Function: OSAL_CRITSECT_DATA_TYPE OSAL_CRIT_Enter(OSAL_CRIT_TYPE severity)
152:                  */
153:                 static OSAL_CRITSECT_DATA_TYPE OSAL_CRIT_Enter(OSAL_CRIT_TYPE severity)
154:                 {
155:                   if(severity == OSAL_CRIT_TYPE_LOW)
156:                     return (0);
157:                   /*if priority is set to HIGH the user wants interrupts disabled*/
158:                   return (SYS_INT_Disable());
159:                 }
160:                 
161:                 // *****************************************************************************
162:                 /* Function: void OSAL_CRIT_Leave(OSAL_CRIT_TYPE severity, OSAL_CRITSECT_DATA_TYPE status)
163:                  */
164:                 static void OSAL_CRIT_Leave(OSAL_CRIT_TYPE severity, OSAL_CRITSECT_DATA_TYPE status)
165:                 {
166:                   if(severity == OSAL_CRIT_TYPE_LOW)
167:                     return;
168:                   /*if priority is set to HIGH the user wants interrupts re-enabled to the state
169:                   they were before disabling.*/
170:                   SYS_INT_Restore(status);
171:                 }
172:                 
173:                 // *****************************************************************************
174:                 /* Function: OSAL_RESULT OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE semID, OSAL_SEM_TYPE type,
175:                                                 uint8_t maxCount, uint8_t initialCount)
176:                  */
177:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE* semID, OSAL_SEM_TYPE type,
178:                                                 uint8_t maxCount, uint8_t initialCount)
179:                 {
180:                   OSAL_CRITSECT_DATA_TYPE IntState;
181:                 
182:                   IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
183:                 
184:                   if (type == OSAL_SEM_TYPE_COUNTING)
185:                     *semID = initialCount;
186:                   else
187:                     *semID = 1;
188:                 
189:                   OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
190:                 
191:                   return OSAL_RESULT_TRUE;
192:                 }
193:                 
194:                 // *****************************************************************************
195:                 /* Function: OSAL_RESULT OSAL_SEM_Delete(OSAL_SEM_HANDLE_TYPE semID)
196:                  */
197:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Delete(OSAL_SEM_HANDLE_TYPE* mutexID)
198:                 {
199:                    return (OSAL_RESULT_TRUE);
200:                 }
201:                 
202:                 // *****************************************************************************
203:                 /* Function: OSAL_RESULT OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE semID, uint16_t waitMS)
204:                  */
205:                 static  OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE* semID, uint16_t waitMS)
206:                 {
207:                   OSAL_CRITSECT_DATA_TYPE IntState;
208:                 
209:                   IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
210:                 
211:                   if (*semID > 0)
212:                   {
213:                     (*semID)--;
214:                     OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
215:                 
216:                     return OSAL_RESULT_TRUE;
217:                   }
218:                 
219:                   OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
220:                 
221:                   return OSAL_RESULT_FALSE;
222:                 }
223:                 
224:                 // *****************************************************************************
225:                 /* Function: OSAL_RESULT OSAL_SEM_Post(OSAL_SEM_HANDLE_TYPE semID)
226:                  */
227:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Post(OSAL_SEM_HANDLE_TYPE* semID)
228:                 {
229:                   OSAL_CRITSECT_DATA_TYPE IntState;
230:                 
231:                   IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
232:                   (*semID)++;
233:                   OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
234:                 
235:                   return OSAL_RESULT_TRUE;
236:                 }
237:                 
238:                 // *****************************************************************************
239:                 /* Function: OSAL_RESULT OSAL_SEM_PostISR(OSAL_SEM_HANDLE_TYPE semID)
240:                  */
241:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_PostISR(OSAL_SEM_HANDLE_TYPE* semID)
242:                 {
243:                   (*semID)++;
244:                   return OSAL_RESULT_TRUE;
245:                 }
246:                 
247:                 // *****************************************************************************
248:                 /* Function: uint8_t OSAL_SEM_GetCount(OSAL_SEM_HANDLE_TYPE semID)
249:                  */
250:                 static uint8_t __attribute__((always_inline)) OSAL_SEM_GetCount(OSAL_SEM_HANDLE_TYPE* semID)
251:                 {
252:                   return *semID;
253:                 }
254:                 
255:                 // *****************************************************************************
256:                 /* Function: OSAL_RESULT OSAL_MUTEX_Create(OSAL_MUTEX_HANDLE_TYPE mutexID)
257:                  */
258:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Create(OSAL_MUTEX_HANDLE_TYPE* mutexID)
259:                 {
260:                   *mutexID = 1;
261:                   return OSAL_RESULT_TRUE;
262:                 }
263:                 
264:                 // *****************************************************************************
265:                 /* Function: OSAL_RESULT OSAL_MUTEX_Delete(OSAL_MUTEX_HANDLE_TYPE mutexID)
266:                  */
267:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Delete(OSAL_MUTEX_HANDLE_TYPE* mutexID)
268:                 {
269:                   return (OSAL_RESULT_TRUE);
270:                 }
271:                 // *****************************************************************************
272:                 /* Function: OSAL_RESULT OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE mutexID, uint16_t waitMS)
273:                  */
274:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE* mutexID, uint16_t waitMS)
275:                 {
276:                   if (*mutexID == 1)
277:                   {
278:                     *mutexID = 0;
279:                     return OSAL_RESULT_TRUE;
280:                   }
281:                   return OSAL_RESULT_FALSE;
282:                 }
283:                 
284:                 // *****************************************************************************
285:                 /* Function: OSAL_RESULT OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE mutexID)
286:                  */
287:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE* mutexID)
288:                 {
289:                   *mutexID = 1;
290:                   return OSAL_RESULT_TRUE;
291:                 }
292:                 
293:                 // *****************************************************************************
294:                 /* Function: void* OSAL_Malloc(size_t size)
295:                  */
296:                 static void* __attribute__((always_inline)) OSAL_Malloc(size_t size)
297:                 {
298:                     return malloc(size);
299:                 }
300:                 
301:                 // *****************************************************************************
302:                 /* Function: void OSAL_Free(void* pData)
303:                  */
304:                 static void __attribute__((always_inline)) OSAL_Free(void* pData)
305:                 {
306:                     free(pData);
307:                 }
308:                 
309:                 // Initialization and Diagnostics
310:                 // *****************************************************************************
311:                 /* Function: OSAL_RESULT OSAL_Initialize()
312:                  */
313:                 #define OSAL_Initialize()
314:                 
315:                 
316:                 // *****************************************************************************
317:                 /* Function: const char* OSAL_Name()
318:                  */
319:                 static const char* __attribute__((always_inline)) OSAL_Name(void)
320:                 {
321:                   return((const char*) "BASIC");
322:                 }
323:                 
324:                 
325:                 #ifdef __cplusplus
326:                 }
327:                 #endif
328:                 
329:                 #endif // _OSAL_IMPL_BASIC_H
330:                 
331:                 /*******************************************************************************
332:                  End of File
333:                  */
334:                 
335:                 
336:                 
337:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
0000000C  00000000   NOP
00000040  00000000   NOP
00000090  00000000   NOP
0000009C  00000000   NOP
000000BC  00000000   NOP
000000C8  00000000   NOP
000000CC  00000000   NOP
000000F4  00000000   NOP
0000010C  00000000   NOP
00000110  00000000   NOP
0000014C  00000000   NOP
00000154  00000000   NOP
00000158  00000000   NOP
00000164  00000000   NOP
0000016C  00000000   NOP
00000188  00000000   NOP
0000018C  00000000   NOP
00000194  00000000   NOP
0000019C  00000000   NOP
000001A0  00000000   NOP
000001AC  00000000   NOP
000001B4  00000000   NOP
000001BC  00000000   NOP
000001C0  00000000   NOP
9D00B254  A7828024   SH V0, -32732(GP)
9D01132C  24020001   ADDIU V0, ZERO, 1
9D011330  A2220030   SB V0, 48(S1)
9D011334  8FBF0034   LW RA, 52(SP)
9D011338  00001025   OR V0, ZERO, ZERO
9D011370  92230030   LBU V1, 48(S1)
9D011374  24020001   ADDIU V0, ZERO, 1
9D011378  50620012   BEQL V1, V0, DRV_USBFS_DEVICE_IRPSubmit::OSAL_MUTEX_Lock
9D01137C  8E240028   LW A0, 40(S1)
9D011380  2402FF81   ADDIU V0, ZERO, -127
9D0113BC  1000FFDC   BEQ ZERO, ZERO, 0x9D011330
9D0113C0  24020001   ADDIU V0, ZERO, 1
9D0113C4  A2200030   SB ZERO, 48(S1)
9D0113C8  0F406033   JAL SYS_INT_SourceDisable
9D011438  90830030   LBU V1, 48(A0)
9D01143C  24020001   ADDIU V0, ZERO, 1
9D011440  5462FFD0   BNEL V1, V0, 0x9D011384
9D011444  2402FF81   ADDIU V0, ZERO, -127
9D011448  8E240028   LW A0, 40(S1)
9D01144C  A2200030   SB ZERO, 48(S1)
9D011450  0F406033   JAL SYS_INT_SourceDisable
9D0115B0  24020001   ADDIU V0, ZERO, 1
9D0115B8  8FBF002C   LW RA, 44(SP)
9D0115BC  00001025   OR V0, ZERO, ZERO
9D0115DC  90840030   LBU A0, 48(A0)
9D0115E0  24030001   ADDIU V1, ZERO, 1
9D0115E4  1083002F   BEQ A0, V1, 0x9D0116A4
9D0115E8  2402FF81   ADDIU V0, ZERO, -127
9D0115EC  8FBF002C   LW RA, 44(SP)
9D01169C  1000FFC5   BEQ ZERO, ZERO, 0x9D0115B4
9D0116A0  24020001   ADDIU V0, ZERO, 1
9D0116A4  8E240028   LW A0, 40(S1)
9D0116A8  A2200030   SB ZERO, 48(S1)
9D0116AC  0F406033   JAL SYS_INT_SourceDisable
9D0116B0  AFA50010   SW A1, 16(SP)
9D012214  24050001   ADDIU A1, ZERO, 1
9D012218  10450012   BEQ V0, A1, 0x9D012264
9D01221C  2411FFA0   ADDIU S1, ZERO, -96
9D012220  8FBF0024   LW RA, 36(SP)
9D012264  3C05A000   LUI A1, -24576
9D012268  24A52788   ADDIU A1, A1, 10120
9D012270  29080002   SLTI T0, T0, 2
9D01229C  2411FF80   ADDIU S1, ZERO, -128
9D0122A0  A3828025   SB V0, -32731(GP)
9D0122A4  8FB30020   LW S3, 32(SP)
9D0122EC  0F402CEE   JAL SYS_INT_Disable
9D0122F4  8E030034   LW V1, 52(S0)
9D0122F8  00402025   OR A0, V0, ZERO
9D012304  0F402CF6   JAL SYS_INT_Restore
9D012308  00000000   NOP
9D01230C  AE510000   SW S1, 0(S2)
9D012328  24020001   ADDIU V0, ZERO, 1
9D01232C  1000FFBC   BEQ ZERO, ZERO, 0x9D012220
9D012334  0F402CEE   JAL SYS_INT_Disable
9D01233C  8E030034   LW V1, 52(S0)
9D012340  00402025   OR A0, V0, ZERO
9D01234C  0F402CF6   JAL SYS_INT_Restore
9D012350  00000000   NOP
9D012354  2402FFFF   ADDIU V0, ZERO, -1
9D01235C  24020001   ADDIU V0, ZERO, 1
9D012360  1000FFAF   BEQ ZERO, ZERO, 0x9D012220
9D012364  A3828025   SB V0, -32731(GP)
9D012634  90840030   LBU A0, 48(A0)
9D012638  24030001   ADDIU V1, ZERO, 1
9D01263C  1083003C   BEQ A0, V1, 0x9D012730
9D012640  2402FF81   ADDIU V0, ZERO, -127
9D012644  8FBF002C   LW RA, 44(SP)
9D0126E4  24020001   ADDIU V0, ZERO, 1
9D0126EC  8FBF002C   LW RA, 44(SP)
9D0126F0  00001025   OR V0, ZERO, ZERO
9D012728  1000FFEF   BEQ ZERO, ZERO, 0x9D0126E8
9D01272C  24020001   ADDIU V0, ZERO, 1
9D012730  8E240028   LW A0, 40(S1)
9D012734  A2200030   SB ZERO, 48(S1)
9D012738  0F406033   JAL SYS_INT_SourceDisable
9D01273C  AFA50010   SW A1, 16(SP)
9D0129A0  24030001   ADDIU V1, ZERO, 1
9D0129AC  8FBF0024   LW RA, 36(SP)
9D0129CC  3C03A000   LUI V1, -24576
9D0129D0  24632788   ADDIU V1, V1, 10120
9D0129D8  29080002   SLTI T0, T0, 2
9D0129DC  15000014   BNE T0, ZERO, 0x9D012A30
9D0129E0  A3808025   SB ZERO, -32731(GP)
9D012A04  2411FF80   ADDIU S1, ZERO, -128
9D012A08  A3828025   SB V0, -32731(GP)
9D012A0C  8FB30020   LW S3, 32(SP)
9D012A5C  0F402CEE   JAL SYS_INT_Disable
9D012A64  8E030038   LW V1, 56(S0)
9D012A68  00402025   OR A0, V0, ZERO
9D012A74  0F402CF6   JAL SYS_INT_Restore
9D012A78  00000000   NOP
9D012A7C  AE710000   SW S1, 0(S3)
9D012A98  24020001   ADDIU V0, ZERO, 1
9D012A9C  1000FFC3   BEQ ZERO, ZERO, 0x9D0129AC
9D012AA0  A3828025   SB V0, -32731(GP)
9D012AA4  0F402CEE   JAL SYS_INT_Disable
9D012AAC  8E030038   LW V1, 56(S0)
9D012AB0  00402025   OR A0, V0, ZERO
9D012ABC  0F402CF6   JAL SYS_INT_Restore
9D012AC0  00000000   NOP
9D012AC4  2402FFFF   ADDIU V0, ZERO, -1
9D012ACC  24020001   ADDIU V0, ZERO, 1
9D012AD0  1000FFB6   BEQ ZERO, ZERO, 0x9D0129AC
9D012F80  24020001   ADDIU V0, ZERO, 1
9D012F84  A2220030   SB V0, 48(S1)
9D012F88  8FBF002C   LW RA, 44(SP)
9D012F8C  00001025   OR V0, ZERO, ZERO
9D012FAC  90840030   LBU A0, 48(A0)
9D012FB0  24030001   ADDIU V1, ZERO, 1
9D012FB4  10830010   BEQ A0, V1, 0x9D012FF8
9D012FB8  2402FF81   ADDIU V0, ZERO, -127
9D012FBC  8FBF002C   LW RA, 44(SP)
9D012FC0  8FB40028   LW S4, 40(SP)
9D012FC4  8FB30024   LW S3, 36(SP)
9D012FC8  8FB20020   LW S2, 32(SP)
9D012FCC  8FB1001C   LW S1, 28(SP)
9D012FE4  1000FFE7   BEQ ZERO, ZERO, 0x9D012F84
9D012FE8  24020001   ADDIU V0, ZERO, 1
9D012FF8  8E240028   LW A0, 40(S1)
9D012FFC  A2200030   SB ZERO, 48(S1)
9D013000  0F406033   JAL SYS_INT_SourceDisable
9D013004  AFA50010   SW A1, 16(SP)
9D013DFC  24902880   ADDIU S0, A0, 10368
9D013E00  A2020030   SB V0, 48(S0)
9D013E20  3C02A000   LUI V0, -24576
9D014E64  24020001   ADDIU V0, ZERO, 1
9D014E68  A2220030   SB V0, 48(S1)
9D014E6C  8FBF0024   LW RA, 36(SP)
9D014E70  00001025   OR V0, ZERO, ZERO
9D014E84  90840030   LBU A0, 48(A0)
9D014E88  24030001   ADDIU V1, ZERO, 1
9D014E8C  1083000A   BEQ A0, V1, 0x9D014EB8
9D014E90  2402FF81   ADDIU V0, ZERO, -127
9D014E94  8FBF0024   LW RA, 36(SP)
9D014E98  8FB20020   LW S2, 32(SP)
9D014E9C  8FB1001C   LW S1, 28(SP)
9D014EB0  1000FFED   BEQ ZERO, ZERO, 0x9D014E68
9D014EB4  24020001   ADDIU V0, ZERO, 1
9D014EB8  8E240028   LW A0, 40(S1)
9D014EBC  A2200030   SB ZERO, 48(S1)
9D014EC0  0F406033   JAL SYS_INT_SourceDisable
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/interrupts.c  ------------------------------
1:                   /*******************************************************************************
2:                    System Interrupts File
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       interrupt.c
9:                   
10:                    Summary:
11:                      Interrupt vectors mapping
12:                  
13:                    Description:
14:                      This file maps all the interrupt vectors to their corresponding
15:                      implementations. If a particular module interrupt is used, then its ISR
16:                      definition can be found in corresponding PLIB source file. If a module
17:                      interrupt is not used, then its ISR implementation is mapped to dummy
18:                      handler.
19:                   *******************************************************************************/
20:                  
21:                  // DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
24:                  *
25:                  * Subject to your compliance with these terms, you may use Microchip software
26:                  * and any derivatives exclusively with Microchip products. It is your
27:                  * responsibility to comply with third party license terms applicable to your
28:                  * use of third party software (including open source software) that may
29:                  * accompany Microchip software.
30:                  *
31:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
32:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
33:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
34:                  * PARTICULAR PURPOSE.
35:                  *
36:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
37:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
38:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
39:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
40:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
41:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
42:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
43:                   *******************************************************************************/
44:                  // DOM-IGNORE-END
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Included Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include "configuration.h"
53:                  #include "interrupts.h"
54:                  #include "definitions.h"
55:                  
56:                  
57:                  // *****************************************************************************
58:                  // *****************************************************************************
59:                  // Section: System Interrupt Vector Functions
60:                  // *****************************************************************************
61:                  // *****************************************************************************
62:                  
63:                  
64:                  void CORE_TIMER_InterruptHandler( void );
65:                  void TIMER_3_InterruptHandler( void );
66:                  void NVM_InterruptHandler( void );
67:                  void DRV_USBFS_USB_Handler( void );
68:                  void UART_1_InterruptHandler( void );
69:                  void UART_2_InterruptHandler( void );
70:                  
71:                  
72:                  
73:                  /* All the handlers are defined here.  Each will call its PLIB-specific function. */
74:                  void __ISR(_CORE_TIMER_VECTOR, ipl1SOFT) CORE_TIMER_Handler (void)
75:                  {
76:                      CORE_TIMER_InterruptHandler();
77:                  }
78:                  
79:                  void __ISR(_TIMER_3_VECTOR, ipl1SOFT) TIMER_3_Handler (void)
80:                  {
81:                      TIMER_3_InterruptHandler();
82:                  }
83:                  
84:                  void __ISR(_FCE_VECTOR, ipl1SOFT) FCE_Handler (void)
85:                  {
86:                      NVM_InterruptHandler();
87:                  }
88:                  
89:                  void __ISR(_USB_1_VECTOR, ipl1SOFT) USB_1_Handler (void)
90:                  {
91:                      DRV_USBFS_USB_Handler();
92:                  }
93:                  
94:                  void __ISR(_UART_1_VECTOR, ipl1SOFT) UART_1_Handler (void)
95:                  {
96:                      UART_1_InterruptHandler();
97:                  }
98:                  
99:                  void __ISR(_UART_2_VECTOR, ipl1SOFT) UART_2_Handler (void)
100:                 {
101:                     UART_2_InterruptHandler();
102:                 }
103:                 
104:                 
105:                 
106:                 
107:                 
108:                 /*******************************************************************************
109:                  End of File
110:                 */
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0144D4  415DE800   RDPGPR SP, SP
9D0144D8  401A7000   MFC0 K0, EPC
9D0144DC  401B6000   MFC0 K1, Status
9D0144E0  27BDFF88   ADDIU SP, SP, -120
9D0144E4  AFBA0074   SW K0, 116(SP)
9D0144E8  401A6002   MFC0 K0, SRSCtl
9D0144EC  AFBB0070   SW K1, 112(SP)
9D0144F0  7C1B7844   INS K1, ZERO, 1, 15
9D0144F4  377B0400   ORI K1, K1, 1024
9D0144F8  AFBA006C   SW K0, 108(SP)
9D0144FC  409B6000   MTC0 K1, Status
9D014500  AFBE0058   SW FP, 88(SP)
9D014504  AFA3001C   SW V1, 28(SP)
9D014508  AFA20018   SW V0, 24(SP)
9D01450C  00001810   MFHI V1
9D014510  03A0F025   OR FP, SP, ZERO
9D014514  AFBF005C   SW RA, 92(SP)
9D014518  00001012   MFLO V0
9D01451C  AFB90054   SW T9, 84(SP)
9D014520  AFB80050   SW T8, 80(SP)
9D014524  AFAF004C   SW T7, 76(SP)
9D014528  AFAE0048   SW T6, 72(SP)
9D01452C  AFAD0044   SW T5, 68(SP)
9D014530  AFAC0040   SW T4, 64(SP)
9D014534  AFAB003C   SW T3, 60(SP)
9D014538  AFAA0038   SW T2, 56(SP)
9D01453C  AFA90034   SW T1, 52(SP)
9D014540  AFA80030   SW T0, 48(SP)
9D014544  AFA7002C   SW A3, 44(SP)
9D014548  AFA60028   SW A2, 40(SP)
9D01454C  AFA50024   SW A1, 36(SP)
9D014550  AFA40020   SW A0, 32(SP)
9D014554  AFA10014   SW AT, 20(SP)
9D014558  AFA20064   SW V0, 100(SP)
9D01455C  AFA30060   SW V1, 96(SP)
9D014560  0F405A81   JAL CORE_TIMER_InterruptHandler
9D014564  00000000   NOP
9D014568  03C0E825   OR SP, FP, ZERO
9D01456C  8FA20064   LW V0, 100(SP)
9D014570  8FA30060   LW V1, 96(SP)
9D014574  8FBF005C   LW RA, 92(SP)
9D014578  00400013   MTLO V0
9D01457C  8FBE0058   LW FP, 88(SP)
9D014580  8FB90054   LW T9, 84(SP)
9D014584  00600011   MTHI V1
9D014588  8FB80050   LW T8, 80(SP)
9D01458C  8FAF004C   LW T7, 76(SP)
9D014590  8FAE0048   LW T6, 72(SP)
9D014594  8FAD0044   LW T5, 68(SP)
9D014598  8FAC0040   LW T4, 64(SP)
9D01459C  8FAB003C   LW T3, 60(SP)
9D0145A0  8FAA0038   LW T2, 56(SP)
9D0145A4  8FA90034   LW T1, 52(SP)
9D0145A8  8FA80030   LW T0, 48(SP)
9D0145AC  8FA7002C   LW A3, 44(SP)
9D0145B0  8FA60028   LW A2, 40(SP)
9D0145B4  8FA50024   LW A1, 36(SP)
9D0145B8  8FA40020   LW A0, 32(SP)
9D0145BC  8FA3001C   LW V1, 28(SP)
9D0145C0  8FA20018   LW V0, 24(SP)
9D0145C4  8FA10014   LW AT, 20(SP)
9D0145C8  41606000   DI ZERO
9D0145CC  000000C0   EHB
9D0145D0  8FBA0074   LW K0, 116(SP)
9D0145D4  8FBB0070   LW K1, 112(SP)
9D0145D8  409A7000   MTC0 K0, EPC
9D0145DC  8FBA006C   LW K0, 108(SP)
9D0145E0  27BD0078   ADDIU SP, SP, 120
9D0145E4  409A6002   MTC0 K0, SRSCtl
9D0145E8  41DDE800   WRPGPR SP, SP
9D0145EC  409B6000   MTC0 K1, Status
9D0145F0  42000018   ERET
9D0145F4  415DE800   RDPGPR SP, SP
9D0145F8  401A7000   MFC0 K0, EPC
9D0145FC  401B6000   MFC0 K1, Status
9D014600  27BDFF88   ADDIU SP, SP, -120
9D014604  AFBA0074   SW K0, 116(SP)
9D014608  401A6002   MFC0 K0, SRSCtl
9D01460C  AFBB0070   SW K1, 112(SP)
9D014610  7C1B7844   INS K1, ZERO, 1, 15
9D014614  377B0400   ORI K1, K1, 1024
9D014618  AFBA006C   SW K0, 108(SP)
9D01461C  409B6000   MTC0 K1, Status
9D014620  AFBE0058   SW FP, 88(SP)
9D014624  AFA3001C   SW V1, 28(SP)
9D014628  AFA20018   SW V0, 24(SP)
9D01462C  00001810   MFHI V1
9D014630  03A0F025   OR FP, SP, ZERO
9D014634  AFBF005C   SW RA, 92(SP)
9D014638  00001012   MFLO V0
9D01463C  AFB90054   SW T9, 84(SP)
9D014640  AFB80050   SW T8, 80(SP)
9D014644  AFAF004C   SW T7, 76(SP)
9D014648  AFAE0048   SW T6, 72(SP)
9D01464C  AFAD0044   SW T5, 68(SP)
9D014650  AFAC0040   SW T4, 64(SP)
9D014654  AFAB003C   SW T3, 60(SP)
9D014658  AFAA0038   SW T2, 56(SP)
9D01465C  AFA90034   SW T1, 52(SP)
9D014660  AFA80030   SW T0, 48(SP)
9D014664  AFA7002C   SW A3, 44(SP)
9D014668  AFA60028   SW A2, 40(SP)
9D01466C  AFA50024   SW A1, 36(SP)
9D014670  AFA40020   SW A0, 32(SP)
9D014674  AFA10014   SW AT, 20(SP)
9D014678  AFA20064   SW V0, 100(SP)
9D01467C  AFA30060   SW V1, 96(SP)
9D014680  0F406278   JAL TIMER_3_InterruptHandler
9D014684  00000000   NOP
9D014688  03C0E825   OR SP, FP, ZERO
9D01468C  8FA20064   LW V0, 100(SP)
9D014690  8FA30060   LW V1, 96(SP)
9D014694  8FBF005C   LW RA, 92(SP)
9D014698  00400013   MTLO V0
9D01469C  8FBE0058   LW FP, 88(SP)
9D0146A0  8FB90054   LW T9, 84(SP)
9D0146A4  00600011   MTHI V1
9D0146A8  8FB80050   LW T8, 80(SP)
9D0146AC  8FAF004C   LW T7, 76(SP)
9D0146B0  8FAE0048   LW T6, 72(SP)
9D0146B4  8FAD0044   LW T5, 68(SP)
9D0146B8  8FAC0040   LW T4, 64(SP)
9D0146BC  8FAB003C   LW T3, 60(SP)
9D0146C0  8FAA0038   LW T2, 56(SP)
9D0146C4  8FA90034   LW T1, 52(SP)
9D0146C8  8FA80030   LW T0, 48(SP)
9D0146CC  8FA7002C   LW A3, 44(SP)
9D0146D0  8FA60028   LW A2, 40(SP)
9D0146D4  8FA50024   LW A1, 36(SP)
9D0146D8  8FA40020   LW A0, 32(SP)
9D0146DC  8FA3001C   LW V1, 28(SP)
9D0146E0  8FA20018   LW V0, 24(SP)
9D0146E4  8FA10014   LW AT, 20(SP)
9D0146E8  41606000   DI ZERO
9D0146EC  000000C0   EHB
9D0146F0  8FBA0074   LW K0, 116(SP)
9D0146F4  8FBB0070   LW K1, 112(SP)
9D0146F8  409A7000   MTC0 K0, EPC
9D0146FC  8FBA006C   LW K0, 108(SP)
9D014700  27BD0078   ADDIU SP, SP, 120
9D014704  409A6002   MTC0 K0, SRSCtl
9D014708  41DDE800   WRPGPR SP, SP
9D01470C  409B6000   MTC0 K1, Status
9D014710  42000018   ERET
9D014714  415DE800   RDPGPR SP, SP
9D014718  401A7000   MFC0 K0, EPC
9D01471C  401B6000   MFC0 K1, Status
9D014720  27BDFF88   ADDIU SP, SP, -120
9D014724  AFBA0074   SW K0, 116(SP)
9D014728  401A6002   MFC0 K0, SRSCtl
9D01472C  AFBB0070   SW K1, 112(SP)
9D014730  7C1B7844   INS K1, ZERO, 1, 15
9D014734  377B0400   ORI K1, K1, 1024
9D014738  AFBA006C   SW K0, 108(SP)
9D01473C  409B6000   MTC0 K1, Status
9D014740  AFBE0058   SW FP, 88(SP)
9D014744  AFA3001C   SW V1, 28(SP)
9D014748  AFA20018   SW V0, 24(SP)
9D01474C  00001810   MFHI V1
9D014750  03A0F025   OR FP, SP, ZERO
9D014754  AFBF005C   SW RA, 92(SP)
9D014758  00001012   MFLO V0
9D01475C  AFB90054   SW T9, 84(SP)
9D014760  AFB80050   SW T8, 80(SP)
9D014764  AFAF004C   SW T7, 76(SP)
9D014768  AFAE0048   SW T6, 72(SP)
9D01476C  AFAD0044   SW T5, 68(SP)
9D014770  AFAC0040   SW T4, 64(SP)
9D014774  AFAB003C   SW T3, 60(SP)
9D014778  AFAA0038   SW T2, 56(SP)
9D01477C  AFA90034   SW T1, 52(SP)
9D014780  AFA80030   SW T0, 48(SP)
9D014784  AFA7002C   SW A3, 44(SP)
9D014788  AFA60028   SW A2, 40(SP)
9D01478C  AFA50024   SW A1, 36(SP)
9D014790  AFA40020   SW A0, 32(SP)
9D014794  AFA10014   SW AT, 20(SP)
9D014798  AFA20064   SW V0, 100(SP)
9D01479C  AFA30060   SW V1, 96(SP)
9D0147A0  0F40632F   JAL NVM_InterruptHandler
9D0147A4  00000000   NOP
9D0147A8  03C0E825   OR SP, FP, ZERO
9D0147AC  8FA20064   LW V0, 100(SP)
9D0147B0  8FA30060   LW V1, 96(SP)
9D0147B4  8FBF005C   LW RA, 92(SP)
9D0147B8  00400013   MTLO V0
9D0147BC  8FBE0058   LW FP, 88(SP)
9D0147C0  8FB90054   LW T9, 84(SP)
9D0147C4  00600011   MTHI V1
9D0147C8  8FB80050   LW T8, 80(SP)
9D0147CC  8FAF004C   LW T7, 76(SP)
9D0147D0  8FAE0048   LW T6, 72(SP)
9D0147D4  8FAD0044   LW T5, 68(SP)
9D0147D8  8FAC0040   LW T4, 64(SP)
9D0147DC  8FAB003C   LW T3, 60(SP)
9D0147E0  8FAA0038   LW T2, 56(SP)
9D0147E4  8FA90034   LW T1, 52(SP)
9D0147E8  8FA80030   LW T0, 48(SP)
9D0147EC  8FA7002C   LW A3, 44(SP)
9D0147F0  8FA60028   LW A2, 40(SP)
9D0147F4  8FA50024   LW A1, 36(SP)
9D0147F8  8FA40020   LW A0, 32(SP)
9D0147FC  8FA3001C   LW V1, 28(SP)
9D014800  8FA20018   LW V0, 24(SP)
9D014804  8FA10014   LW AT, 20(SP)
9D014808  41606000   DI ZERO
9D01480C  000000C0   EHB
9D014810  8FBA0074   LW K0, 116(SP)
9D014814  8FBB0070   LW K1, 112(SP)
9D014818  409A7000   MTC0 K0, EPC
9D01481C  8FBA006C   LW K0, 108(SP)
9D014820  27BD0078   ADDIU SP, SP, 120
9D014824  409A6002   MTC0 K0, SRSCtl
9D014828  41DDE800   WRPGPR SP, SP
9D01482C  409B6000   MTC0 K1, Status
9D014830  42000018   ERET
9D014834  415DE800   RDPGPR SP, SP
9D014838  401A7000   MFC0 K0, EPC
9D01483C  401B6000   MFC0 K1, Status
9D014840  27BDFF88   ADDIU SP, SP, -120
9D014844  AFBA0074   SW K0, 116(SP)
9D014848  401A6002   MFC0 K0, SRSCtl
9D01484C  AFBB0070   SW K1, 112(SP)
9D014850  7C1B7844   INS K1, ZERO, 1, 15
9D014854  377B0400   ORI K1, K1, 1024
9D014858  AFBA006C   SW K0, 108(SP)
9D01485C  409B6000   MTC0 K1, Status
9D014860  AFBE0058   SW FP, 88(SP)
9D014864  AFA3001C   SW V1, 28(SP)
9D014868  AFA20018   SW V0, 24(SP)
9D01486C  00001810   MFHI V1
9D014870  03A0F025   OR FP, SP, ZERO
9D014874  AFBF005C   SW RA, 92(SP)
9D014878  00001012   MFLO V0
9D01487C  AFB90054   SW T9, 84(SP)
9D014880  AFB80050   SW T8, 80(SP)
9D014884  AFAF004C   SW T7, 76(SP)
9D014888  AFAE0048   SW T6, 72(SP)
9D01488C  AFAD0044   SW T5, 68(SP)
9D014890  AFAC0040   SW T4, 64(SP)
9D014894  AFAB003C   SW T3, 60(SP)
9D014898  AFAA0038   SW T2, 56(SP)
9D01489C  AFA90034   SW T1, 52(SP)
9D0148A0  AFA80030   SW T0, 48(SP)
9D0148A4  AFA7002C   SW A3, 44(SP)
9D0148A8  AFA60028   SW A2, 40(SP)
9D0148AC  AFA50024   SW A1, 36(SP)
9D0148B0  AFA40020   SW A0, 32(SP)
9D0148B4  AFA10014   SW AT, 20(SP)
9D0148B8  AFA20064   SW V0, 100(SP)
9D0148BC  AFA30060   SW V1, 96(SP)
9D0148C0  0F402CE6   JAL DRV_USBFS_USB_Handler
9D0148C4  00000000   NOP
9D0148C8  03C0E825   OR SP, FP, ZERO
9D0148CC  8FA20064   LW V0, 100(SP)
9D0148D0  8FA30060   LW V1, 96(SP)
9D0148D4  8FBF005C   LW RA, 92(SP)
9D0148D8  00400013   MTLO V0
9D0148DC  8FBE0058   LW FP, 88(SP)
9D0148E0  8FB90054   LW T9, 84(SP)
9D0148E4  00600011   MTHI V1
9D0148E8  8FB80050   LW T8, 80(SP)
9D0148EC  8FAF004C   LW T7, 76(SP)
9D0148F0  8FAE0048   LW T6, 72(SP)
9D0148F4  8FAD0044   LW T5, 68(SP)
9D0148F8  8FAC0040   LW T4, 64(SP)
9D0148FC  8FAB003C   LW T3, 60(SP)
9D014900  8FAA0038   LW T2, 56(SP)
9D014904  8FA90034   LW T1, 52(SP)
9D014908  8FA80030   LW T0, 48(SP)
9D01490C  8FA7002C   LW A3, 44(SP)
9D014910  8FA60028   LW A2, 40(SP)
9D014914  8FA50024   LW A1, 36(SP)
9D014918  8FA40020   LW A0, 32(SP)
9D01491C  8FA3001C   LW V1, 28(SP)
9D014920  8FA20018   LW V0, 24(SP)
9D014924  8FA10014   LW AT, 20(SP)
9D014928  41606000   DI ZERO
9D01492C  000000C0   EHB
9D014930  8FBA0074   LW K0, 116(SP)
9D014934  8FBB0070   LW K1, 112(SP)
9D014938  409A7000   MTC0 K0, EPC
9D01493C  8FBA006C   LW K0, 108(SP)
9D014940  27BD0078   ADDIU SP, SP, 120
9D014944  409A6002   MTC0 K0, SRSCtl
9D014948  41DDE800   WRPGPR SP, SP
9D01494C  409B6000   MTC0 K1, Status
9D014950  42000018   ERET
9D014954  415DE800   RDPGPR SP, SP
9D014958  401A7000   MFC0 K0, EPC
9D01495C  401B6000   MFC0 K1, Status
9D014960  27BDFF88   ADDIU SP, SP, -120
9D014964  AFBA0074   SW K0, 116(SP)
9D014968  401A6002   MFC0 K0, SRSCtl
9D01496C  AFBB0070   SW K1, 112(SP)
9D014970  7C1B7844   INS K1, ZERO, 1, 15
9D014974  377B0400   ORI K1, K1, 1024
9D014978  AFBA006C   SW K0, 108(SP)
9D01497C  409B6000   MTC0 K1, Status
9D014980  AFBE0058   SW FP, 88(SP)
9D014984  AFA3001C   SW V1, 28(SP)
9D014988  AFA20018   SW V0, 24(SP)
9D01498C  00001810   MFHI V1
9D014990  03A0F025   OR FP, SP, ZERO
9D014994  AFBF005C   SW RA, 92(SP)
9D014998  00001012   MFLO V0
9D01499C  AFB90054   SW T9, 84(SP)
9D0149A0  AFB80050   SW T8, 80(SP)
9D0149A4  AFAF004C   SW T7, 76(SP)
9D0149A8  AFAE0048   SW T6, 72(SP)
9D0149AC  AFAD0044   SW T5, 68(SP)
9D0149B0  AFAC0040   SW T4, 64(SP)
9D0149B4  AFAB003C   SW T3, 60(SP)
9D0149B8  AFAA0038   SW T2, 56(SP)
9D0149BC  AFA90034   SW T1, 52(SP)
9D0149C0  AFA80030   SW T0, 48(SP)
9D0149C4  AFA7002C   SW A3, 44(SP)
9D0149C8  AFA60028   SW A2, 40(SP)
9D0149CC  AFA50024   SW A1, 36(SP)
9D0149D0  AFA40020   SW A0, 32(SP)
9D0149D4  AFA10014   SW AT, 20(SP)
9D0149D8  AFA20064   SW V0, 100(SP)
9D0149DC  AFA30060   SW V1, 96(SP)
9D0149E0  0F404039   JAL UART_1_InterruptHandler
9D0149E4  00000000   NOP
9D0149E8  03C0E825   OR SP, FP, ZERO
9D0149EC  8FA20064   LW V0, 100(SP)
9D0149F0  8FA30060   LW V1, 96(SP)
9D0149F4  8FBF005C   LW RA, 92(SP)
9D0149F8  00400013   MTLO V0
9D0149FC  8FBE0058   LW FP, 88(SP)
9D014A00  8FB90054   LW T9, 84(SP)
9D014A04  00600011   MTHI V1
9D014A08  8FB80050   LW T8, 80(SP)
9D014A0C  8FAF004C   LW T7, 76(SP)
9D014A10  8FAE0048   LW T6, 72(SP)
9D014A14  8FAD0044   LW T5, 68(SP)
9D014A18  8FAC0040   LW T4, 64(SP)
9D014A1C  8FAB003C   LW T3, 60(SP)
9D014A20  8FAA0038   LW T2, 56(SP)
9D014A24  8FA90034   LW T1, 52(SP)
9D014A28  8FA80030   LW T0, 48(SP)
9D014A2C  8FA7002C   LW A3, 44(SP)
9D014A30  8FA60028   LW A2, 40(SP)
9D014A34  8FA50024   LW A1, 36(SP)
9D014A38  8FA40020   LW A0, 32(SP)
9D014A3C  8FA3001C   LW V1, 28(SP)
9D014A40  8FA20018   LW V0, 24(SP)
9D014A44  8FA10014   LW AT, 20(SP)
9D014A48  41606000   DI ZERO
9D014A4C  000000C0   EHB
9D014A50  8FBA0074   LW K0, 116(SP)
9D014A54  8FBB0070   LW K1, 112(SP)
9D014A58  409A7000   MTC0 K0, EPC
9D014A5C  8FBA006C   LW K0, 108(SP)
9D014A60  27BD0078   ADDIU SP, SP, 120
9D014A64  409A6002   MTC0 K0, SRSCtl
9D014A68  41DDE800   WRPGPR SP, SP
9D014A6C  409B6000   MTC0 K1, Status
9D014A70  42000018   ERET
9D014A74  415DE800   RDPGPR SP, SP
9D014A78  401A7000   MFC0 K0, EPC
9D014A7C  401B6000   MFC0 K1, Status
9D014A80  27BDFF88   ADDIU SP, SP, -120
9D014A84  AFBA0074   SW K0, 116(SP)
9D014A88  401A6002   MFC0 K0, SRSCtl
9D014A8C  AFBB0070   SW K1, 112(SP)
9D014A90  7C1B7844   INS K1, ZERO, 1, 15
9D014A94  377B0400   ORI K1, K1, 1024
9D014A98  AFBA006C   SW K0, 108(SP)
9D014A9C  409B6000   MTC0 K1, Status
9D014AA0  AFBE0058   SW FP, 88(SP)
9D014AA4  AFA3001C   SW V1, 28(SP)
9D014AA8  AFA20018   SW V0, 24(SP)
9D014AAC  00001810   MFHI V1
9D014AB0  03A0F025   OR FP, SP, ZERO
9D014AB4  AFBF005C   SW RA, 92(SP)
9D014AB8  00001012   MFLO V0
9D014ABC  AFB90054   SW T9, 84(SP)
9D014AC0  AFB80050   SW T8, 80(SP)
9D014AC4  AFAF004C   SW T7, 76(SP)
9D014AC8  AFAE0048   SW T6, 72(SP)
9D014ACC  AFAD0044   SW T5, 68(SP)
9D014AD0  AFAC0040   SW T4, 64(SP)
9D014AD4  AFAB003C   SW T3, 60(SP)
9D014AD8  AFAA0038   SW T2, 56(SP)
9D014ADC  AFA90034   SW T1, 52(SP)
9D014AE0  AFA80030   SW T0, 48(SP)
9D014AE4  AFA7002C   SW A3, 44(SP)
9D014AE8  AFA60028   SW A2, 40(SP)
9D014AEC  AFA50024   SW A1, 36(SP)
9D014AF0  AFA40020   SW A0, 32(SP)
9D014AF4  AFA10014   SW AT, 20(SP)
9D014AF8  AFA20064   SW V0, 100(SP)
9D014AFC  AFA30060   SW V1, 96(SP)
9D014B00  0F403F4E   JAL UART_2_InterruptHandler
9D014B04  00000000   NOP
9D014B08  03C0E825   OR SP, FP, ZERO
9D014B0C  8FA20064   LW V0, 100(SP)
9D014B10  8FA30060   LW V1, 96(SP)
9D014B14  8FBF005C   LW RA, 92(SP)
9D014B18  00400013   MTLO V0
9D014B1C  8FBE0058   LW FP, 88(SP)
9D014B20  8FB90054   LW T9, 84(SP)
9D014B24  00600011   MTHI V1
9D014B28  8FB80050   LW T8, 80(SP)
9D014B2C  8FAF004C   LW T7, 76(SP)
9D014B30  8FAE0048   LW T6, 72(SP)
9D014B34  8FAD0044   LW T5, 68(SP)
9D014B38  8FAC0040   LW T4, 64(SP)
9D014B3C  8FAB003C   LW T3, 60(SP)
9D014B40  8FAA0038   LW T2, 56(SP)
9D014B44  8FA90034   LW T1, 52(SP)
9D014B48  8FA80030   LW T0, 48(SP)
9D014B4C  8FA7002C   LW A3, 44(SP)
9D014B50  8FA60028   LW A2, 40(SP)
9D014B54  8FA50024   LW A1, 36(SP)
9D014B58  8FA40020   LW A0, 32(SP)
9D014B5C  8FA3001C   LW V1, 28(SP)
9D014B60  8FA20018   LW V0, 24(SP)
9D014B64  8FA10014   LW AT, 20(SP)
9D014B68  41606000   DI ZERO
9D014B6C  000000C0   EHB
9D014B70  8FBA0074   LW K0, 116(SP)
9D014B74  8FBB0070   LW K1, 112(SP)
9D014B78  409A7000   MTC0 K0, EPC
9D014B7C  8FBA006C   LW K0, 108(SP)
9D014B80  27BD0078   ADDIU SP, SP, 120
9D014B84  409A6002   MTC0 K0, SRSCtl
9D014B88  41DDE800   WRPGPR SP, SP
9D014B8C  409B6000   MTC0 K1, Status
9D014B90  42000018   ERET
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/initialization.c  --------------------------
1:                   /*******************************************************************************
2:                     System Initialization File
3:                   
4:                     File Name:
5:                       initialization.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to initialize the system.
9:                   
10:                    Description:
11:                      This file contains source code necessary to initialize the system.  It
12:                      implements the "SYS_Initialize" function, defines the configuration bits,
13:                      and allocates any necessary global system resources,
14:                   *******************************************************************************/
15:                  
16:                  // DOM-IGNORE-BEGIN
17:                  /*******************************************************************************
18:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
19:                  *
20:                  * Subject to your compliance with these terms, you may use Microchip software
21:                  * and any derivatives exclusively with Microchip products. It is your
22:                  * responsibility to comply with third party license terms applicable to your
23:                  * use of third party software (including open source software) that may
24:                  * accompany Microchip software.
25:                  *
26:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
27:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
28:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
29:                  * PARTICULAR PURPOSE.
30:                  *
31:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
32:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
33:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
34:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
35:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
36:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
37:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
38:                   *******************************************************************************/
39:                  // DOM-IGNORE-END
40:                  
41:                  // *****************************************************************************
42:                  // *****************************************************************************
43:                  // Section: Included Files
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  #include "configuration.h"
47:                  #include "definitions.h"
48:                  #include "device.h"
49:                  
50:                  
51:                  
52:                  // ****************************************************************************
53:                  // ****************************************************************************
54:                  // Section: Configuration Bits
55:                  // ****************************************************************************
56:                  // ****************************************************************************
57:                  
58:                  /*** DEVCFG0 ***/
59:                  #pragma config DEBUG =      OFF
60:                  #pragma config JTAGEN =     OFF
61:                  #pragma config ICESEL =     ICS_PGx1
62:                  #pragma config PWP =        OFF
63:                  #pragma config BWP =        OFF
64:                  #pragma config CP =         OFF
65:                  #pragma config SMCLR =      MCLR_NORM
66:                  
67:                  
68:                  /*** DEVCFG1 ***/
69:                  #pragma config FNOSC =      SPLL
70:                  #pragma config FPBDIV =     DIV_1
71:                  #pragma config FSOSCEN =    OFF
72:                  #pragma config IESO =       ON
73:                  #pragma config POSCMOD =    EC
74:                  #pragma config OSCIOFNC =   OFF
75:                  #pragma config FCKSM =      CSDCMD
76:                  #pragma config WDTPS =      PS1048576
77:                  #pragma config WDTSPGM =    ON
78:                  #pragma config FWDTEN =     OFF
79:                  #pragma config WINDIS =     OFF
80:                  #pragma config FWDTWINSZ =  WINSZ_25
81:                  
82:                  
83:                  /*** DEVCFG2 ***/
84:                  #pragma config BOREN =    ON
85:                  #pragma config FPLLIDIV =   DIV_2
86:                  #pragma config FPLLICLK =   PLL_POSC
87:                  #pragma config FPLLMUL =    MUL_18
88:                  #pragma config FPLLODIV =   DIV_1
89:                  #pragma config DSBOREN =    ON
90:                  #pragma config DSWDTPS =    DSPS32
91:                  #pragma config DSWDTOSC =   LPRC
92:                  #pragma config DSWDTEN =    OFF
93:                  #pragma config FDSEN =      ON
94:                  #pragma config UPLLEN =     ON
95:                  #pragma config UPLLIDIV =   DIV_2
96:                  
97:                  /*** DEVCFG3 ***/
98:                  #pragma config AI2C1 =      OFF
99:                  #pragma config AI2C2 =      OFF
100:                 #pragma config USERID =     0xffff
101:                 #pragma config PMDL1WAY =   ON
102:                 #pragma config IOL1WAY =    ON
103:                 #pragma config FUSBIDIO =   ON
104:                 
105:                 
106:                 
107:                 
108:                 
109:                 // *****************************************************************************
110:                 // *****************************************************************************
111:                 // Section: Driver Initialization Data
112:                 // *****************************************************************************
113:                 // *****************************************************************************
114:                 
115:                 
116:                 // *****************************************************************************
117:                 // *****************************************************************************
118:                 // Section: System Data
119:                 // *****************************************************************************
120:                 // *****************************************************************************
121:                 /* Structure to hold the object handles for the modules in the system. */
122:                 SYSTEM_OBJECTS sysObj;
123:                 
124:                 // *****************************************************************************
125:                 // *****************************************************************************
126:                 // Section: Library/Stack Initialization Data
127:                 // *****************************************************************************
128:                 // *****************************************************************************
129:                 /******************************************************
130:                  * USB Driver Initialization
131:                  ******************************************************/
132:                  
133:                 uint8_t __attribute__((aligned(512))) endPointTable1[DRV_USBFS_ENDPOINTS_NUMBER * 32];
134:                 
135:                 
136:                 const DRV_USBFS_INIT drvUSBFSInit =
137:                 {
138:                 	 /* Assign the endpoint table */
139:                     .endpointTable= endPointTable1,
140:                 
141:                 
142:                 	/* Interrupt Source for USB module */
143:                 	.interruptSource = INT_SOURCE_USB,
144:                 
145:                 
146:                     
147:                     /* USB Controller to operate as USB Device */
148:                     .operationMode = DRV_USBFS_OPMODE_DEVICE,
149:                 	
150:                 	.operationSpeed = USB_SPEED_FULL,
151:                  
152:                 	/* Stop in idle */
153:                     .stopInIdle = false,
154:                 	
155:                 	    /* Suspend in sleep */
156:                     .suspendInSleep = false,
157:                  
158:                     /* Identifies peripheral (PLIB-level) ID */
159:                     .usbID = USB_ID_1,
160:                 	
161:                 
162:                 };
163:                 
164:                 
165:                 
166:                 
167:                 
168:                 
169:                 
170:                 
171:                 // *****************************************************************************
172:                 // *****************************************************************************
173:                 // Section: System Initialization
174:                 // *****************************************************************************
175:                 // *****************************************************************************
176:                 
177:                 
178:                 
179:                 // *****************************************************************************
180:                 // *****************************************************************************
181:                 // Section: Local initialization functions
182:                 // *****************************************************************************
183:                 // *****************************************************************************
184:                 
185:                 
186:                 
187:                 /*******************************************************************************
188:                   Function:
189:                     void SYS_Initialize ( void *data )
190:                 
191:                   Summary:
192:                     Initializes the board, services, drivers, application and other modules.
193:                 
194:                   Remarks:
195:                  */
196:                 
197:                 void SYS_Initialize ( void* data )
198:                 {
199:                     /* MISRAC 2012 deviation block start */
200:                     /* MISRA C-2012 Rule 2.2 deviated in this file.  Deviation record ID -  H3_MISRAC_2012_R_2_2_DR_1 */
201:                 
202:                     /* Start out with interrupts disabled before configuring any modules */
203:                     __builtin_disable_interrupts();
204:                 
205:                   
206:                     CLK_Initialize();
207:                 
208:                     /* Configure KSEG0 as cacheable memory. This is needed for Prefetch Buffer */
209:                     __builtin_mtc0(16, 0,(__builtin_mfc0(16, 0) | 0x3));
210:                 
211:                     /* Configure Flash Wait States and Prefetch */
212:                     CHECONbits.PFMWS = 3;
213:                     CHECONbits.PREFEN = 3;
214:                 
215:                     /* Set the SRAM wait states to One */
216:                     BMXCONbits.BMXWSDRM = 1;
217:                 
218:                 
219:                 
220:                 
221:                 	GPIO_Initialize();
222:                 	POWER_Initialize();
223:                 
224:                 
225:                     ADC_Initialize();
226:                 
227:                     NVM_Initialize();
228:                 
229:                     CORETIMER_Initialize();
230:                 	UART1_Initialize();
231:                 
232:                 	UART2_Initialize();
233:                 
234:                     TMR2_Initialize();
235:                 
236:                 
237:                 	SPI1_Initialize();
238:                 
239:                 
240:                 
241:                 
242:                 
243:                     /* Initialize the USB device layer */
244:                     sysObj.usbDevObject0 = USB_DEVICE_Initialize (USB_DEVICE_INDEX_0 , ( SYS_MODULE_INIT* ) & usbDevInitData);
245:                 
246:                 
247:                 	/* Initialize USB Driver */ 
248:                     sysObj.drvUSBFSObject = DRV_USBFS_Initialize(DRV_USBFS_INDEX_0, (SYS_MODULE_INIT *) &drvUSBFSInit);	
249:                 
250:                 
251:                     APP_Initialize();
252:                     APP_USB_Initialize();
253:                     APP_BLE_Initialize();
254:                     APP_X1TXO_Initialize();
255:                 
256:                 
257:                     EVIC_Initialize();
258:                 
259:                 	/* Enable global interrupts */
260:                     __builtin_enable_interrupts();
261:                 
262:                 
263:                     /* MISRAC 2012 deviation block end */
264:                 }
265:                 
266:                 
267:                 /*******************************************************************************
268:                  End of File
269:                 */
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0151FC  27BDFFE8   ADDIU SP, SP, -24
9D015200  AFBF0014   SW RA, 20(SP)
9D015204  AFB00010   SW S0, 16(SP)
9D015208  41626000   DI V0
9D01520C  000000C0   EHB
9D015210  0F406096   JAL CLK_Initialize
9D015214  00000000   NOP
9D015218  40028000   MFC0 V0, Config
9D01521C  34420003   ORI V0, V0, 3
9D015220  40828000   MTC0 V0, Config
9D015224  000000C0   EHB
9D015228  3C02BF88   LUI V0, -16504
9D01522C  8C434000   LW V1, 16384(V0)
9D015230  24040003   ADDIU A0, ZERO, 3
9D015234  27908028   ADDIU S0, GP, -32728
9D015238  7C831004   INS V1, A0, 0, 3
9D01523C  AC434000   SW V1, 16384(V0)
9D015240  8C434000   LW V1, 16384(V0)
9D015244  7C832904   INS V1, A0, 4, 2
9D015248  AC434000   SW V1, 16384(V0)
9D01524C  8C432000   LW V1, 8192(V0)
9D015250  24040001   ADDIU A0, ZERO, 1
9D015254  7C833184   INS V1, A0, 6, 1
9D015258  AC432000   SW V1, 8192(V0)
9D01525C  0F405CB4   JAL GPIO_Initialize
9D015260  00000000   NOP
9D015264  0F406175   JAL POWER_Initialize
9D015268  00000000   NOP
9D01526C  0F406135   JAL ADC_Initialize
9D015270  00000000   NOP
9D015274  0F405CD6   JAL NVM_Initialize
9D015278  00000000   NOP
9D01527C  0F406145   JAL CORETIMER_Initialize
9D015280  00000000   NOP
9D015284  0F405856   JAL UART1_Initialize
9D015288  00000000   NOP
9D01528C  0F405888   JAL UART2_Initialize
9D015290  00000000   NOP
9D015294  0F406205   JAL TMR2_Initialize
9D015298  00000000   NOP
9D01529C  0F405ECD   JAL SPI1_Initialize
9D0152A0  00000000   NOP
9D0152A4  3C059D02   LUI A1, -25342
9D0152A8  24A588E4   ADDIU A1, A1, -30492
9D0152AC  0F404FBF   JAL USB_DEVICE_Initialize
9D0152B0  00002025   OR A0, ZERO, ZERO
9D0152B4  3C059D02   LUI A1, -25342
9D0152B8  24A58ACC   ADDIU A1, A1, -30004
9D0152BC  00002025   OR A0, ZERO, ZERO
9D0152C0  0F404F73   JAL DRV_USBFS_Initialize
9D0152C4  AE020000   SW V0, 0(S0)
9D0152C8  0F406343   JAL APP_Initialize
9D0152CC  AE020004   SW V0, 4(S0)
9D0152D0  0F4058BA   JAL APP_USB_Initialize
9D0152D4  00000000   NOP
9D0152D8  0F405E4A   JAL APP_BLE_Initialize
9D0152DC  00000000   NOP
9D0152E0  0F402CDA   JAL APP_X1TXO_Initialize
9D0152E4  00000000   NOP
9D0152E8  0F4061C0   JAL EVIC_Initialize
9D0152EC  00000000   NOP
9D0152F0  41626020   EI V0
9D0152F4  8FBF0014   LW RA, 20(SP)
9D0152F8  8FB00010   LW S0, 16(SP)
9D0152FC  03E00008   JR RA
9D015300  27BD0018   ADDIU SP, SP, 24
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/exceptions.c  ------------------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Exceptions Source File
3:                   
4:                     File Name:
5:                       exceptions.c
6:                   
7:                     Summary:
8:                       This file contains a function which overrides the default _weak_ exception
9:                       handler provided by the XC32 compiler.
10:                  
11:                    Description:
12:                      This file redefines the default _weak_  exception handler with a more debug
13:                      friendly one. If an unexpected exception occurs the code will stop in a
14:                      while(1) loop.  The debugger can be halted and two variables _excep_code and
15:                      _except_addr can be examined to determine the cause and address where the
16:                      exception occurred.
17:                   *******************************************************************************/
18:                  
19:                  // DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
22:                  *
23:                  * Subject to your compliance with these terms, you may use Microchip software
24:                  * and any derivatives exclusively with Microchip products. It is your
25:                  * responsibility to comply with third party license terms applicable to your
26:                  * use of third party software (including open source software) that may
27:                  * accompany Microchip software.
28:                  *
29:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
31:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
32:                  * PARTICULAR PURPOSE.
33:                  *
34:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                  *******************************************************************************/
42:                  // DOM-IGNORE-END
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Section: Included Files
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  #include "configuration.h"
50:                  #include "device.h"
51:                  #include "definitions.h"
52:                  #include <stdio.h>
53:                  
54:                  
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  // Section: Global Data Definitions
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  
61:                  /*******************************************************************************
62:                    Exception Reason Data
63:                  
64:                    <editor-fold defaultstate="expanded" desc="Exception Reason Data">
65:                  
66:                    Remarks:
67:                      These global static items are used instead of local variables in the
68:                      _general_exception_handler function because the stack may not be available
69:                      if an exception has occured.
70:                  */
71:                  
72:                  /* Address of instruction that caused the exception. */
73:                  static unsigned int _excep_addr;
74:                  
75:                  /* Enum identifying the cause */
76:                  typedef enum {
77:                      EXCEP_IRQ      =  0, // interrupt
78:                      EXCEP_AdEL     =  4, // address error exception (load or ifetch)
79:                      EXCEP_AdES     =  5, // address error exception (store)
80:                      EXCEP_IBE      =  6, // bus error (ifetch)
81:                      EXCEP_DBE      =  7, // bus error (load/store)
82:                      EXCEP_Sys      =  8, // syscall
83:                      EXCEP_Bp       =  9, // breakpoint
84:                      EXCEP_RI       = 10, // reserved instruction
85:                      EXCEP_CpU      = 11, // coprocessor unusable
86:                      EXCEP_Overflow = 12, // arithmetic overflow
87:                      EXCEP_Trap     = 13, // trap (possible divide by zero)
88:                      EXCEP_IS1      = 16, // implementation specfic 1
89:                      EXCEP_CEU      = 17, // CorExtend Unuseable
90:                      EXCEP_C2E      = 18, // coprocessor 2
91:                  } excep_code;
92:                  
93:                  /* Code identifying the cause of the exception (CP0 Cause register). */
94:                  static excep_code _excep_code;
95:                  
96:                  // </editor-fold>
97:                  
98:                  /*******************************************************************************
99:                    Function:
100:                     void _general_exception_handler ( void )
101:                 
102:                   Description:
103:                     A general exception is any non-interrupt exception which occurs during program
104:                     execution outside of bootstrap code.
105:                 
106:                   Remarks:
107:                     Refer to the XC32 User's Guide for additional information.
108:                  */
109:                 
110:                 void __attribute__((noreturn)) _general_exception_handler ( void )
111:                 {
112:                     /* Mask off the ExcCode Field from the Cause Register
113:                     Refer to the MIPs Software User's manual */
114:                     _excep_code = (_CP0_GET_CAUSE() & 0x0000007C) >> 2;
115:                     _excep_addr = _CP0_GET_EPC();
116:                 
117:                     while (1)
118:                     {
119:                         #if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
120:                             __builtin_software_breakpoint();
121:                         #endif
122:                     }
123:                 }
124:                 
125:                 /*******************************************************************************
126:                   Function:
127:                     void _bootstrap_exception_handler ( void )
128:                 
129:                   Description:
130:                     A bootstrap exception is any exception which occurs while bootstrap code is
131:                     running (STATUS.BEV bit is 1).
132:                 
133:                   Remarks:
134:                     Refer to the XC32 User's Guide for additional information.
135:                  */
136:                 
137:                 void __attribute__((noreturn)) _bootstrap_exception_handler(void)
138:                 {
139:                     /* Mask off the ExcCode Field from the Cause Register
140:                     Refer to the MIPs Software User's manual */
141:                     _excep_code = (_CP0_GET_CAUSE() & 0x0000007C) >> 2;
142:                     _excep_addr = _CP0_GET_EPC();
143:                 
144:                     while (1)
145:                     {
146:                         #if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
147:                             __builtin_software_breakpoint();
148:                         #endif
149:                     }
150:                 }
151:                 /*******************************************************************************
152:                  End of File
153:                 */
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D018E64  27BDFFF8   ADDIU SP, SP, -8
9D018E68  AFBF0004   SW RA, 4(SP)
9D018E6C  40026800   MFC0 V0, Cause
9D018E70  40027000   MFC0 V0, EPC
9D018E74  7000003F   SDBBP 0
9D018E78  7000003F   SDBBP 0
9D018E7C  1000FFFD   BEQ ZERO, ZERO, 0x9D018E74
9D018E80  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_stopinidle_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_StopInIdle_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : StopInIdle
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_StopInIdleEnable
16:                          PLIB_USB_StopInIdleDisable
17:                          PLIB_USB_ExistsStopInIdle
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_STOPINIDLE_DEFAULT_H
48:                  #define _USB_STOPINIDLE_DEFAULT_H
49:                  
50:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
51:                  //******************************************************************************
52:                  /* Function :  USB_StopInIdleEnable_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_USB_StopInIdleEnable 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_USB_StopInIdleEnable function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void USB_StopInIdleEnable_Default( USB_MODULE_ID index )
62:                  {
63:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
64:                      usb->UxCNFG1.USBSIDL = 1;
65:                     
66:                  }
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USB_StopInIdleDisable_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_USB_StopInIdleDisable 
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_USB_StopInIdleDisable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void USB_StopInIdleDisable_Default( USB_MODULE_ID index )
79:                  {
80:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
81:                      usb->UxCNFG1.USBSIDL = 0;
82:                  }
83:                  
84:                  //******************************************************************************
85:                  /* Function :  USB_ExistsStopInIdle_Default
86:                  
87:                    Summary:
88:                      Implements Default variant of PLIB_USB_ExistsStopInIdle
89:                  
90:                    Description:
91:                      This template implements the Default variant of the PLIB_USB_ExistsStopInIdle function.
92:                  */
93:                  
94:                  #define PLIB_USB_ExistsStopInIdle PLIB_USB_ExistsStopInIdle
95:                  PLIB_TEMPLATE bool USB_ExistsStopInIdle_Default( USB_MODULE_ID index )
96:                  {
97:                      return true;
98:                  }
99:                  
100:                 
101:                 #endif /*_USB_STOPINIDLE_DEFAULT_H*/
102:                 
103:                 /******************************************************************************
104:                  End of File
105:                 */
106:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D013E50  922202A0   LBU V0, 672(S1)
9D013E5C  7C622104   INS V0, V1, 4, 1
9D013E60  A22202A0   SB V0, 672(S1)
9D013E64  90A20009   LBU V0, 9(A1)
9D013E68  1040001D   BEQ V0, ZERO, DRV_USBFS_Initialize::PLIB_USB_AutoSuspendDisable
9D013E6C  24020001   ADDIU V0, ZERO, 1
9D013ED0  A22202A0   SB V0, 672(S1)
9D013ED4  90A20009   LBU V0, 9(A1)
9D013ED8  1440FFE5   BNE V0, ZERO, DRV_USBFS_Initialize::PLIB_USB_AutoSuspendEnable
9D013EDC  24020001   ADDIU V0, ZERO, 1
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_resumesignaling_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_ResumeSignaling_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ResumeSignaling
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_ResumeSignalingEnable
16:                          PLIB_USB_ResumeSignalingDisable
17:                          PLIB_USB_ExistsResumeSignaling
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_RESUMESIGNALING_DEFAULT_H
48:                  #define _USB_RESUMESIGNALING_DEFAULT_H
49:                  
50:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_ResumeSignalingEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_ResumeSignalingEnable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_ResumeSignalingEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void USB_ResumeSignalingEnable_Default( USB_MODULE_ID index )
64:                  {
65:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
66:                  	usb->UxCON.w |=  UxCON_RESUME_MASK ;
67:                     
68:                  }
69:                  
70:                  //******************************************************************************
71:                  /* Function :  USB_ResumeSignalingDisable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_USB_ResumeSignalingDisable 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_USB_ResumeSignalingDisable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void USB_ResumeSignalingDisable_Default( USB_MODULE_ID index )
81:                  {
82:                  
83:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
84:                  	usb->UxCON.w &= ( ~ UxCON_RESUME_MASK);
85:                    
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  USB_ExistsResumeSignaling_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_USB_ExistsResumeSignaling
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_USB_ExistsResumeSignaling function.
97:                  */
98:                  
99:                  #define PLIB_USB_ExistsResumeSignaling PLIB_USB_ExistsResumeSignaling
100:                 PLIB_TEMPLATE bool USB_ExistsResumeSignaling_Default( USB_MODULE_ID index )
101:                 {
102:                     return true;
103:                 }
104:                 
105:                 
106:                 #endif /*_USB_RESUMESIGNALING_DEFAULT_H*/
107:                 
108:                 /******************************************************************************
109:                  End of File
110:                 */
111:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D018BB4  8C830020   LW V1, 32(A0)
9D018BB8  8C620210   LW V0, 528(V1)
9D018BC4  03E00008   JR RA
9D018BDC  8C830020   LW V1, 32(A0)
9D018BE0  8C620210   LW V0, 528(V1)
9D018BEC  03E00008   JR RA
9D018BF0  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_packettransfer_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_PacketTransfer_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PacketTransfer
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_PacketTransferIsDisabled
16:                          PLIB_USB_PacketTransferEnable
17:                          PLIB_USB_ExistsPacketTransfer
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_PACKETTRANSFER_DEFAULT_H
48:                  #define _USB_PACKETTRANSFER_DEFAULT_H
49:                  
50:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_PacketTransferIsDisabled_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_PacketTransferIsDisabled 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_PacketTransferIsDisabled function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE bool USB_PacketTransferIsDisabled_Default( USB_MODULE_ID index )
64:                  {
65:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
66:                      return ( usb->UxCON.UxCONbits.PKTDIS_TOKBUSY );
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_PacketTransferEnable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_PacketTransferEnable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USB_PacketTransferEnable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USB_PacketTransferEnable_Default( USB_MODULE_ID index )
80:                  {
81:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
82:                      usb->UxCON.UxCONbits.TOKBUSY = 0;
83:                      
84:                  }
85:                  
86:                  //******************************************************************************
87:                  /* Function :  USB_PacketTransferDisable_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_USB_PacketTransferDisable 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_USB_PacketTransferDisable function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE void USB_PacketTransferDisable_Default( USB_MODULE_ID index )
97:                  {
98:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
99:                      usb->UxCON.UxCONbits.TOKBUSY = 1;
100:                    
101:                 }
102:                 
103:                 //******************************************************************************
104:                 /* Function :  USB_ExistsPacketTransfer_Default
105:                 
106:                   Summary:
107:                     Implements Default variant of PLIB_USB_ExistsPacketTransfer
108:                 
109:                   Description:
110:                     This template implements the Default variant of the PLIB_USB_ExistsPacketTransfer function.
111:                 */
112:                 
113:                 #define PLIB_USB_ExistsPacketTransfer PLIB_USB_ExistsPacketTransfer
114:                 PLIB_TEMPLATE bool USB_ExistsPacketTransfer_Default( USB_MODULE_ID index )
115:                 {
116:                     return true;
117:                 }
118:                 
119:                 
120:                 #endif /*_USB_PACKETTRANSFER_DEFAULT_H*/
121:                 
122:                 /******************************************************************************
123:                  End of File
124:                 */
125:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00E600  92040210   LBU A0, 528(S0)
9D00E60C  7C042944   INS A0, ZERO, 5, 1
9D00E618  A2040210   SB A0, 528(S0)
9D00E61C  A3C00000   SB ZERO, 0(FP)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_otg_sessionvalid_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_OTG_SessionValid_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OTG_SessionValid
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_OTG_SessionValid
16:                          PLIB_USB_ExistsOTG_SessionValid
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_OTG_SESSIONVALID_DEFAULT_H
47:                  #define _USB_OTG_SESSIONVALID_DEFAULT_H
48:                  
49:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
50:                  
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USB_OTG_SessionValid_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USB_OTG_SessionValid 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USB_OTG_SessionValid function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE bool USB_OTG_SessionValid_Default( USB_MODULE_ID index )
63:                  {
64:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
65:                  	return ( usb->UxOTGSTAT.SESVD );
66:                  }
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USB_ExistsOTG_SessionValid_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_USB_ExistsOTG_SessionValid
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_USB_ExistsOTG_SessionValid function.
76:                  */
77:                  
78:                  #define PLIB_USB_ExistsOTG_SessionValid PLIB_USB_ExistsOTG_SessionValid
79:                  PLIB_TEMPLATE bool USB_ExistsOTG_SessionValid_Default( USB_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  #endif /*_USB_OTG_SESSIONVALID_DEFAULT_H*/
86:                  
87:                  /******************************************************************************
88:                   End of File
89:                  */
90:                  
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00E4F0  8E020020   LW V0, 32(S0)
9D00E4F8  14400024   BNE V0, ZERO, 0x9D00E58C
9D00E4FC  8C820010   LW V0, 16(A0)
9D00E500  A0800002   SB ZERO, 2(A0)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_otg_interruptstatus_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_OTG_InterruptStatus_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OTG_InterruptStatus
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_OTG_InterruptFlagSet
16:                          PLIB_USB_OTG_InterruptFlagClear
17:                          PLIB_USB_OTG_InterruptFlagGet
18:                          PLIB_USB_ExistsOTG_InterruptStatus
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USB_OTG_INTERRUPTSTATUS_DEFAULT_H
49:                  #define _USB_OTG_INTERRUPTSTATUS_DEFAULT_H
50:                  
51:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_OTG_InterruptFlagSet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_OTG_InterruptFlagSet 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptFlagSet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void USB_OTG_InterruptFlagSet_Default( USB_MODULE_ID index , USB_OTG_INTERRUPTS     interruptFlag )
64:                  {
65:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
66:                  	usb->UxOTGIR.w  |= interruptFlag ;
67:                      
68:                  }
69:                  
70:                  //******************************************************************************
71:                  /* Function :  USB_OTG_InterruptFlagClear_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_USB_OTG_InterruptFlagClear 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptFlagClear function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void USB_OTG_InterruptFlagClear_Default( USB_MODULE_ID index , USB_OTG_INTERRUPTS     interruptFlag )
81:                  {
82:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
83:                  	usb->UxOTGIR.w = interruptFlag ;
84:                  
85:                  }
86:                  
87:                  //******************************************************************************
88:                  /* Function :  USB_OTG_InterruptFlagGet_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_USB_OTG_InterruptFlagGet 
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptFlagGet function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE bool USB_OTG_InterruptFlagGet_Default( USB_MODULE_ID index , USB_OTG_INTERRUPTS     interruptFlag )
98:                  {
99:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
100:                     return (  ( ( ( usb->UxOTGIR.w  ) & ( interruptFlag) )) ? 1 : 0 );
101:                 }
102:                 
103:                 
104:                 //******************************************************************************
105:                 /* Function :  USB_ExistsOTG_InterruptStatus_Default
106:                 
107:                   Summary:
108:                     Implements Default variant of PLIB_USB_ExistsOTG_InterruptStatus
109:                 
110:                   Description:
111:                     This template implements the Default variant of the PLIB_USB_ExistsOTG_InterruptStatus function.
112:                 */
113:                 
114:                 #define PLIB_USB_ExistsOTG_InterruptStatus PLIB_USB_ExistsOTG_InterruptStatus
115:                 PLIB_TEMPLATE bool USB_ExistsOTG_InterruptStatus_Default( USB_MODULE_ID index )
116:                 {
117:                     return true;
118:                 }
119:                 
120:                 
121:                 #endif /*_USB_OTG_INTERRUPTSTATUS_DEFAULT_H*/
122:                 
123:                 /******************************************************************************
124:                  End of File
125:                 */
126:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00E0E0  8C900020   LW S0, 32(A0)
9D00E0EC  8E020000   LW V0, 0(S0)
9D00E0F8  30420008   ANDI V0, V0, 8
9D00E110  10400005   BEQ V0, ZERO, 0x9D00E128
9D00E114  00809025   OR S2, A0, ZERO
9D00E148  240200F5   ADDIU V0, ZERO, 245
9D00E150  8FBF004C   LW RA, 76(SP)
9D00E154  8FBE0048   LW FP, 72(SP)
9D00E158  8FB70044   LW S7, 68(SP)
9D00E15C  8FB60040   LW S6, 64(SP)
9D00E160  8FB5003C   LW S5, 60(SP)
9D00E164  8FB40038   LW S4, 56(SP)
9D00E168  8FB30034   LW S3, 52(SP)
9D00E16C  8FB20030   LW S2, 48(SP)
9D00E180  8E020000   LW V0, 0(S0)
9D00E184  30420010   ANDI V0, V0, 16
9D00E1A0  AE020000   SW V0, 0(S0)
9D00E1A4  8E020010   LW V0, 16(S0)
9D00E518  24030008   ADDIU V1, ZERO, 8
9D00E51C  92420002   LBU V0, 2(S2)
9D00E520  AE030000   SW V1, 0(S0)
9D00E524  1000FF01   BEQ ZERO, ZERO, 0x9D00E12C
9D00E528  00000000   NOP
9D00E52C  8E45001C   LW A1, 28(S2)
9D00E59C  AE050000   SW A1, 0(S0)
9D00E5A0  1000FEE5   BEQ ZERO, ZERO, 0x9D00E138
9D00E718  24020008   ADDIU V0, ZERO, 8
9D00E720  1000FE87   BEQ ZERO, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_ErrorInterruptFlagClear
9D00E724  240200FF   ADDIU V0, ZERO, 255
9D01769C  240300F5   ADDIU V1, ZERO, 245
9D0176A4  8C430010   LW V1, 16(V0)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_otg_interrupt_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_OTG_Interrupt_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OTG_Interrupt
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_OTG_InterruptEnable
16:                          PLIB_USB_OTG_InterruptDisable
17:                          PLIB_USB_OTG_InterruptIsEnabled
18:                          PLIB_USB_ExistsOTG_Interrupt
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USB_OTG_INTERRUPT_DEFAULT_H
49:                  #define _USB_OTG_INTERRUPT_DEFAULT_H
50:                  
51:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_OTG_InterruptEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_OTG_InterruptEnable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void USB_OTG_InterruptEnable_Default( USB_MODULE_ID index , USB_OTG_INTERRUPTS     interruptFlag )
64:                  {
65:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
66:                  	usb->UxOTGIE.w   |= interruptFlag;
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_OTG_InterruptDisable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_OTG_InterruptDisable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptDisable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USB_OTG_InterruptDisable_Default( USB_MODULE_ID index , USB_OTG_INTERRUPTS     interruptFlag )
80:                  {
81:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
82:                      usb->UxOTGIE.w   &= (~interruptFlag);
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  USB_OTG_InterruptIsEnabled_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_USB_OTG_InterruptIsEnabled 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptIsEnabled function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE bool USB_OTG_InterruptIsEnabled_Default( USB_MODULE_ID index , USB_INTERRUPTS interruptFlag )
97:                  {   
98:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
99:                      return ( ( usb->UxOTGIE.w ) & interruptFlag ? 1 : 0 );
100:                 }
101:                 
102:                 
103:                 //******************************************************************************
104:                 /* Function :  USB_ExistsOTG_Interrupt_Default
105:                 
106:                   Summary:
107:                     Implements Default variant of PLIB_USB_ExistsOTG_Interrupt
108:                 
109:                   Description:
110:                     This template implements the Default variant of the PLIB_USB_ExistsOTG_Interrupt function.
111:                 */
112:                 
113:                 #define PLIB_USB_ExistsOTG_Interrupt PLIB_USB_ExistsOTG_Interrupt
114:                 PLIB_TEMPLATE bool USB_ExistsOTG_Interrupt_Default( USB_MODULE_ID index )
115:                 {
116:                     return true;
117:                 }
118:                 
119:                 
120:                 #endif /*_USB_OTG_INTERRUPT_DEFAULT_H*/
121:                 
122:                 /******************************************************************************
123:                  End of File
124:                 */
125:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00E118  8E020010   LW V0, 16(S0)
9D00E11C  30420008   ANDI V0, V0, 8
9D00E190  8E020010   LW V0, 16(S0)
9D00E194  30420010   ANDI V0, V0, 16
9D00E1A4  8E020010   LW V0, 16(S0)
9D00E1AC  7C022104   INS V0, ZERO, 4, 1
9D00E1B0  AE020010   SW V0, 16(S0)
9D00E1B4  10600005   BEQ V1, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E1B8  A2400004   SB ZERO, 4(S2)
9D00E2FC  8E020010   LW V0, 16(S0)
9D00E308  8E0201D0   LW V0, 464(S0)
9D017680  2404FF0A   ADDIU A0, ZERO, -246
9D017684  7C033804   INS V1, ZERO, 0, 8
9D0176A4  8C430010   LW V1, 16(V0)
9D0176A8  00641824   AND V1, V1, A0
9D0176AC  AC430010   SW V1, 16(V0)
9D0176B0  90430210   LBU V1, 528(V0)
9D017F68  8C830020   LW V1, 32(A0)
9D017F6C  8C840028   LW A0, 40(A0)
9D017F70  8C620010   LW V0, 16(V1)
9D017F74  34420008   ORI V0, V0, 8
9D017F78  AC620010   SW V0, 16(V1)
9D017F7C  0B406307   J EVIC_SourceEnable
9D017F80  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_opmodeselect_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_OpModeSelect_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OpModeSelect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_OperatingModeSelect
16:                          PLIB_USB_ExistsOpModeSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_OPMODESELECT_DEFAULT_H
47:                  #define _USB_OPMODESELECT_DEFAULT_H
48:                  
49:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
50:                  
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USB_OperatingModeSelect_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USB_OperatingModeSelect
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USB_OperatingModeSelect function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void USB_OperatingModeSelect_Default( USB_MODULE_ID index , USB_OPMODES opMode )
63:                  {
64:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
65:                      usb->UxCON.UxCONbits.USBEN_SOFEN = 0;
66:                      usb->UxCON.UxCONbits.HOSTEN = 0 ;
67:                  	usb->UxOTGCON.OTGEN = 0;
68:                      switch ( opMode )
69:                      {
70:                          case USB_OPMODE_NONE:
71:                               break;
72:                  			
73:                          case USB_OPMODE_DEVICE:
74:                               usb->UxCON.UxCONbits.USBEN_SOFEN = 1; 
75:                              break;
76:                  
77:                          case USB_OPMODE_HOST:
78:                              usb->UxCON.UxCONbits.HOSTEN = 1 ;
79:                              break;
80:                  
81:                          case USB_OPMODE_OTG:
82:                              usb->UxOTGCON.OTGEN = 1;
83:                              break;
84:                  
85:                          default:
86:                              PLIB_ASSERT( 0, "In USB_OperatingModeSelect, unknown operating mode!" );
87:                              break;
88:                      }
89:                  }
90:                  
91:                  //******************************************************************************
92:                  /* Function :  USB_ExistsOpModeSelect_Default
93:                  
94:                    Summary:
95:                      Implements Default variant of PLIB_USB_ExistsOpModeSelect
96:                  
97:                    Description:
98:                      This template implements the Default variant of the PLIB_USB_ExistsOpModeSelect function.
99:                  */
100:                 
101:                 #define PLIB_USB_ExistsOpModeSelect PLIB_USB_ExistsOpModeSelect
102:                 PLIB_TEMPLATE bool USB_ExistsOpModeSelect_Default( USB_MODULE_ID index )
103:                 {
104:                     return true;
105:                 }
106:                 
107:                 
108:                 #endif /*_USB_OPMODESELECT_DEFAULT_H*/
109:                 
110:                 /******************************************************************************
111:                  End of File
112:                 */
113:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0176B0  90430210   LBU V1, 528(V0)
9D0176BC  90430210   LBU V1, 528(V0)
9D0176C8  90430030   LBU V1, 48(V0)
9D0176D4  03E00008   JR RA
9D0176D8  00000000   NOP
9D0178CC  8C820020   LW V0, 32(A0)
9D0178D4  90430210   LBU V1, 528(V0)
9D0178D8  24040001   ADDIU A0, ZERO, 1
9D0178DC  7C030004   INS V1, ZERO, 0, 1
9D0178E0  A0430210   SB V1, 528(V0)
9D0178E4  90430210   LBU V1, 528(V0)
9D0178E8  7C0318C4   INS V1, ZERO, 3, 1
9D0178EC  A0430210   SB V1, 528(V0)
9D0178F0  90430030   LBU V1, 48(V0)
9D0178F4  7C031084   INS V1, ZERO, 2, 1
9D0178F8  A0430030   SB V1, 48(V0)
9D0178FC  90430210   LBU V1, 528(V0)
9D017900  7C830004   INS V1, A0, 0, 1
9D017904  A0430210   SB V1, 528(V0)
9D017908  240300DF   ADDIU V1, ZERO, 223
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_modulepower_32bit16bit.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_ModulePower_32Bit16Bit.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ModulePower
13:                      and its Variant : 32Bit16Bit
14:                      For following APIs :
15:                          PLIB_USB_Enable
16:                          PLIB_USB_Disable
17:                          PLIB_USB_ExistsModulePower
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_MODULEPOWER_32BIT16BIT_H
48:                  #define _USB_MODULEPOWER_32BIT16BIT_H
49:                  
50:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_Enable_32Bit16Bit
55:                  
56:                    Summary:
57:                      Implements 32Bit16Bit variant of PLIB_USB_Enable 
58:                  
59:                    Description:
60:                      This template implements the 32Bit16Bit variant of the PLIB_USB_Enable function.
61:                  */
62:                  
63:                      
64:                  PLIB_TEMPLATE void USB_Enable_32Bit16Bit( USB_MODULE_ID index )
65:                  {
66:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
67:                  	usb->UxPWRC.USBPWR = 1;
68:                      
69:                  }
70:                  
71:                  //******************************************************************************
72:                  /* Function :  USB_Disable_32Bit16Bit
73:                  
74:                    Summary:
75:                      Implements 32Bit16Bit variant of PLIB_USB_Disable 
76:                  
77:                    Description:
78:                      This template implements the 32Bit16Bit variant of the PLIB_USB_Disable function.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void USB_Disable_32Bit16Bit( USB_MODULE_ID index )
82:                  {
83:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
84:                  	usb->UxPWRC.USBPWR = 0 ;
85:                   
86:                  }
87:                  
88:                  //******************************************************************************
89:                  /* Function :  USB_ExistsModulePower_32Bit16Bit
90:                  
91:                    Summary:
92:                      Implements 32Bit16Bit variant of PLIB_USB_ExistsModulePower
93:                  
94:                    Description:
95:                      This template implements the 32Bit16Bit variant of the PLIB_USB_ExistsModulePower function.
96:                  */
97:                  
98:                  #define PLIB_USB_ExistsModulePower PLIB_USB_ExistsModulePower
99:                  PLIB_TEMPLATE bool USB_ExistsModulePower_32Bit16Bit( USB_MODULE_ID index )
100:                 {
101:                     return true;
102:                 }
103:                 
104:                 
105:                 #endif /*_USB_MODULEPOWER_32BIT16BIT_H*/
106:                 
107:                 /******************************************************************************
108:                  End of File
109:                 */
110:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000050  00000000   NOP
00000054  00000000   NOP
0000005C  00000000   NOP
00000064  00000000   NOP
0000006C  00000000   NOP
9D013DF8  92270040   LBU A3, 64(S1)
9D013E18  7C670004   INS A3, V1, 0, 1
9D013E2C  A2270040   SB A3, 64(S1)
9D013E50  922202A0   LBU V0, 672(S1)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_lasttransactiondetails_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_LastTransactionDetails_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : LastTransactionDetails
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_LastTransactionDetailsGet
16:                          PLIB_USB_ExistsLastTransactionDetails
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_LASTTRANSACTIONDETAILS_DEFAULT_H
47:                  #define _USB_LASTTRANSACTIONDETAILS_DEFAULT_H
48:                  
49:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USB_LastTransactionDetailsGet_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_USB_LastTransactionDetailsGet 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_USB_LastTransactionDetailsGet function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void USB_LastTransactionDetailsGet_Default( USB_MODULE_ID index , USB_BUFFER_DIRECTION * direction , USB_PING_PONG_STATE * pingpong , uint8_t * endpoint )
62:                  {
63:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
64:                      *direction = ( USB_BUFFER_DIRECTION ) usb->UxSTAT.DIR;
65:                      *pingpong =  ( USB_PING_PONG_STATE )usb->UxSTAT.PPBI;
66:                      *endpoint = usb->UxSTAT.ENDPT;
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_ExistsLastTransactionDetails_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_ExistsLastTransactionDetails
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USB_ExistsLastTransactionDetails function.
77:                  */
78:                  
79:                  #define PLIB_USB_ExistsLastTransactionDetails PLIB_USB_ExistsLastTransactionDetails
80:                  PLIB_TEMPLATE bool USB_ExistsLastTransactionDetails_Default( USB_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  #endif /*_USB_LASTTRANSACTIONDETAILS_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00E448  8E110200   LW S1, 512(S0)
9D00E44C  8E040200   LW A0, 512(S0)
9D00E450  8E020200   LW V0, 512(S0)
9D00E454  7E3100C0   EXT S1, S1, 3, 1
9D00E458  7C840080   EXT A0, A0, 2, 1
9D00E45C  7C421900   EXT V0, V0, 4, 4
9D00E460  AE1401C0   SW S4, 448(S0)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_gen_interruptstatus_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_GEN_InterruptStatus_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : GEN_InterruptStatus
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_InterruptFlagSet
16:                          PLIB_USB_InterruptFlagClear
17:                          PLIB_USB_InterruptFlagGet
18:                          PLIB_USB_ExistsGEN_InterruptStatus
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USB_GEN_INTERRUPTSTATUS_DEFAULT_H
49:                  #define _USB_GEN_INTERRUPTSTATUS_DEFAULT_H
50:                  
51:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_InterruptFlagSet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_InterruptFlagSet 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_InterruptFlagSet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void USB_InterruptFlagSet_Default( USB_MODULE_ID index , USB_INTERRUPTS interruptFlag )
64:                  {
65:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
66:                      usb->UxIR.w  |= interruptFlag;
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_InterruptFlagClear_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_InterruptFlagClear 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USB_InterruptFlagClear function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USB_InterruptFlagClear_Default( USB_MODULE_ID index , USB_INTERRUPTS interruptFlag )
80:                  {
81:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
82:                  	usb->UxIR.w  = interruptFlag;
83:                  }
84:                  
85:                  //******************************************************************************
86:                  /* Function :  USB_InterruptFlagGet_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_USB_InterruptFlagGet 
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_USB_InterruptFlagGet function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE bool USB_InterruptFlagGet_Default( USB_MODULE_ID index , USB_INTERRUPTS interruptFlag )
96:                  {
97:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
98:                      return ( (( usb->UxIR.w ) & interruptFlag) ? 1 : 0 );
99:                  }
100:                 
101:                 //******************************************************************************
102:                 /* Function :  USB_InterruptFlagGet_Default
103:                 
104:                   Summary:
105:                     Implements Default variant of PLIB_USB_InterruptFlagAllGet 
106:                 
107:                   Description:
108:                     This template implements the Default variant of the PLIB_USB_InterruptFlagAllGet function.
109:                 */
110:                 
111:                 PLIB_TEMPLATE USB_INTERRUPTS USB_InterruptFlagAllGet_Default( USB_MODULE_ID index )
112:                 {
113:                 	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
114:                 	return (USB_INTERRUPTS) (  usb->UxIR.w ) ;
115:                 }
116:                 
117:                 //******************************************************************************
118:                 /* Function :  USB_ExistsGEN_InterruptStatus_Default
119:                 
120:                   Summary:
121:                     Implements Default variant of PLIB_USB_ExistsGEN_InterruptStatus
122:                 
123:                   Description:
124:                     This template implements the Default variant of the PLIB_USB_ExistsGEN_InterruptStatus function.
125:                 */
126:                 
127:                 #define PLIB_USB_ExistsGEN_InterruptStatus PLIB_USB_ExistsGEN_InterruptStatus
128:                 PLIB_TEMPLATE bool USB_ExistsGEN_InterruptStatus_Default( USB_MODULE_ID index )
129:                 {
130:                     return true;
131:                 }
132:                 
133:                 
134:                 #endif /*_USB_GEN_INTERRUPTSTATUS_DEFAULT_H*/
135:                 
136:                 /******************************************************************************
137:                  End of File
138:                 */
139:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00E144  AE0201C0   SW V0, 448(S0)
9D00E148  240200F5   ADDIU V0, ZERO, 245
9D00E1CC  8E0201C0   LW V0, 448(S0)
9D00E1D0  30420020   ANDI V0, V0, 32
9D00E208  24020020   ADDIU V0, ZERO, 32
9D00E210  8E0201D0   LW V0, 464(S0)
9D00E21C  8E0201C0   LW V0, 448(S0)
9D00E220  30420001   ANDI V0, V0, 1
9D00E244  AE0401C0   SW A0, 448(S0)
9D00E248  24040010   ADDIU A0, ZERO, 16
9D00E254  AC400000   SW ZERO, 0(V0)
9D00E2B4  24020001   ADDIU V0, ZERO, 1
9D00E2BC  8E0201C0   LW V0, 448(S0)
9D00E2C0  30420010   ANDI V0, V0, 16
9D00E2F4  24020010   ADDIU V0, ZERO, 16
9D00E2FC  8E020010   LW V0, 16(S0)
9D00E31C  8E0201C0   LW V0, 448(S0)
9D00E320  30420004   ANDI V0, V0, 4
9D00E354  24020004   ADDIU V0, ZERO, 4
9D00E35C  8E0201C0   LW V0, 448(S0)
9D00E360  30420080   ANDI V0, V0, 128
9D00E3C8  24020080   ADDIU V0, ZERO, 128
9D00E3D0  8E0201C0   LW V0, 448(S0)
9D00E3D4  30420002   ANDI V0, V0, 2
9D00E3E4  24140008   ADDIU S4, ZERO, 8
9D00E438  8E0201C0   LW V0, 448(S0)
9D00E43C  30420008   ANDI V0, V0, 8
9D00E460  AE1401C0   SW S4, 448(S0)
9D00E464  1080FFE3   BEQ A0, ZERO, 0x9D00E3F4
9D00E568  24020002   ADDIU V0, ZERO, 2
9D00E570  1060FF9B   BEQ V1, ZERO, 0x9D00E3E0
9D017670  8C820020   LW V0, 32(A0)
9D017678  AC4501C0   SW A1, 448(V0)
9D01767C  8C4301D0   LW V1, 464(V0)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_gen_interrupt_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_GEN_Interrupt_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : GEN_Interrupt
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_InterruptEnable
16:                          PLIB_USB_InterruptDisable
17:                          PLIB_USB_InterruptIsEnabled
18:                          PLIB_USB_ExistsGEN_Interrupt
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USB_GEN_INTERRUPT_DEFAULT_H
49:                  #define _USB_GEN_INTERRUPT_DEFAULT_H
50:                  
51:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_InterruptEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_InterruptEnable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_InterruptEnable
61:                      function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void USB_InterruptEnable_Default
65:                  ( 
66:                      USB_MODULE_ID index , 
67:                      USB_INTERRUPTS interruptFlag 
68:                  )
69:                  {
70:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
71:                  	usb->UxIE.w  |= interruptFlag ;
72:                  }
73:                  
74:                  //******************************************************************************
75:                  /* Function :  USB_InterruptDisable_Default
76:                  
77:                    Summary:
78:                      Implements Default variant of PLIB_USB_InterruptDisable 
79:                  
80:                    Description:
81:                      This template implements the Default variant of the
82:                      PLIB_USB_InterruptDisable function.
83:                  */
84:                  
85:                  PLIB_TEMPLATE void USB_InterruptDisable_Default
86:                  ( 
87:                      USB_MODULE_ID index , 
88:                      USB_INTERRUPTS interruptFlag 
89:                  )
90:                  {
91:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
92:                  	usb->UxIE.w &= (~interruptFlag);
93:                  }
94:                  
95:                  //******************************************************************************
96:                  /* Function :  USB_InterruptIsEnabled_Default
97:                  
98:                    Summary:
99:                      Implements Default variant of PLIB_USB_InterruptIsEnabled 
100:                 
101:                   Description:
102:                     This template implements the Default variant of the
103:                     PLIB_USB_InterruptIsEnabled function.
104:                 */
105:                 
106:                 PLIB_TEMPLATE bool USB_InterruptIsEnabled_Default
107:                 ( 
108:                     USB_MODULE_ID index , 
109:                     USB_INTERRUPTS interruptFlag 
110:                 )
111:                 {
112:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
113:                     return ( (usb->UxIE.w )  & interruptFlag ? 1 : 0 );
114:                 }
115:                 
116:                 //******************************************************************************
117:                 /* Function :  USB_ExistsGEN_Interrupt_Default
118:                 
119:                   Summary:
120:                     Implements Default variant of PLIB_USB_ExistsGEN_Interrupt
121:                 
122:                   Description:
123:                     This template implements the Default variant of the
124:                     PLIB_USB_ExistsGEN_Interrupt function.
125:                 */
126:                 
127:                 #define PLIB_USB_ExistsGEN_Interrupt PLIB_USB_ExistsGEN_Interrupt
128:                 PLIB_TEMPLATE bool USB_ExistsGEN_Interrupt_Default( USB_MODULE_ID index )
129:                 {
130:                     return true;
131:                 }
132:                 
133:                 #endif /*_USB_GEN_INTERRUPT_DEFAULT_H*/
134:                 
135:                 /******************************************************************************
136:                  End of File
137:                 */
138:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00E1DC  8E0201D0   LW V0, 464(S0)
9D00E1E0  30420020   ANDI V0, V0, 32
9D00E210  8E0201D0   LW V0, 464(S0)
9D00E21C  8E0201C0   LW V0, 448(S0)
9D00E22C  8E0201D0   LW V0, 464(S0)
9D00E230  30420001   ANDI V0, V0, 1
9D00E2CC  8E0201D0   LW V0, 464(S0)
9D00E2D0  30420010   ANDI V0, V0, 16
9D00E308  8E0201D0   LW V0, 464(S0)
9D00E30C  34420020   ORI V0, V0, 32
9D00E310  AE0201D0   SW V0, 464(S0)
9D00E314  24020001   ADDIU V0, ZERO, 1
9D00E32C  8E0201D0   LW V0, 464(S0)
9D00E330  30420004   ANDI V0, V0, 4
9D00E36C  8E0201D0   LW V0, 464(S0)
9D00E370  30420080   ANDI V0, V0, 128
9D00E548  8E0201D0   LW V0, 464(S0)
9D00E54C  30420002   ANDI V0, V0, 2
9D01767C  8C4301D0   LW V1, 464(V0)
9D017684  7C033804   INS V1, ZERO, 0, 8
9D017688  AC4301D0   SW V1, 464(V0)
9D01768C  AC4501E0   SW A1, 480(V0)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_framenumber_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_FrameNumber_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : FrameNumber
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_FrameNumberGet
16:                          PLIB_USB_ExistsFrameNumber
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_FRAMENUMBER_DEFAULT_H
47:                  #define _USB_FRAMENUMBER_DEFAULT_H
48:                  
49:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
50:                  
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USB_FrameNumberGet_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USB_FrameNumberGet 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USB_FrameNumberGet
60:                      function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE uint16_t USB_FrameNumberGet_Default( USB_MODULE_ID index )
64:                  {
65:                      uint16_t retval;
66:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
67:                  	retval =  (( usb->UxFRML.FRML ) |   ( usb->UxFRMH.FRMH << 8 ) );
68:                      return retval;
69:                  }
70:                  
71:                  //******************************************************************************
72:                  /* Function :  USB_ExistsFrameNumber_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_USB_ExistsFrameNumber
76:                  
77:                    Description:
78:                      This template implements the Default variant of the
79:                      PLIB_USB_ExistsFrameNumber function.
80:                  */
81:                  
82:                  #define PLIB_USB_ExistsFrameNumber PLIB_USB_ExistsFrameNumber
83:                  PLIB_TEMPLATE bool USB_ExistsFrameNumber_Default( USB_MODULE_ID index )
84:                  {
85:                      return true;
86:                  }
87:                  
88:                  #endif /*_USB_FRAMENUMBER_DEFAULT_H*/
89:                  
90:                  /******************************************************************************
91:                   End of File
92:                  */
93:                  
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D018990  8C830020   LW V1, 32(A0)
9D018994  90640240   LBU A0, 576(V1)
9D018998  8C620250   LW V0, 592(V1)
9D0189A0  00021200   SLL V0, V0, 8
9D0189A4  00441025   OR V0, V0, A0
9D0189A8  03E00008   JR RA
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_err_interruptstatus_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_ERR_InterruptStatus_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ERR_InterruptStatus
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_ErrorInterruptFlagSet
16:                          PLIB_USB_ErrorInterruptFlagClear
17:                          PLIB_USB_ErrorInterruptFlagGet
18:                          PLIB_USB_ExistsERR_InterruptStatus
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USB_ERR_INTERRUPTSTATUS_DEFAULT_H
49:                  #define _USB_ERR_INTERRUPTSTATUS_DEFAULT_H
50:                  
51:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_ErrorInterruptFlagSet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_ErrorInterruptFlagSet 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the
61:                      PLIB_USB_ErrorInterruptFlagSet function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void USB_ErrorInterruptFlagSet_Default
65:                  ( 
66:                      USB_MODULE_ID index , 
67:                      USB_ERROR_INTERRUPTS   interruptFlag 
68:                  )
69:                  {
70:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
71:                  	usb->UxEIR.w |=  interruptFlag ;
72:                     
73:                  }
74:                  
75:                  //******************************************************************************
76:                  /* Function :  USB_ErrorInterruptFlagClear_Default
77:                  
78:                    Summary:
79:                      Implements Default variant of PLIB_USB_ErrorInterruptFlagClear 
80:                  
81:                    Description:
82:                      This template implements the Default variant of the
83:                      PLIB_USB_ErrorInterruptFlagClear function.
84:                  */
85:                  
86:                  PLIB_TEMPLATE void USB_ErrorInterruptFlagClear_Default
87:                  ( 
88:                      USB_MODULE_ID index , 
89:                      USB_ERROR_INTERRUPTS interruptFlag 
90:                  )
91:                  {
92:                   	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
93:                  	usb->UxEIR.w = interruptFlag ;
94:                  }
95:                  
96:                  //******************************************************************************
97:                  /* Function :  USB_ErrorInterruptFlagGet_Default
98:                  
99:                    Summary:
100:                     Implements Default variant of PLIB_USB_ErrorInterruptFlagGet 
101:                 
102:                   Description:
103:                     This template implements the Default variant of the
104:                     PLIB_USB_ErrorInterruptFlagGet function.
105:                 */
106:                 
107:                 PLIB_TEMPLATE bool USB_ErrorInterruptFlagGet_Default
108:                 ( 
109:                     USB_MODULE_ID index , 
110:                     USB_ERROR_INTERRUPTS interruptFlag 
111:                 )
112:                 {
113:                 	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
114:                     return ( ( usb->UxEIR.w) & interruptFlag ? 1 : 0 );
115:                 }
116:                 
117:                 //******************************************************************************
118:                 /* Function :  USB_ErrorInterruptFlagAllGet_Default
119:                 
120:                   Summary:
121:                     Implements Default variant of PLIB_USB_ErrorInterruptFlagAllGet 
122:                 
123:                   Description:
124:                     This template implements the Default variant of the
125:                     PLIB_USB_ErrorInterruptFlagAllGet function.
126:                 */
127:                 
128:                 PLIB_TEMPLATE USB_ERROR_INTERRUPTS USB_ErrorInterruptFlagAllGet_Default( USB_MODULE_ID index )
129:                 {
130:                 	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
131:                     return (USB_ERROR_INTERRUPTS)( usb->UxEIR.w);
132:                 
133:                 }
134:                 
135:                 //******************************************************************************
136:                 /* Function :  USB_ExistsERR_InterruptStatus_Default
137:                 
138:                   Summary:
139:                     Implements Default variant of PLIB_USB_ExistsERR_InterruptStatus
140:                 
141:                   Description:
142:                     This template implements the Default variant of the
143:                     PLIB_USB_ExistsERR_InterruptStatus function.
144:                 */
145:                 
146:                 #define PLIB_USB_ExistsERR_InterruptStatus PLIB_USB_ExistsERR_InterruptStatus
147:                 PLIB_TEMPLATE bool USB_ExistsERR_InterruptStatus_Default( USB_MODULE_ID index )
148:                 {
149:                     return true;
150:                 }
151:                 
152:                 
153:                 #endif /*_USB_ERR_INTERRUPTSTATUS_DEFAULT_H*/
154:                 
155:                 /******************************************************************************
156:                  End of File
157:                 */
158:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00E140  AE0201E0   SW V0, 480(S0)
9D00E144  AE0201C0   SW V0, 448(S0)
9D00E558  8E0201E0   LW V0, 480(S0)
9D00E55C  8E430010   LW V1, 16(S2)
9D00E564  AE0201E0   SW V0, 480(S0)
9D00E568  24020002   ADDIU V0, ZERO, 2
9D00E720  1000FE87   BEQ ZERO, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_ErrorInterruptFlagClear
9D01768C  AC4501E0   SW A1, 480(V0)
9D017690  8C4301F0   LW V1, 496(V0)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_err_interrupt_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_ERR_Interrupt_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ERR_Interrupt
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_ErrorInterruptEnable
16:                          PLIB_USB_ErrorInterruptDisable
17:                          PLIB_USB_ErrorInterruptIsEnabled
18:                          PLIB_USB_ExistsERR_Interrupt
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USB_ERR_INTERRUPT_DEFAULT_H
49:                  #define _USB_ERR_INTERRUPT_DEFAULT_H
50:                  
51:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
52:                  
53:                  
54:                  //******************************************************************************
55:                  /* Function :  USB_ErrorInterruptEnable_Default
56:                  
57:                    Summary:
58:                      Implements Default variant of PLIB_USB_ErrorInterruptEnable 
59:                  
60:                    Description:
61:                      This template implements the Default variant of the
62:                      PLIB_USB_ErrorInterruptEnable function.
63:                  */
64:                  
65:                  PLIB_TEMPLATE void USB_ErrorInterruptEnable_Default
66:                  ( 
67:                      USB_MODULE_ID index , 
68:                      USB_ERROR_INTERRUPTS interruptFlag 
69:                  )
70:                  {
71:                       volatile usb_registers_t * usb = ((usb_registers_t *)(index));
72:                       usb->UxEIE.w |= interruptFlag ;
73:                   
74:                  }
75:                  //******************************************************************************
76:                  /* Function :  USB_ErrorInterruptDisable_Default
77:                  
78:                    Summary:
79:                      Implements Default variant of PLIB_USB_ErrorInterruptDisable 
80:                  
81:                    Description:
82:                      This template implements the Default variant of the
83:                      PLIB_USB_ErrorInterruptDisable function.
84:                  */
85:                  
86:                  PLIB_TEMPLATE void USB_ErrorInterruptDisable_Default
87:                  ( 
88:                      USB_MODULE_ID index , 
89:                      USB_ERROR_INTERRUPTS interruptFlag 
90:                  )
91:                  {
92:                  	volatile usb_registers_t * usb = ((usb_registers_t *)(index));
93:                  	usb->UxEIE.w &= (~ interruptFlag );
94:                  }
95:                  
96:                  //******************************************************************************
97:                  /* Function :  USB_ErrorInterruptIsEnabled_Default
98:                  
99:                    Summary:
100:                     Implements Default variant of PLIB_USB_ErrorInterruptIsEnabled 
101:                 
102:                   Description:
103:                     This template implements the Default variant of the
104:                     PLIB_USB_ErrorInterruptIsEnabled function.
105:                 */
106:                 
107:                 PLIB_TEMPLATE bool USB_ErrorInterruptIsEnabled_Default
108:                 ( 
109:                     USB_MODULE_ID index , 
110:                     USB_INTERRUPTS interruptFlag 
111:                 )
112:                 {
113:                 	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
114:                 	return ( ( usb->UxEIE.w) & interruptFlag ? 1 : 0 );
115:                 }
116:                 
117:                 //******************************************************************************
118:                 /* Function :  USB_ExistsERR_Interrupt_Default
119:                 
120:                   Summary:
121:                     Implements Default variant of PLIB_USB_ExistsERR_Interrupt
122:                 
123:                   Description:
124:                     This template implements the Default variant of the
125:                     PLIB_USB_ExistsERR_Interrupt function.
126:                 */
127:                 
128:                 #define PLIB_USB_ExistsERR_Interrupt PLIB_USB_ExistsERR_Interrupt
129:                 PLIB_TEMPLATE bool USB_ExistsERR_Interrupt_Default( USB_MODULE_ID index )
130:                 {
131:                     return true;
132:                 }
133:                 
134:                 
135:                 #endif /*_USB_ERR_INTERRUPT_DEFAULT_H*/
136:                 
137:                 /******************************************************************************
138:                  End of File
139:                 */
140:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D017690  8C4301F0   LW V1, 496(V0)
9D01769C  240300F5   ADDIU V1, ZERO, 245
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_epnrxenableenhanced_pic32.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_EPnRxEnableEnhanced_PIC32.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EPnRxEnableEnhanced
13:                      and its Variant : PIC32
14:                      For following APIs :
15:                          PLIB_USB_EPnRxEnable
16:                          PLIB_USB_ExistsEPnRxEnable
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_EPNRXENABLEENHANCED_PIC32_H
47:                  #define _USB_EPNRXENABLEENHANCED_PIC32_H
48:                  
49:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USB_EPnRxEnable_PIC32
53:                  
54:                    Summary:
55:                      Implements PIC32 variant of PLIB_USB_EPnRxEnable 
56:                  
57:                    Description:
58:                      This template implements the PIC32 variant of the PLIB_USB_EPnRxEnable
59:                      function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void USB_EPnRxEnable_PIC32
63:                  ( 
64:                      USB_MODULE_ID index , 
65:                      uint8_t endpoint 
66:                  )
67:                  {
68:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
69:                      usb->UxEP[endpoint].UxEPbits.EPRXEN = 1;
70:                  }
71:                  
72:                  //******************************************************************************
73:                  /* Function :  USB_EPnRxDisable_PIC32
74:                  
75:                    Summary:
76:                      Implements PIC32 variant of PLIB_USB_EPnRxDisable 
77:                  
78:                    Description:
79:                      This template implements the PIC32 variant of the PLIB_USB_EPnRxDisable
80:                      function.
81:                  */
82:                  
83:                  PLIB_TEMPLATE void USB_EPnRxDisable_PIC32
84:                  ( 
85:                      USB_MODULE_ID index , 
86:                      uint8_t endpoint 
87:                  )
88:                  {
89:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
90:                      usb->UxEP[endpoint].UxEPbits.EPRXEN = 0;
91:                  }
92:                  
93:                  //******************************************************************************
94:                  /* Function :  USB_EPnTxEnable_PIC32
95:                  
96:                    Summary:
97:                      Implements PIC32 variant of PLIB_USB_EPnTxEnable 
98:                  
99:                    Description:
100:                     This template implements the PIC32 variant of the PLIB_USB_EPnTxEnable
101:                     function.
102:                 */
103:                 
104:                 PLIB_TEMPLATE void USB_EPnTxEnable_PIC32
105:                 ( 
106:                     USB_MODULE_ID index , 
107:                     uint8_t endpoint 
108:                 )
109:                 {
110:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
111:                     usb->UxEP[endpoint].UxEPbits.EPTXEN = 1;
112:                 }
113:                 
114:                 //******************************************************************************
115:                 /* Function :  USB_EPnTxDisable_PIC32
116:                 
117:                   Summary:
118:                     Implements PIC32 variant of PLIB_USB_EPnTxDisable 
119:                 
120:                   Description:
121:                     This template implements the PIC32 variant of the PLIB_USB_EPnTxDisable
122:                     function.
123:                 */
124:                 
125:                 PLIB_TEMPLATE void USB_EPnTxDisable_PIC32
126:                 ( 
127:                     USB_MODULE_ID index , 
128:                     uint8_t endpoint 
129:                 )
130:                 {
131:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
132:                     usb->UxEP[endpoint].UxEPbits.EPTXEN = 0;
133:                 }
134:                 
135:                 //******************************************************************************
136:                 /* Function :  USB_EPnHandshakeEnable_PIC32
137:                 
138:                   Summary:
139:                     Implements PIC32 variant of PLIB_USB_EPnTxEnable 
140:                 
141:                   Description:
142:                     This template implements the PIC32 variant of the PLIB_USB_EPnTxEnable
143:                     function.
144:                 */
145:                 
146:                 PLIB_TEMPLATE void USB_EPnHandshakeEnable_PIC32
147:                 ( 
148:                     USB_MODULE_ID index , 
149:                     uint8_t endpoint 
150:                 )
151:                 {
152:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
153:                     usb->UxEP[endpoint].UxEPbits.EPHSHK = 1;
154:                    
155:                 }
156:                 
157:                 //******************************************************************************
158:                 /* Function :  USB_EPnTxDisable_PIC32
159:                 
160:                   Summary:
161:                     Implements PIC32 variant of PLIB_USB_EPnTxDisable 
162:                 
163:                   Description:
164:                     This template implements the PIC32 variant of the PLIB_USB_EPnTxDisable
165:                     function.
166:                 */
167:                 
168:                 PLIB_TEMPLATE void USB_EPnHandshakeDisable_PIC32
169:                 ( 
170:                     USB_MODULE_ID index , 
171:                     uint8_t endpoint 
172:                 )
173:                 {
174:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
175:                     usb->UxEP[endpoint].UxEPbits.EPHSHK = 0;
176:                 }
177:                 
178:                 //******************************************************************************
179:                 /* Function :  USB_EPnControlTransferEnable_PIC32
180:                 
181:                   Summary:
182:                     Implements PIC32 variant of PLIB_USB_EPnControlTransferEnable 
183:                 
184:                   Description:
185:                     This template implements the PIC32 variant of the
186:                     PLIB_USB_EPnControlTransferEnable function.
187:                 */
188:                 
189:                 PLIB_TEMPLATE void USB_EPnControlTransferEnable_PIC32
190:                 ( 
191:                     USB_MODULE_ID index , 
192:                     uint8_t endpoint 
193:                 )
194:                 {
195:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
196:                     usb->UxEP[endpoint].w &= (~UxEP_EPCONDIS_MASK);
197:                     usb->UxEP[endpoint].w |= (UxEP_EPTXEN_MASK|UxEP_EPRXEN_MASK);
198:                 }
199:                 
200:                 PLIB_TEMPLATE void USB_EPnAttributesSet_PIC32
201:                 (
202:                     USB_MODULE_ID index, 
203:                     uint8_t endpoint, 
204:                     int direction, 
205:                     bool isControl, 
206:                     bool handshake
207:                 )
208:                 {
209:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
210:                 
211:                     if(isControl)
212:                     {
213:                         usb->UxEP[endpoint].w &= (~UxEP_EPCONDIS_MASK);
214:                         usb->UxEP[endpoint].w |= (UxEP_EPTXEN_MASK|UxEP_EPRXEN_MASK|UxEP_EPHSHK_MASK);
215:                     }
216:                     else 
217:                 	{  
218:                 		/* Set the direction and handshake */
219:                         usb->UxEP[endpoint].w |= ((UxEP_EPRXEN_MASK >> direction)|handshake);
220:                 	}
221:                 }
222:                 
223:                 PLIB_TEMPLATE void USB_EPnAttributesClear_PIC32
224:                 (
225:                     USB_MODULE_ID index, 
226:                     uint8_t endpoint
227:                 )
228:                 {
229:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
230:                     
231:                     usb->UxEP[endpoint].w |= UxEP_EPCONDIS_MASK;
232:                     usb->UxEP[endpoint].w &= (~(UxEP_EPTXEN_MASK|UxEP_EPRXEN_MASK|UxEP_EPHSHK_MASK));
233:                 }
234:                 
235:                 PLIB_TEMPLATE void USB_EPnDirectionDisable_PIC32
236:                 (
237:                     USB_MODULE_ID index, 
238:                     uint8_t endpoint, 
239:                     int direction
240:                 )
241:                 {
242:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
243:                     usb->UxEP[endpoint].w &= (~(UxEP_EPRXEN_MASK >> direction));
244:                 }
245:                 
246:                 //******************************************************************************
247:                 /* Function :  USB_EPnControlTransferDisable_PIC32
248:                 
249:                   Summary:
250:                     Implements PIC32 variant of PLIB_USB_EPnControlTransferDisable 
251:                 
252:                   Description:
253:                     This template implements the PIC32 variant of the
254:                     PLIB_USB_EPnControlTransferDisable function.
255:                 */
256:                 
257:                 PLIB_TEMPLATE void USB_EPnControlTransferDisable_PIC32
258:                 ( 
259:                     USB_MODULE_ID index , 
260:                     uint8_t endpoint 
261:                 )
262:                 {
263:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
264:                     usb->UxEP[endpoint].UxEPbits.EPCONDIS = 1;
265:                 }
266:                 
267:                 //******************************************************************************
268:                 /* Function :  USB_EPnIsStalled_PIC32
269:                 
270:                   Summary:
271:                     Implements PIC32 variant of PLIB_USB_EPnIsStalled 
272:                 
273:                   Description:
274:                     This template implements the PIC32 variant of the PLIB_USB_EPnIsStalled 
275:                     function.
276:                 */
277:                 
278:                 PLIB_TEMPLATE bool USB_EPnIsStalled_PIC32
279:                 ( 
280:                     USB_MODULE_ID index , 
281:                     uint8_t endpoint 
282:                 )
283:                 {
284:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
285:                 	return ( usb->UxEP[endpoint].UxEPbits.EPSTALL );
286:                 }
287:                 
288:                 //******************************************************************************
289:                 /* Function :  USB_EPnStallClear_PIC32
290:                 
291:                   Summary:
292:                     Implements PIC32 variant of PLIB_USB_EPnStallClear 
293:                 
294:                   Description:
295:                     This template implements the PIC32 variant of the PLIB_USB_EPnStallClear 
296:                     function.
297:                 */
298:                 
299:                 PLIB_TEMPLATE void USB_EPnStallClear_PIC32
300:                 (
301:                     USB_MODULE_ID index , 
302:                     uint8_t endpoint 
303:                 )
304:                 {
305:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
306:                     usb->UxEP[endpoint].UxEPbits.EPSTALL = 0;
307:                 }
308:                 
309:                 
310:                 PLIB_TEMPLATE void USB_EP0HostSetup_PIC32(USB_MODULE_ID index)
311:                 {
312:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
313:                 	
314:                 	usb->UxEP[0].w = 0x00 ;
315:                 	
316:                     /* Set up endpoint 0 for typical host operation.
317:                      * Enable Transmit, Receive, Control Transfers, Handshake
318:                      * Disable NAK Retry and Low speed connect */
319:                     
320:                     usb->UxEP[0].w |= (UxEP0_RETRYDIS_MASK|UxEP_EPHSHK_MASK|UxEP_EPTXEN_MASK|UxEP_EPRXEN_MASK);
321:                 }
322:                 
323:                 //******************************************************************************
324:                 /* Function :  USB_ExistsEPnRxEnable_PIC32
325:                 
326:                   Summary:
327:                     Implements PIC32 variant of PLIB_USB_ExistsEPnRxEnable
328:                 
329:                   Description:
330:                     This template implements the PIC32 variant of the PLIB_USB_ExistsEPnRxEnable
331:                     function.
332:                 */
333:                 
334:                 #define PLIB_USB_ExistsEPnRxEnable PLIB_USB_ExistsEPnRxEnable
335:                 PLIB_TEMPLATE bool USB_ExistsEPnRxEnable_PIC32( USB_MODULE_ID index )
336:                 {
337:                     return true;
338:                 }
339:                 
340:                 
341:                 #endif /*_USB_EPNRXENABLEENHANCED_PIC32_H*/
342:                 
343:                 /******************************************************************************
344:                  End of File
345:                 */
346:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00E380  2462002C   ADDIU V0, V1, 44
9D00E390  7C840040   EXT A0, A0, 1, 1
9D00E394  10800004   BEQ A0, ZERO, 0x9D00E3A8
9D00E398  24630001   ADDIU V1, V1, 1
9D00E39C  90440000   LBU A0, 0(V0)
9D00E3A0  7C040844   INS A0, ZERO, 1, 1
9D00E3A4  A0440000   SB A0, 0(V0)
9D00E3A8  1465FFF6   BNE V1, A1, 0x9D00E384
9D00E3AC  2462002C   ADDIU V0, V1, 44
9D012664  2442002C   ADDIU V0, V0, 44
9D012688  7C070844   INS A3, ZERO, 1, 1
9D012694  2414FFFC   ADDIU S4, ZERO, -4
9D012698  A0470000   SB A3, 0(V0)
9D01269C  AE60000C   SW ZERO, 12(S3)
9D012B60  8D0D02C0   LW T5, 704(T0)
9D012B6C  24090008   ADDIU T1, ZERO, 8
9D012B74  01C94807   SRAV T1, T1, T6
9D012B80  012C4825   OR T1, T1, T4
9D012B88  012D4825   OR T1, T1, T5
9D012B9C  AD0902C0   SW T1, 704(T0)
9D012BA0  04A20037   BLTZL A1, 0x9D012C80
9D012C00  00084100   SLL T0, T0, 4
9D012C04  01284021   ADDU T0, T1, T0
9D012C08  8D0602C0   LW A2, 704(T0)
9D012C0C  8C82001C   LW V0, 28(A0)
9D012C14  7C062104   INS A2, ZERO, 4, 1
9D012C18  AD0602C0   SW A2, 704(T0)
9D012C1C  8D0B02C0   LW T3, 704(T0)
9D012C34  3562000D   ORI V0, T3, 13
9D012C44  AD0202C0   SW V0, 704(T0)
9D012C48  00001025   OR V0, ZERO, ZERO
9D014BF0  8C8202C0   LW V0, 704(A0)
9D014BF8  2408FFF2   ADDIU T0, ZERO, -14
9D014BFC  34420010   ORI V0, V0, 16
9D014C00  AC8202C0   SW V0, 704(A0)
9D014C04  8C8702C0   LW A3, 704(A0)
9D014C10  00E83824   AND A3, A3, T0
9D014C14  AC8702C0   SW A3, 704(A0)
9D014C18  AC660014   SW A2, 20(V1)
9D014C24  8C8702C0   LW A3, 704(A0)
9D014C28  24020008   ADDIU V0, ZERO, 8
9D014C30  00052827   NOR A1, ZERO, A1
9D014C34  00A72824   AND A1, A1, A3
9D014C3C  00001025   OR V0, ZERO, ZERO
9D014C4C  240AFFF2   ADDIU T2, ZERO, -14
9D014C54  00041900   SLL V1, A0, 4
9D014C5C  8C6702C0   LW A3, 704(V1)
9D014C68  34E70010   ORI A3, A3, 16
9D014C6C  AC6702C0   SW A3, 704(V1)
9D014C70  8C6702C0   LW A3, 704(V1)
9D014C74  24420030   ADDIU V0, V0, 48
9D014C78  7C060004   INS A2, ZERO, 0, 1
9D014C80  00EA3824   AND A3, A3, T2
9D014C88  AC6702C0   SW A3, 704(V1)
9D014C8C  AC46FFE4   SW A2, -28(V0)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_deviceaddress_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_DeviceAddress_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : DeviceAddress
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_DeviceAddressSet
16:                          PLIB_USB_DeviceAddressGet
17:                          PLIB_USB_ExistsDeviceAddress
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_DEVICEADDRESS_DEFAULT_H
48:                  #define _USB_DEVICEADDRESS_DEFAULT_H
49:                  
50:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_DeviceAddressSet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_DeviceAddressSet 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the
61:                      PLIB_USB_DeviceAddressSet function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void USB_DeviceAddressSet_Default
65:                  ( 
66:                      USB_MODULE_ID index , 
67:                      uint8_t address 
68:                  )
69:                  {
70:                      volatile usb_registers_t  * usb = ((usb_registers_t *)(index));
71:                  	usb->UxADDR.DEVADDR = ( address & 0x7F ) ;
72:                  }
73:                  
74:                  //******************************************************************************
75:                  /* Function :  USB_DeviceAddressGet_Default
76:                  
77:                    Summary:
78:                      Implements Default variant of PLIB_USB_DeviceAddressGet 
79:                  
80:                    Description:
81:                      This template implements the Default variant of the
82:                      PLIB_USB_DeviceAddressGet function.
83:                  */
84:                  
85:                  PLIB_TEMPLATE uint8_t USB_DeviceAddressGet_Default( USB_MODULE_ID index )
86:                  {
87:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
88:                      return ( usb->UxADDR.DEVADDR );
89:                  }
90:                  
91:                  
92:                  //******************************************************************************
93:                  /* Function :  USB_ExistsDeviceAddress_Default
94:                  
95:                    Summary:
96:                      Implements Default variant of PLIB_USB_ExistsDeviceAddress
97:                  
98:                    Description:
99:                      This template implements the Default variant of the
100:                     PLIB_USB_ExistsDeviceAddress function.
101:                 */
102:                 
103:                 #define PLIB_USB_ExistsDeviceAddress PLIB_USB_ExistsDeviceAddress
104:                 PLIB_TEMPLATE bool USB_ExistsDeviceAddress_Default( USB_MODULE_ID index )
105:                 {
106:                     return true;
107:                 }
108:                 
109:                 
110:                 #endif /*_USB_DEVICEADDRESS_DEFAULT_H*/
111:                 
112:                 /******************************************************************************
113:                  End of File
114:                 */
115:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00E28C  92020220   LBU V0, 544(S0)
9D00E298  7C023004   INS V0, ZERO, 0, 7
9D00E2A0  10600004   BEQ V1, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagClear
9D00E2A4  00003025   OR A2, ZERO, ZERO
9D018B8C  8C820020   LW V0, 32(A0)
9D018B90  90430220   LBU V1, 544(V0)
9D018B9C  03E00008   JR RA
9D018BA0  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_bufferfreeze_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_BufferFreeze_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BufferFreeze
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_PingPongFreeze
16:                          PLIB_USB_PingPongUnfreeze
17:                          PLIB_USB_ExistsBufferFreeze
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_BUFFERFREEZE_DEFAULT_H
48:                  #define _USB_BUFFERFREEZE_DEFAULT_H
49:                  
50:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_PingPongFreeze_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_PingPongFreeze 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_PingPongFreeze
61:                      function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void USB_PingPongFreeze_Default( USB_MODULE_ID index )
65:                  {
66:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
67:                  	usb->UxCON.w |=  UxCON_PPBRST_MASK ;
68:                    
69:                  }
70:                  
71:                  //******************************************************************************
72:                  /* Function :  USB_PingPongUnfreeze_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_USB_PingPongUnfreeze 
76:                  
77:                    Description:
78:                      This template implements the Default variant of the
79:                      PLIB_USB_PingPongUnfreeze function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void USB_PingPongUnfreeze_Default( USB_MODULE_ID index )
83:                  {
84:                  
85:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
86:                  	usb->UxCON.w &= ( ~ UxCON_PPBRST_MASK);
87:                      
88:                  }
89:                  
90:                  //******************************************************************************
91:                  /* Function :  USB_PingPongReset_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_USB_PingPongReset 
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_USB_PingPongReset
98:                      function.
99:                  */
100:                 
101:                 PLIB_TEMPLATE void USB_PingPongReset_Default( USB_MODULE_ID index )
102:                 {
103:                 
104:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
105:                     usb->UxCON.w |= UxCON_PPBRST_MASK;
106:                 	usb->UxCON.w &= ( ~ UxCON_PPBRST_MASK);
107:                 }
108:                 
109:                 
110:                 //******************************************************************************
111:                 /* Function :  USB_ExistsBufferFreeze_Default
112:                 
113:                   Summary:
114:                     Implements Default variant of PLIB_USB_ExistsBufferFreeze
115:                 
116:                   Description:
117:                     This template implements the Default variant of the
118:                     PLIB_USB_ExistsBufferFreeze function.
119:                 */
120:                 
121:                 #define PLIB_USB_ExistsBufferFreeze PLIB_USB_ExistsBufferFreeze
122:                 PLIB_TEMPLATE bool USB_ExistsBufferFreeze_Default( USB_MODULE_ID index )
123:                 {
124:                     return true;
125:                 }
126:                 
127:                 
128:                 #endif /*_USB_BUFFERFREEZE_DEFAULT_H*/
129:                 
130:                 /******************************************************************************
131:                  End of File
132:                 */
133:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00E270  8E020210   LW V0, 528(S0)
9D00E274  8E430010   LW V1, 16(S2)
9D00E278  34420002   ORI V0, V0, 2
9D00E27C  AE020210   SW V0, 528(S0)
9D00E280  8E020210   LW V0, 528(S0)
9D00E284  7C020844   INS V0, ZERO, 1, 1
9D00E288  AE020210   SW V0, 528(S0)
9D00E28C  92020220   LBU V0, 544(S0)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_bdtbaseaddress_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_BDTBaseAddress_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BDTBaseAddress
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_BDTBaseAddressGet
16:                          PLIB_USB_BDTBaseAddressSet
17:                          PLIB_USB_ExistsBDTBaseAddress
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_BDTBASEADDRESS_DEFAULT_H
48:                  #define _USB_BDTBASEADDRESS_DEFAULT_H
49:                  
50:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USB_BDTBaseAddressGet_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USB_BDTBaseAddressGet 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the
60:                      PLIB_USB_BDTBaseAddressGet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void* USB_BDTBaseAddressGet_Default( USB_MODULE_ID index )
64:                  {
65:                      uint32_t retval;
66:                  	volatile usb_registers_t * usb = ((usb_registers_t *)(index));
67:                  	
68:                      retval = ( ( usb->UxBDTP3.BDTPTRU << 24 ) | ( usb->UxBDTP2.BDTPTRH << 16 ) | ( usb->UxBDTP1.BDTPTRL << 9 ) );
69:                  	
70:                  	return ( void * )retval;
71:                  }
72:                  
73:                  //******************************************************************************
74:                  /* Function :  USB_BDTBaseAddressSet_Default
75:                  
76:                    Summary:
77:                      Implements Default variant of PLIB_USB_BDTBaseAddressSet 
78:                  
79:                    Description:
80:                      This template implements the Default variant of the
81:                      PLIB_USB_BDTBaseAddressSet function.
82:                  */
83:                  
84:                  PLIB_TEMPLATE void USB_BDTBaseAddressSet_Default( USB_MODULE_ID index , void* address )
85:                  {
86:                      volatile usb_registers_t * usb = ((usb_registers_t *)(index));
87:                  	uint32_t value = (uint32_t) address;
88:                  	usb->UxBDTP3.BDTPTRU = ( value >> 24 ) & 0xFF ;
89:                  	usb->UxBDTP2.BDTPTRH = ( value >> 16 ) & 0xFF ;
90:                  	usb->UxBDTP1.BDTPTRL = ( value >> 9 ) & 0x7F;
91:                  }
92:                  
93:                  //******************************************************************************
94:                  /* Function :  USB_ExistsBDTBaseAddress_Default
95:                  
96:                    Summary:
97:                      Implements Default variant of PLIB_USB_ExistsBDTBaseAddress
98:                  
99:                    Description:
100:                     This template implements the Default variant of the
101:                     PLIB_USB_ExistsBDTBaseAddress function.
102:                 */
103:                 
104:                 #define PLIB_USB_ExistsBDTBaseAddress PLIB_USB_ExistsBDTBaseAddress
105:                 PLIB_TEMPLATE bool USB_ExistsBDTBaseAddress_Default( USB_MODULE_ID index )
106:                 {
107:                     return true;
108:                 }
109:                 
110:                 
111:                 #endif /*_USB_BDTBASEADDRESS_DEFAULT_H*/
112:                 
113:                 /******************************************************************************
114:                  End of File
115:                 */
116:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D013E90  00022602   SRL A0, V0, 24
9D013E94  7C433C00   EXT V1, V0, 16, 8
9D013E98  A2240290   SB A0, 656(S1)
9D013E9C  A2230280   SB V1, 640(S1)
9D013EA0  92240230   LBU A0, 560(S1)
9D013EA8  7C433240   EXT V1, V0, 9, 7
9D013EAC  7C643844   INS A0, V1, 1, 7
9D013EB4  A2240230   SB A0, 560(S1)
9D013EB8  8FB00014   LW S0, 20(SP)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_automaticsuspend_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_AutomaticSuspend_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : AutomaticSuspend
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_AutoSuspendDisable
16:                          PLIB_USB_AutoSuspendEnable
17:                          PLIB_USB_ExistsAutomaticSuspend
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_AUTOMATICSUSPEND_DEFAULT_H
48:                  #define _USB_AUTOMATICSUSPEND_DEFAULT_H
49:                  
50:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USB_AutoSuspendDisable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USB_AutoSuspendDisable 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the
60:                      PLIB_USB_AutoSuspendDisable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void USB_AutoSuspendDisable_Default( USB_MODULE_ID index )
64:                  {
65:                  	volatile usb_registers_t * usb = ((usb_registers_t *)(index));
66:                  	usb->UxCNFG1CLR =  UxCNFG1_UASUSPND_MASK ;
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_AutoSuspendEnable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_AutoSuspendEnable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the
77:                      PLIB_USB_AutoSuspendEnable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void USB_AutoSuspendEnable_Default( USB_MODULE_ID index )
81:                  {
82:                      volatile usb_registers_t * usb = ((usb_registers_t *)(index));
83:                  	usb->UxCNFG1SET =  UxCNFG1_UASUSPND_MASK ;
84:                  }
85:                  
86:                  //******************************************************************************
87:                  /* Function :  USB_ExistsAutomaticSuspend_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_USB_ExistsAutomaticSuspend
91:                  
92:                    Description:
93:                      This template implements the Default variant of the
94:                      PLIB_USB_ExistsAutomaticSuspend function.
95:                  */
96:                  
97:                  #define PLIB_USB_ExistsAutomaticSuspend PLIB_USB_ExistsAutomaticSuspend
98:                  PLIB_TEMPLATE bool USB_ExistsAutomaticSuspend_Default( USB_MODULE_ID index )
99:                  {
100:                     return true;
101:                 }
102:                 
103:                 
104:                 #endif /*_USB_AUTOMATICSUSPEND_DEFAULT_H*/
105:                 
106:                 /******************************************************************************
107:                  End of File
108:                 */
109:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D013E64  90A20009   LBU V0, 9(A1)
9D013E70  AE2202A8   SW V0, 680(S1)
9D013E74  24020001   ADDIU V0, ZERO, 1
9D013E78  10C2001C   BEQ A2, V0, 0x9D013EEC
9D013E7C  00002825   OR A1, ZERO, ZERO
9D013ED4  90A20009   LBU V0, 9(A1)
9D013EE0  AE2202A4   SW V0, 676(S1)
9D013EE4  1000FFE4   BEQ ZERO, ZERO, 0x9D013E78
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/templates/usb_all_interrupt_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_ALL_Interrupt_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ALL_Interrupt
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_AllInterruptEnable
16:                          PLIB_USB_ExistsALL_Interrupt
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_ALL_INTERRUPT_DEFAULT_H
47:                  #define _USB_ALL_INTERRUPT_DEFAULT_H
48:                  
49:                  #include "driver/usb/usbfs/src/templates/usbfs_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USB_AllInterruptEnable_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_USB_AllInterruptEnable 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the
59:                      PLIB_USB_AllInterruptEnable function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void USB_AllInterruptEnable_Default
63:                  ( 
64:                      USB_MODULE_ID index , 
65:                      USB_INTERRUPTS usbInterruptsFlag , 
66:                      USB_ERROR_INTERRUPTS usbErrorInterruptsFlag , 
67:                      USB_OTG_INTERRUPTS otgInterruptFlag 
68:                  )
69:                  {
70:                      volatile usb_registers_t * usb = ((usb_registers_t *)(index));
71:                  	usb->UxIE.w = usbInterruptsFlag;
72:                      usb->UxEIE.w = usbErrorInterruptsFlag;
73:                  	usb->UxOTGIE.w = otgInterruptFlag;
74:                  }
75:                  
76:                  //******************************************************************************
77:                  /* Function :  USB_InterruptEnableGet_Default
78:                  
79:                    Summary:
80:                      Implements Default variant of PLIB_USB_InterruptEnableGet 
81:                  
82:                    Description:
83:                      This template implements the Default variant of the
84:                      PLIB_USB_InterruptEnableGet function.
85:                  */
86:                  
87:                  PLIB_TEMPLATE USB_INTERRUPTS USB_InterruptEnableGet_Default 
88:                  (
89:                      USB_MODULE_ID index
90:                  )
91:                  {
92:                      volatile usb_registers_t * usb = ((usb_registers_t *)(index));
93:                      return (USB_INTERRUPTS)( usb->UxIE.w );
94:                  }
95:                  
96:                  //******************************************************************************
97:                  /* Function :  USB_ExistsALL_Interrupt_Default
98:                  
99:                    Summary:
100:                     Implements Default variant of PLIB_USB_ExistsALL_Interrupt
101:                 
102:                   Description:
103:                     This template implements the Default variant of the
104:                     PLIB_USB_ExistsALL_Interrupt function.
105:                 */
106:                 
107:                 #define PLIB_USB_ExistsALL_Interrupt PLIB_USB_ExistsALL_Interrupt
108:                 PLIB_TEMPLATE bool USB_ExistsALL_Interrupt_Default( USB_MODULE_ID index )
109:                 {
110:                     return true;
111:                 }
112:                 
113:                 
114:                 #endif /*_USB_ALL_INTERRUPT_DEFAULT_H*/
115:                 
116:                 /******************************************************************************
117:                  End of File
118:                 */
119:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D017908  240300DF   ADDIU V1, ZERO, 223
9D017910  240300FF   ADDIU V1, ZERO, 255
9D017918  2403FF1A   ADDIU V1, ZERO, -230
9D017920  03E00008   JR RA
9D018BF4  8C820020   LW V0, 32(A0)
9D018BF8  2403FF00   ADDIU V1, ZERO, -256
9D018C04  AC4301D0   SW V1, 464(V0)
9D018C08  AC4301F0   SW V1, 496(V0)
9D018C0C  2403FF02   ADDIU V1, ZERO, -254
9D018C10  AC430010   SW V1, 16(V0)
9D018C14  03E00008   JR RA
9D018C18  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/plib_usbfs_header.h  --
1:                   /*******************************************************************************
2:                   * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
3:                   *
4:                   * Subject to your compliance with these terms, you may use Microchip software
5:                   * and any derivatives exclusively with Microchip products. It is your
6:                   * responsibility to comply with third party license terms applicable to your
7:                   * use of third party software (including open source software) that may
8:                   * accompany Microchip software.
9:                   *
10:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
11:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
12:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
13:                  * PARTICULAR PURPOSE.
14:                  *
15:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
16:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
17:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
18:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
19:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
20:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
21:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
22:                  *******************************************************************************/
23:                  
24:                  /* Created by plibgen $Revision: 1.31 $ */
25:                  
26:                  
27:                  #ifndef _PLIB_USBFS_H
28:                  #define _PLIB_USBFS_H
29:                  
30:                  /* Section 1 - Enumerate instances, define constants, VREGs */
31:                  
32:                  #include <xc.h>
33:                  #include <stdbool.h>
34:                  
35:                  
36:                  
37:                  /* Default definition used for all API dispatch functions */
38:                  #ifndef PLIB_INLINE_API
39:                       #define PLIB_INLINE_API static inline 
40:                  #endif
41:                  
42:                  /* Default definition used for all other functions */
43:                  #ifndef PLIB_INLINE
44:                       #define PLIB_INLINE static inline 
45:                  #endif
46:                  
47:                  #ifndef _PLIB_UNSUPPORTED
48:                      #define _PLIB_UNSUPPORTED 
49:                  #endif
50:                  
51:                  #ifndef PLIB_ASSERT
52:                      #define PLIB_ASSERT(a,b)  
53:                  #endif 
54:                  
55:                  #if defined(__32MX420F032H__) || defined(__32MX440F128H__) ||  defined(__32MX440F256H__) || defined(__32MX440F512H__) || defined(__32MX440F128L__) || defined(__32MX460F256L__) || defined(__32MX460F512L__)
56:                  
57:                      #define USB_BUSY_FLAG_DOES_NOT_EXIST   
58:                  #endif
59:                  
60:                  typedef enum {
61:                  
62:                      USB_ID_1 = _USB_BASE_ADDRESS,
63:                      USB_NUMBER_OF_MODULES = 1
64:                  	
65:                  } USB_MODULE_ID;
66:                  
67:                  typedef enum {
68:                  
69:                      USB_INT_DEVICE_RESET = 0x01,
70:                      USB_INT_ERROR = 0x02,
71:                      USB_INT_TOKEN_DONE = 0x08,
72:                      USB_INT_IDLE_DETECT = 0x10,
73:                      USB_INT_STALL = 0x80,
74:                      USB_INT_SOF = 0x04,
75:                      USB_INT_HOST_DETACH = 0x01,
76:                      USB_INT_RESUME = 0x20,
77:                      USB_INT_ATTACH = 0x40,
78:                      USB_INT_ANY = 0xFF,
79:                      USB_INT_ALL = 0xFF
80:                  
81:                  } USB_INTERRUPTS;
82:                  
83:                  typedef enum {
84:                  
85:                      USB_ERR_INT_PID_CHECK_FAILURE = 0x01,
86:                      USB_ERR_INT_BAD_CRC5 = 0x02,
87:                      USB_ERR_INT_BAD_CRC16 = 0x04,
88:                      USB_ERR_INT_BAD_DATA_FIELD_SIZE = 0x08,
89:                      USB_ERR_INT_BUS_TURNAROUND_TIMEOUT = 0x10,
90:                      USB_ERR_INT_BIT_STUFF_ERROR = 0x80,
91:                      USB_ERR_INT_HOST_EOF_ERROR = 0x02,
92:                      USB_ERR_INT_DMA_ERROR = 0x20,
93:                      USB_ERR_INT_BUS_MATRIX_ERROR = 0x40,
94:                      USB_ERR_INT_ANY = 0xFF,
95:                      USB_ERR_INT_ALL = 0xFF
96:                  
97:                  } USB_ERROR_INTERRUPTS;
98:                  
99:                  /* Section 2 - Feature variant inclusion */
100:                 
101:                 #define PLIB_TEMPLATE PLIB_INLINE
102:                 #include "driver/usb/usbfs/src/templates/usb_OTG_InterruptStatus_Default.h"
103:                 #include "driver/usb/usbfs/src/templates/usb_OTG_Interrupt_Default.h"
104:                 #include "driver/usb/usbfs/src/templates/usb_OTG_IDPinState_Default.h"
105:                 #include "driver/usb/usbfs/src/templates/usb_OTG_LineState_Default.h"
106:                 #include "driver/usb/usbfs/src/templates/usb_OTG_SessionValid_Default.h"
107:                 #include "driver/usb/usbfs/src/templates/usb_OTG_BSessionEnd_Default.h"
108:                 #include "driver/usb/usbfs/src/templates/usb_OTG_ASessionValid_Default.h"
109:                 #include "driver/usb/usbfs/src/templates/usb_OTG_PullUpPullDown_Default.h"
110:                 #include "driver/usb/usbfs/src/templates/usb_OTG_VbusPowerOnOff_Default.h"
111:                 #include "driver/usb/usbfs/src/templates/usb_OTG_VbusCharge_Default.h"
112:                 #include "driver/usb/usbfs/src/templates/usb_OTG_VbusDischarge_Default.h"
113:                 #include "driver/usb/usbfs/src/templates/usb_ActivityPending_Default.h"
114:                 #include "driver/usb/usbfs/src/templates/usb_SleepEntryGuard_Default.h"
115:                 #include "driver/usb/usbfs/src/templates/usb_Suspend_Default.h"
116:                 #include "driver/usb/usbfs/src/templates/usb_ModulePower_32Bit16Bit.h"
117:                 #include "driver/usb/usbfs/src/templates/usb_GEN_InterruptStatus_Default.h"
118:                 #include "driver/usb/usbfs/src/templates/usb_GEN_Interrupt_Default.h"
119:                 #include "driver/usb/usbfs/src/templates/usb_ALL_Interrupt_Default.h"
120:                 #include "driver/usb/usbfs/src/templates/usb_ERR_InterruptStatus_Default.h"
121:                 #include "driver/usb/usbfs/src/templates/usb_ERR_Interrupt_Default.h"
122:                 #include "driver/usb/usbfs/src/templates/usb_LastEndpoint_Default.h"
123:                 #include "driver/usb/usbfs/src/templates/usb_LastDirection_Default.h"
124:                 #include "driver/usb/usbfs/src/templates/usb_LastPingPong_Default.h"
125:                 #include "driver/usb/usbfs/src/templates/usb_LastTransactionDetails_Default.h"
126:                 #include "driver/usb/usbfs/src/templates/usb_LiveJState_Default.h"
127:                 #include "driver/usb/usbfs/src/templates/usb_LiveSingleEndedZero_Default.h"
128:                 #include "driver/usb/usbfs/src/templates/usb_PacketTransfer_Default.h"
129:                 #include "driver/usb/usbfs/src/templates/usb_HostBusyWithToken_Default.h"
130:                 #include "driver/usb/usbfs/src/templates/usb_HostGeneratesReset_Default.h"
131:                 #include "driver/usb/usbfs/src/templates/usb_OpModeSelect_Default.h"
132:                 #include "driver/usb/usbfs/src/templates/usb_ResumeSignaling_Default.h"
133:                 #include "driver/usb/usbfs/src/templates/usb_BufferFreeze_Default.h"
134:                 #include "driver/usb/usbfs/src/templates/usb_StartOfFrames_Default.h"
135:                 #include "driver/usb/usbfs/src/templates/usb_NextTokenSpeed_Default.h"
136:                 #include "driver/usb/usbfs/src/templates/usb_DeviceAddress_Default.h"
137:                 #include "driver/usb/usbfs/src/templates/usb_FrameNumber_Default.h"
138:                 #include "driver/usb/usbfs/src/templates/usb_TokenPID_Default.h"
139:                 #include "driver/usb/usbfs/src/templates/usb_TokenEP_Default.h"
140:                 #include "driver/usb/usbfs/src/templates/usb_SOFThreshold_Default.h"
141:                 #include "driver/usb/usbfs/src/templates/usb_BDTBaseAddress_Default.h"
142:                 #include "driver/usb/usbfs/src/templates/usb_EyePattern_Default.h"
143:                 #include "driver/usb/usbfs/src/templates/usb_StopInIdle_Default.h"
144:                 #include "driver/usb/usbfs/src/templates/usb_PingPongMode_Unsupported.h"
145:                 #include "driver/usb/usbfs/src/templates/usb_UOEMonitor_Unsupported.h"
146:                 #include "driver/usb/usbfs/src/templates/usb_OnChipPullup_Unsupported.h"
147:                 #include "driver/usb/usbfs/src/templates/usb_OnChipTransceiver_Unsupported.h"
148:                 #include "driver/usb/usbfs/src/templates/usb_SpeedControl_Unsupported.h"
149:                 #include "driver/usb/usbfs/src/templates/usb_EP0LowSpeedConnect_Default.h"
150:                 #include "driver/usb/usbfs/src/templates/usb_EP0NAKRetry_Default.h"
151:                 #include "driver/usb/usbfs/src/templates/usb_EPnTxRx_Default.h"
152:                 #include "driver/usb/usbfs/src/templates/usb_EPnRxEnableEnhanced_PIC32.h"
153:                 #include "driver/usb/usbfs/src/templates/usb_BDTFunctions_PIC32.h"
154:                 #ifndef  USB_BUSY_FLAG_DOES_NOT_EXIST
155:                     #include "driver/usb/usbfs/src/templates/usb_ModuleBusy_Default.h"
156:                     #include "driver/usb/usbfs/src/templates/usb_AutomaticSuspend_Default.h"
157:                 #endif
158:                 
159:                 
160:                 /* Section 3 - PLIB dispatch function definitions */
161:                 
162:                 PLIB_INLINE_API void PLIB_USB_OTG_InterruptFlagSet(USB_MODULE_ID index, USB_OTG_INTERRUPTS interruptFlag)
163:                 {
164:                      USB_OTG_InterruptFlagSet_Default(index, interruptFlag);
165:                 }
166:                 
167:                 PLIB_INLINE_API void PLIB_USB_OTG_InterruptFlagClear(USB_MODULE_ID index, USB_OTG_INTERRUPTS interruptFlag)
168:                 {
169:                      USB_OTG_InterruptFlagClear_Default(index, interruptFlag);
170:                 }
171:                 
172:                 PLIB_INLINE_API bool PLIB_USB_OTG_InterruptFlagGet(USB_MODULE_ID index, USB_OTG_INTERRUPTS interruptFlag)
173:                 {
174:                      return USB_OTG_InterruptFlagGet_Default(index, interruptFlag);
175:                 }
176:                 
177:                 PLIB_INLINE_API bool PLIB_USB_ExistsOTG_InterruptStatus(USB_MODULE_ID index)
178:                 {
179:                      return USB_ExistsOTG_InterruptStatus_Default(index);
180:                 }
181:                 
182:                 PLIB_INLINE_API void PLIB_USB_OTG_InterruptEnable(USB_MODULE_ID index, USB_OTG_INTERRUPTS interruptFlag)
183:                 {
184:                      USB_OTG_InterruptEnable_Default(index, interruptFlag);
185:                 }
186:                 
187:                 PLIB_INLINE_API void PLIB_USB_OTG_InterruptDisable(USB_MODULE_ID index, USB_OTG_INTERRUPTS interruptFlag)
188:                 {
189:                      USB_OTG_InterruptDisable_Default(index, interruptFlag);
190:                 }
191:                 
192:                 PLIB_INLINE_API bool PLIB_USB_OTG_InterruptIsEnabled(USB_MODULE_ID index, USB_INTERRUPTS interruptFlag)
193:                 {
194:                      return USB_OTG_InterruptIsEnabled_Default(index, interruptFlag);
195:                 }
196:                 
197:                 PLIB_INLINE_API bool PLIB_USB_ExistsOTG_Interrupt(USB_MODULE_ID index)
198:                 {
199:                      return USB_ExistsOTG_Interrupt_Default(index);
200:                 }
201:                 
202:                 PLIB_INLINE_API bool PLIB_USB_OTG_IDPinStateIsTypeA(USB_MODULE_ID index)
203:                 {
204:                      return USB_OTG_IDPinStateIsTypeA_Default(index);
205:                 }
206:                 
207:                 PLIB_INLINE_API bool PLIB_USB_ExistsOTG_IDPinState(USB_MODULE_ID index)
208:                 {
209:                      return USB_ExistsOTG_IDPinState_Default(index);
210:                 }
211:                 
212:                 PLIB_INLINE_API bool PLIB_USB_OTG_LineStateIsStable(USB_MODULE_ID index)
213:                 {
214:                      return USB_OTG_LineStateIsStable_Default(index);
215:                 }
216:                 
217:                 PLIB_INLINE_API bool PLIB_USB_ExistsOTG_LineState(USB_MODULE_ID index)
218:                 {
219:                      return USB_ExistsOTG_LineState_Default(index);
220:                 }
221:                 
222:                 PLIB_INLINE_API bool PLIB_USB_OTG_SessionValid(USB_MODULE_ID index)
223:                 {
224:                      return USB_OTG_SessionValid_Default(index);
225:                 }
226:                 
227:                 PLIB_INLINE_API bool PLIB_USB_ExistsOTG_SessionValid(USB_MODULE_ID index)
228:                 {
229:                      return USB_ExistsOTG_SessionValid_Default(index);
230:                 }
231:                 
232:                 PLIB_INLINE_API bool PLIB_USB_OTG_BSessionHasEnded(USB_MODULE_ID index)
233:                 {
234:                      return USB_OTG_BSessionHasEnded_Default(index);
235:                 }
236:                 
237:                 PLIB_INLINE_API bool PLIB_USB_ExistsOTG_BSessionEnd(USB_MODULE_ID index)
238:                 {
239:                      return USB_ExistsOTG_BSessionEnd_Default(index);
240:                 }
241:                 
242:                 PLIB_INLINE_API bool PLIB_USB_OTG_VBusValid(USB_MODULE_ID index)
243:                 {
244:                      return USB_OTG_VBusValid_Default(index);
245:                 }
246:                 
247:                 PLIB_INLINE_API bool PLIB_USB_ExistsOTG_ASessionValid(USB_MODULE_ID index)
248:                 {
249:                      return USB_ExistsOTG_ASessionValid_Default(index);
250:                 }
251:                 
252:                 PLIB_INLINE_API void PLIB_USB_OTG_PullUpPullDownSetup(USB_MODULE_ID index, USB_OTG_PULL_UP_PULL_DOWN resistor, bool enableResistor)
253:                 {
254:                      USB_OTG_PullUpPullDownSetup_Default(index, resistor, enableResistor);
255:                 }
256:                 
257:                 PLIB_INLINE_API bool PLIB_USB_ExistsOTG_PullUpPullDown(USB_MODULE_ID index)
258:                 {
259:                      return USB_ExistsOTG_PullUpPullDown_Default(index);
260:                 }
261:                 
262:                 PLIB_INLINE_API void PLIB_USB_OTG_VBusPowerOff(USB_MODULE_ID index)
263:                 {
264:                      USB_OTG_VBusPowerOff_Default(index);
265:                 }
266:                 
267:                 PLIB_INLINE_API void PLIB_USB_OTG_VBusPowerOn(USB_MODULE_ID index)
268:                 {
269:                      USB_OTG_VBusPowerOn_Default(index);
270:                 }
271:                 
272:                 PLIB_INLINE_API bool PLIB_USB_ExistsOTG_VbusPowerOnOff(USB_MODULE_ID index)
273:                 {
274:                      return USB_ExistsOTG_VbusPowerOnOff_Default(index);
275:                 }
276:                 
277:                 PLIB_INLINE_API void PLIB_USB_OTG_VBusChargeEnable(USB_MODULE_ID index)
278:                 {
279:                      USB_OTG_VBusChargeEnable_Default(index);
280:                 }
281:                 
282:                 PLIB_INLINE_API void PLIB_USB_OTG_VBusChargeDisable(USB_MODULE_ID index)
283:                 {
284:                      USB_OTG_VBusChargeDisable_Default(index);
285:                 }
286:                 
287:                 PLIB_INLINE_API bool PLIB_USB_ExistsOTG_VbusCharge(USB_MODULE_ID index)
288:                 {
289:                      return USB_ExistsOTG_VbusCharge_Default(index);
290:                 }
291:                 
292:                 PLIB_INLINE_API void PLIB_USB_OTG_VBusDischargeEnable(USB_MODULE_ID index)
293:                 {
294:                      USB_OTG_VBusDischargeEnable_Default(index);
295:                 }
296:                 
297:                 PLIB_INLINE_API void PLIB_USB_OTG_VBusDischargeDisable(USB_MODULE_ID index)
298:                 {
299:                      USB_OTG_VBusDischargeDisable_Default(index);
300:                 }
301:                 
302:                 PLIB_INLINE_API bool PLIB_USB_ExistsOTG_VbusDischarge(USB_MODULE_ID index)
303:                 {
304:                      return USB_ExistsOTG_VbusDischarge_Default(index);
305:                 }
306:                 
307:                 PLIB_INLINE_API bool PLIB_USB_ActivityPending(USB_MODULE_ID index)
308:                 {
309:                      return USB_ActivityPending_Default(index);
310:                 }
311:                 
312:                 PLIB_INLINE_API bool PLIB_USB_ExistsActivityPending(USB_MODULE_ID index)
313:                 {
314:                      return USB_ExistsActivityPending_Default(index);
315:                 }
316:                 
317:                 PLIB_INLINE_API void PLIB_USB_SleepGuardEnable(USB_MODULE_ID index)
318:                 {
319:                      USB_SleepGuardEnable_Default(index);
320:                 }
321:                 
322:                 PLIB_INLINE_API void PLIB_USB_SleepGuardDisable(USB_MODULE_ID index)
323:                 {
324:                      USB_SleepGuardDisable_Default(index);
325:                 }
326:                 
327:                 PLIB_INLINE_API bool PLIB_USB_ExistsSleepEntryGuard(USB_MODULE_ID index)
328:                 {
329:                      return USB_ExistsSleepEntryGuard_Default(index);
330:                 }
331:                 #ifndef  USB_BUSY_FLAG_DOES_NOT_EXIST
332:                     PLIB_INLINE_API bool PLIB_USB_ModuleIsBusy(USB_MODULE_ID index)
333:                     {
334:                          return USB_ModuleIsBusy_Default(index);
335:                     }
336:                 
337:                     PLIB_INLINE_API bool PLIB_USB_ExistsModuleBusy(USB_MODULE_ID index)
338:                     {
339:                          return USB_ExistsModuleBusy_Default(index);
340:                     }
341:                 
342:                     PLIB_INLINE_API void PLIB_USB_AutoSuspendDisable(USB_MODULE_ID index)
343:                     {
344:                          USB_AutoSuspendDisable_Default(index);
345:                     }
346:                 
347:                     PLIB_INLINE_API void PLIB_USB_AutoSuspendEnable(USB_MODULE_ID index)
348:                     {
349:                          USB_AutoSuspendEnable_Default(index);
350:                     }
351:                 
352:                     PLIB_INLINE_API bool PLIB_USB_ExistsAutomaticSuspend(USB_MODULE_ID index)
353:                     {
354:                          return USB_ExistsAutomaticSuspend_Default(index);
355:                     }
356:                 #endif
357:                 
358:                 PLIB_INLINE_API void PLIB_USB_SuspendEnable(USB_MODULE_ID index)
359:                 {
360:                      USB_SuspendEnable_Default(index);
361:                 }
362:                 
363:                 PLIB_INLINE_API void PLIB_USB_SuspendDisable(USB_MODULE_ID index)
364:                 {
365:                      USB_SuspendDisable_Default(index);
366:                 }
367:                 
368:                 PLIB_INLINE_API bool PLIB_USB_ExistsSuspend(USB_MODULE_ID index)
369:                 {
370:                      return USB_ExistsSuspend_Default(index);
371:                 }
372:                 
373:                 PLIB_INLINE_API void PLIB_USB_Enable(USB_MODULE_ID index)
374:                 {
375:                      USB_Enable_32Bit16Bit(index);
376:                 }
377:                 
378:                 PLIB_INLINE_API void PLIB_USB_Disable(USB_MODULE_ID index)
379:                 {
380:                      USB_Disable_32Bit16Bit(index);
381:                 }
382:                 
383:                 PLIB_INLINE_API bool PLIB_USB_ExistsModulePower(USB_MODULE_ID index)
384:                 {
385:                      return USB_ExistsModulePower_32Bit16Bit(index);
386:                 }
387:                 
388:                 PLIB_INLINE_API void PLIB_USB_InterruptFlagSet(USB_MODULE_ID index, USB_INTERRUPTS interruptFlag)
389:                 {
390:                      USB_InterruptFlagSet_Default(index, interruptFlag);
391:                 }
392:                 
393:                 PLIB_INLINE_API void PLIB_USB_InterruptFlagClear(USB_MODULE_ID index, USB_INTERRUPTS interruptFlag)
394:                 {
395:                      USB_InterruptFlagClear_Default(index, interruptFlag);
396:                 }
397:                 
398:                 PLIB_INLINE_API bool PLIB_USB_InterruptFlagGet(USB_MODULE_ID index, USB_INTERRUPTS interruptFlag)
399:                 {
400:                      return USB_InterruptFlagGet_Default(index, interruptFlag);
401:                 }
402:                 
403:                 PLIB_INLINE_API USB_INTERRUPTS PLIB_USB_InterruptFlagAllGet(USB_MODULE_ID index)
404:                 {
405:                      return USB_InterruptFlagAllGet_Default(index);
406:                 }
407:                 
408:                 PLIB_INLINE_API bool PLIB_USB_ExistsGEN_InterruptStatus(USB_MODULE_ID index)
409:                 {
410:                      return USB_ExistsGEN_InterruptStatus_Default(index);
411:                 }
412:                 
413:                 PLIB_INLINE_API void PLIB_USB_InterruptEnable(USB_MODULE_ID index, USB_INTERRUPTS interruptFlag)
414:                 {
415:                      USB_InterruptEnable_Default(index, interruptFlag);
416:                 }
417:                 
418:                 PLIB_INLINE_API void PLIB_USB_InterruptDisable(USB_MODULE_ID index, USB_INTERRUPTS interruptFlag)
419:                 {
420:                      USB_InterruptDisable_Default(index, interruptFlag);
421:                 }
422:                 
423:                 PLIB_INLINE_API bool PLIB_USB_InterruptIsEnabled(USB_MODULE_ID index, USB_INTERRUPTS interruptFlag)
424:                 {
425:                      return USB_InterruptIsEnabled_Default(index, interruptFlag);
426:                 }
427:                 
428:                 PLIB_INLINE_API bool PLIB_USB_ExistsGEN_Interrupt(USB_MODULE_ID index)
429:                 {
430:                      return USB_ExistsGEN_Interrupt_Default(index);
431:                 }
432:                 
433:                 PLIB_INLINE_API void PLIB_USB_AllInterruptEnable(USB_MODULE_ID index, USB_INTERRUPTS usbInterruptsFlag, USB_ERROR_INTERRUPTS usbErrorInterruptsFlag, USB_OTG_INTERRUPTS otgInterruptFlag)
434:                 {
435:                      USB_AllInterruptEnable_Default(index, usbInterruptsFlag, usbErrorInterruptsFlag, otgInterruptFlag);
436:                 }
437:                 
438:                 PLIB_INLINE_API USB_INTERRUPTS PLIB_USB_InterruptEnableGet(USB_MODULE_ID index)
439:                 {
440:                      return USB_InterruptEnableGet_Default(index);
441:                 }
442:                 
443:                 PLIB_INLINE_API bool PLIB_USB_ExistsALL_Interrupt(USB_MODULE_ID index)
444:                 {
445:                      return USB_ExistsALL_Interrupt_Default(index);
446:                 }
447:                 
448:                 PLIB_INLINE_API void PLIB_USB_ErrorInterruptFlagSet(USB_MODULE_ID index, USB_ERROR_INTERRUPTS interruptFlag)
449:                 {
450:                      USB_ErrorInterruptFlagSet_Default(index, interruptFlag);
451:                 }
452:                 
453:                 PLIB_INLINE_API void PLIB_USB_ErrorInterruptFlagClear(USB_MODULE_ID index, USB_ERROR_INTERRUPTS interruptFlag)
454:                 {
455:                      USB_ErrorInterruptFlagClear_Default(index, interruptFlag);
456:                 }
457:                 
458:                 PLIB_INLINE_API bool PLIB_USB_ErrorInterruptFlagGet(USB_MODULE_ID index, USB_ERROR_INTERRUPTS interruptFlag)
459:                 {
460:                      return USB_ErrorInterruptFlagGet_Default(index, interruptFlag);
461:                 }
462:                 
463:                 PLIB_INLINE_API USB_ERROR_INTERRUPTS PLIB_USB_ErrorInterruptFlagAllGet(USB_MODULE_ID index)
464:                 {
465:                      return USB_ErrorInterruptFlagAllGet_Default(index);
466:                 }
467:                 
468:                 PLIB_INLINE_API bool PLIB_USB_ExistsERR_InterruptStatus(USB_MODULE_ID index)
469:                 {
470:                      return USB_ExistsERR_InterruptStatus_Default(index);
471:                 }
472:                 
473:                 PLIB_INLINE_API void PLIB_USB_ErrorInterruptEnable(USB_MODULE_ID index, USB_ERROR_INTERRUPTS interruptFlag)
474:                 {
475:                      USB_ErrorInterruptEnable_Default(index, interruptFlag);
476:                 }
477:                 
478:                 PLIB_INLINE_API void PLIB_USB_ErrorInterruptDisable(USB_MODULE_ID index, USB_ERROR_INTERRUPTS interruptFlag)
479:                 {
480:                      USB_ErrorInterruptDisable_Default(index, interruptFlag);
481:                 }
482:                 
483:                 PLIB_INLINE_API bool PLIB_USB_ErrorInterruptIsEnabled(USB_MODULE_ID index, USB_INTERRUPTS interruptFlag)
484:                 {
485:                      return USB_ErrorInterruptIsEnabled_Default(index, interruptFlag);
486:                 }
487:                 
488:                 PLIB_INLINE_API bool PLIB_USB_ExistsERR_Interrupt(USB_MODULE_ID index)
489:                 {
490:                      return USB_ExistsERR_Interrupt_Default(index);
491:                 }
492:                 
493:                 PLIB_INLINE_API uint8_t PLIB_USB_LastTransactionEndPtGet(USB_MODULE_ID index)
494:                 {
495:                      return USB_LastTransactionEndPtGet_Default(index);
496:                 }
497:                 
498:                 PLIB_INLINE_API bool PLIB_USB_ExistsLastEndpoint(USB_MODULE_ID index)
499:                 {
500:                      return USB_ExistsLastEndpoint_Default(index);
501:                 }
502:                 
503:                 PLIB_INLINE_API USB_BUFFER_DIRECTION PLIB_USB_LastTransactionDirectionGet(USB_MODULE_ID index)
504:                 {
505:                      return USB_LastTransactionDirectionGet_Default(index);
506:                 }
507:                 
508:                 PLIB_INLINE_API bool PLIB_USB_ExistsLastDirection(USB_MODULE_ID index)
509:                 {
510:                      return USB_ExistsLastDirection_Default(index);
511:                 }
512:                 
513:                 PLIB_INLINE_API USB_PING_PONG_STATE PLIB_USB_LastTransactionPingPongStateGet(USB_MODULE_ID index)
514:                 {
515:                      return USB_LastTransactionPingPongStateGet_Default(index);
516:                 }
517:                 
518:                 PLIB_INLINE_API bool PLIB_USB_ExistsLastPingPong(USB_MODULE_ID index)
519:                 {
520:                      return USB_ExistsLastPingPong_Default(index);
521:                 }
522:                 
523:                 PLIB_INLINE_API void PLIB_USB_LastTransactionDetailsGet(USB_MODULE_ID index, USB_BUFFER_DIRECTION* direction, USB_PING_PONG_STATE* pingpong, uint8_t* endpoint)
524:                 {
525:                      USB_LastTransactionDetailsGet_Default(index, direction, pingpong, endpoint);
526:                 }
527:                 
528:                 PLIB_INLINE_API bool PLIB_USB_ExistsLastTransactionDetails(USB_MODULE_ID index)
529:                 {
530:                      return USB_ExistsLastTransactionDetails_Default(index);
531:                 }
532:                 
533:                 PLIB_INLINE_API bool PLIB_USB_JStateIsActive(USB_MODULE_ID index)
534:                 {
535:                      return USB_JStateIsActive_Default(index);
536:                 }
537:                 
538:                 PLIB_INLINE_API bool PLIB_USB_ExistsLiveJState(USB_MODULE_ID index)
539:                 {
540:                      return USB_ExistsLiveJState_Default(index);
541:                 }
542:                 
543:                 PLIB_INLINE_API bool PLIB_USB_SE0InProgress(USB_MODULE_ID index)
544:                 {
545:                      return USB_SE0InProgress_Default(index);
546:                 }
547:                 
548:                 PLIB_INLINE_API bool PLIB_USB_ExistsLiveSingleEndedZero(USB_MODULE_ID index)
549:                 {
550:                      return USB_ExistsLiveSingleEndedZero_Default(index);
551:                 }
552:                 
553:                 PLIB_INLINE_API bool PLIB_USB_PacketTransferIsDisabled(USB_MODULE_ID index)
554:                 {
555:                      return USB_PacketTransferIsDisabled_Default(index);
556:                 }
557:                 
558:                 PLIB_INLINE_API void PLIB_USB_PacketTransferEnable(USB_MODULE_ID index)
559:                 {
560:                      USB_PacketTransferEnable_Default(index);
561:                 }
562:                 
563:                 PLIB_INLINE_API void PLIB_USB_PacketTransferDisable(USB_MODULE_ID index)
564:                 {
565:                      USB_PacketTransferDisable_Default(index);
566:                 }
567:                 
568:                 PLIB_INLINE_API bool PLIB_USB_ExistsPacketTransfer(USB_MODULE_ID index)
569:                 {
570:                      return USB_ExistsPacketTransfer_Default(index);
571:                 }
572:                 
573:                 PLIB_INLINE_API bool PLIB_USB_IsBusyWithToken(USB_MODULE_ID index)
574:                 {
575:                      return USB_IsBusyWithToken_Default(index);
576:                 }
577:                 
578:                 PLIB_INLINE_API bool PLIB_USB_ExistsHostBusyWithToken(USB_MODULE_ID index)
579:                 {
580:                      return USB_ExistsHostBusyWithToken_Default(index);
581:                 }
582:                 
583:                 PLIB_INLINE_API void PLIB_USB_ResetSignalEnable(USB_MODULE_ID index)
584:                 {
585:                      USB_ResetSignalEnable_Default(index);
586:                 }
587:                 
588:                 PLIB_INLINE_API void PLIB_USB_ResetSignalDisable(USB_MODULE_ID index)
589:                 {
590:                      USB_ResetSignalDisable_Default(index);
591:                 }
592:                 
593:                 PLIB_INLINE_API bool PLIB_USB_ExistsHostGeneratesReset(USB_MODULE_ID index)
594:                 {
595:                      return USB_ExistsHostGeneratesReset_Default(index);
596:                 }
597:                 
598:                 PLIB_INLINE_API void PLIB_USB_OperatingModeSelect(USB_MODULE_ID index, USB_OPMODES opMode)
599:                 {
600:                      USB_OperatingModeSelect_Default(index, opMode);
601:                 }
602:                 
603:                 PLIB_INLINE_API bool PLIB_USB_ExistsOpModeSelect(USB_MODULE_ID index)
604:                 {
605:                      return USB_ExistsOpModeSelect_Default(index);
606:                 }
607:                 
608:                 PLIB_INLINE_API void PLIB_USB_ResumeSignalingEnable(USB_MODULE_ID index)
609:                 {
610:                      USB_ResumeSignalingEnable_Default(index);
611:                 }
612:                 
613:                 PLIB_INLINE_API void PLIB_USB_ResumeSignalingDisable(USB_MODULE_ID index)
614:                 {
615:                      USB_ResumeSignalingDisable_Default(index);
616:                 }
617:                 
618:                 PLIB_INLINE_API bool PLIB_USB_ExistsResumeSignaling(USB_MODULE_ID index)
619:                 {
620:                      return USB_ExistsResumeSignaling_Default(index);
621:                 }
622:                 
623:                 PLIB_INLINE_API void PLIB_USB_PingPongFreeze(USB_MODULE_ID index)
624:                 {
625:                      USB_PingPongFreeze_Default(index);
626:                 }
627:                 
628:                 PLIB_INLINE_API void PLIB_USB_PingPongUnfreeze(USB_MODULE_ID index)
629:                 {
630:                      USB_PingPongUnfreeze_Default(index);
631:                 }
632:                 
633:                 PLIB_INLINE_API void PLIB_USB_PingPongReset(USB_MODULE_ID index)
634:                 {
635:                      USB_PingPongReset_Default(index);
636:                 }
637:                 
638:                 PLIB_INLINE_API bool PLIB_USB_ExistsBufferFreeze(USB_MODULE_ID index)
639:                 {
640:                      return USB_ExistsBufferFreeze_Default(index);
641:                 }
642:                 
643:                 PLIB_INLINE_API void PLIB_USB_SOFEnable(USB_MODULE_ID index)
644:                 {
645:                      USB_SOFEnable_Default(index);
646:                 }
647:                 
648:                 PLIB_INLINE_API void PLIB_USB_SOFDisable(USB_MODULE_ID index)
649:                 {
650:                      USB_SOFDisable_Default(index);
651:                 }
652:                 
653:                 PLIB_INLINE_API bool PLIB_USB_ExistsStartOfFrames(USB_MODULE_ID index)
654:                 {
655:                      return USB_ExistsStartOfFrames_Default(index);
656:                 }
657:                 
658:                 PLIB_INLINE_API void PLIB_USB_TokenSpeedSelect(USB_MODULE_ID index, USB_TOKEN_SPEED tokenSpeed)
659:                 {
660:                      USB_TokenSpeedSelect_Default(index, tokenSpeed);
661:                 }
662:                 
663:                 PLIB_INLINE_API bool PLIB_USB_ExistsNextTokenSpeed(USB_MODULE_ID index)
664:                 {
665:                      return USB_ExistsNextTokenSpeed_Default(index);
666:                 }
667:                 
668:                 PLIB_INLINE_API void PLIB_USB_DeviceAddressSet(USB_MODULE_ID index, uint8_t address)
669:                 {
670:                      USB_DeviceAddressSet_Default(index, address);
671:                 }
672:                 
673:                 PLIB_INLINE_API uint8_t PLIB_USB_DeviceAddressGet(USB_MODULE_ID index)
674:                 {
675:                      return USB_DeviceAddressGet_Default(index);
676:                 }
677:                 
678:                 PLIB_INLINE_API bool PLIB_USB_ExistsDeviceAddress(USB_MODULE_ID index)
679:                 {
680:                      return USB_ExistsDeviceAddress_Default(index);
681:                 }
682:                 
683:                 PLIB_INLINE_API uint16_t PLIB_USB_FrameNumberGet(USB_MODULE_ID index)
684:                 {
685:                      return USB_FrameNumberGet_Default(index);
686:                 }
687:                 
688:                 PLIB_INLINE_API bool PLIB_USB_ExistsFrameNumber(USB_MODULE_ID index)
689:                 {
690:                      return USB_ExistsFrameNumber_Default(index);
691:                 }
692:                 
693:                 PLIB_INLINE_API USB_PID PLIB_USB_TokenPIDGet(USB_MODULE_ID index)
694:                 {
695:                      return USB_TokenPIDGet_Default(index);
696:                 }
697:                 
698:                 PLIB_INLINE_API void PLIB_USB_TokenPIDSet(USB_MODULE_ID index, USB_PID pidValue)
699:                 {
700:                      USB_TokenPIDSet_Default(index, pidValue);
701:                 }
702:                 
703:                 PLIB_INLINE_API void PLIB_USB_TokenSend(USB_MODULE_ID index, USB_PID pidValue, uint8_t endpoint, uint8_t deviceAddress, bool isLowSpeed)
704:                 {
705:                      USB_TokenSend_Default(index, pidValue, endpoint, deviceAddress, isLowSpeed);
706:                 }
707:                 
708:                 PLIB_INLINE_API bool PLIB_USB_ExistsTokenPID(USB_MODULE_ID index)
709:                 {
710:                      return USB_ExistsTokenPID_Default(index);
711:                 }
712:                 
713:                 PLIB_INLINE_API uint8_t PLIB_USB_TokenEPGet(USB_MODULE_ID index)
714:                 {
715:                      return USB_TokenEPGet_Default(index);
716:                 }
717:                 
718:                 PLIB_INLINE_API void PLIB_USB_TokenEPSet(USB_MODULE_ID index, uint8_t epValue)
719:                 {
720:                      USB_TokenEPSet_Default(index, epValue);
721:                 }
722:                 
723:                 PLIB_INLINE_API bool PLIB_USB_ExistsTokenEP(USB_MODULE_ID index)
724:                 {
725:                      return USB_ExistsTokenEP_Default(index);
726:                 }
727:                 
728:                 PLIB_INLINE_API uint8_t PLIB_USB_SOFThresholdGet(USB_MODULE_ID index)
729:                 {
730:                      return USB_SOFThresholdGet_Default(index);
731:                 }
732:                 
733:                 PLIB_INLINE_API void PLIB_USB_SOFThresholdSet(USB_MODULE_ID index, uint8_t threshold)
734:                 {
735:                      USB_SOFThresholdSet_Default(index, threshold);
736:                 }
737:                 
738:                 PLIB_INLINE_API bool PLIB_USB_ExistsSOFThreshold(USB_MODULE_ID index)
739:                 {
740:                      return USB_ExistsSOFThreshold_Default(index);
741:                 }
742:                 
743:                 PLIB_INLINE_API void* PLIB_USB_BDTBaseAddressGet(USB_MODULE_ID index)
744:                 {
745:                      return USB_BDTBaseAddressGet_Default(index);
746:                 }
747:                 
748:                 PLIB_INLINE_API void PLIB_USB_BDTBaseAddressSet(USB_MODULE_ID index, void* address)
749:                 {
750:                      USB_BDTBaseAddressSet_Default(index, address);
751:                 }
752:                 
753:                 PLIB_INLINE_API bool PLIB_USB_ExistsBDTBaseAddress(USB_MODULE_ID index)
754:                 {
755:                      return USB_ExistsBDTBaseAddress_Default(index);
756:                 }
757:                 
758:                 PLIB_INLINE_API void PLIB_USB_EyePatternDisable(USB_MODULE_ID index)
759:                 {
760:                      USB_EyePatternDisable_Default(index);
761:                 }
762:                 
763:                 PLIB_INLINE_API void PLIB_USB_EyePatternEnable(USB_MODULE_ID index)
764:                 {
765:                      USB_EyePatternEnable_Default(index);
766:                 }
767:                 
768:                 PLIB_INLINE_API bool PLIB_USB_ExistsEyePattern(USB_MODULE_ID index)
769:                 {
770:                      return USB_ExistsEyePattern_Default(index);
771:                 }
772:                 
773:                 PLIB_INLINE_API void PLIB_USB_StopInIdleEnable(USB_MODULE_ID index)
774:                 {
775:                      USB_StopInIdleEnable_Default(index);
776:                 }
777:                 
778:                 PLIB_INLINE_API void PLIB_USB_StopInIdleDisable(USB_MODULE_ID index)
779:                 {
780:                      USB_StopInIdleDisable_Default(index);
781:                 }
782:                 
783:                 PLIB_INLINE_API bool PLIB_USB_ExistsStopInIdle(USB_MODULE_ID index)
784:                 {
785:                      return USB_ExistsStopInIdle_Default(index);
786:                 }
787:                 
788:                 
789:                 
790:                 PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USB_PingPongModeSelect(USB_MODULE_ID index, USB_PING_PONG_MODE ppConfig)
791:                 {
792:                      USB_PingPongModeSelect_Unsupported(index, ppConfig);
793:                 }
794:                 
795:                 PLIB_INLINE_API USB_PING_PONG_MODE _PLIB_UNSUPPORTED PLIB_USB_PingPongModeGet(USB_MODULE_ID index)
796:                 {
797:                      return USB_PingPongModeGet_Unsupported(index);
798:                 }
799:                 
800:                 PLIB_INLINE_API bool PLIB_USB_ExistsPingPongMode(USB_MODULE_ID index)
801:                 {
802:                      return USB_ExistsPingPongMode_Unsupported(index);
803:                 }
804:                 
805:                 PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USB_UOEMonitorEnable(USB_MODULE_ID index)
806:                 {
807:                      USB_UOEMonitorEnable_Unsupported(index);
808:                 }
809:                 
810:                 PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USB_UOEMonitorDisable(USB_MODULE_ID index)
811:                 {
812:                      USB_UOEMonitorDisable_Unsupported(index);
813:                 }
814:                 
815:                 PLIB_INLINE_API bool PLIB_USB_ExistsUOEMonitor(USB_MODULE_ID index)
816:                 {
817:                      return USB_ExistsUOEMonitor_Unsupported(index);
818:                 }
819:                 
820:                 PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USB_OnChipPullUpEnable(USB_MODULE_ID index)
821:                 {
822:                      USB_OnChipPullUpEnable_Unsupported(index);
823:                 }
824:                 
825:                 PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USB_OnChipPullUpDisable(USB_MODULE_ID index)
826:                 {
827:                      USB_OnChipPullUpDisable_Unsupported(index);
828:                 }
829:                 
830:                 PLIB_INLINE_API bool PLIB_USB_ExistsOnChipPullup(USB_MODULE_ID index)
831:                 {
832:                      return USB_ExistsOnChipPullup_Unsupported(index);
833:                 }
834:                 
835:                 PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USB_TransceiverEnable(USB_MODULE_ID index)
836:                 {
837:                      USB_TransceiverEnable_Unsupported(index);
838:                 }
839:                 
840:                 PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USB_TransceiverDisable(USB_MODULE_ID index)
841:                 {
842:                      USB_TransceiverDisable_Unsupported(index);
843:                 }
844:                 
845:                 PLIB_INLINE_API bool PLIB_USB_ExistsOnChipTransceiver(USB_MODULE_ID index)
846:                 {
847:                      return USB_ExistsOnChipTransceiver_Unsupported(index);
848:                 }
849:                 
850:                 PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USB_FullSpeedEnable(USB_MODULE_ID index)
851:                 {
852:                      USB_FullSpeedEnable_Unsupported(index);
853:                 }
854:                 
855:                 PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USB_FullSpeedDisable(USB_MODULE_ID index)
856:                 {
857:                      USB_FullSpeedDisable_Unsupported(index);
858:                 }
859:                 
860:                 PLIB_INLINE_API bool PLIB_USB_ExistsSpeedControl(USB_MODULE_ID index)
861:                 {
862:                      return USB_ExistsSpeedControl_Unsupported(index);
863:                 }
864:                 
865:                 PLIB_INLINE_API void PLIB_USB_EP0LSDirectConnectEnable(USB_MODULE_ID index)
866:                 {
867:                      USB_EP0LSDirectConnectEnable_Default(index);
868:                 }
869:                 
870:                 PLIB_INLINE_API void PLIB_USB_EP0LSDirectConnectDisable(USB_MODULE_ID index)
871:                 {
872:                      USB_EP0LSDirectConnectDisable_Default(index);
873:                 }
874:                 
875:                 PLIB_INLINE_API bool PLIB_USB_ExistsEP0LowSpeedConnect(USB_MODULE_ID index)
876:                 {
877:                      return USB_ExistsEP0LowSpeedConnect_Default(index);
878:                 }
879:                 
880:                 PLIB_INLINE_API void PLIB_USB_EP0NakRetryEnable(USB_MODULE_ID index)
881:                 {
882:                      USB_EP0NakRetryEnable_Default(index);
883:                 }
884:                 
885:                 PLIB_INLINE_API void PLIB_USB_EP0NakRetryDisable(USB_MODULE_ID index)
886:                 {
887:                      USB_EP0NakRetryDisable_Default(index);
888:                 }
889:                 
890:                 PLIB_INLINE_API bool PLIB_USB_ExistsEP0NAKRetry(USB_MODULE_ID index)
891:                 {
892:                      return USB_ExistsEP0NAKRetry_Default(index);
893:                 }
894:                 
895:                 PLIB_INLINE_API void PLIB_USB_EPnTxSelect(USB_MODULE_ID index, uint8_t epValue, USB_EP_TXRX epTxRx)
896:                 {
897:                      USB_EPnTxSelect_Default(index, epValue, epTxRx);
898:                 }
899:                 
900:                 PLIB_INLINE_API void PLIB_USB_EPnRxSelect(USB_MODULE_ID index, uint8_t epValue, USB_EP_TXRX epTxRx)
901:                 {
902:                      USB_EPnRxSelect_Default(index, epValue, epTxRx);
903:                 }
904:                 
905:                 PLIB_INLINE_API void PLIB_USB_EPnTxRxSelect(USB_MODULE_ID index, uint8_t epValue, USB_EP_TXRX epTxRx)
906:                 {
907:                      USB_EPnTxRxSelect_Default(index, epValue, epTxRx);
908:                 }
909:                 
910:                 PLIB_INLINE_API bool PLIB_USB_ExistsEPnTxRx(USB_MODULE_ID index)
911:                 {
912:                      return USB_ExistsEPnTxRx_Default(index);
913:                 }
914:                 
915:                 PLIB_INLINE_API void PLIB_USB_EPnRxEnable(USB_MODULE_ID index, uint8_t endpoint)
916:                 {
917:                      USB_EPnRxEnable_PIC32(index, endpoint);
918:                 }
919:                 
920:                 PLIB_INLINE_API void PLIB_USB_EPnRxDisable(USB_MODULE_ID index, uint8_t endpoint)
921:                 {
922:                      USB_EPnRxDisable_PIC32(index, endpoint);
923:                 }
924:                 
925:                 PLIB_INLINE_API void PLIB_USB_EPnTxEnable(USB_MODULE_ID index, uint8_t endpoint)
926:                 {
927:                      USB_EPnTxEnable_PIC32(index, endpoint);
928:                 }
929:                 
930:                 PLIB_INLINE_API void PLIB_USB_EPnTxDisable(USB_MODULE_ID index, uint8_t endpoint)
931:                 {
932:                      USB_EPnTxDisable_PIC32(index, endpoint);
933:                 }
934:                 
935:                 PLIB_INLINE_API void PLIB_USB_EPnHandshakeEnable(USB_MODULE_ID index, uint8_t epValue)
936:                 {
937:                      USB_EPnHandshakeEnable_PIC32(index, epValue);
938:                 }
939:                 
940:                 PLIB_INLINE_API void PLIB_USB_EPnHandshakeDisable(USB_MODULE_ID index, uint8_t epValue)
941:                 {
942:                      USB_EPnHandshakeDisable_PIC32(index, epValue);
943:                 }
944:                 
945:                 PLIB_INLINE_API void PLIB_USB_EPnControlTransferEnable(USB_MODULE_ID index, uint8_t epValue)
946:                 {
947:                      USB_EPnControlTransferEnable_PIC32(index, epValue);
948:                 }
949:                 
950:                 PLIB_INLINE_API void PLIB_USB_EPnControlTransferDisable(USB_MODULE_ID index, uint8_t epValue)
951:                 {
952:                      USB_EPnControlTransferDisable_PIC32(index, epValue);
953:                 }
954:                 
955:                 PLIB_INLINE_API void PLIB_USB_EPnAttributesSet(USB_MODULE_ID index, uint8_t epValue, int direction, bool isControl, bool handshake)
956:                 {
957:                      USB_EPnAttributesSet_PIC32(index, epValue, direction, isControl, handshake);
958:                 }
959:                 
960:                 PLIB_INLINE_API void PLIB_USB_EPnDirectionDisable(USB_MODULE_ID index, uint8_t epValue, int direction)
961:                 {
962:                      USB_EPnDirectionDisable_PIC32(index, epValue, direction);
963:                 }
964:                 
965:                 PLIB_INLINE_API void PLIB_USB_EPnAttributesClear(USB_MODULE_ID index, uint8_t epValue)
966:                 {
967:                      USB_EPnAttributesClear_PIC32(index, epValue);
968:                 }
969:                 
970:                 PLIB_INLINE_API bool PLIB_USB_EPnIsStalled(USB_MODULE_ID index, uint8_t epValue)
971:                 {
972:                      return USB_EPnIsStalled_PIC32(index, epValue);
973:                 }
974:                 
975:                 PLIB_INLINE_API void PLIB_USB_EPnStallClear(USB_MODULE_ID index, uint8_t epValue)
976:                 {
977:                      USB_EPnStallClear_PIC32(index, epValue);
978:                 }
979:                 
980:                 PLIB_INLINE_API void PLIB_USB_EP0HostSetup(USB_MODULE_ID index)
981:                 {
982:                      USB_EP0HostSetup_PIC32(index);
983:                 }
984:                 
985:                 PLIB_INLINE_API bool PLIB_USB_ExistsEPnRxEnable(USB_MODULE_ID index)
986:                 {
987:                      return USB_ExistsEPnRxEnable_PIC32(index);
988:                 }
989:                 
990:                 PLIB_INLINE_API void* PLIB_USB_BufferAddressGet(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
991:                 {
992:                      return USB_BufferAddressGet_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
993:                 }
994:                 
995:                 PLIB_INLINE_API void PLIB_USB_BufferAddressSet(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong, void* bufferAddress)
996:                 {
997:                      USB_BufferAddressSet_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong, bufferAddress);
998:                 }
999:                 
1000:                PLIB_INLINE_API uint16_t PLIB_USB_BufferByteCountGet(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1001:                {
1002:                     return USB_BufferByteCountGet_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1003:                }
1004:                
1005:                PLIB_INLINE_API void PLIB_USB_BufferByteCountSet(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong, uint16_t bufferByteCount)
1006:                {
1007:                     USB_BufferByteCountSet_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong, bufferByteCount);
1008:                }
1009:                
1010:                PLIB_INLINE_API void PLIB_USB_BufferCancelReleaseToUSB(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1011:                {
1012:                     USB_BufferCancelReleaseToUSB_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1013:                }
1014:                
1015:                PLIB_INLINE_API void PLIB_USB_BufferAllCancelReleaseToUSB(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, int nEndpoints)
1016:                {
1017:                     USB_BufferAllCancelReleaseToUSB_PIC32(index, pBDT, ppMode, nEndpoints);
1018:                }
1019:                
1020:                PLIB_INLINE_API void PLIB_USB_BufferClearAll(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1021:                {
1022:                     USB_BufferClearAll_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1023:                }
1024:                
1025:                PLIB_INLINE_API USB_BUFFER_DATA01 PLIB_USB_BufferDataToggleGet(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1026:                {
1027:                     return USB_BufferDataToggleGet_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1028:                }
1029:                
1030:                PLIB_INLINE_API void PLIB_USB_BufferDataToggleSelect(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong, USB_BUFFER_DATA01 bufferData01)
1031:                {
1032:                     USB_BufferDataToggleSelect_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong, bufferData01);
1033:                }
1034:                
1035:                PLIB_INLINE_API void PLIB_USB_BufferDataToggleSyncEnable(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1036:                {
1037:                     USB_BufferDataToggleSyncEnable_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1038:                }
1039:                
1040:                PLIB_INLINE_API void PLIB_USB_BufferDataToggleSyncDisable(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1041:                {
1042:                     USB_BufferDataToggleSyncDisable_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1043:                }
1044:                
1045:                PLIB_INLINE_API uint8_t PLIB_USB_BufferIndexGet(USB_MODULE_ID index, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1046:                {
1047:                     return USB_BufferIndexGet_PIC32(index, ppMode, epValue, bufferDirection, bufferPingPong);
1048:                }
1049:                
1050:                PLIB_INLINE_API void PLIB_USB_BufferPIDBitsClear(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1051:                {
1052:                     USB_BufferPIDBitsClear_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1053:                }
1054:                
1055:                PLIB_INLINE_API uint8_t PLIB_USB_BufferPIDGet(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1056:                {
1057:                     return USB_BufferPIDGet_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1058:                }
1059:                
1060:                PLIB_INLINE_API bool PLIB_USB_BufferReleasedToSW(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1061:                {
1062:                     return USB_BufferReleasedToSW_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1063:                }
1064:                
1065:                PLIB_INLINE_API void PLIB_USB_BufferReleaseToUSB(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1066:                {
1067:                     USB_BufferReleaseToUSB_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1068:                }
1069:                
1070:                PLIB_INLINE_API void PLIB_USB_BufferSchedule(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong, void* bufferAddress, int16_t bufferByteCount, USB_BUFFER_SCHEDULE_DATA01 bufferData01)
1071:                {
1072:                     USB_BufferSchedule_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong, bufferAddress, bufferByteCount, bufferData01);
1073:                }
1074:                
1075:                PLIB_INLINE_API void PLIB_USB_BufferStallDisable(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1076:                {
1077:                     USB_BufferStallDisable_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1078:                }
1079:                
1080:                PLIB_INLINE_API void PLIB_USB_BufferStallEnable(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1081:                {
1082:                     USB_BufferStallEnable_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1083:                }
1084:                
1085:                PLIB_INLINE_API bool PLIB_USB_BufferStallGet(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection, USB_BUFFER_PING_PONG bufferPingPong)
1086:                {
1087:                     return USB_BufferStallGet_PIC32(index, pBDT, ppMode, epValue, bufferDirection, bufferPingPong);
1088:                }
1089:                
1090:                PLIB_INLINE_API void PLIB_USB_BufferEP0RxStatusInitialize(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, USB_BUFFER_PING_PONG pingpong, uint16_t bufferByteCount)
1091:                {
1092:                     USB_BufferEP0RxStatusInitialize_PIC32(index, pBDT, ppMode, pingpong, bufferByteCount);
1093:                }
1094:                
1095:                PLIB_INLINE_API void PLIB_USB_BufferClearAllDTSEnable(USB_MODULE_ID index, void* pBDT, USB_PING_PONG_MODE ppMode, uint8_t epValue, USB_BUFFER_DIRECTION bufferDirection)
1096:                {
1097:                     USB_BufferClearAllDTSEnable_PIC32(index, pBDT, ppMode, epValue, bufferDirection);
1098:                }
1099:                
1100:                PLIB_INLINE_API bool PLIB_USB_ExistsBDTFunctions(USB_MODULE_ID index)
1101:                {
1102:                     return USB_ExistsBDTFunctions_PIC32(index);
1103:                }
1104:                
1105:                #endif
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000050  00000000   NOP
9D00E110  10400005   BEQ V0, ZERO, 0x9D00E128
9D00E118  8E020010   LW V0, 16(S0)
9D00E140  AE0201E0   SW V0, 480(S0)
9D00E144  AE0201C0   SW V0, 448(S0)
9D00E148  240200F5   ADDIU V0, ZERO, 245
9D00E180  8E020000   LW V0, 0(S0)
9D00E190  8E020010   LW V0, 16(S0)
9D00E1A0  AE020000   SW V0, 0(S0)
9D00E1A4  8E020010   LW V0, 16(S0)
9D00E1CC  8E0201C0   LW V0, 448(S0)
9D00E1DC  8E0201D0   LW V0, 464(S0)
9D00E208  24020020   ADDIU V0, ZERO, 32
9D00E210  8E0201D0   LW V0, 464(S0)
9D00E214  7C022944   INS V0, ZERO, 5, 1
9D00E218  AE0201D0   SW V0, 464(S0)
9D00E21C  8E0201C0   LW V0, 448(S0)
9D00E22C  8E0201D0   LW V0, 464(S0)
9D00E244  AE0401C0   SW A0, 448(S0)
9D00E248  24040010   ADDIU A0, ZERO, 16
9D00E24C  24430080   ADDIU V1, V0, 128
9D00E250  AE0401C0   SW A0, 448(S0)
9D00E270  8E020210   LW V0, 528(S0)
9D00E298  7C023004   INS V0, ZERO, 0, 7
9D00E29C  A2020220   SB V0, 544(S0)
9D00E2B4  24020001   ADDIU V0, ZERO, 1
9D00E2BC  8E0201C0   LW V0, 448(S0)
9D00E2CC  8E0201D0   LW V0, 464(S0)
9D00E2F4  24020010   ADDIU V0, ZERO, 16
9D00E2FC  8E020010   LW V0, 16(S0)
9D00E308  8E0201D0   LW V0, 464(S0)
9D00E31C  8E0201C0   LW V0, 448(S0)
9D00E32C  8E0201D0   LW V0, 464(S0)
9D00E354  24020004   ADDIU V0, ZERO, 4
9D00E35C  8E0201C0   LW V0, 448(S0)
9D00E36C  8E0201D0   LW V0, 464(S0)
9D00E380  2462002C   ADDIU V0, V1, 44
9D00E3C8  24020080   ADDIU V0, ZERO, 128
9D00E3D0  8E0201C0   LW V0, 448(S0)
9D00E438  8E0201C0   LW V0, 448(S0)
9D00E448  8E110200   LW S1, 512(S0)
9D00E460  AE1401C0   SW S4, 448(S0)
9D00E4F0  8E020020   LW V0, 32(S0)
9D00E4F4  7C4200C0   EXT V0, V0, 3, 1
9D00E520  AE030000   SW V1, 0(S0)
9D00E548  8E0201D0   LW V0, 464(S0)
9D00E558  8E0201E0   LW V0, 480(S0)
9D00E568  24020002   ADDIU V0, ZERO, 2
9D00E59C  AE050000   SW A1, 0(S0)
9D00E618  A2040210   SB A0, 528(S0)
9D00E718  24020008   ADDIU V0, ZERO, 8
9D012694  2414FFFC   ADDIU S4, ZERO, -4
9D012B9C  AD0902C0   SW T1, 704(T0)
9D012C00  00084100   SLL T0, T0, 4
9D013E50  922202A0   LBU V0, 672(S1)
9D013E5C  7C622104   INS V0, V1, 4, 1
9D013E64  90A20009   LBU V0, 9(A1)
9D013E70  AE2202A8   SW V0, 680(S1)
9D013E90  00022602   SRL A0, V0, 24
9D013ED0  A22202A0   SB V0, 672(S1)
9D013ED4  90A20009   LBU V0, 9(A1)
9D013EE0  AE2202A4   SW V0, 676(S1)
9D014BF0  8C8202C0   LW V0, 704(A0)
9D014C24  8C8702C0   LW A3, 704(A0)
9D014C54  00041900   SLL V1, A0, 4
9D017678  AC4501C0   SW A1, 448(V0)
9D01767C  8C4301D0   LW V1, 464(V0)
9D01768C  AC4501E0   SW A1, 480(V0)
9D017690  8C4301F0   LW V1, 496(V0)
9D01769C  240300F5   ADDIU V1, ZERO, 245
9D0176A4  8C430010   LW V1, 16(V0)
9D0176B0  90430210   LBU V1, 528(V0)
9D0178D4  90430210   LBU V1, 528(V0)
9D017908  240300DF   ADDIU V1, ZERO, 223
9D017F68  8C830020   LW V1, 32(A0)
9D018990  8C830020   LW V1, 32(A0)
9D018B8C  8C820020   LW V0, 32(A0)
9D018BB4  8C830020   LW V1, 32(A0)
9D018BDC  8C830020   LW V1, 32(A0)
9D018C04  AC4301D0   SW V1, 464(V0)
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/drv_usbfs_device.c  ---
1:                   /*******************************************************************************
2:                     USB Device Driver Implementation of device mode operation routines
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_usbfs_device.c
9:                   
10:                    Summary:
11:                      USB Device Driver Dynamic Implementation of device mode operation routines
12:                  
13:                    Description:
14:                      The USB device driver provides a simple interface to manage the USB modules
15:                      on Microchip microcontrollers.  This file implements the interface routines
16:                      for the USB driver when operating in device mode.
17:                  
18:                      While building the driver from source, ALWAYS use this file in the build if
19:                      device mode operation is required.
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip  Technology  Inc.   All  rights  reserved.
25:                  
26:                  Microchip licenses to  you  the  right  to  use,  modify,  copy  and  distribute
27:                  Software only when embedded on a Microchip  microcontroller  or  digital  signal
28:                  controller  that  is  integrated  into  your  product  or  third  party  product
29:                  (pursuant to the  sublicense  terms  in  the  accompanying  license  agreement).
30:                  
31:                  You should refer  to  the  license  agreement  accompanying  this  Software  for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS  WITHOUT  WARRANTY  OF  ANY  KIND,
35:                  EITHER EXPRESS  OR  IMPLIED,  INCLUDING  WITHOUT  LIMITATION,  ANY  WARRANTY  OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A  PARTICULAR  PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR  ITS  LICENSORS  BE  LIABLE  OR  OBLIGATED  UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,  BREACH  OF  WARRANTY,  OR
39:                  OTHER LEGAL  EQUITABLE  THEORY  ANY  DIRECT  OR  INDIRECT  DAMAGES  OR  EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY  INCIDENTAL,  SPECIAL,  INDIRECT,  PUNITIVE  OR
41:                  CONSEQUENTIAL DAMAGES, LOST  PROFITS  OR  LOST  DATA,  COST  OF  PROCUREMENT  OF
42:                  SUBSTITUTE  GOODS,  TECHNOLOGY,  SERVICES,  OR  ANY  CLAIMS  BY  THIRD   PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  THEREOF),  OR  OTHER  SIMILAR  COSTS.
44:                  *******************************************************************************/
45:                  //DOM-IGNORE-END
46:                  
47:                  #include "configuration.h"
48:                  #include "driver/usb/usbfs/drv_usbfs.h"
49:                  #include "driver/usb/usbfs/src/drv_usbfs_local.h"
50:                  
51:                  /*****************************************************
52:                   * This structure is a pointer to a set of USB Driver
53:                   * Device mode functions. This set is exported to the
54:                   * device layer when the device layer must use the
55:                   * PIC32MX USB Controller.
56:                   ******************************************************/
57:                  
58:                  DRV_USB_DEVICE_INTERFACE gDrvUSBFSDeviceInterface =
59:                  {
60:                      .open = DRV_USBFS_Open,
61:                      .close = DRV_USBFS_Close,
62:                      .eventHandlerSet = DRV_USBFS_ClientEventCallBackSet,
63:                      .deviceAddressSet = DRV_USBFS_DEVICE_AddressSet,
64:                      .deviceCurrentSpeedGet = DRV_USBFS_DEVICE_CurrentSpeedGet,
65:                      .deviceSOFNumberGet = DRV_USBFS_DEVICE_SOFNumberGet,
66:                      .deviceAttach = DRV_USBFS_DEVICE_Attach,
67:                      .deviceDetach = DRV_USBFS_DEVICE_Detach,
68:                      .deviceEndpointEnable = DRV_USBFS_DEVICE_EndpointEnable,
69:                      .deviceEndpointDisable = DRV_USBFS_DEVICE_EndpointDisable,
70:                      .deviceEndpointStall = DRV_USBFS_DEVICE_EndpointStall,
71:                      .deviceEndpointStallClear = DRV_USBFS_DEVICE_EndpointStallClear,
72:                      .deviceEndpointIsEnabled = DRV_USBFS_DEVICE_EndpointIsEnabled,
73:                      .deviceEndpointIsStalled = DRV_USBFS_DEVICE_EndpointIsStalled,
74:                      .deviceIRPSubmit = DRV_USBFS_DEVICE_IRPSubmit,
75:                      .deviceIRPCancel = DRV_USBFS_DEVICE_IRPCancel,
76:                      .deviceIRPCancelAll = DRV_USBFS_DEVICE_IRPCancelAll,
77:                      .deviceRemoteWakeupStop = DRV_USBFS_DEVICE_RemoteWakeupStop,
78:                      .deviceRemoteWakeupStart = DRV_USBFS_DEVICE_RemoteWakeupStart,
79:                      .deviceTestModeEnter = NULL
80:                  };
81:                  
82:                  // *****************************************************************************
83:                  /* Function:
84:                      _DRV_USBFS_DEVICE_Initialize(DRV_USBFS_OBJ * drvObj, SYS_MODULE_INDEX index)
85:                  
86:                    Summary:
87:                      This function is calle when the driver is intialized for device mode
88:                      operation.
89:                  
90:                    Description:
91:                      This function is called when the driver is intialized for device mode
92:                      operation. The function enables USB_OTG_INT_SESSION_VALID interrupt to
93:                      detect VBUS session valid\invalid scenario. All the other interrupts will be
94:                      enabled after the device has been attached (DRV_USBFS_DEVICE_Attach()
95:                      function will be called)
96:                  
97:                    Remarks:
98:                      See drv_usbfs.h for usage information.
99:                  */
100:                 
101:                 void _DRV_USBFS_DEVICE_Initialize
102:                 (
103:                     DRV_USBFS_OBJ * drvObj, 
104:                     SYS_MODULE_INDEX index
105:                 )
106:                 {
107:                     /* Initialize device specific flags */
108:                     drvObj->vbusIsValid = false;
109:                     drvObj->isAttached = false;
110:                     drvObj->isSuspended = false;
111:                 
112:                     /* Disable all interrupts */
113:                     PLIB_USB_AllInterruptEnable(drvObj->usbID, ~USB_INT_ALL, ~USB_ERR_INT_ALL, ~USB_OTG_INT_ALL);
114:                 }
115:                 
116:                 // *****************************************************************************
117:                 /* Function:
118:                     void DRV_USBFS_DEVICE_AddressSet(DRV_HANDLE handle, uint8_t address)
119:                 
120:                   Summary:
121:                     This function will set the USB module address that is obtained from the Host.
122:                 
123:                   Description:
124:                     This function will set the USB module address  that  is  obtained  from  the
125:                     Host in a setup transaction. The address is obtained from  the  SET_ADDRESS
126:                     command issued by the Host. The  primary  (first)  client  of  the  driver
127:                     uses this function to set the module's USB address after decoding the  setup
128:                     transaction from the Host.
129:                 
130:                   Remarks:
131:                     See drv_usbfs.h for usage information.
132:                 */
133:                 
134:                 void DRV_USBFS_DEVICE_AddressSet(DRV_HANDLE handle, uint8_t address)
135:                 {
136:                     /* Check if the handle is valid */
137:                     if((DRV_HANDLE_INVALID != handle) && (handle != (DRV_HANDLE)(NULL)))
138:                     {
139:                         /* Set the address */
140:                         PLIB_USB_DeviceAddressSet( ((DRV_USBFS_OBJ *)handle)->usbID, address );
141:                     }
142:                     else
143:                     {
144:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
145:                     }
146:                 }
147:                 
148:                 // *****************************************************************************
149:                 /* Function:
150:                     USB_SPEED DRV_USBFS_DEVICE_CurrentSpeedGet(DRV_HANDLE handle)
151:                 
152:                   Summary:
153:                     This function returns the USB speed at which the device is operating.
154:                 
155:                   Description:
156:                     This function returns the USB speed at which the device is operating. 
157:                 
158:                   Remarks:
159:                     See drv_usbfs.h for usage information.
160:                 */
161:                 
162:                 USB_SPEED DRV_USBFS_DEVICE_CurrentSpeedGet(DRV_HANDLE handle)
163:                 {
164:                     USB_SPEED speed = USB_SPEED_ERROR;
165:                 
166:                     /* Check if the handle is valid */
167:                     if((DRV_HANDLE_INVALID != handle) && (handle != (DRV_HANDLE)(NULL)))
168:                     {
169:                         speed = USB_SPEED_FULL;
170:                     }
171:                     else
172:                     {
173:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
174:                     }
175:                     
176:                     /* Return the speed */
177:                     return speed;
178:                 }
179:                 
180:                 // *****************************************************************************
181:                 /* Function:
182:                     void DRV_USBFS_DEVICE_RemoteWakeup_Start(DRV_HANDLE handle)
183:                 
184:                   Summary:
185:                     This function causes the device to start Remote Wakeup Signalling on the
186:                     bus.
187:                     
188:                   Description:
189:                     This function causes the device to start Remote Wakeup Signalling on the
190:                     bus. This function should be called when the device, presently placed in
191:                     suspend mode by the Host, wants to be wakeup. Note that the device can do
192:                     this only when the Host has enabled the device's Remote Wakeup capability.
193:                 
194:                   Remarks:
195:                     See drv_usbfs.h for usage information.
196:                 */
197:                 
198:                 void DRV_USBFS_DEVICE_RemoteWakeupStart(DRV_HANDLE handle)
199:                 {
200:                     /* Check if the handle is valid */
201:                     if((DRV_HANDLE_INVALID != handle) && (handle != (DRV_HANDLE)(NULL)))
202:                     {
203:                         /* Enable Resume signalling */
204:                         PLIB_USB_ResumeSignalingEnable(((DRV_USBFS_OBJ *)handle)->usbID);
205:                     }
206:                     else
207:                     {
208:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
209:                     }
210:                 }
211:                 
212:                 // *****************************************************************************
213:                 /* Function:
214:                     void DRV_USBFS_DEVICE_RemoteWakeupStop(DRV_HANDLE handle)
215:                 
216:                   Summary:
217:                     This function causes the device to stop the Remote Wakeup Signalling on the
218:                     bus.
219:                     
220:                   Description:
221:                     This function causes the device to stop Remote Wakeup Signalling on the bus.
222:                     This function should be called after the DRV_USBFS_DEVICE_RemoteWakeupStart
223:                     function was called to start the Remote Wakeup signaling on the bus.
224:                 
225:                   Remarks:
226:                     See drv_usbfs.h for usage information.
227:                 */
228:                 
229:                 void DRV_USBFS_DEVICE_RemoteWakeupStop(DRV_HANDLE handle)
230:                 {
231:                     /* Check if the handle is valid */
232:                     if((DRV_HANDLE_INVALID != handle) && (handle != (DRV_HANDLE)(NULL)))
233:                     {
234:                         /* Disable Resume signalling */
235:                         PLIB_USB_ResumeSignalingDisable(((DRV_USBFS_OBJ *)handle)->usbID);
236:                     }
237:                     else
238:                     {
239:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
240:                     }
241:                 }
242:                 
243:                 // *****************************************************************************
244:                 /* Function:
245:                     void DRV_USBFS_DEVICE_Attach(DRV_HANDLE handle)
246:                 
247:                   Summary:
248:                     This function will enable the attach signaling resistors on the D+ and D-
249:                     lines thus letting the USB Host know that a device has been attached on the
250:                     bus.
251:                 
252:                   Description:
253:                     This function enables the pull-up resistors on the D+ or D- lines thus
254:                     letting the USB Host know that a device has been attached on the bus . This
255:                     function should be called when the driver client is ready  to  receive
256:                     communication  from  the  Host (typically after all initialization is
257:                     complete). The USB 2.0 specification requires VBUS to be detected before the
258:                     data line pull-ups are enabled. The application must ensure the same.
259:                 
260:                   Remarks:
261:                     See drv_usbfs.h for usage information.
262:                 */
263:                 
264:                 void DRV_USBFS_DEVICE_Attach(DRV_HANDLE handle)
265:                 {
266:                     /* Check if the handle is valid */
267:                     if((DRV_HANDLE_INVALID != handle) && (handle != (DRV_HANDLE)(NULL)))
268:                     {
269:                         /* Update the driver flag indicating attach */
270:                         ((DRV_USBFS_OBJ *)handle)->isAttached = true;
271:                 
272:                         /* Configure the peripheral for device mode operation. This function
273:                          * also enables the D+ pull up resistor.  */
274:                         PLIB_USB_OperatingModeSelect(((DRV_USBFS_OBJ *)handle)->usbID, USB_OPMODE_DEVICE);
275:                 
276:                         /* Enables all interrupts except RESUME. RESUMEIF will be enabled only
277:                          * on getting SUSPEND */
278:                         PLIB_USB_AllInterruptEnable(((DRV_USBFS_OBJ *)handle)->usbID, (USB_INT_ALL & ~USB_INT_RESUME), USB_ERR_INT_ALL, ((~USB_OTG_INT_ALL) | USB_OTG_INT_SESSION_VALID | USB_OTG_INT_ACTIVITY_DETECT));
279:                     }
280:                     else
281:                     {
282:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
283:                     }
284:                 }
285:                 
286:                 // *****************************************************************************
287:                 /* Function:
288:                       void DRV_USBFS_DEVICE_Detach(DRV_HANDLE handle)
289:                 
290:                   Summary:
291:                     This function will disable the attach signaling resistors on the D+ and D-
292:                     lines thus letting the USB Host know that the device has detached from the
293:                     bus.
294:                 
295:                   Description:
296:                     This function disables the pull-up resistors on the D+ or D- lines. This
297:                     function should be called when the application wants to disconnect the
298:                     device  from  the bus (typically to implement a soft detach or switch  to
299:                     Host  mode operation).  A self-powered device should be detached from the
300:                     bus when the VBUS is not valid.
301:                 
302:                   Remarks:
303:                     See drv_usbfs.h for usage information.
304:                 */
305:                 
306:                 void DRV_USBFS_DEVICE_Detach(DRV_HANDLE handle)
307:                 {
308:                     /* Check if the handle is valid */
309:                     if((DRV_HANDLE_INVALID != handle) && (handle != (DRV_HANDLE)(NULL)))
310:                     {
311:                         /* Update the driver flag indicating detach */
312:                         ((DRV_USBFS_OBJ *)handle)->isAttached = false;
313:                 
314:                         /* Clear all the USB interrupt flags */
315:                         PLIB_USB_InterruptFlagClear(((DRV_USBFS_OBJ *)handle)->usbID, USB_INT_ALL);
316:                         
317:                         /* Disable all the USB interrupts */
318:                         PLIB_USB_InterruptDisable(((DRV_USBFS_OBJ *)handle)->usbID, (USB_INT_ALL)); 
319:                         
320:                         /* Clear all USB Error Interrupt flags */
321:                         PLIB_USB_ErrorInterruptFlagClear(((DRV_USBFS_OBJ *)handle)->usbID, USB_ERR_INT_ALL);
322:                         
323:                         /* Disable all USB Error interrupts */
324:                         PLIB_USB_ErrorInterruptDisable(((DRV_USBFS_OBJ *)handle)->usbID, USB_ERR_INT_ALL);   
325:                         
326:                         /* Clear the interrupt flags excep Session Valid interrupt flag */
327:                         PLIB_USB_OTG_InterruptFlagClear(((DRV_USBFS_OBJ *)handle)->usbID, (USB_OTG_INT_ALL & (~ USB_OTG_INT_SESSION_VALID)));
328:                         
329:                         /* Disable all interrupts except Session Valid Interrupt Enable */
330:                         PLIB_USB_OTG_InterruptDisable(((DRV_USBFS_OBJ *)handle)->usbID, (USB_OTG_INT_ALL & (~ USB_OTG_INT_SESSION_VALID))); 
331:                         
332:                         /* Reset the operating mode */
333:                         PLIB_USB_OperatingModeSelect(((DRV_USBFS_OBJ *)handle)->usbID, USB_OPMODE_NONE);
334:                     }
335:                     else
336:                     {
337:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
338:                     }
339:                 }
340:                 
341:                 // *****************************************************************************
342:                 /* Function:
343:                     void _DRV_USBFS_DEVICE_EndpointObjectEnable
344:                     (
345:                         DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject,
346:                         uint16_t endpointSize,
347:                         USB_TRANSFER_TYPE endpointType,
348:                         USB_BUFFER_DATA01 dataToggle
349:                      )
350:                 
351:                   Summary:
352:                     This helper function populates the software endpoint object with provided
353:                     data.
354:                 
355:                   Description:
356:                     This helper function populates the software endpoint object with provided
357:                     data.
358:                 
359:                   Remarks:
360:                     This is a local function and should not be called directly by the
361:                     application.
362:                 */
363:                 
364:                 void _DRV_USBFS_DEVICE_EndpointObjectEnable
365:                 (
366:                     DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject,
367:                     uint16_t endpointSize,
368:                     USB_TRANSFER_TYPE endpointType,
369:                     USB_BUFFER_DATA01 dataToggle,
370:                     USB_PING_PONG_STATE nextPingPong
371:                 )
372:                 {
373:                     /* This is a helper function */
374:                     endpointObject->nextDataToggle  = USB_BUFFER_DATA0;
375:                     endpointObject->irpQueue        = NULL;
376:                     endpointObject->maxPacketSize   = endpointSize;
377:                     endpointObject->nextPingPong    = nextPingPong;
378:                     endpointObject->endpointType    = endpointType;
379:                     endpointObject->endpointState  |= DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED;
380:                     
381:                 }
382:                 
383:                 // *****************************************************************************
384:                 /* Function:
385:                     USB_ERROR DRV_USBFS_DEVICE_EndpointEnable
386:                     (
387:                         DRV_HANDLE handle,
388:                         USB_ENDPOINT endpointAndDirection,
389:                         USB_TRANSFER_TYPE endpointType,
390:                         uint16_t endpointSize
391:                     )
392:                 
393:                   Summary:
394:                     This function enables an endpoint for the specified direction and endpoint
395:                     size.
396:                     
397:                   Description:
398:                     This function enables an endpoint for the specified direction and endpoint
399:                     size. The function will enable the endpoint for communication in one
400:                     direction at a time. It must be called twice if the endpoint is required to
401:                     communicate in both the directions, with the exception of control endpoints.
402:                     If the endpoint type is a control endpoint, the endpoint is always
403:                     bidirectional and the function needs to be called only once.  
404:                     
405:                     The size of the endpoint must match the wMaxPacketSize reported in the
406:                     endpoint descriptor for this endpoint. A transfer that is scheduled over
407:                     this endpoint will be scheduled in wMaxPacketSize transactions. The function
408:                     does not check if the endpoint is already in use. It is the client's
409:                     responsibility to make sure that a endpoint is not accidentally reused.
410:                 
411:                   Remarks:
412:                     See drv_usbfs.h for usage information.
413:                 */
414:                 
415:                 USB_ERROR DRV_USBFS_DEVICE_EndpointEnable
416:                 (
417:                     DRV_HANDLE handle, 
418:                     USB_ENDPOINT endpointAndDirection, 
419:                     USB_TRANSFER_TYPE endpointType,
420:                     uint16_t endpointSize
421:                 )
422:                 {
423:                     /* This function can be called from from the USB ISR. Because an endpoint
424:                      * can be owned by one client only, we dont need mutex protection in this
425:                      * function */
426:                 
427:                     int direction;
428:                     int iEntry;
429:                     bool handshake;
430:                     uint8_t endpoint;
431:                     DRV_USBFS_OBJ * hDriver;
432:                     USB_MODULE_ID usbID;
433:                     DRV_USBFS_BDT_ENTRY * pBDT;
434:                     DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject;
435:                     USB_PING_PONG_STATE nextPingPong;
436:                     uint32_t mask = 1;
437:                     USB_ERROR returnValue = USB_ERROR_NONE;
438:                 
439:                     /* Enable the endpoint */
440:                 
441:                     endpoint = endpointAndDirection & 0xF;
442:                     direction = ((endpointAndDirection & 0x80) != 0);
443:                     
444:                     if(endpoint < DRV_USBFS_ENDPOINTS_NUMBER)
445:                     {
446:                         if((DRV_HANDLE_INVALID != handle) && (handle != (DRV_HANDLE)(NULL)))
447:                         {
448:                             /* Check if the handle is valid */
449:                             usbID = ((DRV_USBFS_OBJ *)handle)->usbID;
450:                             hDriver = (DRV_USBFS_OBJ *)handle;
451:                 
452:                             /* The BDT table has four entries per endpoint The following statement
453:                              * points pBDT to the first endpoint specific entry */
454:                 
455:                             pBDT = hDriver->pBDT + (endpoint * 4);
456:                 
457:                             /* Get the pointer to the endpoint object */
458:                 
459:                             endpointObject = (hDriver->endpointTable + (2 * endpoint) + 0);
460:                 
461:                             if(endpointType == USB_TRANSFER_TYPE_CONTROL)
462:                             {
463:                                 /* For a control endpoint enable both directions. Clear up the
464:                                  * BDT entries. */
465:                 
466:                                 uint32_t * pBDT32bit = (uint32_t *)pBDT;
467:                 
468:                                 for(iEntry = 0; iEntry < 7; iEntry ++)
469:                                 {
470:                                     /* A full duplex endpoint has 4 entries, 2 for each
471:                                      * direction */
472:                 
473:                                     *(pBDT32bit + iEntry) = 0;
474:                                 }
475:                 
476:                                 /* The following function enables both directions */
477:                 
478:                                 PLIB_USB_EPnAttributesSet( usbID, endpoint, 0, true, 0 );
479:                 
480:                                 /* The BDT even odd buffer descriptor entries to be used is is
481:                                  * contained in the tx/rx endpoint next ping pong indicators.
482:                                  * These indicators are updated when the hardware interrupts
483:                                  * occur */
484:                 
485:                                 mask = mask << endpoint ; 
486:                                 if ( hDriver->rxEndpointsNextPingPong & mask  )
487:                                 {
488:                                     nextPingPong = USB_PING_PONG_ODD ;
489:                                 }
490:                                 else
491:                                 {
492:                                     nextPingPong = USB_PING_PONG_EVEN;
493:                                 }
494:                 
495:                                 /* This is the RX endpoint */        
496:                                 _DRV_USBFS_DEVICE_EndpointObjectEnable(endpointObject, endpointSize, endpointType, USB_BUFFER_DATA0,nextPingPong);
497:                 
498:                                 /* This is when data moves from device to host. For control end
499:                                  * points the Data toggle always starts with DATA1. */
500:                 
501:                                 endpointObject ++;
502:                 
503:                                 if ( hDriver->txEndpointsNextPingPong & mask  )
504:                                 {
505:                                     nextPingPong = USB_PING_PONG_ODD; 
506:                                 }
507:                                 else
508:                                 {
509:                                     nextPingPong = USB_PING_PONG_EVEN;
510:                                 }
511:                 
512:                                 /* Update the TX endpoint object */
513:                                 _DRV_USBFS_DEVICE_EndpointObjectEnable(endpointObject, endpointSize, endpointType, USB_BUFFER_DATA1,nextPingPong);
514:                             }
515:                             else
516:                             {
517:                                 /* Clear up the even odd entries for this endpoint direction in
518:                                  * the BDT.  Each entry has 2 32 bit entries */
519:                 
520:                                 pBDT += (2 * direction);
521:                 
522:                                 /* Clear up the even entry */
523:                                 pBDT->word[0] = 0;
524:                                 pBDT->word[1] = 0;
525:                                 pBDT ++;
526:                 
527:                                 /* Clear up the odd entry */
528:                                 pBDT->word[0] = 0;
529:                                 pBDT->word[1] = 0;
530:                 
531:                                 handshake = (endpointType == USB_TRANSFER_TYPE_ISOCHRONOUS) ? false : true;
532:                                 PLIB_USB_EPnAttributesSet(usbID, endpoint, direction, false, handshake);
533:                                 mask = mask << endpoint ;
534:                 
535:                                 /* Update the endpoint database */
536:                                 if( direction == 0)
537:                                 {
538:                                     if ( hDriver->rxEndpointsNextPingPong & mask  )
539:                                     {
540:                                         /* This means the next ping pong entry should be ODD */
541:                                         nextPingPong = USB_PING_PONG_ODD ;
542:                                     }
543:                                     else
544:                                     {
545:                                         /* This means the next ping entry should be even */
546:                                         nextPingPong = USB_PING_PONG_EVEN;
547:                                     }
548:                                 }
549:                                 else  
550:                                 {
551:                                     if ( hDriver->txEndpointsNextPingPong & mask  )
552:                                     {
553:                                         nextPingPong = USB_PING_PONG_ODD; 
554:                                     }
555:                                     else
556:                                     {
557:                                         nextPingPong = USB_PING_PONG_EVEN;
558:                                     }
559:                                 }
560:                 
561:                                 /* Update the endpoint object */
562:                                 endpointObject += direction;
563:                                 _DRV_USBFS_DEVICE_EndpointObjectEnable(endpointObject, endpointSize, endpointType, USB_BUFFER_DATA0 ,nextPingPong);
564:                             }
565:                         }
566:                         else
567:                         {
568:                             SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
569:                             returnValue = USB_ERROR_PARAMETER_INVALID;
570:                         }
571:                     }
572:                     else
573:                     {
574:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO,"\r\nUSBFS Driver: Unsupported endpoint");
575:                         returnValue = USB_ERROR_DEVICE_ENDPOINT_INVALID;
576:                     }
577:                     
578:                     return(returnValue);
579:                 }
580:                 
581:                 // *****************************************************************************
582:                 /* Function:
583:                     USB_ERROR DRV_USBFS_DEVICE_EndpointDisable
584:                     (
585:                         DRV_HANDLE handle,
586:                         USB_ENDPOINT endpointAndDirection
587:                     )
588:                 
589:                   Summary:
590:                     This function disables an endpoint.
591:                     
592:                   Description:
593:                     This function disables an endpoint. If the endpoint type is a control
594:                     endpoint type, both directions are disabled. For non-control endpoints, the
595:                     function disables the specified direction only. The direction to be disabled 
596:                     is specified by the Most Significant Bit (MSB) of the endpointAndDirection 
597:                     parameter.
598:                 
599:                   Remarks:
600:                     See drv_usbfs.h for usage information.
601:                 */
602:                 
603:                 USB_ERROR DRV_USBFS_DEVICE_EndpointDisable
604:                 (
605:                     DRV_HANDLE handle, 
606:                     USB_ENDPOINT endpointAndDirection
607:                 )
608:                 {
609:                     /* This routine disables the specified endpoint.  It does not check if there
610:                      * is any ongoing communication on the bus through the endpoint */
611:                 
612:                     uint8_t endpoint;
613:                     int  direction, iEntry;
614:                     DRV_USBFS_OBJ * hDriver;
615:                     DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject;
616:                     USB_MODULE_ID usbID;
617:                     USB_ERROR returnValue  = USB_ERROR_NONE;
618:                 
619:                     /* Check if the handle is valid */
620:                     if((DRV_HANDLE_INVALID != handle) && (handle != (DRV_HANDLE)(NULL)))
621:                     {
622:                         /* Get the pointer to associated endpoint object table. Note that the
623:                          * default value of returnValue is USB_ERROR_NONE. This is the value
624:                          * that will returned if the function excutes all the success paths. */
625:                 
626:                         hDriver = ((DRV_USBFS_OBJ *)handle);
627:                         usbID = hDriver->usbID;
628:                         endpointObject = hDriver->endpointTable;
629:                 
630:                         /* If the endpointAndDirection is _DRV_USBFS_DEVICE_ENDPOINT_ALL then
631:                          * this means that the DRV_USBFS_DEVICE_EndpointDisableAll() function
632:                          * was called */
633:                 
634:                         if(endpointAndDirection == DRV_USBFS_DEVICE_ENDPOINT_ALL)
635:                         {
636:                             for(iEntry = 0; iEntry < DRV_USBFS_ENDPOINTS_NUMBER; iEntry ++)
637:                             {
638:                                 PLIB_USB_EPnAttributesClear(usbID, iEntry);
639:                 
640:                                 /* Update the endpoint database */
641:                 
642:                                 endpointObject->endpointState  &= ~DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED;
643:                                 endpointObject ++;
644:                                 endpointObject->endpointState  &= ~DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED;
645:                                 endpointObject ++;
646:                             }
647:                         }
648:                         else
649:                         {
650:                             /* A specific endpoint and direction needs to be disabled */
651:                 
652:                             endpoint = endpointAndDirection & 0xF;
653:                             direction = ((endpointAndDirection & 0x80) != 0);
654:                 
655:                             if(endpoint < DRV_USBFS_ENDPOINTS_NUMBER)
656:                             {
657:                                 /* Setup the endpointObj to point to the correct endpoint object */
658:                 
659:                                 endpointObject += ((2 * endpoint) + direction);
660:                 
661:                                 if(endpointObject->endpointType == USB_TRANSFER_TYPE_CONTROL)
662:                                 {
663:                                     /* Disable a control endpoint and update the endpoint
664:                                      * database. */
665:                 
666:                                     PLIB_USB_EPnAttributesClear(usbID, endpoint);
667:                                     endpointObject->endpointState  &= ~DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED;
668:                                     endpointObject += 1;
669:                                     endpointObject->endpointState  &= ~DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED;
670:                                 }
671:                                 else
672:                                 {
673:                                     /* Disable a specific endpoint direction for non control
674:                                      * endpoints */
675:                 
676:                                     PLIB_USB_EPnDirectionDisable(usbID, endpoint, direction);
677:                                     endpoint += direction;
678:                                     endpointObject->endpointState  &= ~DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED;
679:                                 }
680:                             }
681:                             else
682:                             {
683:                                 /* This means the endpoint is not valid */
684:                                 SYS_DEBUG_MESSAGE(SYS_ERROR_INFO,"\r\nUSBFS Driver: Unsupported endpoint");
685:                                 returnValue = USB_ERROR_DEVICE_ENDPOINT_INVALID;
686:                             }
687:                         }
688:                     }
689:                     else
690:                     {
691:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
692:                         returnValue = USB_ERROR_PARAMETER_INVALID;
693:                     }
694:                 
695:                     return(returnValue);
696:                 }
697:                 
698:                 // *****************************************************************************
699:                 /* Function:
700:                     bool DRV_USBFS_DEVICE_EndpointIsEnabled
701:                     (
702:                         DRV_HANDLE client,
703:                         USB_ENDPOINT endpointAndDirection
704:                     )
705:                 
706:                   Summary:
707:                     This function returns the enable/disable status of the specified endpoint
708:                     and direction.
709:                     
710:                   Description:
711:                     This function returns the enable/disable status of the specified endpoint
712:                     and direction.
713:                 
714:                   Remarks:
715:                     See drv_usbfs.h for usage information.
716:                 */
717:                 
718:                 bool DRV_USBFS_DEVICE_EndpointIsEnabled
719:                 (
720:                     DRV_HANDLE client, 
721:                     USB_ENDPOINT endpointAndDirection
722:                 )
723:                 {
724:                     DRV_USBFS_OBJ * hDriver;
725:                     DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObj;
726:                     bool isEnabled = false;
727:                 
728:                     uint8_t endpoint = endpointAndDirection & 0xF;
729:                     int direction = ((endpointAndDirection & 0x80) != 0);
730:                 
731:                     /* Check if the handle is valid */
732:                     if((DRV_HANDLE_INVALID != client) && (client != (DRV_HANDLE)(NULL)))
733:                     {
734:                         if(endpoint < DRV_USBFS_ENDPOINTS_NUMBER)
735:                         {
736:                             hDriver = ((DRV_USBFS_OBJ *)client);
737:                             endpointObj = hDriver->endpointTable + (2 * endpoint) + direction;
738:                 
739:                             /* The default value of isEnabled is false. Check the endpoint state. */
740:                             if((endpointObj->endpointState & DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED) != 0)
741:                             {
742:                                 isEnabled = true;
743:                             }
744:                         }
745:                         else
746:                         {
747:                             SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Endpoint is not invalid");
748:                         }
749:                     }
750:                     else
751:                     {
752:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
753:                     }
754:                 
755:                     return (isEnabled);
756:                 }
757:                 
758:                 // *****************************************************************************
759:                 /* Function:
760:                     bool DRV_USBFS_DEVICE_EndpointIsStalled
761:                     (
762:                         DRV_HANDLE client,
763:                         USB_ENDPOINT endpointAndDirection
764:                     )
765:                 
766:                   Summary:
767:                     This function returns the stall status of the specified endpoint and
768:                     direction.
769:                 
770:                   Description:
771:                     This function returns the stall status of the specified endpoint and
772:                     direction.
773:                 
774:                   Remarks:
775:                     See drv_usbfs.h for usage information.
776:                 */
777:                 
778:                 bool DRV_USBFS_DEVICE_EndpointIsStalled
779:                 (
780:                     DRV_HANDLE client, 
781:                     USB_ENDPOINT endpointAndDirection
782:                 )
783:                 {
784:                     DRV_USBFS_OBJ * hDriver;
785:                     DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObj;
786:                     uint8_t endpoint = endpointAndDirection & 0xF;
787:                     int direction = ((endpointAndDirection & 0x80) != 0);
788:                     bool isStalled = false;
789:                 
790:                     /* Check if the handle is valid */
791:                     if((DRV_HANDLE_INVALID != client) && (client != (DRV_HANDLE)(NULL)))
792:                     {
793:                         hDriver = ((DRV_USBFS_OBJ *)client);
794:                 
795:                         if(endpoint < DRV_USBFS_ENDPOINTS_NUMBER)
796:                         {
797:                             endpointObj = hDriver->endpointTable + (2 * endpoint) + direction;
798:                 
799:                             if((endpointObj->endpointState & DRV_USBFS_DEVICE_ENDPOINT_STATE_STALLED) != 0)
800:                             {
801:                                 isStalled = true;
802:                             }
803:                         }
804:                         else
805:                         {
806:                             SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Endpoint is invalid");
807:                         }
808:                     }
809:                     else
810:                     {
811:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
812:                     }
813:                 
814:                     return(isStalled);
815:                 }
816:                 
817:                 // *****************************************************************************
818:                 /* Function:
819:                     void _DRV_USBFS_DEVICE_EndpointBDTEntryArm
820:                     (
821:                         DRV_USBFS_BDT_ENTRY * pBDT,
822:                         DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObj,
823:                         USB_DEVICE_IRP_LOCAL * irp,
824:                         int direction
825:                     )
826:                 
827:                   Summary:
828:                     This function enables a Buffer Descriptor Table entry. 
829:                 
830:                   Description:
831:                     This function enables a Buffer Descriptor Table entry. Enabling and arming
832:                     the entry allows the endpoint to reply to the host request.
833:                 
834:                   Remarks:
835:                     This is a local function and should not be called directly by the
836:                     application.
837:                 */
838:                 
839:                 void _DRV_USBFS_DEVICE_EndpointBDTEntryArm
840:                 (
841:                     DRV_USBFS_BDT_ENTRY * pBDT, 
842:                     DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObj, 
843:                     USB_DEVICE_IRP_LOCAL * irp,
844:                     int direction
845:                 )
846:                 {
847:                     /* pBDT is the pointer to the ping pong BDT entries for the endpoint and
848:                      * direction  In this driver we dont check for the data toggle while
849:                      * receiving data from the host. The assumption here is that the host is
850:                      * correct */
851:                 
852:                     /* If the endpoint is stalled, the stall will be cleared */
853:                 
854:                     uint16_t size;
855:                     DRV_USBFS_BDT_ENTRY * currentBDTEntry;
856:                 
857:                     currentBDTEntry = pBDT + endpointObj->nextPingPong;
858:                 
859:                     /* Calculate the size of the transaction */
860:                     if(USB_DATA_DIRECTION_DEVICE_TO_HOST == direction)
861:                     {
862:                         /* If data is moving from device to host then enable data toggle
863:                          * syncronization */
864:                 
865:                         currentBDTEntry->byte[0] = 0x08;
866:                 
867:                         /* Adjust buffer address for the number of bytes sent */
868:                         currentBDTEntry->word[1] = (uint32_t) (KVA_TO_PA ((uint8_t *)irp->data + irp->size - irp->nPendingBytes));
869:                 
870:                         if(irp->nPendingBytes == 0)  
871:                         {
872:                             /* This applies when we need to send a ZLP */
873:                             size = 0;
874:                         }
875:                         else
876:                         {
877:                             /* In case this is a multi-transaction transfer, then we start with
878:                              * endpoint size of data. */
879:                             size = (irp->nPendingBytes > endpointObj->maxPacketSize) ? endpointObj->maxPacketSize: irp->nPendingBytes;
880:                         }
881:                 
882:                         /* Update the pending bytes only if the data direction is from device to
883:                          * host. The pending bytes for the other direction is updated in the ISR
884:                          * */
885:                 
886:                         irp->nPendingBytes -= size;
887:                     }
888:                     else
889:                     {
890:                         /* Data is moving from host to device */
891:                         currentBDTEntry->byte[0] = 0x0;
892:                 
893:                         /* Adjust the buffer address for the number of bytes received so far */
894:                         currentBDTEntry->word[1] = (uint32_t) (KVA_TO_PA ((uint8_t *)irp->data + irp->nPendingBytes));
895:                         size = (irp->size - irp->nPendingBytes > endpointObj->maxPacketSize) ? endpointObj->maxPacketSize : irp->size - irp->nPendingBytes;
896:                 
897:                     }
898:                 
899:                     /* We set up the data toggle. This will be active only if DTS is active.
900:                      * Clear the DATA0/1 and then set it according to the next data toggle to be
901:                      * used.*/
902:                 
903:                     currentBDTEntry->byte[0] &= 0xBF;
904:                     currentBDTEntry->byte[0] |= (endpointObj->nextDataToggle << 6);
905:                     
906:                     /* Set the size */
907:                     currentBDTEntry->shortWord[1] = size;
908:                     
909:                     /* Set the UOWN bit */
910:                     currentBDTEntry->byte[0] |= 0x80;
911:                     endpointObj->nextPingPong ^= 0x1;
912:                     endpointObj->nextDataToggle ^= 0x1;
913:                 }
914:                 
915:                 // *****************************************************************************
916:                 /* Function:
917:                     USB_ERROR DRV_USBFS_DEVICE_IRPSubmit
918:                     (
919:                         DRV_HANDLE client,
920:                         USB_ENDPOINT endpointAndDirection,
921:                         USB_DEVICE_IRP * inputIRP
922:                     )
923:                 
924:                   Summary:
925:                     This function submits an I/O Request Packet (IRP) for processing to the
926:                     Hi-Speed USB Driver.
927:                     
928:                   Description:
929:                     This function submits an I/O Request Packet (IRP) for processing to the USB
930:                     Driver. The IRP allows a client to send and receive data from the USB Host.
931:                     The data will be sent or received through the specified endpoint. The direction
932:                     of the data transfer is indicated by the direction flag in the
933:                     endpointAndDirection parameter. Submitting an IRP arms the endpoint to
934:                     either send data to or receive data from the Host.  If an IRP is already
935:                     being processed on the endpoint, the subsequent IRP submit operation
936:                     will be queued. The contents of the IRP (including the application buffers)
937:                     should not be changed until the IRP has been processed.
938:                     
939:                     Particular attention should be paid to the size parameter of IRP. The
940:                     following should be noted:
941:                     
942:                       * The size parameter while sending data to the Host can be less than,
943:                         greater than, equal to, or be an exact multiple of the maximum packet size
944:                         for the endpoint. The maximum packet size for the endpoint determines
945:                         the number of transactions required to process the IRP.
946:                       * If the size parameter, while sending data to the Host is less than the
947:                         maximum packet size, the transfer will complete in one transaction.
948:                       * If the size parameter, while sending data to the Host is greater
949:                         than the maximum packet size, the IRP will be processed in multiple
950:                         transactions.
951:                       * If the size parameter, while sending data to the Host is equal to or
952:                         an exact multiple of the maximum packet size, the client can optionally
953:                         ask the driver to send a Zero Length Packet(ZLP) by specifying the
954:                         USB_DEVICE_IRP_FLAG_DATA_COMPLETE flag as the flag parameter.
955:                       * The size parameter, while receiving data from the Host must be an
956:                         exact multiple of the maximum packet size of the endpoint. If this is
957:                         not the case, the driver will return a USB_ERROR_IRP_SIZE_INVALID
958:                         result. If while processing the IRP, the driver receives less than
959:                         maximum packet size or a ZLP from the Host, the driver considers the
960:                         IRP as processed. The size parameter at this point contains the actual
961:                         amount of data received from the Host. The IRP status is returned as
962:                         USB_DEVICE_IRP_STATUS_COMPLETED_SHORT.
963:                       * If a ZLP needs to be sent to Host, the IRP size should be specified
964:                         as 0 and the flag parameter should be set as
965:                         USB_DEVICE_IRP_FLAG_DATA_COMPLETE.
966:                       * If the IRP size is an exact multiple of the endpoint size, the client
967:                         can request the driver to not send a ZLP by setting the flag parameter
968:                         to USB_DEVICE_IRP_FLAG_DATA_PENDING. This flag indicates that there is
969:                         more data pending in this transfer.
970:                       * Specifying a size less than the endpoint size along with the
971:                         USB_DEVICE_IRP_FLAG_DATA_PENDING flag will cause the driver to return a
972:                         USB_ERROR_IRP_SIZE_INVALID.
973:                       * If the size is greater than but not a multiple of the endpoint size, and
974:                         the flag is specified as USB_DEVICE_IRP_FLAG_DATA_PENDING, the driver
975:                         will send multiple of endpoint size number of bytes. For example, if the
976:                         IRP size is 130 and the endpoint size if 64, the number of bytes sent
977:                         will 128.
978:                 
979:                   Remarks:
980:                     See drv_usbfs.h for usage information.
981:                 */
982:                 
983:                 USB_ERROR DRV_USBFS_DEVICE_IRPSubmit
984:                 (
985:                     DRV_HANDLE client,
986:                     USB_ENDPOINT endpointAndDirection, 
987:                     USB_DEVICE_IRP * inputIRP
988:                 )
989:                 {
990:                     uint8_t endpoint;
991:                     bool interruptWasEnabled = false;
992:                     int direction;
993:                     int remainder;
994:                     DRV_USBFS_OBJ * hDriver;
995:                     USB_DEVICE_IRP_LOCAL * irp = (USB_DEVICE_IRP_LOCAL *)inputIRP;
996:                     DRV_USBFS_BDT_ENTRY * pBDT;
997:                     DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObj;
998:                     USB_ERROR returnValue = USB_ERROR_NONE;
999:                 
1000:                    /* Check if the client handle is valid */
1001:                    if((client != DRV_HANDLE_INVALID) && (client != (DRV_HANDLE)(NULL)))
1002:                    {
1003:                        /* Make sure the IRP is available for use. */
1004:                        if(irp->status <= USB_DEVICE_IRP_STATUS_SETUP)
1005:                        {
1006:                            /* Check for a valid endpoint */
1007:                            endpoint = endpointAndDirection & 0xF;
1008:                            direction = ((endpointAndDirection & 0x80) != 0);
1009:                
1010:                            if(endpoint < DRV_USBFS_ENDPOINTS_NUMBER)
1011:                            {
1012:                                /* Get the driver object, the module ID and the endpoint and
1013:                                 * direction specific BDT entry and the endpoint object. */
1014:                
1015:                                hDriver = ((DRV_USBFS_OBJ *)client);
1016:                                pBDT = hDriver->pBDT + (endpoint * 4) + (2 * direction);
1017:                                endpointObj = hDriver->endpointTable + (2 * endpoint) + direction;
1018:                
1019:                                if((endpointObj->endpointState & DRV_USBFS_DEVICE_ENDPOINT_STATE_ENABLED) != 0)
1020:                                {
1021:                                    /* Check the size of the IRP. If the endpoint receives data
1022:                                     * from the host, then IRP size must be multiple of
1023:                                     * maxPacketSize. If the send ZLP flag is set, then size
1024:                                     * must be multiple of endpoint size. */
1025:                
1026:                                    remainder = irp->size % endpointObj->maxPacketSize;
1027:                
1028:                                    if(remainder == 0)
1029:                                    {
1030:                                        /* The IRP size is either 0 or a exact multiple of
1031:                                         * maxPacketSize */
1032:                
1033:                                        if(USB_DATA_DIRECTION_DEVICE_TO_HOST == direction)
1034:                                        {
1035:                                            if(((irp->flags & USB_DEVICE_IRP_FLAG_DATA_COMPLETE) == USB_DEVICE_IRP_FLAG_DATA_COMPLETE) && (irp->size != 0))
1036:                                            {
1037:                                                /* This means a ZLP should be sent after the
1038:                                                 * data is sent. We will OR this flag as this
1039:                                                 * flag is temporary and must co-exist by the
1040:                                                 * driver client defined flag. */
1041:                
1042:                                                irp->flags |= USB_DEVICE_IRP_FLAG_SEND_ZLP;
1043:                                            }
1044:                                        }
1045:                                    }
1046:                                    else
1047:                                    {
1048:                                        /* Not exact multiple of maxPacketSize */
1049:                                        if(USB_DATA_DIRECTION_HOST_TO_DEVICE == direction)
1050:                                        {
1051:                                            /* For receive IRP it needs to exact multiple of
1052:                                             * maxPacketSize.  Hence this is an error condition. */
1053:                                            returnValue = USB_ERROR_PARAMETER_INVALID;
1054:                                        }
1055:                                    }
1056:                
1057:                                    if(returnValue == USB_ERROR_NONE)
1058:                                    {
1059:                                        /* So far no error. We can continue. Now we check if the
1060:                                         * interrupt context is active. If so the we dont need
1061:                                         * to get a mutex or disable interrupts. If this were
1062:                                         * being done in non interrupt context, then we would
1063:                                         * disable the interrupt. In which case we would get the
1064:                                         * mutex and then disable the interrupt. The mutex here
1065:                                         * is protecting the interrupt. */
1066:                
1067:                                        if(!(hDriver->inInterruptContext))
1068:                                        {
1069:                                            if(OSAL_MUTEX_Lock(&hDriver->mutexID, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1070:                                            {
1071:                                                /* Disable the interrupt as we will update the
1072:                                                 * endpoint IRP queue. We do not want a USB
1073:                                                 * interrupt to update this queue while we are
1074:                                                 * submitting an IRP. */
1075:                
1076:                                                interruptWasEnabled = _DRV_USBFS_InterruptSourceDisable(hDriver->interruptSource);
1077:                                            }
1078:                                            else
1079:                                            {
1080:                                                /* There was an error obtaining the mutex */
1081:                                                returnValue = USB_ERROR_OSAL_FUNCTION;
1082:                                            }
1083:                                        }
1084:                
1085:                                        if(returnValue == USB_ERROR_NONE)
1086:                                        {
1087:                                            irp->next = NULL;
1088:                
1089:                                            /* If the data is moving from device to host then
1090:                                             * pending bytes is data remaining to be sent to the
1091:                                             * host. If the data is moving from host to device,
1092:                                             * nPendingBytes tracks the amount of data received
1093:                                             * so far */
1094:                
1095:                                            if(USB_DATA_DIRECTION_DEVICE_TO_HOST == direction)
1096:                                            {
1097:                                                irp->nPendingBytes = irp->size;
1098:                                            }
1099:                                            else
1100:                                            {
1101:                                                irp->nPendingBytes = 0;
1102:                                            }
1103:                
1104:                                            /* Mark the IRP status as pending */
1105:                                            irp->status = USB_DEVICE_IRP_STATUS_PENDING;
1106:                
1107:                                            /* Get the last object in the endpoint object IRP Queue */
1108:                                            if(endpointObj->irpQueue == NULL)
1109:                                            {
1110:                                                /* Queue is empty */
1111:                                                endpointObj->irpQueue = irp;
1112:                                                irp->previous = NULL;
1113:                
1114:                                                /* Because this is the first IRP in the queue
1115:                                                 * then we we must arm the endpoint entry in the
1116:                                                 * BDT. */
1117:                
1118:                                                irp->status = USB_DEVICE_IRP_STATUS_IN_PROGRESS;
1119:                                                _DRV_USBFS_DEVICE_EndpointBDTEntryArm(pBDT,endpointObj, irp, direction);
1120:                                            }
1121:                                            else
1122:                                            {
1123:                                                /* This means we should surf the linked list to
1124:                                                 * get to the last entry .  */
1125:                
1126:                                                USB_DEVICE_IRP_LOCAL * iterator;
1127:                                                iterator = endpointObj->irpQueue;
1128:                
1129:                                                while(iterator->next != NULL)
1130:                                                {
1131:                                                    iterator = iterator->next;
1132:                                                }
1133:                
1134:                                                iterator->next = irp;
1135:                                                irp->previous = iterator;
1136:                                                irp->status = USB_DEVICE_IRP_STATUS_PENDING;
1137:                                            }
1138:                
1139:                                            if(!(hDriver->inInterruptContext))
1140:                                            {
1141:                                                if(interruptWasEnabled)
1142:                                                {
1143:                                                    /* Enable the interrupt only if it was enabled */
1144:                                                    _DRV_USBFS_InterruptSourceEnable(hDriver->interruptSource);
1145:                                                }
1146:                
1147:                                                /* Unlock the mutex */
1148:                                                OSAL_MUTEX_Unlock(&hDriver->mutexID);
1149:                                            }
1150:                                        }
1151:                                    }
1152:                                }
1153:                                else
1154:                                {
1155:                                    /* This means the endpoint is disabled */        
1156:                                    returnValue = USB_ERROR_ENDPOINT_NOT_CONFIGURED;        
1157:                                }
1158:                            }
1159:                            else
1160:                            {
1161:                                SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Endpoint is not provisioned for");
1162:                                returnValue = USB_ERROR_DEVICE_ENDPOINT_INVALID;
1163:                            }
1164:                        }
1165:                        else
1166:                        {
1167:                            /* This means that the IRP is in use */
1168:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Device IRP is already in use");
1169:                            returnValue = USB_ERROR_DEVICE_IRP_IN_USE;
1170:                        }
1171:                    }
1172:                    else
1173:                    {
1174:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Invalid handle");
1175:                        returnValue =  USB_ERROR_PARAMETER_INVALID;
1176:                    }
1177:                
1178:                    return(returnValue);
1179:                }
1180:                
1181:                // *****************************************************************************
1182:                /* Function:
1183:                    void _DRV_USBFS_DEVICE_IRPQueueFlush
1184:                    (
1185:                        DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject
1186:                        USB_DEVICE_IRP_STATUS status
1187:                    )
1188:                
1189:                  Summary:
1190:                    This function flushes all the IRPs in the queue.
1191:                
1192:                  Description:
1193:                    This function flushes all the IRPs in the queue. Function scans for all the
1194:                    IRPs on the endpoint queue and cancels them all. status indicate the abort
1195:                    status to be returned when the IRP callback is invoked.
1196:                
1197:                  Remarks:
1198:                    This is a local function and should not be called directly by the
1199:                    application.
1200:                */
1201:                
1202:                void _DRV_USBFS_DEVICE_IRPQueueFlush
1203:                (
1204:                    DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject,
1205:                    USB_DEVICE_IRP_STATUS status
1206:                )
1207:                {
1208:                    USB_DEVICE_IRP_LOCAL * iterator = NULL;
1209:                    
1210:                    if(endpointObject != NULL)
1211:                    {
1212:                        /* Check if any IRPs are assigned on this endpoint and abort them */
1213:                
1214:                        if(endpointObject->irpQueue != NULL)
1215:                        {
1216:                            /* Scan for all the IRPs on this endpoint Cancel the IRP and
1217:                             * deallocate driver IRP objects */
1218:                
1219:                            iterator = endpointObject->irpQueue;
1220:                            while(iterator != NULL)
1221:                            {
1222:                                iterator->status = status;
1223:                                if(iterator->callback != NULL)
1224:                                {
1225:                                    iterator->callback((USB_DEVICE_IRP *)iterator);
1226:                                }
1227:                                iterator = iterator->next;
1228:                            }
1229:                        }
1230:                
1231:                        /* Set the head pointer to NULL */
1232:                        endpointObject->irpQueue = NULL;
1233:                    }
1234:                }
1235:                
1236:                // *****************************************************************************
1237:                /* Function:
1238:                    USB_ERROR DRV_USBFS_DEVICE_IRPCancel
1239:                    (
1240:                        DRV_HANDLE client, 
1241:                        USB_DEVICE_IRP * irp
1242:                    )
1243:                
1244:                  Summary:
1245:                    Dynamic implementation of DRV_USBFS_DEVICE_IRPCancel client interface
1246:                    function.
1247:                
1248:                  Description:
1249:                    This is the dynamic implementation of DRV_USBFS_DEVICE_IRPCancel client
1250:                    interface function for USB device.  Function checks the validity of the
1251:                    input arguments and on success cancels  the specific IRP.  An IRP that was
1252:                    in the queue but that has been processed yet will be cancelled successfully
1253:                    and the IRP callback function will be called from this function with
1254:                    USB_DEVICE_IRP_STATUS_ABORTED status. The application can release the data
1255:                    buffer memory used by the IRP when this callback occurs.  If the IRP was in
1256:                    progress (a transaction in on the bus) when the cancel function was called,
1257:                    the IRP will be cancelled only when an ongoing or the next transaction has
1258:                    completed. The IRP callback function will then be called in an interrupt
1259:                    context. The application should not release the related data buffer unless
1260:                    the IRP callback has occurred.
1261:                
1262:                  Remarks:
1263:                    See drv_usbfs.h for usage information.
1264:                */
1265:                
1266:                USB_ERROR DRV_USBFS_DEVICE_IRPCancel
1267:                (
1268:                    DRV_HANDLE client, 
1269:                    USB_DEVICE_IRP * irp
1270:                )
1271:                {
1272:                    USB_ERROR returnValue = USB_ERROR_NONE;
1273:                    DRV_USBFS_OBJ * hDriver = NULL;
1274:                    USB_DEVICE_IRP_LOCAL * irpToCancel = (USB_DEVICE_IRP_LOCAL *)irp;
1275:                    bool interruptWasEnabled = false;
1276:                
1277:                    if((client != DRV_HANDLE_INVALID) && (client != (DRV_HANDLE)(NULL)))
1278:                    {
1279:                        if(irpToCancel != NULL)
1280:                        {
1281:                            /* Check the state of the IRP */
1282:                
1283:                            hDriver = ((DRV_USBFS_OBJ *)client);
1284:                
1285:                            if(irpToCancel->status > USB_DEVICE_IRP_STATUS_SETUP)
1286:                            {
1287:                                if(!(hDriver->inInterruptContext))
1288:                                {
1289:                                    if(OSAL_MUTEX_Lock(&hDriver->mutexID, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1290:                                    {
1291:                                        /* Disable the interrupt */
1292:                                        interruptWasEnabled = _DRV_USBFS_InterruptSourceDisable(hDriver->interruptSource);
1293:                                    }
1294:                                    else
1295:                                    {
1296:                                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Mutex lock failed");
1297:                                        returnValue = USB_ERROR_OSAL_FUNCTION;
1298:                                    }
1299:                                }
1300:                
1301:                                if(returnValue == USB_ERROR_NONE)
1302:                                {
1303:                                    /* The code will come here both when the IRP is NOT the 1st
1304:                                     * in queue as well as when it is at the HEAD. We will change
1305:                                     * the IRP status for either scenario but will give the callback
1306:                                     * only if it is NOT at the HEAD of the queue.
1307:                                     * 
1308:                                     * What it means for HEAD IRP case is it will be caught in USB
1309:                                     * ISR and will be further processed in ISR. This is done to
1310:                                     * make sure that the user cannot release the IRP buffer before
1311:                                     * ABORT callback*/
1312:                
1313:                                    /* Mark the IRP status as aborted */
1314:                                    irpToCancel->status = USB_DEVICE_IRP_STATUS_ABORTED;
1315:                
1316:                                    /* No data for this IRP was sent or received */
1317:                                    irpToCancel->size = 0;
1318:                
1319:                                    if(irpToCancel->previous != NULL)
1320:                                    {
1321:                                        /* This means this is not the HEAD IRP in the IRP queue.
1322:                                           Can be removed from the endpoint object queue safely.*/
1323:                                        irpToCancel->previous->next = irpToCancel->next;
1324:                
1325:                                        if(irpToCancel->next != NULL)
1326:                                        {
1327:                                            /* If this is not the last IRP in the queue then update
1328:                                               the previous link connection for the next IRP */
1329:                                            irpToCancel->next->previous = irpToCancel->previous;
1330:                                        }
1331:                
1332:                                        irpToCancel->previous = NULL;
1333:                                        irpToCancel->next = NULL;
1334:                
1335:                                        if(irpToCancel->callback != NULL)
1336:                                        {
1337:                                            irpToCancel->callback((USB_DEVICE_IRP *)irpToCancel);
1338:                                        }
1339:                                    }
1340:                
1341:                                    /* Restore the interrupt state if this was changed */
1342:                                    if(!(hDriver->inInterruptContext))  
1343:                                    {
1344:                                        if(interruptWasEnabled)
1345:                                        {
1346:                                            _DRV_USBFS_InterruptSourceEnable(hDriver->interruptSource);
1347:                                        }
1348:                
1349:                                        OSAL_MUTEX_Unlock(&hDriver->mutexID); 
1350:                                    }
1351:                                }
1352:                            }
1353:                            else
1354:                            {
1355:                                /* This IRP has either completed or has been aborted.*/
1356:                                SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: IRP is already completed");
1357:                                returnValue = USB_ERROR_PARAMETER_INVALID;
1358:                            }
1359:                        }
1360:                        else
1361:                        {
1362:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: IRP is invalid");
1363:                            returnValue = USB_ERROR_PARAMETER_INVALID;
1364:                        }
1365:                    }
1366:                    else
1367:                    {
1368:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
1369:                        returnValue = USB_ERROR_PARAMETER_INVALID;
1370:                    }
1371:                
1372:                    return returnValue;
1373:                }
1374:                
1375:                // *****************************************************************************
1376:                /* Function:
1377:                    USB_ERROR DRV_USBFS_DEVICE_IRPCancelAll
1378:                    (
1379:                        DRV_HANDLE client,
1380:                        USB_ENDPOINT endpointAndDirection
1381:                    )
1382:                
1383:                  Summary:
1384:                    Dynamic implementation of DRV_USBFS_DEVICE_IRPCancelAll client interface
1385:                    function.
1386:                
1387:                  Description:
1388:                    This is the dynamic implementation of DRV_USBFS_DEVICE_IRPCancelAll client
1389:                    interface function for USB device.  Function checks the validity of the
1390:                    input arguments and on success cancels all the IRPs on the specific endpoint
1391:                    object queue.
1392:                
1393:                  Remarks:
1394:                    See drv_usbfs.h for usage information.
1395:                */
1396:                
1397:                USB_ERROR DRV_USBFS_DEVICE_IRPCancelAll
1398:                (
1399:                    DRV_HANDLE client,
1400:                    USB_ENDPOINT endpointAndDirection
1401:                )
1402:                {
1403:                    uint8_t endpoint;
1404:                    bool interruptWasEnabled = false;
1405:                    int direction;
1406:                    DRV_USBFS_OBJ * hDriver;
1407:                    DRV_USBFS_BDT_ENTRY * pBDT;
1408:                    DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject;
1409:                    USB_ERROR returnValue = USB_ERROR_NONE;
1410:                
1411:                    endpoint = endpointAndDirection & 0xF;
1412:                    direction = ((endpointAndDirection & 0x80) != 0);
1413:                
1414:                    if(endpoint < DRV_USBFS_ENDPOINTS_NUMBER)
1415:                    {
1416:                        /* Endpoint is in range. */
1417:                
1418:                        if((client != DRV_HANDLE_INVALID) && (client != (DRV_HANDLE)(NULL)))
1419:                        {
1420:                            /* Driver handle is valid. */
1421:                
1422:                            hDriver = ((DRV_USBFS_OBJ *)client);
1423:                
1424:                            /* Get the endpoint object */
1425:                            endpointObject = hDriver->endpointTable + (2 * endpoint) + direction;
1426:                
1427:                            /* Get the BDT entry for this endpoint */
1428:                            pBDT = hDriver->pBDT + (4 * endpoint) + (2 * direction);
1429:                
1430:                            if(!(hDriver->inInterruptContext))
1431:                            {
1432:                                if(OSAL_MUTEX_Lock(&hDriver->mutexID, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1433:                                {
1434:                                    /* Disable the interrupt */
1435:                                    interruptWasEnabled = _DRV_USBFS_InterruptSourceDisable(hDriver->interruptSource);
1436:                                }
1437:                                else
1438:                                {
1439:                                    SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Mutex lock failed");
1440:                                    returnValue = USB_ERROR_OSAL_FUNCTION;
1441:                                }
1442:                            }
1443:                
1444:                            if(returnValue == USB_ERROR_NONE)
1445:                            {
1446:                                /* If there is a IRP in progress on the endpoint, and this
1447:                                 * endpoint is being cancelled, we must revert the nextPingPong
1448:                                 * indicator to what it what it before the transaction was
1449:                                 * scheduled on the endpoint */
1450:                
1451:                                if((endpointObject->irpQueue != NULL) && (endpointObject->irpQueue->status == USB_DEVICE_IRP_STATUS_IN_PROGRESS))
1452:                                {
1453:                                    endpointObject->nextPingPong ^= 1;
1454:                                }
1455:                                
1456:                                pBDT->byte[0] = 0x0;
1457:                                (pBDT + 1)->byte[0] = 0x0;
1458:                
1459:                                /* Flush the endpoint */
1460:                                _DRV_USBFS_DEVICE_IRPQueueFlush(endpointObject, USB_DEVICE_IRP_STATUS_ABORTED);
1461:                
1462:                                if(!(hDriver->inInterruptContext))
1463:                                {
1464:                                    if(interruptWasEnabled)
1465:                                    {
1466:                                        _DRV_USBFS_InterruptSourceEnable(hDriver->interruptSource);
1467:                                    }
1468:                
1469:                                    OSAL_MUTEX_Unlock(&hDriver->mutexID);
1470:                                }
1471:                            }
1472:                        }
1473:                        else
1474:                        {
1475:                            /* Driver Handle is not valid. */
1476:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
1477:                            returnValue = USB_ERROR_PARAMETER_INVALID;
1478:                        }
1479:                    }
1480:                    else
1481:                    {
1482:                        /* This is not a provisioned endpoint */
1483:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO,"\r\nUSBFS Driver: Unsupported endpoint");
1484:                        returnValue = USB_ERROR_DEVICE_ENDPOINT_INVALID;
1485:                    }
1486:                
1487:                    return(returnValue);
1488:                }
1489:                
1490:                // *****************************************************************************
1491:                /* Function:
1492:                    USB_ERROR DRV_USBFS_DEVICE_EndpointStall
1493:                    (
1494:                        DRV_HANDLE client,
1495:                        USB_ENDPOINT endpointAndDirection
1496:                    )
1497:                
1498:                  Summary:
1499:                    This function stalls an endpoint in the specified direction.
1500:                    
1501:                  Description:
1502:                    This function stalls an endpoint in the specified direction.
1503:                
1504:                  Remarks:
1505:                    See drv_usbfs.h for usage information.
1506:                */
1507:                
1508:                USB_ERROR DRV_USBFS_DEVICE_EndpointStall
1509:                (
1510:                    DRV_HANDLE client,
1511:                    USB_ENDPOINT endpointAndDirection
1512:                )
1513:                {
1514:                    int direction;
1515:                    bool interruptWasEnabled = false;
1516:                    uint8_t endpoint;
1517:                    DRV_USBFS_OBJ * hDriver;
1518:                    DRV_USBFS_BDT_ENTRY * pBDT;
1519:                    DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject;
1520:                    USB_ERROR returnValue = USB_ERROR_NONE;
1521:                
1522:                    endpoint = endpointAndDirection & 0xF;
1523:                    direction = ((endpointAndDirection & 0x80) != 0);
1524:                
1525:                    if(endpoint < DRV_USBFS_ENDPOINTS_NUMBER)
1526:                    {
1527:                        if((client != DRV_HANDLE_INVALID) && (client != (DRV_HANDLE)(NULL)))
1528:                        {
1529:                            hDriver = ((DRV_USBFS_OBJ *)client);
1530:                
1531:                            if(!(hDriver->inInterruptContext))
1532:                            {
1533:                                if(OSAL_MUTEX_Lock(&hDriver->mutexID, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1534:                                {
1535:                                    /* Disable the interrupt */
1536:                                    interruptWasEnabled = _DRV_USBFS_InterruptSourceDisable(hDriver->interruptSource);
1537:                                }
1538:                                else
1539:                                {
1540:                                    /* There was an error in getting the mutex */
1541:                                    SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Mutex lock failed");
1542:                                    returnValue = USB_ERROR_OSAL_FUNCTION;
1543:                                }
1544:                            }
1545:                
1546:                            if(returnValue == USB_ERROR_NONE)
1547:                            {
1548:                                /* At this time the function is thread safe and is interrupt
1549:                                 * safe. */
1550:                
1551:                                if(endpoint == 0)
1552:                                {
1553:                                    /* For zero endpoint we stall both directions */
1554:                
1555:                                    endpointObject = hDriver->endpointTable;
1556:                                    pBDT = hDriver->pBDT + (endpointObject->nextPingPong);
1557:                
1558:                                    /* This is the RX direction for EP0. Get the BDT back, stall
1559:                                     * it, flush all IRPs and then set the endpoint state */
1560:                
1561:                                    pBDT->byte[0] = 0x0;
1562:                                    pBDT->byte[0] |= (USBFS_UOWN|USBFS_STALL_SET);
1563:                                    _DRV_USBFS_DEVICE_IRPQueueFlush(endpointObject, USB_DEVICE_IRP_STATUS_ABORTED_ENDPOINT_HALT);
1564:                                    endpointObject->endpointState |= DRV_USBFS_DEVICE_ENDPOINT_STATE_STALLED;
1565:                
1566:                                    /* Now do the same for the TX direction */
1567:                
1568:                                    endpointObject = hDriver->endpointTable + 1;
1569:                                    pBDT = hDriver->pBDT + 2 + (endpointObject->nextPingPong);
1570:                
1571:                                    /* This is the TX direction for EP0. Get the BDT back, stall
1572:                                     * it, flush all IRPs and then set the endpoint state */
1573:                
1574:                                    pBDT->byte[0] = 0x0;
1575:                                    pBDT->byte[0] |= (USBFS_UOWN|USBFS_STALL_SET);
1576:                                    _DRV_USBFS_DEVICE_IRPQueueFlush(endpointObject, USB_DEVICE_IRP_STATUS_ABORTED_ENDPOINT_HALT );
1577:                                    endpointObject->endpointState |= DRV_USBFS_DEVICE_ENDPOINT_STATE_STALLED;
1578:                                } 
1579:                                else
1580:                                {
1581:                                    /* For non zero endpoints we stall the specified direction.
1582:                                     * Get the endpoint object. */
1583:                                    endpointObject = hDriver->endpointTable + (2 * endpoint) + direction;
1584:                
1585:                                    /* Get the BDT entry for this endpoint */
1586:                                    pBDT = hDriver->pBDT + (4 * endpoint) + (2 * direction) ;
1587:                
1588:                                    /* Get the endpoint BDT back. Stall the entry.  Flush the
1589:                                     * endpoint and set the object state. */
1590:                                    pBDT->byte[0] = 0x0;
1591:                                    pBDT->byte[0] |= (USBFS_UOWN|USBFS_STALL_SET);
1592:                
1593:                                    pBDT = hDriver->pBDT + (4 * endpoint) + (2 * direction) + 1;
1594:                
1595:                                    /* Get the endpoint BDT back. Stall the entry.  Flush the
1596:                                     * endpoint and set the object state. */
1597:                                    pBDT->byte[0] = 0x0;
1598:                                    pBDT->byte[0] |= (USBFS_UOWN|USBFS_STALL_SET);
1599:                
1600:                                    _DRV_USBFS_DEVICE_IRPQueueFlush(endpointObject, USB_DEVICE_IRP_STATUS_ABORTED_ENDPOINT_HALT);
1601:                                    endpointObject->endpointState |= DRV_USBFS_DEVICE_ENDPOINT_STATE_STALLED;
1602:                                }
1603:                
1604:                                /* Restore the interrupt enable status if this was modified. */
1605:                                if(!(hDriver->inInterruptContext))
1606:                                {
1607:                                    if(interruptWasEnabled)
1608:                                    {
1609:                                        /* Enable the interrupt */
1610:                                        _DRV_USBFS_InterruptSourceEnable(hDriver->interruptSource);
1611:                                    }
1612:                
1613:                                    OSAL_MUTEX_Unlock(&hDriver->mutexID);
1614:                                }
1615:                            }
1616:                        }
1617:                        else
1618:                        {
1619:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
1620:                            returnValue = USB_ERROR_PARAMETER_INVALID;
1621:                        }
1622:                    }
1623:                    else
1624:                    {
1625:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO,"\r\nUSBFS Driver: Unsupported endpoint");
1626:                        returnValue = USB_ERROR_DEVICE_ENDPOINT_INVALID;
1627:                    }
1628:                
1629:                    return(returnValue);
1630:                }
1631:                
1632:                // *****************************************************************************
1633:                /* Function:
1634:                    USB_ERROR DRV_USBFS_DEVICE_EndpointStallClear
1635:                    (
1636:                        DRV_HANDLE client,
1637:                        USB_ENDPOINT endpointAndDirection
1638:                    )
1639:                
1640:                  Summary:
1641:                    This function clears the stall on an endpoint in the specified direction.
1642:                    
1643:                  Description:
1644:                    This function clears the stall on an endpoint in the specified direction.
1645:                
1646:                  Remarks:
1647:                    See drv_usbfs.h for usage information.
1648:                */
1649:                
1650:                USB_ERROR DRV_USBFS_DEVICE_EndpointStallClear
1651:                (
1652:                    DRV_HANDLE client,
1653:                    USB_ENDPOINT endpointAndDirection
1654:                )
1655:                {
1656:                    int direction;
1657:                    uint8_t endpoint;
1658:                    DRV_USBFS_OBJ * hDriver;
1659:                    DRV_USBFS_BDT_ENTRY * pBDT;
1660:                    DRV_USBFS_DEVICE_ENDPOINT_OBJ * endpointObject;
1661:                    bool interruptWasEnabled = false;
1662:                    USB_MODULE_ID usbID; 
1663:                    USB_ERROR returnValue = USB_ERROR_NONE;
1664:                
1665:                    endpoint = endpointAndDirection & 0xF;
1666:                    direction = ((endpointAndDirection & 0x80) != 0);
1667:                
1668:                    if(endpoint < DRV_USBFS_ENDPOINTS_NUMBER)
1669:                    {
1670:                        if((client != DRV_HANDLE_INVALID) && (client != (DRV_HANDLE)(NULL)))
1671:                        {
1672:                            hDriver = ((DRV_USBFS_OBJ *)client);
1673:                            usbID = hDriver->usbID;
1674:                
1675:                            /* Get the endpoint object */
1676:                            endpointObject = hDriver->endpointTable + (2 * endpoint) + direction;
1677:                
1678:                            /* If the function is not being called from an interrupt context,
1679:                             * then capture the mutex. */
1680:                            if(!(hDriver->inInterruptContext))
1681:                            {
1682:                                if(OSAL_MUTEX_Lock(&hDriver->mutexID, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1683:                                {
1684:                                    /* Disable the interrupt */
1685:                                    interruptWasEnabled = _DRV_USBFS_InterruptSourceDisable(hDriver->interruptSource);
1686:                                }
1687:                                else
1688:                                {
1689:                                    SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Mutex lock failed");
1690:                                    returnValue = USB_ERROR_OSAL_FUNCTION;
1691:                                }
1692:                            }
1693:                
1694:                            if(returnValue == USB_ERROR_NONE)
1695:                            {
1696:                                if(endpoint == 0)
1697:                                {
1698:                                    /* Get the BDT entry for this endpoint */
1699:                                    pBDT = hDriver->pBDT + (4 * endpoint) + (2 * direction) + endpointObject->nextPingPong;
1700:                
1701:                                    /* Clear the stall and data toggle on the endpoint */
1702:                                    pBDT->byte[0] = 0x0;
1703:                                }
1704:                                else
1705:                                {
1706:                                    /* Get the BDT entry for this endpoint */
1707:                                    pBDT = hDriver->pBDT + (4 * endpoint) + (2 * direction);
1708:                
1709:                                    /* Clear the stall and data toggle on the endpoint */
1710:                                    pBDT->byte[0] = 0x0;
1711:                
1712:                                    /* Get the BDT entry for this endpoint */
1713:                                    pBDT = hDriver->pBDT + (4 * endpoint) + (2 * direction) + 1;
1714:                
1715:                                    /* Clear the stall and data toggle on the endpoint */
1716:                                    pBDT->byte[0] = 0x0;
1717:                
1718:                                    /* Clear Endpoint Stall status bit */ 
1719:                                    PLIB_USB_EPnStallClear(usbID,endpoint);
1720:                                }
1721:                
1722:                                if((endpoint == 0) && (direction == USB_DATA_DIRECTION_DEVICE_TO_HOST))
1723:                                {
1724:                                    /* All endpoint 0 transmit must start with data toggle DATA1 */
1725:                                    endpointObject->nextDataToggle = USB_BUFFER_DATA1;
1726:                                }
1727:                                else
1728:                                {
1729:                                    endpointObject->nextDataToggle = USB_BUFFER_DATA0;
1730:                                }
1731:                
1732:                                endpointObject->endpointState &= ~DRV_USBFS_DEVICE_ENDPOINT_STATE_STALLED;
1733:                
1734:                                if(endpoint != 0)
1735:                                {
1736:                
1737:                                    /* Clear up all the IRPs on this endpoint */
1738:                                    _DRV_USBFS_DEVICE_IRPQueueFlush(endpointObject, USB_DEVICE_IRP_STATUS_TERMINATED_BY_HOST);
1739:                                }
1740:                
1741:                                /* Enable the interrupt if it was previously enabled */
1742:                                if(!(hDriver->inInterruptContext))
1743:                                {
1744:                                    if(interruptWasEnabled)
1745:                                    {
1746:                                        /* Enable the interrupt */
1747:                                        _DRV_USBFS_InterruptSourceEnable(hDriver->interruptSource);
1748:                                    }
1749:                
1750:                                    /* Release the mutex */
1751:                                    OSAL_MUTEX_Unlock(&hDriver->mutexID);
1752:                                }
1753:                            }
1754:                        }
1755:                        else
1756:                        {
1757:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
1758:                            returnValue = USB_ERROR_PARAMETER_INVALID;
1759:                        }
1760:                    }
1761:                    else
1762:                    {
1763:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO,"\r\nUSBFS Driver: Unsupported endpoint");
1764:                        returnValue = USB_ERROR_DEVICE_ENDPOINT_INVALID;
1765:                    }
1766:                
1767:                    return(returnValue);
1768:                }
1769:                
1770:                // *****************************************************************************
1771:                /* Function:
1772:                    uint16_t DRV_USBFS_DEVICE_SOFNumberGet(DRV_HANDLE client)
1773:                
1774:                  Summary:
1775:                    This function will return the USB SOF packet number.
1776:                
1777:                  Description:
1778:                    This function will return the USB SOF packet number..
1779:                
1780:                  Remarks:
1781:                    See drv_usbfs.h for usage information.
1782:                */
1783:                
1784:                uint16_t DRV_USBFS_DEVICE_SOFNumberGet(DRV_HANDLE client)
1785:                {
1786:                    uint16_t sofNumber = 0;
1787:                    USB_MODULE_ID usbID;
1788:                
1789:                    /* Check if the handle is valid */
1790:                    if((DRV_HANDLE_INVALID != client) && (client != (DRV_HANDLE)(NULL)))
1791:                    {
1792:                        /* Get the Frame count */
1793:                        usbID = ((DRV_USBFS_OBJ *)client)->usbID;
1794:                        sofNumber = PLIB_USB_FrameNumberGet(usbID);
1795:                    }
1796:                    else
1797:                    {
1798:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver Handle is invalid");
1799:                    }
1800:                
1801:                    return sofNumber;
1802:                }
1803:                
1804:                // *****************************************************************************
1805:                /* Function:
1806:                      void _DRV_USBFS_DEVICE_Tasks_ISR(DRV_USBFS_OBJ * hDriver)
1807:                
1808:                  Summary:
1809:                    Dynamic implementation of _DRV_USBFS_DEVICE_Tasks_ISR ISR handler function.
1810:                
1811:                  Description:
1812:                    This is the dynamic implementation of _DRV_USBFS_DEVICE_Tasks_ISR ISR handler
1813:                    function for USB device.  Function will get called automatically due to USB
1814:                    interrupts in interrupt mode.  In polling mode this function will be
1815:                    routinely called from USB driver DRV_USBFS_Tasks() function.  This function
1816:                    performs necessary action based on the interrupt and clears the interrupt
1817:                    after that. The USB device layer callback is called with the interrupt event
1818:                    details, if callback function is registered.
1819:                
1820:                  Remarks:
1821:                    This is a local function and should not be called directly by the
1822:                    application.
1823:                */
1824:                
1825:                void _DRV_USBFS_DEVICE_Tasks_ISR(DRV_USBFS_OBJ * hDriver)
1826:                {
1827:                    bool queueWasEmpty = false;
1828:                    bool processNextIRP;
1829:                    uint8_t lastEndpoint = 0;
1830:                    int iEntry;
1831:                    unsigned int errorType;
1832:                    USB_MODULE_ID usbID;
1833:                    DRV_USBFS_EVENT eventType = 0;
1834:                    USB_DEVICE_IRP_LOCAL * irp;
1835:                    DRV_USBFS_BDT_ENTRY * currentBDTEntry;
1836:                    DRV_USBFS_BDT_ENTRY * lastBDTEntry;
1837:                    DRV_USBFS_BDT_ENTRY * ep0TransmitBDTEntry;
1838:                    USB_PING_PONG_STATE lastPingPong = 0;
1839:                    USB_PING_PONG_STATE nextPingPong = 0;
1840:                    USB_BUFFER_DIRECTION lastDirection = 0;
1841:                    DRV_USBFS_DEVICE_ENDPOINT_OBJ * lastEndpointObj;
1842:                    uint32_t  mask;
1843:                
1844:                    usbID = hDriver->usbID;
1845:                
1846:                    /* Check is there was a change in VBUS voltage level */
1847:                    if(PLIB_USB_OTG_InterruptFlagGet(usbID, USB_OTG_INT_SESSION_VALID) && PLIB_USB_OTG_InterruptIsEnabled(usbID, USB_OTG_INT_SESSION_VALID))
1848:                    {
1849:                        /* This means there was a change in the VBUS voltage detected level. We
1850:                         * can find out if the VBUS is valid */
1851:                
1852:                        if(PLIB_USB_OTG_SessionValid(usbID))
1853:                        {
1854:                            /* This means we detected a valid VBUS voltage. */
1855:                            hDriver->vbusIsValid = true;
1856:                            eventType = DRV_USBFS_EVENT_DEVICE_SESSION_VALID; 
1857:                        }
1858:                        else
1859:                        {
1860:                            /* This means the VBUS is not valid anymore */
1861:                            hDriver->vbusIsValid = false;
1862:                            eventType = DRV_USBFS_EVENT_DEVICE_SESSION_INVALID;
1863:                        }
1864:                
1865:                        if(hDriver->pEventCallBack != NULL)
1866:                        {
1867:                            /* Send this event to the client */
1868:                            hDriver->pEventCallBack(hDriver->hClientArg, eventType,  (void *)NULL);
1869:                        }
1870:                
1871:                        /* Clear the interrupt */
1872:                        PLIB_USB_OTG_InterruptFlagClear(usbID, USB_OTG_INT_SESSION_VALID);
1873:                    }
1874:                
1875:                    /* If there is no VBUS or if the device pull up is not enabled yet, then
1876:                     * clear all the interrupt flags except VBUS session interrupt. Clear all
1877:                     * error, OTG and general interrupts. We cannot clear the session valid
1878:                     * interrupt because this may have change already by the time we have
1879:                     * reached here. After clearing the interrup we exit as we have nothing more
1880:                     * to be done in the ISR. */
1881:                
1882:                    if((!(hDriver->vbusIsValid)) || (!(hDriver->isAttached)))
1883:                    {
1884:                        PLIB_USB_ErrorInterruptFlagClear(usbID, USB_ERR_INT_ALL);
1885:                        PLIB_USB_InterruptFlagClear(usbID, USB_INT_ALL);
1886:                        PLIB_USB_OTG_InterruptFlagClear(usbID, (USB_OTG_INT_ALL & (~ USB_OTG_INT_SESSION_VALID))); 
1887:                    }
1888:                    else
1889:                    {
1890:                        /* Check if there was activity on the bus. This interrupt is enabled before
1891:                         * entering suspend mode. This interrupt must be enabled to wake up the
1892:                         * microcontroller from sleep due to USB activity. The driver wraps this
1893:                         * interrupt as resume detection. */
1894:                
1895:                        if(PLIB_USB_OTG_InterruptFlagGet(usbID, USB_OTG_INT_ACTIVITY_DETECT) && PLIB_USB_OTG_InterruptIsEnabled(usbID, USB_OTG_INT_ACTIVITY_DETECT ))
1896:                        {
1897:                            /* Clear the interrupt */
1898:                            PLIB_USB_OTG_InterruptFlagClear(usbID, USB_OTG_INT_ACTIVITY_DETECT);
1899:                
1900:                            /* Disable the interrupt */
1901:                            PLIB_USB_OTG_InterruptDisable(usbID, USB_OTG_INT_ACTIVITY_DETECT);
1902:                
1903:                            /* Device is not suspended any more */
1904:                            hDriver->isSuspended = false;
1905:                
1906:                            if(hDriver->pEventCallBack != NULL)
1907:                            {
1908:                                /* Send this event to the client */
1909:                                hDriver->pEventCallBack(hDriver->hClientArg, DRV_USBFS_EVENT_RESUME_DETECT,  (void *)NULL);
1910:                            }
1911:                        }
1912:                
1913:                        /* The RESUME event can only occur after the device has been suspended. */
1914:                        if (PLIB_USB_InterruptFlagGet(usbID, USB_INT_RESUME) && PLIB_USB_InterruptIsEnabled(usbID, USB_INT_RESUME))
1915:                        {
1916:                            /* Device is not suspended any more */
1917:                            hDriver->isSuspended = false;
1918:                
1919:                            if(hDriver->pEventCallBack != NULL)
1920:                            {
1921:                                /* Send this event to the client */
1922:                                hDriver->pEventCallBack(hDriver->hClientArg, DRV_USBFS_EVENT_RESUME_DETECT,  (void *)NULL);
1923:                            }
1924:                
1925:                            /* Clear the interrupt flag and disable it. This event will be enabled
1926:                             * the next time we enter suspend mode. */
1927:                            PLIB_USB_InterruptFlagClear(usbID, USB_INT_RESUME);
1928:                            PLIB_USB_InterruptDisable(usbID, USB_INT_RESUME);
1929:                        }
1930:                
1931:                        /* Check if RESET signalling was received */
1932:                        if ( PLIB_USB_InterruptFlagGet(usbID, USB_INT_DEVICE_RESET) && PLIB_USB_InterruptIsEnabled(usbID, USB_INT_DEVICE_RESET))
1933:                        {
1934:                            /* Device is not suspended any more */
1935:                            hDriver->isSuspended = false;
1936:                
1937:                            /* The host may have suspended the device before reset.
1938:                             * Clear the suspend flag and the resume flag */
1939:                            PLIB_USB_InterruptFlagClear( usbID, USB_INT_RESUME );
1940:                            PLIB_USB_InterruptFlagClear( usbID, USB_INT_IDLE_DETECT );
1941:                
1942:                            /* Make sure that all BDs are returned
1943:                             * back to the application */
1944:                
1945:                            for(iEntry = 0; iEntry < DRV_USBFS_ENDPOINTS_NUMBER; iEntry++)
1946:                            {
1947:                                currentBDTEntry = hDriver->pBDT + (4 * iEntry);
1948:                                (currentBDTEntry + 0)->word[0] = 0x0;
1949:                                (currentBDTEntry + 1)->word[0] = 0x0;
1950:                                (currentBDTEntry + 2)->word[0] = 0x0;
1951:                                (currentBDTEntry + 3)->word[0] = 0x0;
1952:                            }
1953:                
1954:                            /* Reset all ping pong buffers to even */
1955:                            PLIB_USB_PingPongReset(usbID);
1956:                
1957:                            /* Because we have reset the ping pong, the rx and tx
1958:                             * ping pong indicators need to set to set to all even */
1959:                            hDriver->rxEndpointsNextPingPong = 0 ;
1960:                            hDriver->txEndpointsNextPingPong = 0 ;
1961:                
1962:                            /* Reset address to default value (0) */
1963:                            PLIB_USB_DeviceAddressSet( usbID, 0 );
1964:                
1965:                            if(hDriver->pEventCallBack != NULL)
1966:                            {
1967:                                /* Send this event to the client */
1968:                                hDriver->pEventCallBack(hDriver->hClientArg, DRV_USBFS_EVENT_RESET_DETECT,  (void *)NULL);
1969:                            }
1970:                
1971:                            /* Clear the interrupt flag */
1972:                            PLIB_USB_InterruptFlagClear(usbID, USB_INT_DEVICE_RESET);
1973:                        }
1974:                
1975:                        /* Check if the host has suspended the bus. */
1976:                        if (PLIB_USB_InterruptFlagGet(usbID, USB_INT_IDLE_DETECT) && PLIB_USB_InterruptIsEnabled(usbID, USB_INT_IDLE_DETECT))
1977:                        {
1978:                            /* The bus is IDLE and is suspended. Send the event to the client. */
1979:                            if(hDriver->pEventCallBack != NULL)
1980:                            {
1981:                                /* Send this event to the client */
1982:                                hDriver->pEventCallBack(hDriver->hClientArg, DRV_USBFS_EVENT_IDLE_DETECT,  (void *)NULL);
1983:                            }
1984:                
1985:                            /* Clear the interrupt flag and disable it. This event will be enabled
1986:                             * the next time we enter suspend mode. */
1987:                            PLIB_USB_InterruptFlagClear(usbID, USB_INT_IDLE_DETECT);
1988:                
1989:                            /* Enable the actvity interrupt */
1990:                            PLIB_USB_OTG_InterruptEnable(usbID, USB_OTG_INT_ACTIVITY_DETECT);
1991:                
1992:                            /* Enable the resume interrupt */
1993:                            PLIB_USB_InterruptEnable(usbID, USB_INT_RESUME);
1994:                
1995:                            /* Set the suspended flag */
1996:                            hDriver->isSuspended = true;
1997:                        }
1998:                
1999:                        /* Check if an SOF was received */
2000:                
2001:                        if (PLIB_USB_InterruptFlagGet(usbID,USB_INT_SOF) && PLIB_USB_InterruptIsEnabled(usbID, USB_INT_SOF))
2002:                        {
2003:                            /* SOF received by Device or SOF threshold reached by Host no event data
2004:                             * to send. */
2005:                
2006:                            if(hDriver->pEventCallBack != NULL)
2007:                            {
2008:                                /* Send this event to the client */
2009:                                hDriver->pEventCallBack(hDriver->hClientArg, DRV_USBFS_EVENT_SOF_DETECT,  (void *)NULL);
2010:                            }
2011:                
2012:                            /* Clear the interrupt flag */
2013:                            PLIB_USB_InterruptFlagClear(usbID, USB_INT_SOF);
2014:                        }
2015:                
2016:                        /* The following event occurs when and endpoint has sent stall to the host.
2017:                         * If the stall was sent from endpoint 0, the device layer would know about
2018:                         * it. If it was sent from an non-zero endpoint, the host would send a clear
2019:                         * feature control request. This event therefore does not send any event
2020:                         * data to the client. */
2021:                
2022:                        if (PLIB_USB_InterruptFlagGet(usbID, USB_INT_STALL) && PLIB_USB_InterruptIsEnabled(usbID, USB_INT_STALL))
2023:                        {
2024:                            unsigned int iEndpoint;
2025:                            for ( iEndpoint = 0; iEndpoint < DRV_USBFS_ENDPOINTS_NUMBER; iEndpoint++ )
2026:                            {
2027:                                if ( PLIB_USB_EPnIsStalled(usbID,iEndpoint) )
2028:                                {
2029:                                    PLIB_USB_EPnStallClear(usbID,iEndpoint);
2030:                                }
2031:                            }
2032:                
2033:                            if(hDriver->pEventCallBack != NULL)
2034:                            {
2035:                                /* Send this event to the client */
2036:                                hDriver->pEventCallBack(hDriver->hClientArg, DRV_USBFS_EVENT_STALL,  (void *)NULL);
2037:                            }
2038:                
2039:                            /* Clear the interrupt flag */
2040:                            PLIB_USB_InterruptFlagClear(usbID, USB_INT_STALL);
2041:                        }
2042:                
2043:                        /* Check if an error has occurred */
2044:                        if ( PLIB_USB_InterruptFlagGet( usbID, USB_INT_ERROR ) && PLIB_USB_InterruptIsEnabled(usbID, USB_INT_ERROR))
2045:                        {
2046:                            /* Get the error type to send to the client */
2047:                            errorType = PLIB_USB_ErrorInterruptFlagAllGet(usbID);
2048:                
2049:                            /* Clear the base error flags and the interrupt flag */
2050:                            PLIB_USB_ErrorInterruptFlagClear( usbID, errorType );
2051:                            PLIB_USB_InterruptFlagClear( usbID, USB_INT_ERROR );
2052:                
2053:                            if(hDriver->pEventCallBack != NULL)
2054:                            {
2055:                                /* Send this event to the client */
2056:                                hDriver->pEventCallBack(hDriver->hClientArg, DRV_USBFS_EVENT_ERROR,  (void *)&errorType);
2057:                            }
2058:                        }
2059:                
2060:                        /* This while loop will empty the token received FIFO. This while will not
2061:                         * run forever because there are only that many tokens that can be received
2062:                         * in a period of 1 millisecond. */
2063:                
2064:                        while(PLIB_USB_InterruptFlagGet(usbID, USB_INT_TOKEN_DONE))
2065:                        {
2066:                            /* Get the details of the last transaction */
2067:                            PLIB_USB_LastTransactionDetailsGet(usbID, &lastDirection, &lastPingPong, &lastEndpoint); 
2068:                
2069:                            /* Now that the details of the last transaction have been obtained, we
2070:                             * need to clear the TOKEN interrupt immediately. This will give enough
2071:                             * time for the TRNIF flag to clear. This way we avoid situations where
2072:                             * the flag was cleared but the code still enters TRNIF was still set.
2073:                             * */
2074:                
2075:                            PLIB_USB_InterruptFlagClear(usbID,USB_INT_TOKEN_DONE);
2076:                
2077:                            /* Set up the next ping pong buffer descriptor. This will tell the IRP
2078:                             * processing code which buffer descriptors to use. When the host does a
2079:                             * set configuration 0, the Device Layer will disable and enable all
2080:                             * endpoints. A set configuration 0 is not the same a bus reset in which
2081:                             * case the ping pong indicators would have been reset. So the endpoint
2082:                             * enable function will ready the soft ping pong trackers to find out
2083:                             * which ping pong to use.  */
2084:                
2085:                            if ( lastPingPong == USB_PING_PONG_EVEN )
2086:                            {
2087:                                nextPingPong = USB_PING_PONG_ODD;
2088:                            }
2089:                            else
2090:                            {
2091:                                nextPingPong = USB_PING_PONG_EVEN;
2092:                            }
2093:                
2094:                            mask = 1 << lastEndpoint ;
2095:                
2096:                            /* Update the next ping pong indicator for this endpoint. Each bit in
2097:                             * the rxEndpointsNextPingPong and txEndpointsNextPingPong track the
2098:                             * ping pong value for the endpoint. */
2099:                
2100:                            if( lastDirection == USB_BUFFER_RX ) 
2101:                            {
2102:                                /* This is for the RX direction */
2103:                                if (nextPingPong == USB_PING_PONG_ODD )
2104:                                {
2105:                                    hDriver->rxEndpointsNextPingPong =   hDriver->rxEndpointsNextPingPong | mask ;
2106:                                }
2107:                                else
2108:                                {
2109:                                    hDriver->rxEndpointsNextPingPong =  ( hDriver->rxEndpointsNextPingPong & (~mask ) ) ;
2110:                                }
2111:                            }
2112:                            else    
2113:                            {
2114:                                /* This is for the TX direction */
2115:                                if (nextPingPong == USB_PING_PONG_ODD )
2116:                                {
2117:                                    hDriver->txEndpointsNextPingPong =   hDriver->txEndpointsNextPingPong | mask ;
2118:                                }
2119:                                else
2120:                                {
2121:                                    hDriver->txEndpointsNextPingPong =  ( hDriver->txEndpointsNextPingPong & (~mask ) ) ;
2122:                                }
2123:                            }
2124:                
2125:                            /* Get the associated endpoint object */
2126:                            lastEndpointObj = hDriver->endpointTable + (lastEndpoint * 2) + lastDirection;
2127:                
2128:                            /* Get the first IRP in the queue */
2129:                            irp = lastEndpointObj->irpQueue; 
2130:                
2131:                            /* Get the BDT entry for this direction. currentBDTEntry points to the
2132:                             * ping pong set. lastBDTEntry points to the specific ping or pong
2133:                             * entry. */
2134:                
2135:                            currentBDTEntry = hDriver->pBDT + (4 * lastEndpoint) + (2 * lastDirection); 
2136:                            lastBDTEntry = currentBDTEntry + lastPingPong;
2137:                
2138:                            if(irp != NULL)
2139:                            {
2140:                                /* This flag lets us know if the current IRP is done and that the next
2141:                                 * IRP should be processed */
2142:                
2143:                                processNextIRP = false;
2144:                                switch(lastBDTEntry->byte[0] & 0x3C)
2145:                                {
2146:                                    case 0x34 :
2147:                
2148:                                        /* This means a setup packet has been received */
2149:                
2150:                                        irp->status = USB_DEVICE_IRP_STATUS_SETUP;
2151:                                        irp->size   = lastBDTEntry->word[1];
2152:                
2153:                                        /* currentBDTEntry at this point will point to enpoint 0 BDT
2154:                                         * entry. We should get the transmit BDT entries and clear
2155:                                         * the stall conditions */
2156:                
2157:                                        ep0TransmitBDTEntry = currentBDTEntry + 2;
2158:                
2159:                                        /* ep0TranmitBDTEntry at this point should point to the EP0
2160:                                         * transmit even BDT entry. Clearing byte 0 will clear clear
2161:                                         * the stall */
2162:                                        ep0TransmitBDTEntry->byte[0] = 0;
2163:                
2164:                                        /* Now get the transmit BDT odd entry and do the same */
2165:                
2166:                                        ep0TransmitBDTEntry ++;
2167:                                        ep0TransmitBDTEntry->byte[0] = 0;
2168:                
2169:                                        /* Reset the data toggle on the TX endpoint to DATA1 because
2170:                                         * we received a setup packet. Any packet that the device
2171:                                         * transmit on this endpoint must start with DATA1 toggle.
2172:                                         * */
2173:                
2174:                                        (lastEndpointObj + USB_DATA_DIRECTION_DEVICE_TO_HOST)->nextDataToggle = USB_BUFFER_DATA1;
2175:                
2176:                                        PLIB_USB_PacketTransferEnable(usbID);
2177:                
2178:                                        /* We should get the next IRP in the queue . */
2179:                
2180:                                        processNextIRP = true;
2181:                                        break;
2182:                
2183:                                    case 0x4:
2184:                
2185:                                        /* We received an OUT token. Check if the size is less than
2186:                                         * maxPacketSize. This means the end of the transfer. If the
2187:                                         * pending size is 0 then again we end the transfer */
2188:                
2189:                                        irp->nPendingBytes += lastBDTEntry->shortWord[1];
2190:                
2191:                                        if(irp->status == USB_DEVICE_IRP_STATUS_ABORTED)
2192:                                        {
2193:                                            /* No need to process this aborted IRP. Enable the
2194:                                             * driver to move to the next IRP in the queue. */
2195:                                            if(irp->callback != NULL)
2196:                                            {
2197:                                                irp->callback((USB_DEVICE_IRP *)irp);
2198:                                            }
2199:                                            processNextIRP = true;
2200:                                        }
2201:                
2202:                                        else if((lastBDTEntry->shortWord[1] < lastEndpointObj->maxPacketSize) || (irp->nPendingBytes >= irp->size))
2203:                                        {
2204:                                            /* We end the transfer because we either got the amount
2205:                                             * of data that we were expecting or we got the a short
2206:                                             * packet. */
2207:                
2208:                                            /* If we got less data than we were expecting, then set
2209:                                             * the IRP status to short else say it is completed */
2210:                
2211:                                            if(irp->nPendingBytes >= irp->size)
2212:                                            {
2213:                                                irp->status = USB_DEVICE_IRP_STATUS_COMPLETED;
2214:                                            }
2215:                                            else
2216:                                            {
2217:                                                irp->status = USB_DEVICE_IRP_STATUS_COMPLETED_SHORT;
2218:                                            }
2219:                
2220:                                            /* Update the irp size with received data */
2221:                                            irp->size = irp->nPendingBytes;
2222:                
2223:                                            processNextIRP = true;
2224:                
2225:                                        }
2226:                                        else
2227:                                        {
2228:                                            /* We must continue this transfer */
2229:                                            _DRV_USBFS_DEVICE_EndpointBDTEntryArm(currentBDTEntry, lastEndpointObj, irp, lastDirection);
2230:                                        }
2231:                                        break;
2232:                
2233:                                    case 0x24:
2234:                
2235:                                        /* This means that a IN token was received from the host */
2236:                
2237:                                        if(irp->status == USB_DEVICE_IRP_STATUS_ABORTED)
2238:                                        {
2239:                                            /* No need to process this aborted IRP. Enable the
2240:                                             * driver to move to the next IRP in the queue. */
2241:                
2242:                                            if(irp->callback != NULL)
2243:                                            {
2244:                                                irp->callback((USB_DEVICE_IRP *)irp);
2245:                                            }
2246:                                            processNextIRP = true;
2247:                                        }
2248:                
2249:                                        else if(irp->nPendingBytes == 0)
2250:                                        {
2251:                                            if((irp->flags & USB_DEVICE_IRP_FLAG_SEND_ZLP) != 0)
2252:                                            {
2253:                                                /* This means a ZLP must be sent */
2254:                                                irp->flags &= ~USB_DEVICE_IRP_FLAG_SEND_ZLP;
2255:                                                _DRV_USBFS_DEVICE_EndpointBDTEntryArm(currentBDTEntry, lastEndpointObj, irp, lastDirection);
2256:                                            }
2257:                                            else
2258:                                            {
2259:                                                irp->status = USB_DEVICE_IRP_STATUS_COMPLETED;
2260:                                                processNextIRP = true;
2261:                                            }
2262:                                        }
2263:                                        else
2264:                                        {
2265:                                            /* We must continue this transfer */
2266:                                            _DRV_USBFS_DEVICE_EndpointBDTEntryArm(currentBDTEntry, lastEndpointObj, irp, lastDirection);
2267:                                        }
2268:                
2269:                                        break;
2270:                
2271:                                    default:
2272:                                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Unknown TOKEN received from host");
2273:                                        break;
2274:                                }
2275:                
2276:                                /* Reset the BDT status */
2277:                                lastBDTEntry->byte[0] = 0;
2278:                
2279:                                if(processNextIRP)
2280:                                {
2281:                                    /* Check the queue and get the next IRP */
2282:                
2283:                                    lastEndpointObj->irpQueue = irp->next;
2284:                
2285:                                    /* Check if the queue is empty. This will then allow us to track
2286:                                     * if a IRP was submitted after the  IRP callback. If so, then
2287:                                     * we should not call the
2288:                                     * _DRV_USBFS_DEVICE_EndpointBDTEntryArm(). For an IRP added in
2289:                                     * the IRP callback, the _DRV_USBFS_DEVICE_EndpointBDTEntryArm
2290:                                     * would have already been done in the IRP Submit function */
2291:                
2292:                                    if(lastEndpointObj->irpQueue == NULL)
2293:                                    {
2294:                                        /* Queue was empty before the call back */
2295:                                        queueWasEmpty = true;
2296:                                    }
2297:                
2298:                                    /* Now do the IRP callback*/
2299:                
2300:                                    if(irp->callback != NULL && irp->status != USB_DEVICE_IRP_STATUS_ABORTED)
2301:                                    {
2302:                                        /* Invoke the callback */
2303:                                        irp->callback((USB_DEVICE_IRP *)irp);
2304:                                    }
2305:                
2306:                                    if((lastEndpointObj->irpQueue != NULL) && (!(queueWasEmpty)))
2307:                                    {
2308:                                        /* This means we have something in the queue and this was not
2309:                                         * added in the IRP callback. We can arm the endpoint. */
2310:                
2311:                                        lastEndpointObj->irpQueue->status = USB_DEVICE_IRP_STATUS_IN_PROGRESS;
2312:                                        _DRV_USBFS_DEVICE_EndpointBDTEntryArm( currentBDTEntry, lastEndpointObj, lastEndpointObj->irpQueue, lastDirection);
2313:                                    }
2314:                                }
2315:                            }
2316:                            else
2317:                            {
2318:                                /* The IRP is null. This can happen if the IRP was aborted. In which
2319:                                 * case we have nothing to do. */
2320:                            }
2321:                        }
2322:                    }
2323:                }
2324:                
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
00000024  00000000   NOP
00000028  00000000   NOP
0000002C  00000000   NOP
00000030  00000000   NOP
00000034  00000000   NOP
00000038  00000000   NOP
0000003C  00000000   NOP
00000040  00000000   NOP
00000044  00000000   NOP
00000048  00000000   NOP
0000004C  00000000   NOP
00000050  00000000   NOP
00000054  00000000   NOP
00000058  00000000   NOP
0000005C  00000000   NOP
00000060  00000000   NOP
00000064  00000000   NOP
00000068  00000000   NOP
0000006C  00000000   NOP
00000070  00000000   NOP
00000074  00000000   NOP
9D00B388  2482FFFF   ADDIU V0, A0, -1
9D00B38C  2C42FFFE   SLTIU V0, V0, -2
9D00B390  03E00008   JR RA
9D00B394  00021040   SLL V0, V0, 1
9D00E0D8  27BDFFB0   ADDIU SP, SP, -80
9D00E0DC  AFB00028   SW S0, 40(SP)
9D00E0E4  AFB20030   SW S2, 48(SP)
9D00E0E8  AFBF004C   SW RA, 76(SP)
9D00E0F0  AFBE0048   SW FP, 72(SP)
9D00E0F4  AFB70044   SW S7, 68(SP)
9D00E0FC  AFB60040   SW S6, 64(SP)
9D00E100  AFB5003C   SW S5, 60(SP)
9D00E104  AFB40038   SW S4, 56(SP)
9D00E108  AFB30034   SW S3, 52(SP)
9D00E10C  AFB1002C   SW S1, 44(SP)
9D00E110  10400005   BEQ V0, ZERO, 0x9D00E128
9D00E120  144000F3   BNE V0, ZERO, PLIB_USB_OTG_SessionValid
9D00E124  00000000   NOP
9D00E128  92420002   LBU V0, 2(S2)
9D00E12C  10400004   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_ErrorInterruptFlagClear
9D00E130  240200FF   ADDIU V0, ZERO, 255
9D00E134  92550003   LBU S5, 3(S2)
9D00E138  16A00011   BNE S5, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_OTG_InterruptFlagGet
9D00E13C  240200FF   ADDIU V0, ZERO, 255
9D00E140  AE0201E0   SW V0, 480(S0)
9D00E144  AE0201C0   SW V0, 448(S0)
9D00E148  240200F5   ADDIU V0, ZERO, 245
9D00E150  8FBF004C   LW RA, 76(SP)
9D00E170  8FB1002C   LW S1, 44(SP)
9D00E174  8FB00028   LW S0, 40(SP)
9D00E178  03E00008   JR RA
9D00E17C  27BD0050   ADDIU SP, SP, 80
9D00E180  8E020000   LW V0, 0(S0)
9D00E188  10400010   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E18C  00000000   NOP
9D00E198  1040000C   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E19C  24020010   ADDIU V0, ZERO, 16
9D00E1A0  AE020000   SW V0, 0(S0)
9D00E1A4  8E020010   LW V0, 16(S0)
9D00E1A8  8E430010   LW V1, 16(S2)
9D00E1B4  10600005   BEQ V1, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E1BC  8E44000C   LW A0, 12(S2)
9D00E1C0  00003025   OR A2, ZERO, ZERO
9D00E1C4  0060F809   JALR V1
9D00E1C8  24050003   ADDIU A1, ZERO, 3
9D00E1CC  8E0201C0   LW V0, 448(S0)
9D00E1D4  10400011   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E1D8  00000000   NOP
9D00E1E4  1040000D   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E1E8  00000000   NOP
9D00E1EC  8E420010   LW V0, 16(S2)
9D00E1F0  10400005   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagClear
9D00E1F4  A2400004   SB ZERO, 4(S2)
9D00E1F8  8E44000C   LW A0, 12(S2)
9D00E1FC  00003025   OR A2, ZERO, ZERO
9D00E200  0040F809   JALR V0
9D00E204  24050003   ADDIU A1, ZERO, 3
9D00E208  24020020   ADDIU V0, ZERO, 32
9D00E20C  AE0201C0   SW V0, 448(S0)
9D00E210  8E0201D0   LW V0, 464(S0)
9D00E21C  8E0201C0   LW V0, 448(S0)
9D00E224  10400025   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E228  00000000   NOP
9D00E234  10400021   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E238  24040020   ADDIU A0, ZERO, 32
9D00E23C  8E42002C   LW V0, 44(S2)
9D00E240  A2400004   SB ZERO, 4(S2)
9D00E244  AE0401C0   SW A0, 448(S0)
9D00E248  24040010   ADDIU A0, ZERO, 16
9D00E254  AC400000   SW ZERO, 0(V0)
9D00E258  AC400008   SW ZERO, 8(V0)
9D00E25C  AC400010   SW ZERO, 16(V0)
9D00E260  AC400018   SW ZERO, 24(V0)
9D00E264  24420020   ADDIU V0, V0, 32
9D00E268  5443FFFB   BNEL V0, V1, 0x9D00E258
9D00E26C  AC400000   SW ZERO, 0(V0)
9D00E270  8E020210   LW V0, 528(S0)
9D00E274  8E430010   LW V1, 16(S2)
9D00E28C  92020220   LBU V0, 544(S0)
9D00E290  AE400018   SW ZERO, 24(S2)
9D00E294  AE40001C   SW ZERO, 28(S2)
9D00E298  7C023004   INS V0, ZERO, 0, 7
9D00E2A0  10600004   BEQ V1, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagClear
9D00E2A8  8E44000C   LW A0, 12(S2)
9D00E2AC  0060F809   JALR V1
9D00E2B0  24050002   ADDIU A1, ZERO, 2
9D00E2B4  24020001   ADDIU V0, ZERO, 1
9D00E2B8  AE0201C0   SW V0, 448(S0)
9D00E2BC  8E0201C0   LW V0, 448(S0)
9D00E2C4  10400015   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E2C8  00000000   NOP
9D00E2D4  10400011   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E2D8  00000000   NOP
9D00E2DC  8E420010   LW V0, 16(S2)
9D00E2E0  10400004   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagClear
9D00E2E4  00003025   OR A2, ZERO, ZERO
9D00E2E8  8E44000C   LW A0, 12(S2)
9D00E2EC  0040F809   JALR V0
9D00E2F0  24050004   ADDIU A1, ZERO, 4
9D00E2F4  24020010   ADDIU V0, ZERO, 16
9D00E2F8  AE0201C0   SW V0, 448(S0)
9D00E2FC  8E020010   LW V0, 16(S0)
9D00E300  34420010   ORI V0, V0, 16
9D00E304  AE020010   SW V0, 16(S0)
9D00E308  8E0201D0   LW V0, 464(S0)
9D00E314  24020001   ADDIU V0, ZERO, 1
9D00E318  A2420004   SB V0, 4(S2)
9D00E31C  8E0201C0   LW V0, 448(S0)
9D00E324  1040000D   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E328  00000000   NOP
9D00E334  10400009   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E338  00000000   NOP
9D00E33C  8E420010   LW V0, 16(S2)
9D00E340  10400004   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagClear
9D00E344  00003025   OR A2, ZERO, ZERO
9D00E348  8E44000C   LW A0, 12(S2)
9D00E34C  0040F809   JALR V0
9D00E350  24050007   ADDIU A1, ZERO, 7
9D00E354  24020004   ADDIU V0, ZERO, 4
9D00E358  AE0201C0   SW V0, 448(S0)
9D00E35C  8E0201C0   LW V0, 448(S0)
9D00E364  1040001A   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E368  00000000   NOP
9D00E374  10400016   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E378  00001825   OR V1, ZERO, ZERO
9D00E37C  24050004   ADDIU A1, ZERO, 4
9D00E380  2462002C   ADDIU V0, V1, 44
9D00E384  00021100   SLL V0, V0, 4
9D00E388  02021021   ADDU V0, S0, V0
9D00E38C  8C440000   LW A0, 0(V0)
9D00E394  10800004   BEQ A0, ZERO, 0x9D00E3A8
9D00E3A8  1465FFF6   BNE V1, A1, 0x9D00E384
9D00E3B0  8E420010   LW V0, 16(S2)
9D00E3B4  10400004   BEQ V0, ZERO, PLIB_USB_InterruptFlagClear
9D00E3B8  00003025   OR A2, ZERO, ZERO
9D00E3BC  8E44000C   LW A0, 12(S2)
9D00E3C0  0040F809   JALR V0
9D00E3C4  24050006   ADDIU A1, ZERO, 6
9D00E3C8  24020080   ADDIU V0, ZERO, 128
9D00E3D0  8E0201C0   LW V0, 448(S0)
9D00E3D8  1440005B   BNE V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptIsEnabled
9D00E3DC  00000000   NOP
9D00E3E0  0000B825   OR S7, ZERO, ZERO
9D00E3E8  24130001   ADDIU S3, ZERO, 1
9D00E3EC  10000012   BEQ ZERO, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E3F0  24160024   ADDIU S6, ZERO, 36
9D00E3F4  56200051   BNEL S1, ZERO, 0x9D00E53C
9D00E3F8  8E45001C   LW A1, 28(S2)
9D00E3FC  8E450018   LW A1, 24(S2)
9D00E400  00A31825   OR V1, A1, V1
9D00E404  AE430018   SW V1, 24(S2)
9D00E408  00023840   SLL A3, V0, 1
9D00E40C  00111840   SLL V1, S1, 1
9D00E410  00E22821   ADDU A1, A3, V0
9D00E414  00711021   ADDU V0, V1, S1
9D00E418  8E430034   LW V1, 52(S2)
9D00E41C  000210C0   SLL V0, V0, 3
9D00E420  00052900   SLL A1, A1, 4
9D00E424  00A22821   ADDU A1, A1, V0
9D00E428  00652821   ADDU A1, V1, A1
9D00E42C  8CA20000   LW V0, 0(A1)
9D00E430  54400020   BNEL V0, ZERO, 0x9D00E4B4
9D00E434  8E48002C   LW T0, 44(S2)
9D00E438  8E0201C0   LW V0, 448(S0)
9D00E440  1040FF44   BEQ V0, ZERO, 0x9D00E154
9D00E444  8FBF004C   LW RA, 76(SP)
9D00E448  8E110200   LW S1, 512(S0)
9D00E460  AE1401C0   SW S4, 448(S0)
9D00E464  1080FFE3   BEQ A0, ZERO, 0x9D00E3F4
9D00E468  00531804   SLLV V1, S3, V0
9D00E46C  1620002F   BNE S1, ZERO, 0x9D00E52C
9D00E470  00031827   NOR V1, ZERO, V1
9D00E474  8E450018   LW A1, 24(S2)
9D00E478  00023840   SLL A3, V0, 1
9D00E47C  00A31824   AND V1, A1, V1
9D00E480  AE430018   SW V1, 24(S2)
9D00E484  00111840   SLL V1, S1, 1
9D00E488  00E22821   ADDU A1, A3, V0
9D00E48C  00711021   ADDU V0, V1, S1
9D00E490  8E430034   LW V1, 52(S2)
9D00E494  000210C0   SLL V0, V0, 3
9D00E498  00052900   SLL A1, A1, 4
9D00E49C  00A22821   ADDU A1, A1, V0
9D00E4A0  00652821   ADDU A1, V1, A1
9D00E4A4  8CA20000   LW V0, 0(A1)
9D00E4A8  1040FFE3   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E4AC  00000000   NOP
9D00E4B0  8E48002C   LW T0, 44(S2)
9D00E4B4  00F13821   ADDU A3, A3, S1
9D00E4B8  00073900   SLL A3, A3, 4
9D00E4BC  01074021   ADDU T0, T0, A3
9D00E4C0  000420C0   SLL A0, A0, 3
9D00E4C4  0104F021   ADDU FP, T0, A0
9D00E4C8  93C30000   LBU V1, 0(FP)
9D00E4CC  3063003C   ANDI V1, V1, 60
9D00E4D0  10760067   BEQ V1, S6, 0x9D00E670
9D00E4D4  24040034   ADDIU A0, ZERO, 52
9D00E4D8  10640045   BEQ V1, A0, 0x9D00E5F0
9D00E4DC  24040004   ADDIU A0, ZERO, 4
9D00E4E0  50640031   BEQL V1, A0, 0x9D00E5A8
9D00E4E4  97C60002   LHU A2, 2(FP)
9D00E4E8  1000FFD3   BEQ ZERO, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E4EC  A3C00000   SB ZERO, 0(FP)
9D00E4F0  8E020020   LW V0, 32(S0)
9D00E4F8  14400024   BNE V0, ZERO, 0x9D00E58C
9D00E504  10400084   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_OTG_InterruptFlagClear
9D00E508  24050009   ADDIU A1, ZERO, 9
9D00E50C  8E44000C   LW A0, 12(S2)
9D00E510  0040F809   JALR V0
9D00E514  00003025   OR A2, ZERO, ZERO
9D00E520  AE030000   SW V1, 0(S0)
9D00E52C  8E45001C   LW A1, 28(S2)
9D00E530  00A31824   AND V1, A1, V1
9D00E534  1000FFB4   BEQ ZERO, ZERO, 0x9D00E408
9D00E538  AE43001C   SW V1, 28(S2)
9D00E53C  00A31825   OR V1, A1, V1
9D00E540  1000FFB1   BEQ ZERO, ZERO, 0x9D00E408
9D00E544  AE43001C   SW V1, 28(S2)
9D00E550  1040FFA4   BEQ V0, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagClear
9D00E554  0000B825   OR S7, ZERO, ZERO
9D00E558  8E0201E0   LW V0, 480(S0)
9D00E55C  8E430010   LW V1, 16(S2)
9D00E560  AFA20010   SW V0, 16(SP)
9D00E568  24020002   ADDIU V0, ZERO, 2
9D00E56C  AE0201C0   SW V0, 448(S0)
9D00E570  1060FF9B   BEQ V1, ZERO, 0x9D00E3E0
9D00E574  27A60010   ADDIU A2, SP, 16
9D00E578  8E44000C   LW A0, 12(S2)
9D00E57C  0060F809   JALR V1
9D00E580  24050001   ADDIU A1, ZERO, 1
9D00E584  1000FF97   BEQ ZERO, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagClear
9D00E588  0000B825   OR S7, ZERO, ZERO
9D00E58C  24030001   ADDIU V1, ZERO, 1
9D00E590  A0830002   SB V1, 2(A0)
9D00E594  1440FFDD   BNE V0, ZERO, 0x9D00E50C
9D00E598  24050008   ADDIU A1, ZERO, 8
9D00E59C  AE050000   SW A1, 0(S0)
9D00E5A0  1000FEE5   BEQ ZERO, ZERO, 0x9D00E138
9D00E5A4  92550003   LBU S5, 3(S2)
9D00E5A8  8C430020   LW V1, 32(V0)
9D00E5AC  8C470008   LW A3, 8(V0)
9D00E5B0  2404FFFE   ADDIU A0, ZERO, -2
9D00E5B4  00C31821   ADDU V1, A2, V1
9D00E5B8  10E40042   BEQ A3, A0, 0x9D00E6C4
9D00E5BC  AC430020   SW V1, 32(V0)
9D00E5C0  94A70004   LHU A3, 4(A1)
9D00E5C4  8C440004   LW A0, 4(V0)
9D00E5C8  00C7302B   SLTU A2, A2, A3
9D00E5CC  14C00003   BNE A2, ZERO, 0x9D00E5DC
9D00E5D0  0064202B   SLTU A0, V1, A0
9D00E5D4  14800056   BNE A0, ZERO, 0x9D00E730
9D00E5D8  02203825   OR A3, S1, ZERO
9D00E5DC  AC430004   SW V1, 4(V0)
9D00E5E0  AC440008   SW A0, 8(V0)
9D00E5E4  8C43000C   LW V1, 12(V0)
9D00E5E8  1000000D   BEQ ZERO, ZERO, 0x9D00E620
9D00E5EC  A3C00000   SB ZERO, 0(FP)
9D00E5F0  8FC30004   LW V1, 4(FP)
9D00E5F4  24040002   ADDIU A0, ZERO, 2
9D00E5F8  AC440008   SW A0, 8(V0)
9D00E5FC  AC430004   SW V1, 4(V0)
9D00E600  92040210   LBU A0, 528(S0)
9D00E604  8C43000C   LW V1, 12(V0)
9D00E608  A1000010   SB ZERO, 16(T0)
9D00E60C  7C042944   INS A0, ZERO, 5, 1
9D00E610  A1000018   SB ZERO, 24(T0)
9D00E614  ACB30024   SW S3, 36(A1)
9D00E618  A2040210   SB A0, 528(S0)
9D00E61C  A3C00000   SB ZERO, 0(FP)
9D00E620  8C460018   LW A2, 24(V0)
9D00E624  10C00034   BEQ A2, ZERO, 0x9D00E6F8
9D00E628  ACA60000   SW A2, 0(A1)
9D00E62C  1060000C   BEQ V1, ZERO, 0x9D00E660
9D00E630  2404FFFE   ADDIU A0, ZERO, -2
9D00E634  8C470008   LW A3, 8(V0)
9D00E638  10E40009   BEQ A3, A0, 0x9D00E660
9D00E63C  00000000   NOP
9D00E640  00402025   OR A0, V0, ZERO
9D00E644  AFA8001C   SW T0, 28(SP)
9D00E648  0060F809   JALR V1
9D00E64C  AFA50018   SW A1, 24(SP)
9D00E650  8FA50018   LW A1, 24(SP)
9D00E654  8CA60000   LW A2, 0(A1)
9D00E658  10C0FF77   BEQ A2, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E65C  8FA8001C   LW T0, 28(SP)
9D00E660  12E00012   BEQ S7, ZERO, 0x9D00E6AC
9D00E664  24020004   ADDIU V0, ZERO, 4
9D00E668  1000FF73   BEQ ZERO, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E66C  02A0B825   OR S7, S5, ZERO
9D00E670  8C440008   LW A0, 8(V0)
9D00E674  2403FFFE   ADDIU V1, ZERO, -2
9D00E678  50830013   BEQL A0, V1, 0x9D00E6C8
9D00E67C  8C43000C   LW V1, 12(V0)
9D00E680  8C430020   LW V1, 32(V0)
9D00E684  1460002A   BNE V1, ZERO, 0x9D00E730
9D00E688  02203825   OR A3, S1, ZERO
9D00E68C  8C430010   LW V1, 16(V0)
9D00E690  30640080   ANDI A0, V1, 128
9D00E694  54800024   BNEL A0, ZERO, 0x9D00E728
9D00E698  7C0339C4   INS V1, ZERO, 7, 1
9D00E69C  AC400008   SW ZERO, 8(V0)
9D00E6A0  8C43000C   LW V1, 12(V0)
9D00E6A4  1000FFDE   BEQ ZERO, ZERO, 0x9D00E620
9D00E6A8  A3C00000   SB ZERO, 0(FP)
9D00E6AC  ACC20008   SW V0, 8(A2)
9D00E6B0  02203825   OR A3, S1, ZERO
9D00E6B4  0F405677   JAL _DRV_USBFS_DEVICE_EndpointBDTEntryArm
9D00E6B8  01002025   OR A0, T0, ZERO
9D00E6BC  1000FF5E   BEQ ZERO, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E6C0  00000000   NOP
9D00E6C4  8C43000C   LW V1, 12(V0)
9D00E6C8  1060001E   BEQ V1, ZERO, 0x9D00E744
9D00E6CC  00402025   OR A0, V0, ZERO
9D00E6D0  AFA80020   SW T0, 32(SP)
9D00E6D4  AFA5001C   SW A1, 28(SP)
9D00E6D8  0060F809   JALR V1
9D00E6DC  AFA20018   SW V0, 24(SP)
9D00E6E0  8FA20018   LW V0, 24(SP)
9D00E6E4  8FA5001C   LW A1, 28(SP)
9D00E6E8  8FA80020   LW T0, 32(SP)
9D00E6EC  8C43000C   LW V1, 12(V0)
9D00E6F0  1000FFCB   BEQ ZERO, ZERO, 0x9D00E620
9D00E6F4  A3C00000   SB ZERO, 0(FP)
9D00E6F8  1060FF4F   BEQ V1, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E6FC  02A0B825   OR S7, S5, ZERO
9D00E700  8C460008   LW A2, 8(V0)
9D00E704  2404FFFE   ADDIU A0, ZERO, -2
9D00E708  54C4FFCE   BNEL A2, A0, 0x9D00E644
9D00E70C  00402025   OR A0, V0, ZERO
9D00E710  1000FF49   BEQ ZERO, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E714  00000000   NOP
9D00E718  24020008   ADDIU V0, ZERO, 8
9D00E71C  AE020000   SW V0, 0(S0)
9D00E720  1000FE87   BEQ ZERO, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_ErrorInterruptFlagClear
9D00E728  AC430010   SW V1, 16(V0)
9D00E72C  02203825   OR A3, S1, ZERO
9D00E730  00403025   OR A2, V0, ZERO
9D00E734  0F405677   JAL _DRV_USBFS_DEVICE_EndpointBDTEntryArm
9D00E738  01002025   OR A0, T0, ZERO
9D00E73C  1000FF3E   BEQ ZERO, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E740  A3C00000   SB ZERO, 0(FP)
9D00E744  8C460018   LW A2, 24(V0)
9D00E748  A3C00000   SB ZERO, 0(FP)
9D00E74C  14C0FFC4   BNE A2, ZERO, 0x9D00E660
9D00E750  ACA60000   SW A2, 0(A1)
9D00E754  1000FF38   BEQ ZERO, ZERO, _DRV_USBFS_DEVICE_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D00E758  02A0B825   OR S7, S5, ZERO
9D01122C  2482FFFF   ADDIU V0, A0, -1
9D011230  2C42FFFE   SLTIU V0, V0, -2
9D011234  1040008C   BEQ V0, ZERO, 0x9D011468
9D011238  00000000   NOP
9D01123C  8CC20008   LW V0, 8(A2)
9D011240  28420003   SLTI V0, V0, 3
9D011244  1040008C   BEQ V0, ZERO, 0x9D011478
9D011248  00000000   NOP
9D01124C  27BDFFC8   ADDIU SP, SP, -56
9D011250  30A3000C   ANDI V1, A1, 12
9D011254  AFB20024   SW S2, 36(SP)
9D011258  AFBF0034   SW RA, 52(SP)
9D01125C  AFB50030   SW S5, 48(SP)
9D011260  AFB4002C   SW S4, 44(SP)
9D011264  AFB30028   SW S3, 40(SP)
9D011268  AFB10020   SW S1, 32(SP)
9D01126C  AFB0001C   SW S0, 28(SP)
9D011270  30A2000F   ANDI V0, A1, 15
9D011274  1460007E   BNE V1, ZERO, 0x9D011470
9D011278  7C059420   SEB S2, A1
9D01127C  0002A040   SLL S4, V0, 1
9D011280  02821021   ADDU V0, S4, V0
9D011284  2A430000   SLTI V1, S2, 0
9D011288  8C930034   LW S3, 52(A0)
9D01128C  24050018   ADDIU A1, ZERO, 24
9D011290  00021100   SLL V0, V0, 4
9D011294  0003280A   MOVZ A1, ZERO, V1
9D011298  00451021   ADDU V0, V0, A1
9D01129C  02629821   ADDU S3, S3, V0
9D0112A0  8E620014   LW V0, 20(S3)
9D0112A4  30420001   ANDI V0, V0, 1
9D0112A8  10400075   BEQ V0, ZERO, 0x9D011480
9D0112AC  8C95002C   LW S5, 44(A0)
9D0112B0  96700004   LHU S0, 4(S3)
9D0112B4  8CC20004   LW V0, 4(A2)
9D0112B8  0050001B   DIVU V0, S0
9D0112BC  020001F4   TEQ S0, ZERO
9D0112C0  00008010   MFHI S0
9D0112C4  16000025   BNE S0, ZERO, 0x9D01135C
9D0112C8  00808825   OR S1, A0, ZERO
9D0112CC  06400047   BLTZ S2, 0x9D0113EC
9D0112D0  90830001   LBU V1, 1(A0)
9D0112D4  10600058   BEQ V1, ZERO, DRV_USBFS_DEVICE_IRPSubmit::OSAL_MUTEX_Lock
9D0112D8  00006025   OR T4, ZERO, ZERO
9D0112DC  ACC00018   SW ZERO, 24(A2)
9D0112E0  8E670000   LW A3, 0(S3)
9D0112E4  24030003   ADDIU V1, ZERO, 3
9D0112E8  ACD00020   SW S0, 32(A2)
9D0112EC  14E00003   BNE A3, ZERO, 0x9D0112FC
9D0112F0  ACC30008   SW V1, 8(A2)
9D0112F4  10000045   BEQ ZERO, ZERO, 0x9D01140C
9D0112F8  00123FC2   SRL A3, S2, 31
9D0112FC  8CE30018   LW V1, 24(A3)
9D011300  5460FFFE   BNEL V1, ZERO, 0x9D0112FC
9D011304  00603825   OR A3, V1, ZERO
9D011308  24030003   ADDIU V1, ZERO, 3
9D01130C  ACE60018   SW A2, 24(A3)
9D011310  ACC7001C   SW A3, 28(A2)
9D011314  ACC30008   SW V1, 8(A2)
9D011318  92230001   LBU V1, 1(S1)
9D01131C  14600019   BNE V1, ZERO, 0x9D011384
9D011320  00001025   OR V0, ZERO, ZERO
9D011324  15800023   BNE T4, ZERO, 0x9D0113B4
9D011328  00000000   NOP
9D01132C  24020001   ADDIU V0, ZERO, 1
9D011334  8FBF0034   LW RA, 52(SP)
9D01133C  8FB50030   LW S5, 48(SP)
9D011340  8FB4002C   LW S4, 44(SP)
9D011344  8FB30028   LW S3, 40(SP)
9D011348  8FB20024   LW S2, 36(SP)
9D01134C  8FB10020   LW S1, 32(SP)
9D011350  8FB0001C   LW S0, 28(SP)
9D011354  03E00008   JR RA
9D011358  27BD0038   ADDIU SP, SP, 56
9D01135C  06430009   BGEZL S2, 0x9D011384
9D011360  2402FF83   ADDIU V0, ZERO, -125
9D011364  90830001   LBU V1, 1(A0)
9D011368  5460000F   BNEL V1, ZERO, 0x9D0113A8
9D01136C  ACC00018   SW ZERO, 24(A2)
9D011370  92230030   LBU V1, 48(S1)
9D011380  2402FF81   ADDIU V0, ZERO, -127
9D011384  8FBF0034   LW RA, 52(SP)
9D011388  8FB50030   LW S5, 48(SP)
9D01138C  8FB4002C   LW S4, 44(SP)
9D011390  8FB30028   LW S3, 40(SP)
9D011394  8FB20024   LW S2, 36(SP)
9D011398  8FB10020   LW S1, 32(SP)
9D01139C  8FB0001C   LW S0, 28(SP)
9D0113A0  03E00008   JR RA
9D0113A4  27BD0038   ADDIU SP, SP, 56
9D0113A8  00408025   OR S0, V0, ZERO
9D0113AC  1000FFCC   BEQ ZERO, ZERO, 0x9D0112E0
9D0113B0  00006025   OR T4, ZERO, ZERO
9D0113B4  0F406307   JAL EVIC_SourceEnable
9D0113B8  8E240028   LW A0, 40(S1)
9D0113C8  0F406033   JAL SYS_INT_SourceDisable
9D0113CC  AFA60010   SW A2, 16(SP)
9D0113D0  8FA60010   LW A2, 16(SP)
9D0113D4  00406025   OR T4, V0, ZERO
9D0113D8  00008025   OR S0, ZERO, ZERO
9D0113DC  0641FFC0   BGEZ S2, 0x9D0112E0
9D0113E0  ACC00018   SW ZERO, 24(A2)
9D0113E4  1000FFBE   BEQ ZERO, ZERO, 0x9D0112E0
9D0113E8  8CD00004   LW S0, 4(A2)
9D0113EC  8CC40010   LW A0, 16(A2)
9D0113F0  30850001   ANDI A1, A0, 1
9D0113F4  10A0FFDC   BEQ A1, ZERO, 0x9D011368
9D0113F8  00000000   NOP
9D0113FC  1040FFDA   BEQ V0, ZERO, 0x9D011368
9D011400  34840080   ORI A0, A0, 128
9D011404  1000FFD8   BEQ ZERO, ZERO, 0x9D011368
9D011408  ACC40010   SW A0, 16(A2)
9D01140C  02872021   ADDU A0, S4, A3
9D011410  24020004   ADDIU V0, ZERO, 4
9D011414  00042100   SLL A0, A0, 4
9D011418  AE660000   SW A2, 0(S3)
9D01141C  02602825   OR A1, S3, ZERO
9D011420  ACC0001C   SW ZERO, 28(A2)
9D011424  ACC20008   SW V0, 8(A2)
9D011428  0F405677   JAL _DRV_USBFS_DEVICE_EndpointBDTEntryArm
9D01142C  02A42021   ADDU A0, S5, A0
9D011430  1000FFBA   BEQ ZERO, ZERO, 0x9D01131C
9D011434  92230001   LBU V1, 1(S1)
9D011438  90830030   LBU V1, 48(A0)
9D011448  8E240028   LW A0, 40(S1)
9D011450  0F406033   JAL SYS_INT_SourceDisable
9D011454  AFA60010   SW A2, 16(SP)
9D011458  8FA60010   LW A2, 16(SP)
9D01145C  00406025   OR T4, V0, ZERO
9D011460  1000FF9F   BEQ ZERO, ZERO, 0x9D0112E0
9D011464  ACC00018   SW ZERO, 24(A2)
9D011468  03E00008   JR RA
9D01146C  2402FF83   ADDIU V0, ZERO, -125
9D011470  1000FFC4   BEQ ZERO, ZERO, 0x9D011384
9D011474  2402FF84   ADDIU V0, ZERO, -124
9D011478  03E00008   JR RA
9D01147C  2402FF85   ADDIU V0, ZERO, -123
9D011480  1000FFC0   BEQ ZERO, ZERO, 0x9D011384
9D011484  2402FF8A   ADDIU V0, ZERO, -118
9D011488  30A2000C   ANDI V0, A1, 12
9D01148C  1440008E   BNE V0, ZERO, 0x9D0116C8
9D011490  00000000   NOP
9D011494  2482FFFF   ADDIU V0, A0, -1
9D011498  2C42FFFE   SLTIU V0, V0, -2
9D01149C  1040008C   BEQ V0, ZERO, 0x9D0116D0
9D0114A0  00000000   NOP
9D0114A4  90820001   LBU V0, 1(A0)
9D0114A8  27BDFFD0   ADDIU SP, SP, -48
9D0114AC  AFB1001C   SW S1, 28(SP)
9D0114B0  AFBF002C   SW RA, 44(SP)
9D0114B4  AFB40028   SW S4, 40(SP)
9D0114B8  AFB30024   SW S3, 36(SP)
9D0114BC  AFB20020   SW S2, 32(SP)
9D0114C0  AFB00018   SW S0, 24(SP)
9D0114C4  10400045   BEQ V0, ZERO, DRV_USBFS_DEVICE_EndpointStall::OSAL_MUTEX_Lock
9D0114C8  00808825   OR S1, A0, ZERO
9D0114CC  00009025   OR S2, ZERO, ZERO
9D0114D0  30A2000F   ANDI V0, A1, 15
9D0114D4  8E330034   LW S3, 52(S1)
9D0114D8  1440004C   BNE V0, ZERO, 0x9D01160C
9D0114DC  8E23002C   LW V1, 44(S1)
9D0114E0  8E620010   LW V0, 16(S3)
9D0114E4  8E700000   LW S0, 0(S3)
9D0114E8  2404FF84   ADDIU A0, ZERO, -124
9D0114EC  000210C0   SLL V0, V0, 3
9D0114F0  00621021   ADDU V0, V1, V0
9D0114F4  12000072   BEQ S0, ZERO, 0x9D0116C0
9D0114F8  A0440000   SB A0, 0(V0)
9D0114FC  2414FFFD   ADDIU S4, ZERO, -3
9D011500  8E02000C   LW V0, 12(S0)
9D011504  02002025   OR A0, S0, ZERO
9D011508  10400003   BEQ V0, ZERO, 0x9D011518
9D01150C  AE140008   SW S4, 8(S0)
9D011510  0040F809   JALR V0
9D011514  00000000   NOP
9D011518  8E100018   LW S0, 24(S0)
9D01151C  5600FFF9   BNEL S0, ZERO, 0x9D011504
9D011520  8E02000C   LW V0, 12(S0)
9D011524  8E340034   LW S4, 52(S1)
9D011528  8E23002C   LW V1, 44(S1)
9D01152C  8E850028   LW A1, 40(S4)
9D011530  8E640014   LW A0, 20(S3)
9D011534  26820018   ADDIU V0, S4, 24
9D011538  24A50002   ADDIU A1, A1, 2
9D01153C  34840002   ORI A0, A0, 2
9D011540  000528C0   SLL A1, A1, 3
9D011544  AE640014   SW A0, 20(S3)
9D011548  00651821   ADDU V1, V1, A1
9D01154C  2404FF84   ADDIU A0, ZERO, -124
9D011550  AE600000   SW ZERO, 0(S3)
9D011554  1040000E   BEQ V0, ZERO, 0x9D011590
9D01155C  8E900018   LW S0, 24(S4)
9D011560  1200000A   BEQ S0, ZERO, 0x9D01158C
9D011568  8E02000C   LW V0, 12(S0)
9D01156C  02002025   OR A0, S0, ZERO
9D011570  10400003   BEQ V0, ZERO, 0x9D011580
9D011578  0040F809   JALR V0
9D011580  8E100018   LW S0, 24(S0)
9D011584  5600FFF9   BNEL S0, ZERO, 0x9D01156C
9D01158C  AE800018   SW ZERO, 24(S4)
9D011590  8E82002C   LW V0, 44(S4)
9D011594  34420002   ORI V0, V0, 2
9D011598  AE82002C   SW V0, 44(S4)
9D01159C  92230001   LBU V1, 1(S1)
9D0115A0  14600012   BNE V1, ZERO, 0x9D0115EC
9D0115A4  00001025   OR V0, ZERO, ZERO
9D0115A8  1640003A   BNE S2, ZERO, 0x9D011694
9D0115AC  00000000   NOP
9D0115B0  24020001   ADDIU V0, ZERO, 1
9D0115B4  A2220030   SB V0, 48(S1)
9D0115B8  8FBF002C   LW RA, 44(SP)
9D0115C0  8FB40028   LW S4, 40(SP)
9D0115C4  8FB30024   LW S3, 36(SP)
9D0115C8  8FB20020   LW S2, 32(SP)
9D0115CC  8FB1001C   LW S1, 28(SP)
9D0115D0  8FB00018   LW S0, 24(SP)
9D0115D4  03E00008   JR RA
9D0115D8  27BD0030   ADDIU SP, SP, 48
9D0115DC  90840030   LBU A0, 48(A0)
9D0115EC  8FBF002C   LW RA, 44(SP)
9D0115F0  8FB40028   LW S4, 40(SP)
9D0115F4  8FB30024   LW S3, 36(SP)
9D0115F8  8FB20020   LW S2, 32(SP)
9D0115FC  8FB1001C   LW S1, 28(SP)
9D011600  8FB00018   LW S0, 24(SP)
9D011604  03E00008   JR RA
9D011608  27BD0030   ADDIU SP, SP, 48
9D01160C  7C052C20   SEB A1, A1
9D011610  00023040   SLL A2, V0, 1
9D011614  28A40000   SLTI A0, A1, 0
9D011618  00C21021   ADDU V0, A2, V0
9D01161C  00052FC2   SRL A1, A1, 31
9D011620  24070018   ADDIU A3, ZERO, 24
9D011624  00021100   SLL V0, V0, 4
9D011628  0004380A   MOVZ A3, ZERO, A0
9D01162C  00A62821   ADDU A1, A1, A2
9D011630  00471021   ADDU V0, V0, A3
9D011634  00052900   SLL A1, A1, 4
9D011638  00652821   ADDU A1, V1, A1
9D01163C  02629821   ADDU S3, S3, V0
9D011640  2403FF84   ADDIU V1, ZERO, -124
9D011644  A0A30000   SB V1, 0(A1)
9D011648  1260000E   BEQ S3, ZERO, 0x9D011684
9D011650  8E700000   LW S0, 0(S3)
9D011654  1200000A   BEQ S0, ZERO, 0x9D011680
9D01165C  8E02000C   LW V0, 12(S0)
9D011660  02002025   OR A0, S0, ZERO
9D011664  10400003   BEQ V0, ZERO, 0x9D011674
9D01166C  0040F809   JALR V0
9D011674  8E100018   LW S0, 24(S0)
9D011678  5600FFF9   BNEL S0, ZERO, 0x9D011660
9D011680  AE600000   SW ZERO, 0(S3)
9D011684  8E620014   LW V0, 20(S3)
9D011688  34420002   ORI V0, V0, 2
9D01168C  1000FFC3   BEQ ZERO, ZERO, 0x9D01159C
9D011690  AE620014   SW V0, 20(S3)
9D011694  0F406307   JAL EVIC_SourceEnable
9D011698  8E240028   LW A0, 40(S1)
9D0116A4  8E240028   LW A0, 40(S1)
9D0116AC  0F406033   JAL SYS_INT_SourceDisable
9D0116B4  00409025   OR S2, V0, ZERO
9D0116B8  1000FF85   BEQ ZERO, ZERO, 0x9D0114D0
9D0116BC  8FA50010   LW A1, 16(SP)
9D0116C0  1000FF9A   BEQ ZERO, ZERO, 0x9D01152C
9D0116C4  0260A025   OR S4, S3, ZERO
9D0116C8  03E00008   JR RA
9D0116CC  2402FF84   ADDIU V0, ZERO, -124
9D0116D0  03E00008   JR RA
9D0116D4  2402FF83   ADDIU V0, ZERO, -125
9D012580  30A2000C   ANDI V0, A1, 12
9D012584  14400071   BNE V0, ZERO, 0x9D01274C
9D012588  00000000   NOP
9D01258C  2482FFFF   ADDIU V0, A0, -1
9D012590  2C42FFFE   SLTIU V0, V0, -2
9D012594  1040006F   BEQ V0, ZERO, 0x9D012754
9D012598  00000000   NOP
9D01259C  90820001   LBU V0, 1(A0)
9D0125A0  27BDFFD0   ADDIU SP, SP, -48
9D0125A4  AFB40028   SW S4, 40(SP)
9D0125A8  AFB1001C   SW S1, 28(SP)
9D0125AC  AFB00018   SW S0, 24(SP)
9D0125B0  AFBF002C   SW RA, 44(SP)
9D0125B4  AFB30024   SW S3, 36(SP)
9D0125B8  AFB20020   SW S2, 32(SP)
9D0125BC  00808825   OR S1, A0, ZERO
9D0125C0  8C940020   LW S4, 32(A0)
9D0125C4  1040001B   BEQ V0, ZERO, DRV_USBFS_DEVICE_EndpointStallClear::OSAL_MUTEX_Lock
9D0125C8  8C900034   LW S0, 52(A0)
9D0125CC  00009025   OR S2, ZERO, ZERO
9D0125D0  30A2000F   ANDI V0, A1, 15
9D0125D4  00022040   SLL A0, V0, 1
9D0125D8  7C052C20   SEB A1, A1
9D0125DC  28B30000   SLTI S3, A1, 0
9D0125E0  00821821   ADDU V1, A0, V0
9D0125E4  24060018   ADDIU A2, ZERO, 24
9D0125E8  0013300A   MOVZ A2, ZERO, S3
9D0125EC  00031900   SLL V1, V1, 4
9D0125F0  00661821   ADDU V1, V1, A2
9D0125F4  02039821   ADDU S3, S0, V1
9D0125F8  8E660014   LW A2, 20(S3)
9D0125FC  8E23002C   LW V1, 44(S1)
9D012600  14400018   BNE V0, ZERO, DRV_USBFS_DEVICE_EndpointStallClear::PLIB_USB_EPnStallClear
9D012604  7C060844   INS A2, ZERO, 1, 1
9D012608  8E640010   LW A0, 16(S3)
9D01260C  00051183   SRA V0, A1, 6
9D012610  30420002   ANDI V0, V0, 2
9D012614  00441021   ADDU V0, V0, A0
9D012618  000210C0   SLL V0, V0, 3
9D01261C  00621821   ADDU V1, V1, V0
9D012620  04A0003B   BLTZ A1, 0x9D012710
9D012624  A0600000   SB ZERO, 0(V1)
9D012628  AE60000C   SW ZERO, 12(S3)
9D01262C  10000028   BEQ ZERO, ZERO, 0x9D0126D0
9D012630  AE660014   SW A2, 20(S3)
9D012634  90840030   LBU A0, 48(A0)
9D012644  8FBF002C   LW RA, 44(SP)
9D012648  8FB40028   LW S4, 40(SP)
9D01264C  8FB30024   LW S3, 36(SP)
9D012650  8FB20020   LW S2, 32(SP)
9D012654  8FB1001C   LW S1, 28(SP)
9D012658  8FB00018   LW S0, 24(SP)
9D01265C  03E00008   JR RA
9D012660  27BD0030   ADDIU SP, SP, 48
9D012664  2442002C   ADDIU V0, V0, 44
9D012668  00021100   SLL V0, V0, 4
9D01266C  02821021   ADDU V0, S4, V0
9D012670  90470000   LBU A3, 0(V0)
9D012674  00052FC2   SRL A1, A1, 31
9D012678  8E700000   LW S0, 0(S3)
9D01267C  00A42821   ADDU A1, A1, A0
9D012680  00052900   SLL A1, A1, 4
9D012684  00652821   ADDU A1, V1, A1
9D01268C  A0A00000   SB ZERO, 0(A1)
9D012690  A0A00008   SB ZERO, 8(A1)
9D012694  2414FFFC   ADDIU S4, ZERO, -4
9D012698  A0470000   SB A3, 0(V0)
9D01269C  AE60000C   SW ZERO, 12(S3)
9D0126A0  1200000A   BEQ S0, ZERO, 0x9D0126CC
9D0126A4  AE660014   SW A2, 20(S3)
9D0126A8  8E02000C   LW V0, 12(S0)
9D0126AC  02002025   OR A0, S0, ZERO
9D0126B0  10400003   BEQ V0, ZERO, 0x9D0126C0
9D0126B4  AE140008   SW S4, 8(S0)
9D0126B8  0040F809   JALR V0
9D0126BC  00000000   NOP
9D0126C0  8E100018   LW S0, 24(S0)
9D0126C4  5600FFF9   BNEL S0, ZERO, 0x9D0126AC
9D0126C8  8E02000C   LW V0, 12(S0)
9D0126CC  AE600000   SW ZERO, 0(S3)
9D0126D0  92230001   LBU V1, 1(S1)
9D0126D4  1460FFDB   BNE V1, ZERO, 0x9D012644
9D0126D8  00001025   OR V0, ZERO, ZERO
9D0126DC  16400010   BNE S2, ZERO, 0x9D012720
9D0126E0  00000000   NOP
9D0126E4  24020001   ADDIU V0, ZERO, 1
9D0126E8  A2220030   SB V0, 48(S1)
9D0126EC  8FBF002C   LW RA, 44(SP)
9D0126F4  8FB40028   LW S4, 40(SP)
9D0126F8  8FB30024   LW S3, 36(SP)
9D0126FC  8FB20020   LW S2, 32(SP)
9D012700  8FB1001C   LW S1, 28(SP)
9D012704  8FB00018   LW S0, 24(SP)
9D012708  03E00008   JR RA
9D01270C  27BD0030   ADDIU SP, SP, 48
9D012710  24020001   ADDIU V0, ZERO, 1
9D012714  AE62000C   SW V0, 12(S3)
9D012718  1000FFED   BEQ ZERO, ZERO, 0x9D0126D0
9D01271C  AE660014   SW A2, 20(S3)
9D012720  0F406307   JAL EVIC_SourceEnable
9D012724  8E240028   LW A0, 40(S1)
9D012730  8E240028   LW A0, 40(S1)
9D012738  0F406033   JAL SYS_INT_SourceDisable
9D012740  00409025   OR S2, V0, ZERO
9D012744  1000FFA2   BEQ ZERO, ZERO, 0x9D0125D0
9D012748  8FA50010   LW A1, 16(SP)
9D01274C  03E00008   JR RA
9D012750  2402FF84   ADDIU V0, ZERO, -124
9D012754  03E00008   JR RA
9D012758  2402FF83   ADDIU V0, ZERO, -125
9D012B0C  30A2000C   ANDI V0, A1, 12
9D012B10  1440006B   BNE V0, ZERO, 0x9D012CC0
9D012B14  30A8000F   ANDI T0, A1, 15
9D012B18  2489FFFF   ADDIU T1, A0, -1
9D012B1C  2D29FFFE   SLTIU T1, T1, -2
9D012B20  11200069   BEQ T1, ZERO, 0x9D012CC8
9D012B24  00084840   SLL T1, T0, 1
9D012B28  8C83002C   LW V1, 44(A0)
9D012B2C  8C8A0034   LW T2, 52(A0)
9D012B30  01284821   ADDU T1, T1, T0
9D012B34  00094900   SLL T1, T1, 4
9D012B38  00081140   SLL V0, T0, 5
9D012B3C  00621021   ADDU V0, V1, V0
9D012B40  01491821   ADDU V1, T2, T1
9D012B44  240A0001   ADDIU T2, ZERO, 1
9D012B48  010A5004   SLLV T2, T2, T0
9D012B4C  10C00027   BEQ A2, ZERO, 0x9D012BEC
9D012B50  8C890020   LW T1, 32(A0)
9D012B54  00084100   SLL T0, T0, 4
9D012B58  01284021   ADDU T0, T1, T0
9D012B5C  7C052C20   SEB A1, A1
9D012B60  8D0D02C0   LW T5, 704(T0)
9D012B64  000577C2   SRL T6, A1, 31
9D012B68  38CC0001   XORI T4, A2, 1
9D012B70  000558C3   SRA T3, A1, 3
9D012B78  000C602B   SLTU T4, ZERO, T4
9D012B7C  316B0010   ANDI T3, T3, 16
9D012B84  004B1021   ADDU V0, V0, T3
9D012B88  012D4825   OR T1, T1, T5
9D012B8C  AC400000   SW ZERO, 0(V0)
9D012B90  AC400004   SW ZERO, 4(V0)
9D012B94  AC400008   SW ZERO, 8(V0)
9D012B98  AC40000C   SW ZERO, 12(V0)
9D012B9C  AD0902C0   SW T1, 704(T0)
9D012BA0  04A20037   BLTZL A1, 0x9D012C80
9D012BA4  8C82001C   LW V0, 28(A0)
9D012BA8  8C820018   LW V0, 24(A0)
9D012BAC  24040018   ADDIU A0, ZERO, 24
9D012BB0  01425024   AND T2, T2, V0
9D012BB4  28A20000   SLTI V0, A1, 0
9D012BB8  0002200A   MOVZ A0, ZERO, V0
9D012BBC  00641821   ADDU V1, V1, A0
9D012BC0  8C620014   LW V0, 20(V1)
9D012BC4  000A502B   SLTU T2, ZERO, T2
9D012BC8  AC60000C   SW ZERO, 12(V1)
9D012BCC  34420001   ORI V0, V0, 1
9D012BD0  AC620014   SW V0, 20(V1)
9D012BD4  AC600000   SW ZERO, 0(V1)
9D012BD8  A4670004   SH A3, 4(V1)
9D012BDC  AC6A0010   SW T2, 16(V1)
9D012BE0  AC660008   SW A2, 8(V1)
9D012BE4  03E00008   JR RA
9D012BE8  00001025   OR V0, ZERO, ZERO
9D012BEC  2445001C   ADDIU A1, V0, 28
9D012BF0  AC400000   SW ZERO, 0(V0)
9D012BF4  24420004   ADDIU V0, V0, 4
9D012BF8  54A2FFFE   BNEL A1, V0, 0x9D012BF4
9D012BFC  AC400000   SW ZERO, 0(V0)
9D012C00  00084100   SLL T0, T0, 4
9D012C0C  8C82001C   LW V0, 28(A0)
9D012C10  8C850018   LW A1, 24(A0)
9D012C20  8C690014   LW T1, 20(V1)
9D012C24  8C66002C   LW A2, 44(V1)
9D012C28  01452024   AND A0, T2, A1
9D012C2C  01425024   AND T2, T2, V0
9D012C30  0004202B   SLTU A0, ZERO, A0
9D012C38  35290001   ORI T1, T1, 1
9D012C3C  000A502B   SLTU T2, ZERO, T2
9D012C40  34C50001   ORI A1, A2, 1
9D012C48  00001025   OR V0, ZERO, ZERO
9D012C4C  AC60000C   SW ZERO, 12(V1)
9D012C50  AC600000   SW ZERO, 0(V1)
9D012C54  A4670004   SH A3, 4(V1)
9D012C58  AC640010   SW A0, 16(V1)
9D012C5C  AC600008   SW ZERO, 8(V1)
9D012C60  AC690014   SW T1, 20(V1)
9D012C64  AC600024   SW ZERO, 36(V1)
9D012C68  AC600018   SW ZERO, 24(V1)
9D012C6C  A467001C   SH A3, 28(V1)
9D012C70  AC6A0028   SW T2, 40(V1)
9D012C74  AC600020   SW ZERO, 32(V1)
9D012C78  03E00008   JR RA
9D012C7C  AC65002C   SW A1, 44(V1)
9D012C80  24040018   ADDIU A0, ZERO, 24
9D012C84  01425024   AND T2, T2, V0
9D012C88  28A20000   SLTI V0, A1, 0
9D012C8C  0002200A   MOVZ A0, ZERO, V0
9D012C90  00641821   ADDU V1, V1, A0
9D012C94  8C620014   LW V0, 20(V1)
9D012C98  000A502B   SLTU T2, ZERO, T2
9D012C9C  AC60000C   SW ZERO, 12(V1)
9D012CA0  34420001   ORI V0, V0, 1
9D012CA4  AC620014   SW V0, 20(V1)
9D012CA8  AC600000   SW ZERO, 0(V1)
9D012CAC  A4670004   SH A3, 4(V1)
9D012CB0  AC6A0010   SW T2, 16(V1)
9D012CB4  AC660008   SW A2, 8(V1)
9D012CB8  03E00008   JR RA
9D012CBC  00001025   OR V0, ZERO, ZERO
9D012CC0  03E00008   JR RA
9D012CC4  2402FF84   ADDIU V0, ZERO, -124
9D012CC8  03E00008   JR RA
9D012CCC  2402FF83   ADDIU V0, ZERO, -125
9D012E8C  30A2000C   ANDI V0, A1, 12
9D012E90  14400060   BNE V0, ZERO, 0x9D013014
9D012E94  00000000   NOP
9D012E98  2482FFFF   ADDIU V0, A0, -1
9D012E9C  2C42FFFE   SLTIU V0, V0, -2
9D012EA0  1040005E   BEQ V0, ZERO, 0x9D01301C
9D012EA4  00000000   NOP
9D012EA8  90820001   LBU V0, 1(A0)
9D012EAC  27BDFFD0   ADDIU SP, SP, -48
9D012EB0  AFB40028   SW S4, 40(SP)
9D012EB4  AFB30024   SW S3, 36(SP)
9D012EB8  AFB1001C   SW S1, 28(SP)
9D012EBC  AFBF002C   SW RA, 44(SP)
9D012EC0  AFB20020   SW S2, 32(SP)
9D012EC4  AFB00018   SW S0, 24(SP)
9D012EC8  00808825   OR S1, A0, ZERO
9D012ECC  8C930034   LW S3, 52(A0)
9D012ED0  10400036   BEQ V0, ZERO, DRV_USBFS_DEVICE_IRPCancelAll::OSAL_MUTEX_Lock
9D012ED4  8C94002C   LW S4, 44(A0)
9D012ED8  00009025   OR S2, ZERO, ZERO
9D012EDC  30A2000F   ANDI V0, A1, 15
9D012EE0  00022040   SLL A0, V0, 1
9D012EE4  7C052C20   SEB A1, A1
9D012EE8  28A30000   SLTI V1, A1, 0
9D012EEC  00821021   ADDU V0, A0, V0
9D012EF0  24060018   ADDIU A2, ZERO, 24
9D012EF4  00021100   SLL V0, V0, 4
9D012EF8  0003300A   MOVZ A2, ZERO, V1
9D012EFC  00461021   ADDU V0, V0, A2
9D012F00  02629821   ADDU S3, S3, V0
9D012F04  00052FC2   SRL A1, A1, 31
9D012F08  8E700000   LW S0, 0(S3)
9D012F0C  00A42821   ADDU A1, A1, A0
9D012F10  00052900   SLL A1, A1, 4
9D012F14  12000035   BEQ S0, ZERO, 0x9D012FEC
9D012F18  02852821   ADDU A1, S4, A1
9D012F1C  8E030008   LW V1, 8(S0)
9D012F20  24020004   ADDIU V0, ZERO, 4
9D012F24  54620005   BNEL V1, V0, 0x9D012F3C
9D012F28  A0A00000   SB ZERO, 0(A1)
9D012F2C  8E620010   LW V0, 16(S3)
9D012F30  38420001   XORI V0, V0, 1
9D012F34  AE620010   SW V0, 16(S3)
9D012F38  A0A00000   SB ZERO, 0(A1)
9D012F3C  A0A00008   SB ZERO, 8(A1)
9D012F40  2414FFFE   ADDIU S4, ZERO, -2
9D012F44  8E02000C   LW V0, 12(S0)
9D012F48  02002025   OR A0, S0, ZERO
9D012F4C  10400003   BEQ V0, ZERO, 0x9D012F5C
9D012F50  AE140008   SW S4, 8(S0)
9D012F54  0040F809   JALR V0
9D012F58  00000000   NOP
9D012F5C  8E100018   LW S0, 24(S0)
9D012F60  5600FFF9   BNEL S0, ZERO, 0x9D012F48
9D012F64  8E02000C   LW V0, 12(S0)
9D012F68  92230001   LBU V1, 1(S1)
9D012F6C  00001025   OR V0, ZERO, ZERO
9D012F70  14600012   BNE V1, ZERO, 0x9D012FBC
9D012F74  AE600000   SW ZERO, 0(S3)
9D012F78  16400018   BNE S2, ZERO, 0x9D012FDC
9D012F7C  00000000   NOP
9D012F80  24020001   ADDIU V0, ZERO, 1
9D012F88  8FBF002C   LW RA, 44(SP)
9D012F90  8FB40028   LW S4, 40(SP)
9D012F94  8FB30024   LW S3, 36(SP)
9D012F98  8FB20020   LW S2, 32(SP)
9D012F9C  8FB1001C   LW S1, 28(SP)
9D012FA0  8FB00018   LW S0, 24(SP)
9D012FA4  03E00008   JR RA
9D012FA8  27BD0030   ADDIU SP, SP, 48
9D012FAC  90840030   LBU A0, 48(A0)
9D012FBC  8FBF002C   LW RA, 44(SP)
9D012FD0  8FB00018   LW S0, 24(SP)
9D012FD4  03E00008   JR RA
9D012FD8  27BD0030   ADDIU SP, SP, 48
9D012FDC  0F406307   JAL EVIC_SourceEnable
9D012FE0  8E240028   LW A0, 40(S1)
9D012FEC  A0A00000   SB ZERO, 0(A1)
9D012FF0  1000FFDD   BEQ ZERO, ZERO, 0x9D012F68
9D012FF4  A0A00008   SB ZERO, 8(A1)
9D012FF8  8E240028   LW A0, 40(S1)
9D013000  0F406033   JAL SYS_INT_SourceDisable
9D013008  00409025   OR S2, V0, ZERO
9D01300C  1000FFB3   BEQ ZERO, ZERO, 0x9D012EDC
9D013010  8FA50010   LW A1, 16(SP)
9D013014  03E00008   JR RA
9D013018  2402FF84   ADDIU V0, ZERO, -124
9D01301C  03E00008   JR RA
9D013020  2402FF83   ADDIU V0, ZERO, -125
9D014B94  2482FFFF   ADDIU V0, A0, -1
9D014B98  2C42FFFE   SLTIU V0, V0, -2
9D014B9C  10400040   BEQ V0, ZERO, 0x9D014CA0
9D014BA0  24030010   ADDIU V1, ZERO, 16
9D014BA4  8C880020   LW T0, 32(A0)
9D014BA8  10A30027   BEQ A1, V1, 0x9D014C48
9D014BAC  8C820034   LW V0, 52(A0)
9D014BB0  30A3000C   ANDI V1, A1, 12
9D014BB4  30A4000F   ANDI A0, A1, 15
9D014BB8  1460003B   BNE V1, ZERO, 0x9D014CA8
9D014BBC  000529C2   SRL A1, A1, 7
9D014BC0  00041840   SLL V1, A0, 1
9D014BC4  00653021   ADDU A2, V1, A1
9D014BC8  00061840   SLL V1, A2, 1
9D014BCC  00661821   ADDU V1, V1, A2
9D014BD0  000318C0   SLL V1, V1, 3
9D014BD4  00431821   ADDU V1, V0, V1
9D014BD8  8C660014   LW A2, 20(V1)
9D014BDC  8C620008   LW V0, 8(V1)
9D014BE0  00042100   SLL A0, A0, 4
9D014BE4  7C060004   INS A2, ZERO, 0, 1
9D014BE8  1440000E   BNE V0, ZERO, DRV_USBFS_DEVICE_EndpointDisable::PLIB_USB_EPnDirectionDisable
9D014BEC  01042021   ADDU A0, T0, A0
9D014BF0  8C8202C0   LW V0, 704(A0)
9D014BF4  8C65002C   LW A1, 44(V1)
9D014C08  7C050004   INS A1, ZERO, 0, 1
9D014C0C  00001025   OR V0, ZERO, ZERO
9D014C18  AC660014   SW A2, 20(V1)
9D014C1C  03E00008   JR RA
9D014C20  AC65002C   SW A1, 44(V1)
9D014C24  8C8702C0   LW A3, 704(A0)
9D014C3C  00001025   OR V0, ZERO, ZERO
9D014C40  03E00008   JR RA
9D014C44  AC660014   SW A2, 20(V1)
9D014C48  00002025   OR A0, ZERO, ZERO
9D014C50  24090004   ADDIU T1, ZERO, 4
9D014C54  00041900   SLL V1, A0, 4
9D014C58  01031821   ADDU V1, T0, V1
9D014C60  8C460014   LW A2, 20(V0)
9D014C64  8C45002C   LW A1, 44(V0)
9D014C78  7C060004   INS A2, ZERO, 0, 1
9D014C7C  7C050004   INS A1, ZERO, 0, 1
9D014C84  24840001   ADDIU A0, A0, 1
9D014C8C  AC46FFE4   SW A2, -28(V0)
9D014C90  1489FFF0   BNE A0, T1, DRV_USBFS_DEVICE_EndpointDisable::PLIB_USB_EPnAttributesClear
9D014C94  AC45FFFC   SW A1, -4(V0)
9D014C98  03E00008   JR RA
9D014C9C  00001025   OR V0, ZERO, ZERO
9D014CA0  03E00008   JR RA
9D014CA4  2402FF83   ADDIU V0, ZERO, -125
9D014CA8  03E00008   JR RA
9D014CAC  2402FF84   ADDIU V0, ZERO, -124
9D014DC8  2482FFFF   ADDIU V0, A0, -1
9D014DCC  2C42FFFE   SLTIU V0, V0, -2
9D014DD0  10400040   BEQ V0, ZERO, 0x9D014ED4
9D014DD4  00000000   NOP
9D014DD8  10A0003E   BEQ A1, ZERO, 0x9D014ED4
9D014DDC  00000000   NOP
9D014DE0  8CA20008   LW V0, 8(A1)
9D014DE4  28420003   SLTI V0, V0, 3
9D014DE8  1440003A   BNE V0, ZERO, 0x9D014ED4
9D014DEC  00000000   NOP
9D014DF0  90820001   LBU V0, 1(A0)
9D014DF4  27BDFFD8   ADDIU SP, SP, -40
9D014DF8  AFB1001C   SW S1, 28(SP)
9D014DFC  AFBF0024   SW RA, 36(SP)
9D014E00  AFB20020   SW S2, 32(SP)
9D014E04  1040001F   BEQ V0, ZERO, DRV_USBFS_DEVICE_IRPCancel::OSAL_MUTEX_Lock
9D014E08  00808825   OR S1, A0, ZERO
9D014E0C  00009025   OR S2, ZERO, ZERO
9D014E10  8CA3001C   LW V1, 28(A1)
9D014E14  2404FFFE   ADDIU A0, ZERO, -2
9D014E18  ACA40008   SW A0, 8(A1)
9D014E1C  1060000C   BEQ V1, ZERO, 0x9D014E50
9D014E20  ACA00004   SW ZERO, 4(A1)
9D014E24  8CA20018   LW V0, 24(A1)
9D014E28  AC620018   SW V0, 24(V1)
9D014E2C  8CA40018   LW A0, 24(A1)
9D014E30  54800001   BNEL A0, ZERO, 0x9D014E38
9D014E34  AC83001C   SW V1, 28(A0)
9D014E38  8CA3000C   LW V1, 12(A1)
9D014E3C  ACA0001C   SW ZERO, 28(A1)
9D014E40  10600003   BEQ V1, ZERO, 0x9D014E50
9D014E44  ACA00018   SW ZERO, 24(A1)
9D014E48  0060F809   JALR V1
9D014E4C  00A02025   OR A0, A1, ZERO
9D014E50  92230001   LBU V1, 1(S1)
9D014E54  1460000F   BNE V1, ZERO, 0x9D014E94
9D014E58  00001025   OR V0, ZERO, ZERO
9D014E5C  16400012   BNE S2, ZERO, 0x9D014EA8
9D014E60  00000000   NOP
9D014E64  24020001   ADDIU V0, ZERO, 1
9D014E6C  8FBF0024   LW RA, 36(SP)
9D014E74  8FB20020   LW S2, 32(SP)
9D014E78  8FB1001C   LW S1, 28(SP)
9D014E7C  03E00008   JR RA
9D014E80  27BD0028   ADDIU SP, SP, 40
9D014E84  90840030   LBU A0, 48(A0)
9D014E94  8FBF0024   LW RA, 36(SP)
9D014EA0  03E00008   JR RA
9D014EA4  27BD0028   ADDIU SP, SP, 40
9D014EA8  0F406307   JAL EVIC_SourceEnable
9D014EAC  8E240028   LW A0, 40(S1)
9D014EB8  8E240028   LW A0, 40(S1)
9D014EC0  0F406033   JAL SYS_INT_SourceDisable
9D014EC4  AFA50010   SW A1, 16(SP)
9D014EC8  00409025   OR S2, V0, ZERO
9D014ECC  1000FFD0   BEQ ZERO, ZERO, 0x9D014E10
9D014ED0  8FA50010   LW A1, 16(SP)
9D014ED4  03E00008   JR RA
9D014ED8  2402FF83   ADDIU V0, ZERO, -125
9D0159DC  8CA80010   LW T0, 16(A1)
9D0159E0  8CCA0020   LW T2, 32(A2)
9D0159E4  8CC30004   LW V1, 4(A2)
9D0159E8  000810C0   SLL V0, T0, 3
9D0159EC  240B0001   ADDIU T3, ZERO, 1
9D0159F0  00822021   ADDU A0, A0, V0
9D0159F4  006A4823   SUBU T1, V1, T2
9D0159F8  10EB0015   BEQ A3, T3, 0x9D015A50
9D0159FC  8CC20000   LW V0, 0(A2)
9D015A00  94A60004   LHU A2, 4(A1)
9D015A04  004A1021   ADDU V0, V0, T2
9D015A08  7C42E000   EXT V0, V0, 0, 29
9D015A0C  0126182B   SLTU V1, T1, A2
9D015A10  00C3480A   MOVZ T1, A2, V1
9D015A14  8CA6000C   LW A2, 12(A1)
9D015A18  AC820004   SW V0, 4(A0)
9D015A1C  00001025   OR V0, ZERO, ZERO
9D015A20  00063980   SLL A3, A2, 6
9D015A24  00471025   OR V0, V0, A3
9D015A28  2407FF80   ADDIU A3, ZERO, -128
9D015A2C  3123FFFF   ANDI V1, T1, -1
9D015A30  39080001   XORI T0, T0, 1
9D015A34  00471025   OR V0, V0, A3
9D015A38  38C60001   XORI A2, A2, 1
9D015A3C  A4830002   SH V1, 2(A0)
9D015A40  A0820000   SB V0, 0(A0)
9D015A44  ACA80010   SW T0, 16(A1)
9D015A48  03E00008   JR RA
9D015A4C  ACA6000C   SW A2, 12(A1)
9D015A50  00491821   ADDU V1, V0, T1
9D015A54  7C63E000   EXT V1, V1, 0, 29
9D015A58  AC830004   SW V1, 4(A0)
9D015A5C  1540000F   BNE T2, ZERO, 0x9D015A9C
9D015A60  00001825   OR V1, ZERO, ZERO
9D015A64  ACCA0020   SW T2, 32(A2)
9D015A68  24020008   ADDIU V0, ZERO, 8
9D015A6C  8CA6000C   LW A2, 12(A1)
9D015A70  39080001   XORI T0, T0, 1
9D015A74  A4830002   SH V1, 2(A0)
9D015A78  00063980   SLL A3, A2, 6
9D015A7C  00471025   OR V0, V0, A3
9D015A80  2407FF80   ADDIU A3, ZERO, -128
9D015A84  00471025   OR V0, V0, A3
9D015A88  38C60001   XORI A2, A2, 1
9D015A8C  A0820000   SB V0, 0(A0)
9D015A90  ACA80010   SW T0, 16(A1)
9D015A94  03E00008   JR RA
9D015A98  ACA6000C   SW A2, 12(A1)
9D015A9C  94A30004   LHU V1, 4(A1)
9D015AA0  0143102B   SLTU V0, T2, V1
9D015AA4  0142180B   MOVN V1, T2, V0
9D015AA8  00601025   OR V0, V1, ZERO
9D015AAC  01425023   SUBU T2, T2, V0
9D015AB0  3063FFFF   ANDI V1, V1, -1
9D015AB4  ACCA0020   SW T2, 32(A2)
9D015AB8  1000FFEC   BEQ ZERO, ZERO, 0x9D015A6C
9D015ABC  24020008   ADDIU V0, ZERO, 8
9D017660  2482FFFF   ADDIU V0, A0, -1
9D017664  2C42FFFE   SLTIU V0, V0, -2
9D017668  1040001A   BEQ V0, ZERO, DRV_USBFS_DEVICE_Detach
9D01766C  240500FF   ADDIU A1, ZERO, 255
9D017670  8C820020   LW V0, 32(A0)
9D017674  A0800003   SB ZERO, 3(A0)
9D017678  AC4501C0   SW A1, 448(V0)
9D01767C  8C4301D0   LW V1, 464(V0)
9D01768C  AC4501E0   SW A1, 480(V0)
9D017690  8C4301F0   LW V1, 496(V0)
9D01769C  240300F5   ADDIU V1, ZERO, 245
9D0176A4  8C430010   LW V1, 16(V0)
9D0176B0  90430210   LBU V1, 528(V0)
9D0176D4  03E00008   JR RA
9D0178BC  2482FFFF   ADDIU V0, A0, -1
9D0178C0  2C42FFFE   SLTIU V0, V0, -2
9D0178C4  10400016   BEQ V0, ZERO, DRV_USBFS_DEVICE_Attach
9D0178C8  24030001   ADDIU V1, ZERO, 1
9D0178CC  8C820020   LW V0, 32(A0)
9D0178D0  A0830003   SB V1, 3(A0)
9D0178D4  90430210   LBU V1, 528(V0)
9D017908  240300DF   ADDIU V1, ZERO, 223
9D017920  03E00008   JR RA
9D017924  00000000   NOP
9D01802C  2483FFFF   ADDIU V1, A0, -1
9D018030  2C63FFFE   SLTIU V1, V1, -2
9D018034  1060000F   BEQ V1, ZERO, 0x9D018074
9D018038  00001025   OR V0, ZERO, ZERO
9D01803C  30A3000C   ANDI V1, A1, 12
9D018040  1460000C   BNE V1, ZERO, 0x9D018074
9D018044  30A6000F   ANDI A2, A1, 15
9D018048  8C820034   LW V0, 52(A0)
9D01804C  00061840   SLL V1, A2, 1
9D018050  00661821   ADDU V1, V1, A2
9D018054  000529C2   SRL A1, A1, 7
9D018058  00031900   SLL V1, V1, 4
9D01805C  24040018   ADDIU A0, ZERO, 24
9D018060  00431021   ADDU V0, V0, V1
9D018064  0005200A   MOVZ A0, ZERO, A1
9D018068  00442821   ADDU A1, V0, A0
9D01806C  8CA20014   LW V0, 20(A1)
9D018070  30420001   ANDI V0, V0, 1
9D018074  03E00008   JR RA
9D018078  00000000   NOP
9D01807C  2483FFFF   ADDIU V1, A0, -1
9D018080  2C63FFFE   SLTIU V1, V1, -2
9D018084  1060000F   BEQ V1, ZERO, 0x9D0180C4
9D018088  00001025   OR V0, ZERO, ZERO
9D01808C  30A3000C   ANDI V1, A1, 12
9D018090  1460000C   BNE V1, ZERO, 0x9D0180C4
9D018094  30A6000F   ANDI A2, A1, 15
9D018098  8C820034   LW V0, 52(A0)
9D01809C  00061840   SLL V1, A2, 1
9D0180A0  00661821   ADDU V1, V1, A2
9D0180A4  000529C2   SRL A1, A1, 7
9D0180A8  00031900   SLL V1, V1, 4
9D0180AC  24040018   ADDIU A0, ZERO, 24
9D0180B0  00431021   ADDU V0, V0, V1
9D0180B4  0005200A   MOVZ A0, ZERO, A1
9D0180B8  00442821   ADDU A1, V0, A0
9D0180BC  8CA20014   LW V0, 20(A1)
9D0180C0  7C420040   EXT V0, V0, 1, 1
9D0180C4  03E00008   JR RA
9D0180C8  00000000   NOP
9D018980  2483FFFF   ADDIU V1, A0, -1
9D018984  2C63FFFE   SLTIU V1, V1, -2
9D018988  10600007   BEQ V1, ZERO, DRV_USBFS_DEVICE_SOFNumberGet
9D01898C  00001025   OR V0, ZERO, ZERO
9D018990  8C830020   LW V1, 32(A0)
9D0189A8  03E00008   JR RA
9D0189AC  00000000   NOP
9D018B7C  2482FFFF   ADDIU V0, A0, -1
9D018B80  2C42FFFE   SLTIU V0, V0, -2
9D018B84  10400005   BEQ V0, ZERO, 0x9D018B9C
9D018B88  00000000   NOP
9D018B8C  8C820020   LW V0, 32(A0)
9D018B9C  03E00008   JR RA
9D018BA4  2482FFFF   ADDIU V0, A0, -1
9D018BA8  2C42FFFE   SLTIU V0, V0, -2
9D018BAC  10400005   BEQ V0, ZERO, DRV_USBFS_DEVICE_RemoteWakeupStart
9D018BB0  00000000   NOP
9D018BB4  8C830020   LW V1, 32(A0)
9D018BC4  03E00008   JR RA
9D018BC8  00000000   NOP
9D018BCC  2482FFFF   ADDIU V0, A0, -1
9D018BD0  2C42FFFE   SLTIU V0, V0, -2
9D018BD4  10400005   BEQ V0, ZERO, DRV_USBFS_DEVICE_RemoteWakeupStop
9D018BD8  00000000   NOP
9D018BDC  8C830020   LW V1, 32(A0)
9D018BEC  03E00008   JR RA
9D018BF4  8C820020   LW V0, 32(A0)
9D018BFC  A4800002   SH ZERO, 2(A0)
9D018C00  A0800004   SB ZERO, 4(A0)
9D018C04  AC4301D0   SW V1, 464(V0)
9D018C14  03E00008   JR RA
---  c:/users/db/desktop/nano_tx/firmware/src/config/default/driver/usb/usbfs/src/drv_usbfs.c  ----------
1:                   /*******************************************************************************
2:                     USB Controller Driver Core Routines.
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_usbfs.c
9:                   
10:                    Summary:
11:                      USB Controller Driver Core Routines intended for Dynamic implementation.
12:                  
13:                    Description:
14:                      The USB Controller driver provides a simple interface to manage the USB
15:                      modules on Microchip microcontrollers.  This file Implements the core
16:                      interface routines to be used both by the client(USB Host or Device layer)
17:                      and the system for communicating with USB Contoller driver.  While building
18:                      the driver from source, ALWAYS use this file in the build.
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute Software
26:                  only when embedded on a Microchip microcontroller or digital  signal  controller
27:                  that is integrated into your product or third party  product  (pursuant  to  the
28:                  sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS  WITHOUT  WARRANTY  OF  ANY  KIND,
34:                  EITHER EXPRESS  OR  IMPLIED,  INCLUDING  WITHOUT  LIMITATION,  ANY  WARRANTY  OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A  PARTICULAR  PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR  ITS  LICENSORS  BE  LIABLE  OR  OBLIGATED  UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,  BREACH  OF  WARRANTY,  OR
38:                  OTHER LEGAL  EQUITABLE  THEORY  ANY  DIRECT  OR  INDIRECT  DAMAGES  OR  EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY  INCIDENTAL,  SPECIAL,  INDIRECT,  PUNITIVE  OR
40:                  CONSEQUENTIAL DAMAGES, LOST  PROFITS  OR  LOST  DATA,  COST  OF  PROCUREMENT  OF
41:                  SUBSTITUTE  GOODS,  TECHNOLOGY,  SERVICES,  OR  ANY  CLAIMS  BY  THIRD   PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  THEREOF),  OR  OTHER  SIMILAR  COSTS.
43:                  *******************************************************************************/
44:                  //DOM-IGNORE-END
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Include Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include "configuration.h"
53:                  #include "driver/usb/usbfs/src/drv_usbfs_local.h"
54:                  
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  // Section: Global Data
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  
61:                  /******************************************************
62:                   * Hardware instance, endpoint table and client object
63:                   * lumped together as group to save memory.
64:                   ******************************************************/
65:                  DRV_USBFS_GROUP gDrvUSBGroup[DRV_USBFS_INSTANCES_NUMBER];
66:                  
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  // Section: USB Controller Driver Interface Implementations
70:                  // *****************************************************************************
71:                  // *****************************************************************************
72:                  
73:                  // *****************************************************************************
74:                  /* Function:
75:                      SYS_MODULE_OBJ DRV_USBFS_Initialize
76:                      ( 
77:                          const SYS_MODULE_INDEX index,
78:                          const SYS_MODULE_INIT * const init
79:                      )
80:                  
81:                    Summary:
82:                      Initializes the USB Driver.
83:                     
84:                    Description:
85:                      This function initializes the USB Driver, making it ready for clients to
86:                      open. The driver initialization does not complete when this function
87:                      returns. The DRV_USBFS_Tasks function must called periodically to complete
88:                      the driver initialization. The DRV_USBHS_Open function will fail if the
89:                      driver was not initialized or if initialization has not completed.
90:                    
91:                    Remarks:
92:                      See drv_usbfs.h for usage information.
93:                  */
94:                  
95:                  SYS_MODULE_OBJ DRV_USBFS_Initialize 
96:                  (
97:                      const SYS_MODULE_INDEX  drvIndex,
98:                      const SYS_MODULE_INIT * const init
99:                  )
100:                 {
101:                     DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)NULL;
102:                     USB_MODULE_ID usbID = USB_NUMBER_OF_MODULES;
103:                     DRV_USBFS_INIT * pusbInit = (DRV_USBFS_INIT *)NULL;
104:                     SYS_MODULE_OBJ returnValue = SYS_MODULE_OBJ_INVALID;
105:                 
106:                     if(drvIndex < DRV_USBFS_INSTANCES_NUMBER)
107:                     {
108:                         /* Driver index is valid */
109:                         if(gDrvUSBGroup[drvIndex].gDrvUSBObj.inUse == false)
110:                         {
111:                             /* Driver object is available. Grab the particular USB instance
112:                              * object*/
113:                             gDrvUSBGroup[drvIndex].gDrvUSBObj.inUse = true;
114:                 
115:                             /* Assign to the local pointer the init data passed */
116:                             pusbInit = (DRV_USBFS_INIT *) init;
117:                             usbID = pusbInit->usbID;
118:                             pUSBDrvObj = &gDrvUSBGroup[drvIndex].gDrvUSBObj;
119:                 
120:                             /* If this being built in an OS application, then create a mutex */
121:                             if(OSAL_MUTEX_Create(&pUSBDrvObj->mutexID) == OSAL_RESULT_TRUE)
122:                             {
123:                                 /* Populate the driver instance object with required data */
124:                                 pUSBDrvObj->status = SYS_STATUS_BUSY;
125:                                 pUSBDrvObj->usbID = usbID;
126:                                 pUSBDrvObj->operationMode = pusbInit->operationMode;
127:                                 pUSBDrvObj->pBDT = (DRV_USBFS_BDT_ENTRY *)(pusbInit->endpointTable);
128:                                 pUSBDrvObj->isOpened = false;
129:                                 pUSBDrvObj->pEventCallBack = NULL;
130:                 
131:                                 /* Assign the endpoint table */
132:                                 pUSBDrvObj->endpointTable = &gDrvUSBGroup[drvIndex].gDrvUSBEndpoints[0];
133:                                 pUSBDrvObj->interruptSource  = pusbInit->interruptSource;
134:                 
135:                                 /* Enable USB module(U1PWRC<0>). This internally does the following:
136:                                  * - Start the USB clock
137:                                  * - Allow the USB interrupt to be activated
138:                                  * - Select USB as the owner of the necessary I/O pins
139:                                  * - Enable the USB transceiver
140:                                  * - Enable the USB comparators */
141:                 
142:                                 PLIB_USB_Enable(usbID);
143:                 
144:                                 /* Setup the Hardware */
145:                                 if(pusbInit->stopInIdle)
146:                                 {
147:                                     PLIB_USB_StopInIdleEnable( usbID );
148:                                 }
149:                                 else
150:                                 {
151:                                     PLIB_USB_StopInIdleDisable( usbID );
152:                                 }
153:                 
154:                 #ifdef PLIB_USB_ExistsAutomaticSuspend
155:                                 if(PLIB_USB_ExistsAutomaticSuspend(usbID))
156:                                 {
157:                                     if(pusbInit->suspendInSleep)
158:                                     {
159:                                         PLIB_USB_AutoSuspendEnable( usbID );
160:                                     }
161:                                     else
162:                                     {
163:                                         PLIB_USB_AutoSuspendDisable( usbID );
164:                                     }
165:                                 }
166:                 #endif
167:                                 /* Setup the USB Module as per selected mode */
168:                                 switch(pusbInit->operationMode)
169:                                 {
170:                                     case DRV_USBFS_OPMODE_DEVICE:
171:                 
172:                                         /* Initialize USB Controller for Device mode */
173:                                         _DRV_USBFS_DEVICE_INIT(pUSBDrvObj, drvIndex);
174:                                         break;
175:                 
176:                                     case DRV_USBFS_OPMODE_HOST:
177:                 
178:                                         /* Initialize USB Controller for Host mode */
179:                                         _DRV_USBFS_HOST_INIT(pUSBDrvObj, drvIndex, pusbInit);
180:                                         break;
181:                 
182:                                     case DRV_USBFS_OPMODE_OTG:
183:                                         /* Not implemented at this point of time*/
184:                                         break;
185:                 
186:                                     default:
187:                                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: What mode are you trying?");
188:                                         break;
189:                                 }
190:                 
191:                                 /* Assign the BDT table base address */
192:                                 PLIB_USB_BDTBaseAddressSet(usbID , (void *)((uint32_t)KVA_TO_PA(pUSBDrvObj->pBDT)));    
193:                 
194:                                 /* Indicate that the object is ready and in use and return the driver
195:                                  * handle */
196:                 
197:                                 pUSBDrvObj->status = SYS_STATUS_READY;
198:                                 returnValue = drvIndex;
199:                             }
200:                             else
201:                             {
202:                                 /* Could not create mutex. Return the object. */
203:                                 gDrvUSBGroup[drvIndex].gDrvUSBObj.inUse = false;
204:                                 SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Mutex create failed");
205:                             } 
206:                         }
207:                         else
208:                         {
209:                             /* Cannot initialize an object that is already in use. */
210:                             SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Hardware Instance already in use");
211:                         }
212:                     }
213:                     else
214:                     {
215:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Invalid driver index");
216:                     }
217:                 
218:                     return (returnValue);
219:                 }
220:                 
221:                 // *****************************************************************************
222:                 /* Function:
223:                     void DRV_USBFS_Deinitialize( const SYS_MODULE_OBJ object )
224:                 
225:                   Summary:
226:                     This function deinitializes the USBFS driver instance. 
227:                 
228:                   Description:
229:                     This function deinitializes the USBFS driver instance. 
230:                 
231:                   Remarks:
232:                     A typicall USB application may not to called this function.
233:                 */
234:                 
235:                 void DRV_USBFS_Deinitialize
236:                 ( 
237:                     const SYS_MODULE_OBJ  object
238:                 )
239:                 {
240:                     DRV_USBFS_OBJ * pUSBDrvObj = NULL;
241:                 
242:                     if((object != SYS_MODULE_OBJ_INVALID) && (object < DRV_USBFS_INSTANCES_NUMBER))
243:                     {
244:                         /* Object is valid */
245:                         if(gDrvUSBGroup[object].gDrvUSBObj.inUse == true)
246:                         {
247:                             pUSBDrvObj = &gDrvUSBGroup[object].gDrvUSBObj;
248:                 
249:                             /* Release the USB instance object */
250:                             pUSBDrvObj->inUse = false;
251:                 
252:                             /* Reset the open flag */
253:                             pUSBDrvObj->isOpened = false;
254:                 
255:                             /* Delete the mutex */
256:                             OSAL_MUTEX_Delete(&pUSBDrvObj->mutexID);
257:                 
258:                             /* Uninitialize the status*/
259:                             pUSBDrvObj->status = SYS_STATUS_UNINITIALIZED;
260:                 
261:                             pUSBDrvObj->pEventCallBack = NULL;
262:                 
263:                             /* Clear and disable the interrupts */
264:                             _DRV_USBFS_InterruptSourceDisable(pUSBDrvObj->interruptSource);
265:                             _DRV_USBFS_InterruptSourceClear(pUSBDrvObj->interruptSource);
266:                 
267:                             /* Turn off USB module */
268:                             PLIB_USB_Disable(pUSBDrvObj->usbID);
269:                         }
270:                         else
271:                         {
272:                             /* Cannot deinitialize an object that is not in use. */
273:                             SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Instance not in use");
274:                         }
275:                     }
276:                     else
277:                     {
278:                         /* Invalid object */
279:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Invalid System Module Object");
280:                     }
281:                 } 
282:                 
283:                 // *****************************************************************************
284:                 /* Function:
285:                     SYS_STATUS DRV_USBFS_Status( const SYS_MODULE_OBJ object )
286:                 
287:                   Summary:
288:                     Provides the current status of the USB Driver module.
289:                 
290:                   Description:
291:                     This function provides the current status of the USB Driver module.
292:                 
293:                   Remarks:
294:                     See drv_usbfs.h for usage information.
295:                 */
296:                 
297:                 SYS_STATUS DRV_USBFS_Status
298:                 (
299:                     const SYS_MODULE_OBJ object
300:                 )
301:                 {
302:                     SYS_STATUS returnValue = SYS_STATUS_UNINITIALIZED;
303:                 
304:                     /* Check if USB instance object is valid */
305:                     if((object != SYS_MODULE_OBJ_INVALID) || (object < DRV_USBFS_INSTANCES_NUMBER))
306:                     {
307:                         returnValue = gDrvUSBGroup[object].gDrvUSBObj.status;
308:                     }
309:                     else
310:                     {
311:                         /* Invalid object */
312:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Invalid object");
313:                     }
314:                 
315:                     /* Return the status of the driver object */
316:                     return returnValue;
317:                 }
318:                 
319:                 // *****************************************************************************
320:                 /* Function:
321:                     DRV_HANDLE DRV_USBFS_Open
322:                     (
323:                         const SYS_MODULE_INDEX drvIndex,
324:                         const DRV_IO_INTENT ioIntent 
325:                     )
326:                 
327:                   Summary:
328:                     Opens the specified USB Driver instance and returns a handle to it.
329:                    
330:                   Description:
331:                     This function opens the specified USB Driver instance and provides a handle
332:                     that must be provided to all other client-level operations to identify the
333:                     caller and the instance of the driver. The intent flag is ignored.  Any
334:                     other setting of the intent flag will return a invalid driver handle. A
335:                     driver instance can only support one client. Trying to open a driver that
336:                     has an existing client will result in an unsuccessful function call.
337:                 
338:                   Remarks:
339:                     See drv_usbfs.h for usage information.
340:                 */
341:                 
342:                 DRV_HANDLE DRV_USBFS_Open
343:                 (
344:                     const SYS_MODULE_INDEX drvIndex,
345:                     const DRV_IO_INTENT ioIntent 
346:                 )
347:                 {
348:                     DRV_HANDLE handle = DRV_HANDLE_INVALID;
349:                 
350:                     /* Check if the specified driver index is in valid range */
351:                     if(drvIndex < DRV_USBFS_INSTANCES_NUMBER)
352:                     {
353:                         if(gDrvUSBGroup[drvIndex].gDrvUSBObj.status == SYS_STATUS_READY)
354:                         {
355:                             if(gDrvUSBGroup[drvIndex].gDrvUSBObj.isOpened == false)
356:                             {
357:                                 gDrvUSBGroup[drvIndex].gDrvUSBObj.isOpened = true;
358:                                 
359:                                 /* Handle is the pointer to the client object */
360:                                 handle = ((DRV_HANDLE)&(gDrvUSBGroup[drvIndex].gDrvUSBObj));
361:                             }
362:                             else
363:                             {
364:                                 /* Driver supports exclusive open only */
365:                                 SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver already opened once. Cannot open again");
366:                             }
367:                         }
368:                         else
369:                         {
370:                             /* The USB module should be ready */
371:                             SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Was the driver initialized?");
372:                         }
373:                     }
374:                     else
375:                     {
376:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Driver Index");
377:                     }
378:                 
379:                     /* Return invalid handle */
380:                     return handle;
381:                 }
382:                 
383:                 // *****************************************************************************
384:                 /* Function:
385:                     void DRV_USBFS_Close( DRV_HANDLE client )
386:                 
387:                   Summary:
388:                     Closes an opened-instance of the  USB Driver.
389:                 
390:                   Description:
391:                     This function closes an opened-instance of the  USB Driver, invalidating the
392:                     handle.
393:                 
394:                   Remarks:
395:                     See drv_usbfs.h for usage information.
396:                 */
397:                 
398:                 void DRV_USBFS_Close
399:                 (
400:                     DRV_HANDLE handle
401:                 )
402:                 {
403:                     DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)NULL;
404:                 
405:                     /* Check if the handle is valid */
406:                     if((handle != DRV_HANDLE_INVALID) && (handle != (DRV_HANDLE)(NULL)))
407:                     {
408:                         /* Reset the relevant parameters */
409:                         pUSBDrvObj = (DRV_USBFS_OBJ *)handle;
410:                         if(pUSBDrvObj->isOpened)
411:                         {
412:                             pUSBDrvObj->isOpened = false;
413:                             pUSBDrvObj->pEventCallBack = NULL;
414:                         }
415:                         else
416:                         {
417:                             SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Client Handle already closed");
418:                         }
419:                     }
420:                     else
421:                     {
422:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client Handle");
423:                     }
424:                 }
425:                 
426:                 // *****************************************************************************
427:                 /* Function:
428:                     DRV_HANDLE DRV_USBFS_Tasks_ISR( SYS_MODULE_OBJ object )
429:                 
430:                   Summary:
431:                     Maintains the driver's Interrupt state machine and implements its ISR.
432:                 
433:                   Description:
434:                     This function is used to maintain the driver's internal Interrupt state
435:                     machine and implement its ISR for interrupt-driven implementations.
436:                 
437:                   Remarks:
438:                     See drv_usbfs.h for usage information.
439:                 */
440:                 
441:                 void DRV_USBFS_Tasks_ISR
442:                 (
443:                     SYS_MODULE_OBJ object
444:                 )
445:                 {
446:                     DRV_USBFS_OBJ * pUSBDriver = (DRV_USBFS_OBJ *)NULL;
447:                 
448:                     pUSBDriver = &gDrvUSBGroup[object].gDrvUSBObj;
449:                 
450:                     /* We are entering an interrupt context */
451:                     pUSBDriver->inInterruptContext = true;
452:                 
453:                     /* Clear the interrupt */
454:                     _DRV_USBFS_InterruptSourceClear(pUSBDriver->interruptSource);
455:                    
456:                     switch(pUSBDriver->operationMode)
457:                     {
458:                         case DRV_USBFS_OPMODE_DEVICE:
459:                             
460:                             /* Driver is running in Device Mode */
461:                             _DRV_USBFS_DEVICE_TASKS_ISR(pUSBDriver);
462:                             break;
463:                         
464:                         case DRV_USBFS_OPMODE_HOST:
465:                 
466:                             /* Driver is running in Host Mode */
467:                             _DRV_USBFS_HOST_TASKS_ISR(pUSBDriver);
468:                             break;
469:                 
470:                         case DRV_USBFS_OPMODE_OTG:
471:                             /* OTG mode is not supported yet */
472:                             break;
473:                 
474:                         default:
475:                             SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: What mode are you trying?");
476:                             break;
477:                     }
478:                   
479:                     pUSBDriver->inInterruptContext = false;
480:                 }
481:                 
482:                 // *****************************************************************************
483:                 /* Function:
484:                     void DRV_USBFS_ClientEventCallBackSet
485:                     (
486:                         DRV_HANDLE handle,
487:                         uintptr_t hReferenceData,
488:                         DRV_USBFS_EVENT_CALLBACK eventCallBack
489:                     )
490:                 
491:                   Summary:
492:                     This function sets up the event callback function that is invoked by the USB
493:                     controller driver to notify the client of USB bus events.
494:                    
495:                   Description:
496:                     This function sets up the event callback function that is invoked by the USB
497:                     controller driver to notify the client of USB bus events. The callback is
498:                     disabled by either not calling this function after the DRV_USBFS_Open
499:                     function has been called or by setting the myEventCallBack argument as NULL.
500:                     When the callback function is called, the hReferenceData argument is
501:                     returned.
502:                 
503:                   Remarks:
504:                     See drv_usbfs.h for usage information.
505:                 */
506:                 
507:                 void DRV_USBFS_ClientEventCallBackSet
508:                 ( 
509:                     DRV_HANDLE handle,
510:                     uintptr_t hReferenceData,
511:                     DRV_USB_EVENT_CALLBACK eventCallBack 
512:                 )
513:                 {
514:                     DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)handle;
515:                     
516:                     /* Check if the handle is valid or opened */
517:                     if((handle != DRV_HANDLE_INVALID) && (handle != (DRV_HANDLE)(NULL)) && (pUSBDrvObj->isOpened == true))
518:                     {
519:                         /* Assign event call back and reference data */
520:                         pUSBDrvObj->hClientArg = hReferenceData;
521:                         pUSBDrvObj->pEventCallBack = eventCallBack;
522:                 
523:                         /* If the driver is operating in device mode, this is the time we enable
524:                          * the USB interrupt */
525:                 
526:                         if(pUSBDrvObj->operationMode == USB_OPMODE_DEVICE)
527:                         {
528:                             /* Enable the session valid interrupt */
529:                             PLIB_USB_OTG_InterruptEnable(pUSBDrvObj->usbID, USB_OTG_INT_SESSION_VALID);
530:                             
531:                             /* Enable the interrupt */
532:                             _DRV_USBFS_InterruptSourceEnable(pUSBDrvObj->interruptSource);
533:                         }
534:                     }
535:                     else
536:                     {
537:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client or client closed");
538:                     }
539:                 } 
540:                 
541:                 // *****************************************************************************
542:                 /* Function:
543:                     void DRV_USBFS_Tasks( SYS_MODULE_OBJ object )
544:                 
545:                   Summary:
546:                     Maintains the driver's state machine when the driver is configured for 
547:                     polled mode.
548:                 
549:                   Description:
550:                     Maintains the driver's state machine when the driver is configured for 
551:                     polled mode. This function should be called from the system tasks routine.
552:                 
553:                   Remarks:
554:                     Refer to drv_usbfs.h for usage information.
555:                 */
556:                 
557:                 void DRV_USBFS_Tasks(SYS_MODULE_OBJ object)
558:                 {
559:                     /* This driver does not have any non interrupt tasks. When the driver
560:                      * is configured for polled mode operation, the _DRV_USBFS_Tasks_ISR function
561:                      * will map to DRV_USBFS_Tasks_ISR function. In interrupt mode, this function
562:                      * will be mapped to nothing and hence this function will not have any
563:                      * effect. */
564:                 
565:                     _DRV_USBFS_Tasks_ISR(object);
566:                 }
567:                 
568:                 void DRV_USBFS_Tasks_ISR_USBDMA( SYS_MODULE_OBJ object )
569:                 {
570:                     /* This function is implemented to only maintain compatibility with the
571:                      * PIC32MZ High Speed USB Driver. This function does not do anything on the
572:                      * PIC32MX USB driver and is not required to be called in a PIC32MX USB
573:                      * applicaiton */
574:                 }
575:                 
576:                 // *****************************************************************************
577:                 /* Function:
578:                     void DRV_USBFS_USB_Handler(void)
579:                 
580:                   Summary:
581:                     USBFS Interrupt Handler 
582:                 	
583:                   Description:
584:                     This is USBFS Interrupt Handler 
585:                 
586:                   Remarks:
587:                 	None 
588:                 */
589:                 
590:                 void DRV_USBFS_USB_Handler(void)
591:                 {
592:                 	DRV_USBFS_Tasks_ISR(sysObj.drvUSBFSObject); 
593:                 }
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000018  00000000   NOP
00000020  00000000   NOP
00000024  00000000   NOP
00000028  00000000   NOP
0000002C  00000000   NOP
00000030  00000000   NOP
00000034  00000000   NOP
00000038  00000000   NOP
0000003C  00000000   NOP
00000040  00000000   NOP
00000048  00000000   NOP
00000050  00000000   NOP
00000054  00000000   NOP
00000060  00000000   NOP
0000006C  00000000   NOP
9D00B398  0B4059FF   J DRV_USBFS_Tasks_ISR
9D00B39C  8F84802C   LW A0, -32724(GP)
9D013DCC  1480003E   BNE A0, ZERO, 0x9D013EC8
9D013DD0  00000000   NOP
9D013DD4  3C04A000   LUI A0, -24576
9D013DD8  90822880   LBU V0, 10368(A0)
9D013DDC  1440003A   BNE V0, ZERO, 0x9D013EC8
9D013DE0  00000000   NOP
9D013DE4  27BDFFE0   ADDIU SP, SP, -32
9D013DE8  AFB10018   SW S1, 24(SP)
9D013DEC  8CB10004   LW S1, 4(A1)
9D013DF0  24020001   ADDIU V0, ZERO, 1
9D013DF4  AFB00014   SW S0, 20(SP)
9D013E04  8CA9000C   LW T1, 12(A1)
9D013E08  90A80008   LBU T0, 8(A1)
9D013E0C  8CA60014   LW A2, 20(A1)
9D013E10  8CAA0018   LW T2, 24(A1)
9D013E14  24030001   ADDIU V1, ZERO, 1
9D013E1C  A0822880   SB V0, 10368(A0)
9D013E20  3C02A000   LUI V0, -24576
9D013E24  244228B8   ADDIU V0, V0, 10424
9D013E28  AFBF001C   SW RA, 28(SP)
9D013E30  AE020034   SW V0, 52(S0)
9D013E34  AE030014   SW V1, 20(S0)
9D013E38  AE110020   SW S1, 32(S0)
9D013E3C  AE060024   SW A2, 36(S0)
9D013E40  AE0A002C   SW T2, 44(S0)
9D013E44  A2000005   SB ZERO, 5(S0)
9D013E48  AE000010   SW ZERO, 16(S0)
9D013E4C  AE090028   SW T1, 40(S0)
9D013E50  922202A0   LBU V0, 672(S1)
9D013E54  5100001E   BEQL T0, ZERO, DRV_USBFS_Initialize::PLIB_USB_StopInIdleDisable
9D013E58  7C022104   INS V0, ZERO, 4, 1
9D013E5C  7C622104   INS V0, V1, 4, 1
9D013E64  90A20009   LBU V0, 9(A1)
9D013E70  AE2202A8   SW V0, 680(S1)
9D013E74  24020001   ADDIU V0, ZERO, 1
9D013E80  8E02002C   LW V0, 44(S0)
9D013E84  24030002   ADDIU V1, ZERO, 2
9D013E88  AE030014   SW V1, 20(S0)
9D013E8C  7C42E000   EXT V0, V0, 0, 29
9D013EA4  8FBF001C   LW RA, 28(SP)
9D013EB0  00001025   OR V0, ZERO, ZERO
9D013EB8  8FB00014   LW S0, 20(SP)
9D013EBC  8FB10018   LW S1, 24(SP)
9D013EC0  03E00008   JR RA
9D013EC4  27BD0020   ADDIU SP, SP, 32
9D013EC8  03E00008   JR RA
9D013ECC  2402FFFF   ADDIU V0, ZERO, -1
9D013ED0  A22202A0   SB V0, 672(S1)
9D013ED4  90A20009   LBU V0, 9(A1)
9D013EE0  AE2202A4   SW V0, 676(S1)
9D013EE4  1000FFE4   BEQ ZERO, ZERO, 0x9D013E78
9D013EE8  24020001   ADDIU V0, ZERO, 1
9D013EEC  0F4062FD   JAL _DRV_USBFS_DEVICE_Initialize
9D013EF0  24842880   ADDIU A0, A0, 10368
9D013EF4  1000FFE3   BEQ ZERO, ZERO, 0x9D013E84
9D013EF8  8E02002C   LW V0, 44(S0)
9D0167FC  27BDFFD8   ADDIU SP, SP, -40
9D016800  AFB2001C   SW S2, 28(SP)
9D016804  00049140   SLL S2, A0, 5
9D016808  AFB10018   SW S1, 24(SP)
9D01680C  AFB00014   SW S0, 20(SP)
9D016810  3C11A000   LUI S1, -24576
9D016814  02448023   SUBU S0, S2, A0
9D016818  26312880   ADDIU S1, S1, 10368
9D01681C  001080C0   SLL S0, S0, 3
9D016820  02308021   ADDU S0, S1, S0
9D016824  AFB30020   SW S3, 32(SP)
9D016828  00809825   OR S3, A0, ZERO
9D01682C  8E040028   LW A0, 40(S0)
9D016830  24020001   ADDIU V0, ZERO, 1
9D016834  AFBF0024   SW RA, 36(SP)
9D016838  0F40631B   JAL EVIC_SourceStatusClear
9D01683C  A2020001   SB V0, 1(S0)
9D016840  8E030024   LW V1, 36(S0)
9D016844  24020001   ADDIU V0, ZERO, 1
9D016848  1062000B   BEQ V1, V0, 0x9D016878
9D01684C  8FBF0024   LW RA, 36(SP)
9D016850  02539023   SUBU S2, S2, S3
9D016854  001290C0   SLL S2, S2, 3
9D016858  02328821   ADDU S1, S1, S2
9D01685C  A2200001   SB ZERO, 1(S1)
9D016860  8FB30020   LW S3, 32(SP)
9D016864  8FB2001C   LW S2, 28(SP)
9D016868  8FB10018   LW S1, 24(SP)
9D01686C  8FB00014   LW S0, 20(SP)
9D016870  03E00008   JR RA
9D016874  27BD0028   ADDIU SP, SP, 40
9D016878  0F403836   JAL _DRV_USBFS_DEVICE_Tasks_ISR
9D01687C  02002025   OR A0, S0, ZERO
9D016880  02539023   SUBU S2, S2, S3
9D016884  8FBF0024   LW RA, 36(SP)
9D016888  001290C0   SLL S2, S2, 3
9D01688C  02328821   ADDU S1, S1, S2
9D016890  A2200001   SB ZERO, 1(S1)
9D016894  8FB30020   LW S3, 32(SP)
9D016898  8FB2001C   LW S2, 28(SP)
9D01689C  8FB10018   LW S1, 24(SP)
9D0168A0  8FB00014   LW S0, 20(SP)
9D0168A4  03E00008   JR RA
9D0168A8  27BD0028   ADDIU SP, SP, 40
9D017F30  2482FFFF   ADDIU V0, A0, -1
9D017F34  2C42FFFE   SLTIU V0, V0, -2
9D017F38  10400009   BEQ V0, ZERO, 0x9D017F60
9D017F3C  00000000   NOP
9D017F40  90820005   LBU V0, 5(A0)
9D017F44  10400006   BEQ V0, ZERO, 0x9D017F60
9D017F48  00000000   NOP
9D017F4C  8C830024   LW V1, 36(A0)
9D017F50  24020001   ADDIU V0, ZERO, 1
9D017F54  AC85000C   SW A1, 12(A0)
9D017F58  10620003   BEQ V1, V0, DRV_USBFS_ClientEventCallBackSet::PLIB_USB_OTG_InterruptEnable
9D017F5C  AC860010   SW A2, 16(A0)
9D017F60  03E00008   JR RA
9D017F64  00000000   NOP
9D017F68  8C830020   LW V1, 32(A0)
9D017F6C  8C840028   LW A0, 40(A0)
9D017F7C  0B406307   J EVIC_SourceEnable
9D017F84  3C040000   LUI A0, 0
9D01820C  14800010   BNE A0, ZERO, 0x9D018250
9D018210  00000000   NOP
9D018214  3C03A000   LUI V1, -24576
9D018218  24632880   ADDIU V1, V1, 10368
9D01821C  8C650014   LW A1, 20(V1)
9D018220  24040002   ADDIU A0, ZERO, 2
9D018224  10A40003   BEQ A1, A0, 0x9D018234
9D018228  2402FFFF   ADDIU V0, ZERO, -1
9D01822C  03E00008   JR RA
9D018230  00000000   NOP
9D018234  90640005   LBU A0, 5(V1)
9D018238  1480FFFC   BNE A0, ZERO, 0x9D01822C
9D01823C  00000000   NOP
9D018240  24020001   ADDIU V0, ZERO, 1
9D018244  A0620005   SB V0, 5(V1)
9D018248  03E00008   JR RA
9D01824C  00601025   OR V0, V1, ZERO
9D018250  03E00008   JR RA
9D018254  2402FFFF   ADDIU V0, ZERO, -1
9D018AA0  2482FFFF   ADDIU V0, A0, -1
9D018AA4  2C42FFFE   SLTIU V0, V0, -2
9D018AA8  10400006   BEQ V0, ZERO, 0x9D018AC4
9D018AAC  00000000   NOP
9D018AB0  90820005   LBU V0, 5(A0)
9D018AB4  10400003   BEQ V0, ZERO, 0x9D018AC4
9D018AB8  00000000   NOP
9D018ABC  A0800005   SB ZERO, 5(A0)
9D018AC0  AC800010   SW ZERO, 16(A0)
9D018AC4  03E00008   JR RA
9D018AC8  00000000   NOP
---  c:/users/db/desktop/nano_tx/firmware/src/app_x1txo.c  ----------------------------------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       app_x1txo.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It
15:                      implements the logic of the application's state machine and it may call
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // *****************************************************************************
25:                  // *****************************************************************************
26:                  // Section: Included Files
27:                  // *****************************************************************************
28:                  // *****************************************************************************
29:                  
30:                  #include "app_x1txo.h"
31:                  #include "user_hal/debug.h"
32:                  #include "definitions.h"                // GPIO, UART
33:                  
34:                  // *****************************************************************************
35:                  // *****************************************************************************
36:                  // Section: Global Data Definitions
37:                  // *****************************************************************************
38:                  // *****************************************************************************
39:                  
40:                  extern bool taskBusy;
41:                  
42:                  // *****************************************************************************
43:                  /* Application Data
44:                  
45:                    Summary:
46:                      Holds application data
47:                  
48:                    Description:
49:                      This structure holds the application's data.
50:                  
51:                    Remarks:
52:                      This structure should be initialized by the APP_X1TXO_Initialize function.
53:                  
54:                      Application strings and buffers are be defined outside this structure.
55:                  */
56:                  
57:                  APP_X1TXO_DATA appX1txoData;
58:                  
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  // Section: Application Callback Functions
62:                  // *****************************************************************************
63:                  // *****************************************************************************
64:                  
65:                  /* TODO:  Add any necessary callback functions.
66:                  */
67:                  
68:                  // *****************************************************************************
69:                  // *****************************************************************************
70:                  // Section: Application Local Functions
71:                  // *****************************************************************************
72:                  // *****************************************************************************
73:                  
74:                  
75:                  void APP_X1TXO_setMode(X1TXO_MODE mode)
76:                  {
77:                      // Nothing to do if already in desired target mode
78:                      if (mode == appX1txoData.mode) {
79:                          return;
80:                      }
81:                      
82:                      // Transition from INIT to NORMAL requires intermediate mode START
83:                      if ((mode == X1TXO_MODE_NORMAL) && (appX1txoData.mode == X1TXO_MODE_INIT)) {
84:                          appX1txoData.modeStartPackets = 0;
85:                          appX1txoData.mode = X1TXO_MODE_START;
86:                          return;
87:                      }
88:                      
89:                      // Transition from other modes to NORMAL is immediate
90:                      if (mode == X1TXO_MODE_NORMAL) {
91:                          appX1txoData.mode = X1TXO_MODE_NORMAL;
92:                          return;
93:                      }
94:                      
95:                      // Transition to BIND is immediate
96:                      if (mode == X1TXO_MODE_BIND) {
97:                          appX1txoData.mode = X1TXO_MODE_BIND;
98:                          return;
99:                      }
100:                     
101:                     // Transition to INIT is immediate
102:                     if (mode == X1TXO_MODE_INIT) {
103:                         appX1txoData.mode = X1TXO_MODE_INIT;
104:                         return;
105:                     }
106:                 }
107:                 
108:                 /**
109:                  * Generates and, if appropriate, sends an X1TXO packet.
110:                  * Depending on the X1TXO mode, the packet sent contains RC channel data,
111:                  * receiver bind data.
112:                  * In idle modes, no data is sent.
113:                  */
114:                 void APP_X1TXO_Send(void)
115:                 {
116:                     uint8_t x1txoPacket[2 + 2 * X1TXO_CHANNELS];
117:                     uint16_t* ch = appX1txoData.ch;
118:                     
119:                     // Reset packet data to all zeroes
120:                     memset(x1txoPacket, 0, sizeof(x1txoPacket));
121:                     
122:                     if (appX1txoData.mode == X1TXO_MODE_START) {
123:                         // Bytes 0 and 1: bind / normal operation, otherwise unknown
124:                         x1txoPacket[0] = 0x18;
125:                         x1txoPacket[1] = 0x00;
126:                     
127:                         // Bytes 2 to 13: all zeroes for INIT, so nothing to do here
128:                         
129:                         // Count number of start packets
130:                         // Then switch to normal mode after sending all start packets
131:                         appX1txoData.modeStartPackets++;
132:                         if (appX1txoData.modeStartPackets >= X1TXO_START_PACKETS) {
133:                             appX1txoData.mode = X1TXO_MODE_NORMAL;
134:                             appX1txoData.modeStartPackets = 0;
135:                         }
136:                     } else if (appX1txoData.mode == X1TXO_MODE_NORMAL) {
137:                         // Bytes 0 and 1: bind / normal operation, otherwise unknown
138:                         x1txoPacket[0] = 0x18;
139:                         x1txoPacket[1] = 0x00;
140:                     
141:                         // Bytes 2 to 13: channels
142:                         // 6 most significant bits: channel number
143:                         // 10 least significant bits (2 in low, 8 in high byte): channel value    
144:                         int n;
145:                         for (n = 0; n < X1TXO_CHANNELS; n++) {
146:                             x1txoPacket[2 + 2 * n + 0] = (n << 2) | ((ch[n] >> 8) & 0x3);
147:                             x1txoPacket[2 + 2 * n + 1] =            ((ch[n] >> 0) & 0xFF);
148:                         }
149:                     } else if (appX1txoData.mode == X1TXO_MODE_BIND) {
150:                         // Bytes 0 and 1: bind / normal operation, otherwise unknown
151:                         x1txoPacket[0] = 0x98;
152:                         x1txoPacket[1] = 0x00;
153:                     
154:                         // Bytes 2 to 13: unknown, maybe failsafe channel settings?
155:                         // We just send what the DX5E transmitter sends:
156:                         // 0x9800000005FF09FF0DFF10AA14AA
157:                         x1txoPacket[2]  = 0x00;
158:                         x1txoPacket[3]  = 0x00;
159:                         x1txoPacket[4]  = 0x05;
160:                         x1txoPacket[5]  = 0xFF;
161:                         x1txoPacket[6]  = 0x09;
162:                         x1txoPacket[7]  = 0xFF;
163:                         x1txoPacket[8]  = 0x0D;
164:                         x1txoPacket[9]  = 0xFF;
165:                         x1txoPacket[10] = 0x10;
166:                         x1txoPacket[11] = 0xAA;
167:                         x1txoPacket[12] = 0x14;
168:                         x1txoPacket[13] = 0xAA;
169:                     } else {
170:                         // Default mode (INIT): do not send any packets yet
171:                         return;
172:                     }
173:                     
174:                     if (appX1txoData.pause > 0) {
175:                         int i;
176:                         for (i = 0; i < sizeof(x1txoPacket); i++) {
177:                             UART2_Write(&x1txoPacket[i], 1);
178:                             CORETIMER_DelayUs(appX1txoData.pause);
179:                         }
180:                     } else {
181:                         UART2_Write(x1txoPacket, sizeof(x1txoPacket));
182:                     }
183:                         
184:                     dprintf("APP_X1TXO_Send: <");
185:                     int i;
186:                     for (i = 0; i < sizeof(x1txoPacket); i++) {
187:                         dprintf("%02X", x1txoPacket[i]);
188:                     }            
189:                     dprintf(">\n");
190:                 }
191:                 
192:                 // *****************************************************************************
193:                 // *****************************************************************************
194:                 // Section: Application Initialization and State Machine Functions
195:                 // *****************************************************************************
196:                 // *****************************************************************************
197:                 
198:                 /*******************************************************************************
199:                   Function:
200:                     void APP_X1TXO_Initialize ( void )
201:                 
202:                   Remarks:
203:                     See prototype in app_ble.h.
204:                  */
205:                 
206:                 void APP_X1TXO_Initialize ( void )
207:                 {
208:                     /* Place the App state machine in its initial state. */
209:                     appX1txoData.state = APP_X1TXO_STATE_INIT;
210:                     appX1txoData.modeStartPackets = 0;
211:                 }
212:                 
213:                 
214:                 /******************************************************************************
215:                   Function:
216:                     void APP_X1TXO_Tasks ( void )
217:                 
218:                   Remarks:
219:                     See prototype in app_x1txo.h.
220:                  */
221:                 
222:                 void APP_X1TXO_Tasks ( void )
223:                 {
224:                     uint32_t ts32 = _CP0_GET_COUNT();
225:                     
226:                     /* Check the application's current state. */
227:                     switch (appX1txoData.state)
228:                     {
229:                         /* Application's initial state. */
230:                         case APP_X1TXO_STATE_INIT:
231:                         {
232:                             appX1txoData.state = APP_X1TXO_STATE_SERVICE_TASKS;
233:                             
234:                             // Default packet transmit interval
235:                             appX1txoData.interval =
236:                                     X1TXO_DEFAULT_INTERVAL_MS * 0.001 * CORE_TIMER_FREQUENCY;
237:                             
238:                             // Default byte transmit pause
239:                             appX1txoData.pause = X1TXO_DEFAULT_PAUSE_US;
240:                             
241:                             // Initialize timestamp of last packet send to X1TXO
242:                             appX1txoData.ts32 = ts32;
243:                             break;
244:                         }
245:                 
246:                         case APP_X1TXO_STATE_SERVICE_TASKS:
247:                         {
248:                             uint32_t ts32 = _CP0_GET_COUNT();
249:                             
250:                             // X1TXO TX port (RX for processor): print received data
251:                             // Can also be used to listen to data transferred from Spektrum
252:                             // controller to X1TXO module
253:                             unsigned char buffer[128];
254:                             uint32_t size = UART2_Read(buffer, sizeof(buffer) - 1);
255:                             if (size > 0) {
256:                                 dprintf("APP_X1TXO_Tasks: read <");
257:                                 int i;
258:                                 for (i = 0; i < size; i++) {
259:                                     dprintf("%02X", buffer[i]);
260:                                 }            
261:                                 dprintf(">\n");
262:                             }
263:                             
264:                             // X1TXO RX port (TX for processor): periodically send packet
265:                             if (ts32 - appX1txoData.ts32 > appX1txoData.interval) {
266:                                 APP_X1TXO_Send();
267:                                 // Remember timestamp of last packet sent to X1TXO
268:                                 appX1txoData.ts32 = ts32;                
269:                             }
270:                             break;
271:                         }
272:                 
273:                         /* The default state should never be executed. */
274:                         default:
275:                         {
276:                             /* TODO: Handle error in application's state machine. */
277:                             break;
278:                         }
279:                     }
280:                 }
281:                 
282:                 
283:                 /*******************************************************************************
284:                  End of File
285:                  */
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00B368  3C02A000   LUI V0, -24576
9D00B36C  24432E00   ADDIU V1, V0, 11776
9D00B370  AC402E00   SW ZERO, 11776(V0)
9D00B374  03E00008   JR RA
9D00B378  AC600020   SW ZERO, 32(V1)
9D013024  27BDFFC8   ADDIU SP, SP, -56
9D013028  AFB30030   SW S3, 48(SP)
9D01302C  3C13A000   LUI S3, -24576
9D013030  26732E00   ADDIU S3, S3, 11776
9D013034  8E620004   LW V0, 4(S3)
9D013038  24030001   ADDIU V1, ZERO, 1
9D01303C  AFBF0034   SW RA, 52(SP)
9D013040  AFB2002C   SW S2, 44(SP)
9D013044  AFB10028   SW S1, 40(SP)
9D013048  AFB00024   SW S0, 36(SP)
9D01304C  AFA00010   SW ZERO, 16(SP)
9D013050  AFA00014   SW ZERO, 20(SP)
9D013054  AFA00018   SW ZERO, 24(SP)
9D013058  1043004B   BEQ V0, V1, 0x9D013188
9D01305C  A7A0001C   SH ZERO, 28(SP)
9D013060  24030002   ADDIU V1, ZERO, 2
9D013064  50430030   BEQL V0, V1, 0x9D013128
9D013068  24020018   ADDIU V0, ZERO, 24
9D01306C  24030003   ADDIU V1, ZERO, 3
9D013070  14430027   BNE V0, V1, 0x9D013110
9D013074  8FBF0034   LW RA, 52(SP)
9D013078  2402FF98   ADDIU V0, ZERO, -104
9D01307C  A3A20010   SB V0, 16(SP)
9D013080  3C02FF09   LUI V0, -247
9D013084  3442FF05   ORI V0, V0, -251
9D013088  AFA20014   SW V0, 20(SP)
9D01308C  3C02AA10   LUI V0, -22000
9D013090  3442FF0D   ORI V0, V0, -243
9D013094  AFA20018   SW V0, 24(SP)
9D013098  2402AA14   ADDIU V0, ZERO, -21996
9D01309C  A7A2001C   SH V0, 28(SP)
9D0130A0  8E620010   LW V0, 16(S3)
9D0130A4  10400033   BEQ V0, ZERO, 0x9D013174
9D0130A8  27B00010   ADDIU S0, SP, 16
9D0130AC  02008825   OR S1, S0, ZERO
9D0130B0  27B2001E   ADDIU S2, SP, 30
9D0130B4  02202025   OR A0, S1, ZERO
9D0130B8  0F40543D   JAL UART2_Write
9D0130BC  24050001   ADDIU A1, ZERO, 1
9D0130C0  8E640010   LW A0, 16(S3)
9D0130C4  0F4061F8   JAL CORETIMER_DelayUs
9D0130C8  26310001   ADDIU S1, S1, 1
9D0130CC  1651FFFA   BNE S2, S1, 0x9D0130B8
9D0130D0  02202025   OR A0, S1, ZERO
9D0130D4  3C049D02   LUI A0, -25342
9D0130D8  24848E84   ADDIU A0, A0, -29052
9D0130DC  0F405C23   JAL dprintf
9D0130E0  3C119D02   LUI S1, -25342
9D0130E4  26318E98   ADDIU S1, S1, -29032
9D0130E8  92050000   LBU A1, 0(S0)
9D0130EC  02202025   OR A0, S1, ZERO
9D0130F0  0F405C23   JAL dprintf
9D0130F4  26100001   ADDIU S0, S0, 1
9D0130F8  5650FFFC   BNEL S2, S0, 0x9D0130EC
9D0130FC  92050000   LBU A1, 0(S0)
9D013100  3C049D02   LUI A0, -25342
9D013104  0F405C23   JAL dprintf
9D013108  24848EA0   ADDIU A0, A0, -29024
9D01310C  8FBF0034   LW RA, 52(SP)
9D013110  8FB30030   LW S3, 48(SP)
9D013114  8FB2002C   LW S2, 44(SP)
9D013118  8FB10028   LW S1, 40(SP)
9D01311C  8FB00024   LW S0, 36(SP)
9D013120  03E00008   JR RA
9D013124  27BD0038   ADDIU SP, SP, 56
9D013128  A3A20010   SB V0, 16(SP)
9D01312C  3C02A000   LUI V0, -24576
9D013130  24422E14   ADDIU V0, V0, 11796
9D013134  27A30012   ADDIU V1, SP, 18
9D013138  26680020   ADDIU T0, S3, 32
9D01313C  00002825   OR A1, ZERO, ZERO
9D013140  94460000   LHU A2, 0(V0)
9D013144  24A70004   ADDIU A3, A1, 4
9D013148  24420002   ADDIU V0, V0, 2
9D01314C  7CC40A00   EXT A0, A2, 8, 2
9D013150  00852025   OR A0, A0, A1
9D013154  A0640000   SB A0, 0(V1)
9D013158  A0660001   SB A2, 1(V1)
9D01315C  30E500FF   ANDI A1, A3, 255
9D013160  1448FFF7   BNE V0, T0, 0x9D013140
9D013164  24630002   ADDIU V1, V1, 2
9D013168  8E620010   LW V0, 16(S3)
9D01316C  1440FFCF   BNE V0, ZERO, 0x9D0130AC
9D013170  27B00010   ADDIU S0, SP, 16
9D013174  2405000E   ADDIU A1, ZERO, 14
9D013178  0F40543D   JAL UART2_Write
9D01317C  02002025   OR A0, S0, ZERO
9D013180  1000FFD4   BEQ ZERO, ZERO, 0x9D0130D4
9D013184  27B2001E   ADDIU S2, SP, 30
9D013188  8E620020   LW V0, 32(S3)
9D01318C  24030018   ADDIU V1, ZERO, 24
9D013190  A3A30010   SB V1, 16(SP)
9D013194  24420001   ADDIU V0, V0, 1
9D013198  2C430011   SLTIU V1, V0, 17
9D01319C  1460FFC0   BNE V1, ZERO, 0x9D0130A0
9D0131A0  AE620020   SW V0, 32(S3)
9D0131A4  24020002   ADDIU V0, ZERO, 2
9D0131A8  AE620004   SW V0, 4(S3)
9D0131AC  1000FFBC   BEQ ZERO, ZERO, 0x9D0130A0
9D0131B0  AE600020   SW ZERO, 32(S3)
9D01360C  27BDFF58   ADDIU SP, SP, -168
9D013610  AFBF00A4   SW RA, 164(SP)
9D013614  AFB400A0   SW S4, 160(SP)
9D013618  AFB3009C   SW S3, 156(SP)
9D01361C  AFB20098   SW S2, 152(SP)
9D013620  AFB10094   SW S1, 148(SP)
9D013624  AFB00090   SW S0, 144(SP)
9D013628  40034800   MFC0 V1, Count
9D01362C  3C11A000   LUI S1, -24576
9D013630  8E222E00   LW V0, 11776(S1)
9D013634  10400018   BEQ V0, ZERO, 0x9D013698
9D013638  24040001   ADDIU A0, ZERO, 1
9D01363C  24030001   ADDIU V1, ZERO, 1
9D013640  1443000E   BNE V0, V1, 0x9D01367C
9D013644  8FBF00A4   LW RA, 164(SP)
9D013648  40134800   MFC0 S3, Count
9D01364C  2405007F   ADDIU A1, ZERO, 127
9D013650  0F4057BD   JAL UART2_Read
9D013654  27A40010   ADDIU A0, SP, 16
9D013658  14400029   BNE V0, ZERO, 0x9D013700
9D01365C  00409025   OR S2, V0, ZERO
9D013660  26312E00   ADDIU S1, S1, 11776
9D013664  8E220008   LW V0, 8(S1)
9D013668  8E23000C   LW V1, 12(S1)
9D01366C  02621023   SUBU V0, S3, V0
9D013670  0062102B   SLTU V0, V1, V0
9D013674  14400017   BNE V0, ZERO, 0x9D0136D4
9D013678  8FBF00A4   LW RA, 164(SP)
9D01367C  8FB400A0   LW S4, 160(SP)
9D013680  8FB3009C   LW S3, 156(SP)
9D013684  8FB20098   LW S2, 152(SP)
9D013688  8FB10094   LW S1, 148(SP)
9D01368C  8FB00090   LW S0, 144(SP)
9D013690  03E00008   JR RA
9D013694  27BD00A8   ADDIU SP, SP, 168
9D013698  8FBF00A4   LW RA, 164(SP)
9D01369C  AE242E00   SW A0, 11776(S1)
9D0136A0  3C04000B   LUI A0, 11
9D0136A4  26222E00   ADDIU V0, S1, 11776
9D0136A8  34848920   ORI A0, A0, -30432
9D0136AC  8FB400A0   LW S4, 160(SP)
9D0136B0  8FB3009C   LW S3, 156(SP)
9D0136B4  8FB20098   LW S2, 152(SP)
9D0136B8  8FB10094   LW S1, 148(SP)
9D0136BC  8FB00090   LW S0, 144(SP)
9D0136C0  AC44000C   SW A0, 12(V0)
9D0136C4  AC400010   SW ZERO, 16(V0)
9D0136C8  AC430008   SW V1, 8(V0)
9D0136CC  03E00008   JR RA
9D0136D0  27BD00A8   ADDIU SP, SP, 168
9D0136D4  0F404C09   JAL APP_X1TXO_Send
9D0136D8  00000000   NOP
9D0136DC  8FBF00A4   LW RA, 164(SP)
9D0136E0  AE330008   SW S3, 8(S1)
9D0136E4  8FB400A0   LW S4, 160(SP)
9D0136E8  8FB3009C   LW S3, 156(SP)
9D0136EC  8FB20098   LW S2, 152(SP)
9D0136F0  8FB10094   LW S1, 148(SP)
9D0136F4  8FB00090   LW S0, 144(SP)
9D0136F8  03E00008   JR RA
9D0136FC  27BD00A8   ADDIU SP, SP, 168
9D013700  3C049D01   LUI A0, -25343
9D013704  2484B268   ADDIU A0, A0, -19864
9D013708  27B00010   ADDIU S0, SP, 16
9D01370C  0F405C23   JAL dprintf
9D013710  3C149D02   LUI S4, -25342
9D013714  02129021   ADDU S2, S0, S2
9D013718  26948E98   ADDIU S4, S4, -29032
9D01371C  92050000   LBU A1, 0(S0)
9D013720  02802025   OR A0, S4, ZERO
9D013724  0F405C23   JAL dprintf
9D013728  26100001   ADDIU S0, S0, 1
9D01372C  5650FFFC   BNEL S2, S0, 0x9D013720
9D013730  92050000   LBU A1, 0(S0)
9D013734  3C049D02   LUI A0, -25342
9D013738  26312E00   ADDIU S1, S1, 11776
9D01373C  0F405C23   JAL dprintf
9D013740  24848EA0   ADDIU A0, A0, -29024
9D013744  8E220008   LW V0, 8(S1)
9D013748  8E23000C   LW V1, 12(S1)
9D01374C  02621023   SUBU V0, S3, V0
9D013750  0062102B   SLTU V0, V1, V0
9D013754  1040FFC9   BEQ V0, ZERO, 0x9D01367C
9D013758  8FBF00A4   LW RA, 164(SP)
9D01375C  1000FFDD   BEQ ZERO, ZERO, 0x9D0136D4
9D013760  00000000   NOP
9D017D70  3C02A000   LUI V0, -24576
9D017D74  24422E00   ADDIU V0, V0, 11776
9D017D78  8C430004   LW V1, 4(V0)
9D017D7C  10640008   BEQ V1, A0, 0x9D017DA0
9D017D80  24050002   ADDIU A1, ZERO, 2
9D017D84  10850008   BEQ A0, A1, 0x9D017DA8
9D017D88  00000000   NOP
9D017D8C  24030003   ADDIU V1, ZERO, 3
9D017D90  10830007   BEQ A0, V1, 0x9D017DB0
9D017D94  00000000   NOP
9D017D98  10800007   BEQ A0, ZERO, 0x9D017DB8
9D017D9C  00000000   NOP
9D017DA0  03E00008   JR RA
9D017DA4  00000000   NOP
9D017DA8  10600005   BEQ V1, ZERO, 0x9D017DC0
9D017DAC  24030001   ADDIU V1, ZERO, 1
9D017DB0  03E00008   JR RA
9D017DB4  AC440004   SW A0, 4(V0)
9D017DB8  03E00008   JR RA
9D017DBC  AC400004   SW ZERO, 4(V0)
9D017DC0  AC400020   SW ZERO, 32(V0)
9D017DC4  03E00008   JR RA
9D017DC8  AC430004   SW V1, 4(V0)
---  c:/users/db/desktop/nano_tx/firmware/src/app_usb.c  ------------------------------------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                     
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       app_usb.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It 
15:                      implements the logic of the application's state machine and it may call 
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
27:                  *
28:                  * Subject to your compliance with these terms, you may use Microchip software
29:                  * and any derivatives exclusively with Microchip products. It is your
30:                  * responsibility to comply with third party license terms applicable to your
31:                  * use of third party software (including open source software) that may
32:                  * accompany Microchip software.
33:                  *
34:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
35:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
36:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
37:                  * PARTICULAR PURPOSE.
38:                  *
39:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
40:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
41:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
42:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
43:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
44:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
45:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  // Section: Included Files 
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  
56:                  #include "app_usb.h"
57:                  
58:                  
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  // Section: Global Data Definitions
62:                  // *****************************************************************************
63:                  // *****************************************************************************
64:                  
65:                  extern bool taskBusy;
66:                  uint8_t CACHE_ALIGN cdcReadBuffer[APP_USB_READ_BUFFER_SIZE];
67:                  uint8_t CACHE_ALIGN cdcWriteBuffer[APP_USB_READ_BUFFER_SIZE];
68:                  uint8_t appUsbHostOutStreamBuffer[APP_USB_STREAM_BUFFER_SIZE];
69:                  uint8_t appUsbHostInStreamBuffer[APP_USB_STREAM_BUFFER_SIZE];
70:                  RINGBUFFER* appUsbRbHostOut = NULL;
71:                  RINGBUFFER* appUsbRbHostIn = NULL;
72:                  
73:                  // *****************************************************************************
74:                  /* Application Data
75:                  
76:                    Summary:
77:                      Holds application data
78:                  
79:                    Description:
80:                      This structure holds the application's data.
81:                  
82:                    Remarks:
83:                      This structure should be initialized by the APP_Initialize function.
84:                      
85:                      Application strings and buffers are be defined outside this structure.
86:                  */
87:                  
88:                  APP_USB_DATA appUsbData;
89:                  
90:                  
91:                  // *****************************************************************************
92:                  // *****************************************************************************
93:                  // Section: Application Callback Functions
94:                  // *****************************************************************************
95:                  // *****************************************************************************
96:                  
97:                  
98:                  
99:                  /*******************************************************
100:                  * USB CDC Device Events - Application Event Handler
101:                  *******************************************************/
102:                 
103:                 USB_DEVICE_CDC_EVENT_RESPONSE APP_USBDeviceCDCEventHandler
104:                 (
105:                     USB_DEVICE_CDC_INDEX index,
106:                     USB_DEVICE_CDC_EVENT event,
107:                     void * pData,
108:                     uintptr_t userData
109:                 )
110:                 {
111:                     APP_USB_DATA * appDataObject;
112:                     USB_CDC_CONTROL_LINE_STATE * controlLineStateData;
113:                     USB_DEVICE_CDC_EVENT_DATA_READ_COMPLETE * eventDataRead;
114:                     
115:                     appDataObject = (APP_USB_DATA *)userData;
116:                 
117:                     switch(event)
118:                     {
119:                         case USB_DEVICE_CDC_EVENT_GET_LINE_CODING:
120:                 
121:                             /* This means the host wants to know the current line
122:                              * coding. This is a control transfer request. Use the
123:                              * USB_DEVICE_ControlSend() function to send the data to
124:                              * host.  */
125:                 
126:                             USB_DEVICE_ControlSend(appDataObject->deviceHandle,
127:                                     &appDataObject->getLineCodingData, sizeof(USB_CDC_LINE_CODING));
128:                 
129:                             break;
130:                 
131:                         case USB_DEVICE_CDC_EVENT_SET_LINE_CODING:
132:                 
133:                             /* This means the host wants to set the line coding.
134:                              * This is a control transfer request. Use the
135:                              * USB_DEVICE_ControlReceive() function to receive the
136:                              * data from the host */
137:                 
138:                             USB_DEVICE_ControlReceive(appDataObject->deviceHandle,
139:                                     &appDataObject->setLineCodingData, sizeof(USB_CDC_LINE_CODING));
140:                 
141:                             break;
142:                 
143:                         case USB_DEVICE_CDC_EVENT_SET_CONTROL_LINE_STATE:
144:                 
145:                             /* This means the host is setting the control line state.
146:                              * Read the control line state. We will accept this request
147:                              * for now. */
148:                 
149:                             controlLineStateData = (USB_CDC_CONTROL_LINE_STATE *)pData;
150:                             appDataObject->controlLineStateData.dtr = controlLineStateData->dtr;
151:                             appDataObject->controlLineStateData.carrier = controlLineStateData->carrier;
152:                 
153:                             USB_DEVICE_ControlStatus(appDataObject->deviceHandle, USB_DEVICE_CONTROL_STATUS_OK);
154:                 
155:                             break;
156:                 
157:                         case USB_DEVICE_CDC_EVENT_SEND_BREAK:
158:                 
159:                             /* This means that the host is requesting that a break of the
160:                              * specified duration be sent. Read the break duration */
161:                 
162:                             appDataObject->breakData = ((USB_DEVICE_CDC_EVENT_DATA_SEND_BREAK *)pData)->breakDuration;
163:                             
164:                             /* Complete the control transfer by sending a ZLP  */
165:                             USB_DEVICE_ControlStatus(appDataObject->deviceHandle, USB_DEVICE_CONTROL_STATUS_OK);
166:                             
167:                             break;
168:                 
169:                         case USB_DEVICE_CDC_EVENT_READ_COMPLETE:
170:                 
171:                             /* This means that the host has sent some data*/
172:                             eventDataRead = (USB_DEVICE_CDC_EVENT_DATA_READ_COMPLETE *)pData;
173:                             appDataObject->isReadComplete = true;
174:                             appDataObject->numBytesRead = eventDataRead->length; 
175:                             break;
176:                 
177:                         case USB_DEVICE_CDC_EVENT_CONTROL_TRANSFER_DATA_RECEIVED:
178:                 
179:                             /* The data stage of the last control transfer is
180:                              * complete. For now we accept all the data */
181:                 
182:                             USB_DEVICE_ControlStatus(appDataObject->deviceHandle, USB_DEVICE_CONTROL_STATUS_OK);
183:                             break;
184:                 
185:                         case USB_DEVICE_CDC_EVENT_CONTROL_TRANSFER_DATA_SENT:
186:                 
187:                             /* This means the GET LINE CODING function data is valid. We don't
188:                              * do much with this data in this demo. */
189:                             break;
190:                 
191:                         case USB_DEVICE_CDC_EVENT_WRITE_COMPLETE:
192:                 
193:                             /* This means that the data write got completed. We can schedule
194:                              * the next read. */
195:                 
196:                             appDataObject->isWriteComplete = true;
197:                             break;
198:                 
199:                         default:
200:                             break;
201:                     }
202:                 
203:                     return USB_DEVICE_CDC_EVENT_RESPONSE_NONE;
204:                 }
205:                 
206:                 /***********************************************
207:                  * Application USB Device Layer Event Handler.
208:                  ***********************************************/
209:                 void APP_USBDeviceEventHandler 
210:                 (
211:                     USB_DEVICE_EVENT event, 
212:                     void * eventData, 
213:                     uintptr_t context 
214:                 )
215:                 {
216:                     USB_DEVICE_EVENT_DATA_CONFIGURED *configuredEventData;
217:                 
218:                     switch(event)
219:                     {
220:                         case USB_DEVICE_EVENT_SOF:
221:                 
222:                             appUsbData.sofEventHasOccurred = true;
223:                             
224:                             break;
225:                 
226:                         case USB_DEVICE_EVENT_RESET:
227:                 
228:                             /* Update LED to show reset state */
229:                             //LED_Off();
230:                 
231:                             appUsbData.isConfigured = false;
232:                 
233:                             break;
234:                 
235:                         case USB_DEVICE_EVENT_CONFIGURED:
236:                 
237:                             /* Check the configuration. We only support configuration 1 */
238:                             configuredEventData = (USB_DEVICE_EVENT_DATA_CONFIGURED*)eventData;
239:                             
240:                             if ( configuredEventData->configurationValue == 1)
241:                             {
242:                                 /* Update LED to show configured state */
243:                                 //LED_On();
244:                                 
245:                                 /* Register the CDC Device application event handler here.
246:                                  * Note how the appData object pointer is passed as the
247:                                  * user data */
248:                 
249:                                 USB_DEVICE_CDC_EventHandlerSet(USB_DEVICE_CDC_INDEX_0, APP_USBDeviceCDCEventHandler, (uintptr_t)&appUsbData);
250:                 
251:                                 /* Mark that the device is now configured */
252:                                 appUsbData.isConfigured = true;
253:                             }
254:                             
255:                             break;
256:                 
257:                         case USB_DEVICE_EVENT_POWER_DETECTED:
258:                 
259:                             /* VBUS was detected. We can attach the device */
260:                             USB_DEVICE_Attach(appUsbData.deviceHandle);
261:                             
262:                             /* Mark that the device is now attached */
263:                             appUsbData.isAttached = true;
264:                             
265:                             break;
266:                 
267:                         case USB_DEVICE_EVENT_POWER_REMOVED:
268:                 
269:                             /* VBUS is not available any more. Detach the device. */
270:                             USB_DEVICE_Detach(appUsbData.deviceHandle);
271:                             
272:                             /* Mark that the device is now detached */
273:                             appUsbData.isAttached = false;
274:                             
275:                             //LED_Off();
276:                             
277:                             break;
278:                 
279:                         case USB_DEVICE_EVENT_SUSPENDED:
280:                 
281:                             //LED_Off();
282:                             
283:                             break;
284:                 
285:                         case USB_DEVICE_EVENT_RESUMED:
286:                         case USB_DEVICE_EVENT_ERROR:
287:                         default:
288:                             
289:                             break;
290:                     }
291:                 }
292:                 
293:                 // *****************************************************************************
294:                 // *****************************************************************************
295:                 // Section: Application Local Functions
296:                 // *****************************************************************************
297:                 // *****************************************************************************
298:                 
299:                 /*****************************************************
300:                  * This function is called in every step of the
301:                  * application state machine.
302:                  *****************************************************/
303:                 
304:                 bool APP_StateReset(void)
305:                 {
306:                     /* This function returns true if the device
307:                      * was reset  */
308:                 
309:                     bool retVal;
310:                 
311:                     if(appUsbData.isConfigured == false)
312:                     {
313:                         appUsbData.state = APP_USB_STATE_WAIT_FOR_CONFIGURATION;
314:                         appUsbData.readTransferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
315:                         appUsbData.writeTransferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
316:                         appUsbData.isReadComplete = true;
317:                         appUsbData.numBytesRead = 0;
318:                         appUsbData.isWriteComplete = true;
319:                         retVal = true;
320:                     }
321:                     else
322:                     {
323:                         retVal = false;
324:                     }
325:                 
326:                     return(retVal);
327:                 }
328:                 
329:                 // *****************************************************************************
330:                 // *****************************************************************************
331:                 // Section: Application Initialization and State Machine Functions
332:                 // *****************************************************************************
333:                 // *****************************************************************************
334:                 
335:                 /*******************************************************************************
336:                   Function:
337:                     void APP_Initialize(void)
338:                 
339:                   Remarks:
340:                     See prototype in app.h.
341:                  */
342:                 
343:                 void APP_USB_Initialize(void)
344:                 {
345:                     /* Place the App state machine in its initial state. */
346:                     appUsbData.state = APP_STATE_INIT;
347:                     
348:                     /* Device Layer Handle  */
349:                     appUsbData.deviceHandle = USB_DEVICE_HANDLE_INVALID ;
350:                 
351:                     /* Device configured status */
352:                     appUsbData.isConfigured = false;
353:                 
354:                     /* Initial get line coding state */
355:                     appUsbData.getLineCodingData.dwDTERate = 9600;
356:                     appUsbData.getLineCodingData.bParityType = 0;
357:                     appUsbData.getLineCodingData.bParityType = 0;
358:                     appUsbData.getLineCodingData.bDataBits = 8;
359:                 
360:                     /* Read Transfer Handle */
361:                     appUsbData.readTransferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
362:                 
363:                     /* Write Transfer Handle */
364:                     appUsbData.writeTransferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
365:                 
366:                     /* Initialize the read complete flag and the pending read bytes count */
367:                     appUsbData.isReadComplete = true;
368:                     appUsbData.numBytesRead = 0;
369:                 
370:                     /*Initialize the write complete flag*/
371:                     appUsbData.isWriteComplete = true;
372:                 
373:                     /* Reset other flags */
374:                     appUsbData.sofEventHasOccurred = false;
375:                 
376:                     /* Set up the USB CDC read buffer */
377:                     appUsbData.cdcReadBuffer = &cdcReadBuffer[0];
378:                 
379:                     /* Set up the USB CDC write buffer */
380:                     appUsbData.cdcWriteBuffer = &cdcWriteBuffer[0];      
381:                     
382:                     /* Set up the host output stream buffer */
383:                     RB_Init(&appUsbData.rbHostOut,
384:                             appUsbHostOutStreamBuffer,
385:                             sizeof(appUsbHostOutStreamBuffer));
386:                     appUsbRbHostOut = &appUsbData.rbHostOut;
387:                     
388:                     /* Set up the host input stream buffer */
389:                     RB_Init(&appUsbData.rbHostIn,
390:                             appUsbHostInStreamBuffer,
391:                             sizeof(appUsbHostInStreamBuffer));
392:                     appUsbRbHostIn = &appUsbData.rbHostIn;
393:                 }
394:                 
395:                 
396:                 /******************************************************************************
397:                   Function:
398:                     void APP_Tasks(void)
399:                 
400:                   Remarks:
401:                     See prototype in app.h.
402:                  */
403:                 
404:                 void APP_USB_Tasks(void)
405:                 {
406:                     /* Do not enter idle state while USB device is attached */
407:                     if (appUsbData.isAttached) {
408:                         taskBusy = true;
409:                     }
410:                     
411:                     /* Update the application state machine based
412:                      * on the current state */
413:                     //int i;
414:                     
415:                     switch(appUsbData.state)
416:                     {
417:                         case APP_STATE_INIT:
418:                 
419:                             /* Open the device layer */
420:                             appUsbData.deviceHandle = USB_DEVICE_Open( USB_DEVICE_INDEX_0, DRV_IO_INTENT_READWRITE );
421:                 
422:                             if(appUsbData.deviceHandle != USB_DEVICE_HANDLE_INVALID)
423:                             {
424:                                 /* Register a callback with device layer to get event notification (for end point 0) */
425:                                 USB_DEVICE_EventHandlerSet(appUsbData.deviceHandle, APP_USBDeviceEventHandler, 0);
426:                 
427:                                 appUsbData.state = APP_USB_STATE_WAIT_FOR_CONFIGURATION;
428:                             }
429:                             else
430:                             {
431:                                 /* The Device Layer is not ready to be opened. We should try
432:                                  * again later. */
433:                             }
434:                 
435:                             break;
436:                 
437:                         case APP_USB_STATE_WAIT_FOR_CONFIGURATION:
438:                 
439:                             /* Check if the device was configured */
440:                             if(appUsbData.isConfigured)
441:                             {
442:                                 /* If the device is configured then lets start reading */
443:                                 appUsbData.state = APP_USB_STATE_SCHEDULE_READ;
444:                             }
445:                             
446:                             break;
447:                 
448:                         case APP_USB_STATE_SCHEDULE_READ:
449:                 
450:                             if(APP_StateReset())
451:                             {
452:                                 break;
453:                             }
454:                 
455:                             /* If a read is complete, then schedule a read
456:                              * else wait for the current read to complete */
457:                 
458:                             appUsbData.state = APP_USB_STATE_WAIT_FOR_READ_COMPLETE;
459:                             if ((appUsbData.isReadComplete == true) && (appUsbData.numBytesRead == 0))
460:                             {
461:                                 appUsbData.isReadComplete = false;
462:                                 appUsbData.readTransferHandle =  USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
463:                 
464:                                 USB_DEVICE_CDC_Read (USB_DEVICE_CDC_INDEX_0,
465:                                         &appUsbData.readTransferHandle, appUsbData.cdcReadBuffer,
466:                                         APP_USB_READ_BUFFER_SIZE);
467:                                 
468:                                 if(appUsbData.readTransferHandle == USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID)
469:                                 {
470:                                     appUsbData.state = APP_USB_STATE_ERROR;
471:                                     break;
472:                                 }
473:                             }
474:                 
475:                             break;
476:                 
477:                         case APP_USB_STATE_WAIT_FOR_READ_COMPLETE:
478:                 
479:                             if (APP_StateReset())
480:                             {
481:                                 break;
482:                             }
483:                 
484:                             /* Check if a character was received the isReadComplete flag gets 
485:                              * updated in the CDC event handler. */
486:                             if (appUsbData.isReadComplete)
487:                             {
488:                                 if (appUsbData.numBytesRead < RB_GetFree(&appUsbData.rbHostOut))
489:                                 {
490:                                     RB_Write(&appUsbData.rbHostOut, 
491:                                          appUsbData.cdcReadBuffer,
492:                                          appUsbData.numBytesRead);
493:                                     appUsbData.numBytesRead = 0;
494:                                 }
495:                             }
496:                             
497:                             /* Schedule write.
498:                              * If the read is not complete yet we will wait for it as soon as
499:                              * there are no pending writes.
500:                              * See https://github.com/Microchip-MPLAB-Harmony/usb_apps_device/blob/master/apps/cdc_com_port_single/firmware/src/app.c
501:                              * for example. */
502:                             appUsbData.state = APP_USB_STATE_SCHEDULE_WRITE;
503:                             
504:                             break;
505:                 
506:                 
507:                         case APP_USB_STATE_SCHEDULE_WRITE:
508:                 
509:                             if (APP_StateReset())
510:                             {
511:                                 break;
512:                             }
513:                             
514:                 //            /* Skip write and go ahead with read if no data pending for
515:                 //             * write. */
516:                 //            if (RB_GetUsed(&appUsbData.rbHostIn) == 0)
517:                 //            {
518:                 //                appUsbData.state = APP_USB_STATE_SCHEDULE_READ;
519:                 //                break;
520:                 //            }
521:                 
522:                 
523:                 
524:                 //            /* Else echo each received character by adding 1 */
525:                 //            for(i = 0; i < appUsbData.numBytesRead; i++)
526:                 //            {
527:                 //                if((appUsbData.cdcReadBuffer[i] != 0x0A) && (appUsbData.cdcReadBuffer[i] != 0x0D))
528:                 //                {
529:                 //                    appUsbData.cdcWriteBuffer[i] = appUsbData.cdcReadBuffer[i] + 1;
530:                 //                }
531:                 //            }
532:                             
533:                             /* Read data from host input stream buffer */
534:                             uint32_t writeBytes = 0;
535:                             writeBytes = RB_Read(&appUsbData.rbHostIn,
536:                                     appUsbData.cdcWriteBuffer,
537:                                     APP_USB_READ_BUFFER_SIZE);
538:                             USB_DEVICE_CDC_TRANSFER_FLAGS txFlags
539:                                     = USB_DEVICE_CDC_TRANSFER_FLAGS_DATA_COMPLETE;
540:                             if (RB_GetUsed(&appUsbData.rbHostIn) > 0) {
541:                                 txFlags = USB_DEVICE_CDC_TRANSFER_FLAGS_MORE_DATA_PENDING;
542:                             }
543:                             
544:                             /* Skip write and go ahead with read if no data pending for
545:                              * write. */
546:                             if (writeBytes == 0)
547:                             {
548:                                 appUsbData.state = APP_USB_STATE_SCHEDULE_READ;
549:                                 break;
550:                             }
551:                                     /* Setup the write */
552:                             appUsbData.writeTransferHandle = USB_DEVICE_CDC_TRANSFER_HANDLE_INVALID;
553:                             appUsbData.isWriteComplete = false;
554:                             appUsbData.state = APP_USB_STATE_WAIT_FOR_WRITE_COMPLETE;            
555:                             
556:                             USB_DEVICE_CDC_Write(USB_DEVICE_CDC_INDEX_0,
557:                                     &appUsbData.writeTransferHandle,
558:                                     appUsbData.cdcWriteBuffer, writeBytes,
559:                                     txFlags);
560:                 
561:                             break;
562:                 
563:                         case APP_USB_STATE_WAIT_FOR_WRITE_COMPLETE:
564:                 
565:                             if(APP_StateReset())
566:                             {
567:                                 break;
568:                             }
569:                 
570:                             /* Check if a character was sent. The isWriteComplete
571:                              * flag gets updated in the CDC event handler */
572:                 
573:                             if(appUsbData.isWriteComplete == true)
574:                             {
575:                                 appUsbData.state = APP_USB_STATE_SCHEDULE_READ;
576:                             }
577:                 
578:                             break;
579:                 
580:                         case APP_USB_STATE_ERROR:
581:                         default:
582:                             
583:                             break;
584:                     }
585:                 }
586:                 
587:                 /*******************************************************************************
588:                  End of File
589:                  */
590:                 
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000018  00000000   NOP
9D010A9C  27BDFFD8   ADDIU SP, SP, -40
9D010AA4  3C11A000   LUI S1, -24576
9D010AA8  AFB00018   SW S0, 24(SP)
9D010AAC  26302C6C   ADDIU S0, S1, 11372
9D010AB0  92020034   LBU V0, 52(S0)
9D010AB4  AFBF0024   SW RA, 36(SP)
9D010AB8  10400003   BEQ V0, ZERO, 0x9D010AC8
9D010ABC  AFB20020   SW S2, 32(SP)
9D010AC0  24020001   ADDIU V0, ZERO, 1
9D010AC4  A3828026   SB V0, -32730(GP)
9D010AC8  8E020004   LW V0, 4(S0)
9D010ACC  2C430006   SLTIU V1, V0, 6
9D010AD0  1060001A   BEQ V1, ZERO, 0x9D010B3C
9D010AD4  00021880   SLL V1, V0, 2
9D010AD8  3C029D01   LUI V0, -25343
9D010ADC  24420AF0   ADDIU V0, V0, 2800
9D010AE0  00431021   ADDU V0, V0, V1
9D010AE4  8C420000   LW V0, 0(V0)
9D010AE8  00400008   JR V0
9D010AEC  00000000   NOP
9D010B08  24050003   ADDIU A1, ZERO, 3
9D010B14  2403FFFF   ADDIU V1, ZERO, -1
9D010B18  10430008   BEQ V0, V1, 0x9D010B3C
9D010B1C  AE222C6C   SW V0, 11372(S1)
9D010B20  3C059D01   LUI A1, -25343
9D010B24  00402025   OR A0, V0, ZERO
9D010B28  00003025   OR A2, ZERO, ZERO
9D010B2C  0F4060A9   JAL USB_DEVICE_EventHandlerSet
9D010B30  24A543AC   ADDIU A1, A1, 17324
9D010B34  24020001   ADDIU V0, ZERO, 1
9D010B38  AE020004   SW V0, 4(S0)
9D010B3C  8FBF0024   LW RA, 36(SP)
9D010B40  8FB20020   LW S2, 32(SP)
9D010B44  8FB1001C   LW S1, 28(SP)
9D010B48  8FB00018   LW S0, 24(SP)
9D010B4C  03E00008   JR RA
9D010B50  27BD0028   ADDIU SP, SP, 40
9D010B54  9202000F   LBU V0, 15(S0)
9D010B68  1440FFF5   BNE V0, ZERO, 0x9D010B40
9D010B6C  8FBF0024   LW RA, 36(SP)
9D010B70  8E05002C   LW A1, 44(S0)
9D010B74  3C11A000   LUI S1, -24576
9D010B78  24060800   ADDIU A2, ZERO, 2048
9D010B7C  0F405F2E   JAL RB_Read
9D010B80  26242CB4   ADDIU A0, S1, 11444
9D010B84  26242CB4   ADDIU A0, S1, 11444
9D010B88  0F402CFE   JAL RB_GetUsed
9D010B8C  00409025   OR S2, V0, ZERO
9D010B90  0002102B   SLTU V0, ZERO, V0
9D010B94  16400059   BNE S2, ZERO, 0x9D010CFC
9D010B98  24420001   ADDIU V0, V0, 1
9D010B9C  24020002   ADDIU V0, ZERO, 2
9D010BA0  AE020004   SW V0, 4(S0)
9D010BA4  8FBF0024   LW RA, 36(SP)
9D010BA8  8FB20020   LW S2, 32(SP)
9D010BAC  8FB1001C   LW S1, 28(SP)
9D010BB0  8FB00018   LW S0, 24(SP)
9D010BB4  03E00008   JR RA
9D010BB8  27BD0028   ADDIU SP, SP, 40
9D010BBC  9202000F   LBU V0, 15(S0)
9D010BD0  1440FFDB   BNE V0, ZERO, 0x9D010B40
9D010BD4  8FBF0024   LW RA, 36(SP)
9D010BD8  92020021   LBU V0, 33(S0)
9D010BDC  1040FFD8   BEQ V0, ZERO, 0x9D010B40
9D010BE0  8FBF0024   LW RA, 36(SP)
9D010BE4  24020002   ADDIU V0, ZERO, 2
9D010BE8  1000FFEE   BEQ ZERO, ZERO, 0x9D010BA4
9D010BEC  AE020004   SW V0, 4(S0)
9D010BF0  9202000F   LBU V0, 15(S0)
9D010C04  1440FFCE   BNE V0, ZERO, 0x9D010B40
9D010C08  8FBF0024   LW RA, 36(SP)
9D010C0C  92020020   LBU V0, 32(S0)
9D010C10  24030003   ADDIU V1, ZERO, 3
9D010C14  1040FFC9   BEQ V0, ZERO, 0x9D010B3C
9D010C18  AE030004   SW V1, 4(S0)
9D010C1C  8E020030   LW V0, 48(S0)
9D010C20  1440FFC7   BNE V0, ZERO, 0x9D010B40
9D010C24  8FBF0024   LW RA, 36(SP)
9D010C28  8E060028   LW A2, 40(S0)
9D010C2C  3C05A000   LUI A1, -24576
9D010C30  2411FFFF   ADDIU S1, ZERO, -1
9D010C34  24070800   ADDIU A3, ZERO, 2048
9D010C38  24A52C84   ADDIU A1, A1, 11396
9D010C3C  00002025   OR A0, ZERO, ZERO
9D010C40  A2000020   SB ZERO, 32(S0)
9D010C44  0F404A4E   JAL USB_DEVICE_CDC_Read
9D010C48  AE110018   SW S1, 24(S0)
9D010C4C  8E020018   LW V0, 24(S0)
9D010C50  1451FFBB   BNE V0, S1, 0x9D010B40
9D010C54  8FBF0024   LW RA, 36(SP)
9D010C58  24020006   ADDIU V0, ZERO, 6
9D010C5C  1000FFB7   BEQ ZERO, ZERO, 0x9D010B3C
9D010C60  AE020004   SW V0, 4(S0)
9D010C64  9202000F   LBU V0, 15(S0)
9D010C78  1440FFB1   BNE V0, ZERO, 0x9D010B40
9D010C7C  8FBF0024   LW RA, 36(SP)
9D010C80  92020020   LBU V0, 32(S0)
9D010C84  5440000F   BNEL V0, ZERO, 0x9D010CC4
9D010C88  8E110030   LW S1, 48(S0)
9D010C8C  24020004   ADDIU V0, ZERO, 4
9D010C90  AE020004   SW V0, 4(S0)
9D010C94  8FBF0024   LW RA, 36(SP)
9D010C98  8FB20020   LW S2, 32(SP)
9D010C9C  8FB1001C   LW S1, 28(SP)
9D010CA0  8FB00018   LW S0, 24(SP)
9D010CA4  03E00008   JR RA
9D010CA8  27BD0028   ADDIU SP, SP, 40
9D010CAC  9202000F   LBU V0, 15(S0)
9D010CB0  1040FFA3   BEQ V0, ZERO, 0x9D010B40
9D010CB4  8FBF0024   LW RA, 36(SP)
9D010CB8  24020002   ADDIU V0, ZERO, 2
9D010CBC  1000FFB9   BEQ ZERO, ZERO, 0x9D010BA4
9D010CC0  AE020004   SW V0, 4(S0)
9D010CC4  3C12A000   LUI S2, -24576
9D010CC8  0F402CF2   JAL RB_GetFree
9D010CCC  26442CA4   ADDIU A0, S2, 11428
9D010CD0  0222102B   SLTU V0, S1, V0
9D010CD4  1040FFEE   BEQ V0, ZERO, 0x9D010C90
9D010CD8  24020004   ADDIU V0, ZERO, 4
9D010CDC  8E060030   LW A2, 48(S0)
9D010CE0  8E050028   LW A1, 40(S0)
9D010CE4  0F405F17   JAL RB_Write
9D010CE8  26442CA4   ADDIU A0, S2, 11428
9D010CEC  24020004   ADDIU V0, ZERO, 4
9D010CF0  AE000030   SW ZERO, 48(S0)
9D010CF4  1000FFE7   BEQ ZERO, ZERO, 0x9D010C94
9D010CF8  AE020004   SW V0, 4(S0)
9D010CFC  8E06002C   LW A2, 44(S0)
9D010D00  AFA20010   SW V0, 16(SP)
9D010D04  3C05A000   LUI A1, -24576
9D010D08  2402FFFF   ADDIU V0, ZERO, -1
9D010D0C  AE02001C   SW V0, 28(S0)
9D010D10  02403825   OR A3, S2, ZERO
9D010D14  24A52C88   ADDIU A1, A1, 11400
9D010D18  00002025   OR A0, ZERO, ZERO
9D010D1C  24020005   ADDIU V0, ZERO, 5
9D010D20  A2000021   SB ZERO, 33(S0)
9D010D24  0F40486B   JAL USB_DEVICE_CDC_Write
9D010D28  AE020004   SW V0, 4(S0)
9D010D2C  1000FF84   BEQ ZERO, ZERO, 0x9D010B40
9D010D30  8FBF0024   LW RA, 36(SP)
9D0143AC  2C82000B   SLTIU V0, A0, 11
9D0143B0  10400046   BEQ V0, ZERO, APP_USBDeviceEventHandler
9D0143B4  00042080   SLL A0, A0, 2
9D0143B8  3C029D01   LUI V0, -25343
9D0143BC  244243DC   ADDIU V0, V0, 17372
9D0143C0  00442021   ADDU A0, V0, A0
9D0143C4  8C820000   LW V0, 0(A0)
9D0143C8  27BDFFE0   ADDIU SP, SP, -32
9D0143CC  AFBF001C   SW RA, 28(SP)
9D0143D0  AFB10018   SW S1, 24(SP)
9D0143D4  00400008   JR V0
9D0143D8  AFB00014   SW S0, 20(SP)
9D014408  3C10A000   LUI S0, -24576
9D014418  A2000034   SB ZERO, 52(S0)
9D01441C  8FBF001C   LW RA, 28(SP)
9D014420  8FB10018   LW S1, 24(SP)
9D014424  8FB00014   LW S0, 20(SP)
9D014428  03E00008   JR RA
9D01442C  27BD0020   ADDIU SP, SP, 32
9D014430  90B00000   LBU S0, 0(A1)
9D014434  24020001   ADDIU V0, ZERO, 1
9D014438  1602FFF9   BNE S0, V0, APP_USBDeviceEventHandler
9D01443C  8FBF001C   LW RA, 28(SP)
9D014440  3C11A000   LUI S1, -24576
9D014448  26262C6C   ADDIU A2, S1, 11372
9D01444C  24A55C80   ADDIU A1, A1, 23680
9D01445C  1000FFEF   BEQ ZERO, ZERO, APP_USBDeviceEventHandler
9D014460  A230000F   SB S0, 15(S1)
9D014464  8FBF001C   LW RA, 28(SP)
9D014468  3C02A000   LUI V0, -24576
9D01446C  8FB10018   LW S1, 24(SP)
9D014470  8FB00014   LW S0, 20(SP)
9D014474  A0402C7B   SB ZERO, 11387(V0)
9D014478  03E00008   JR RA
9D01447C  27BD0020   ADDIU SP, SP, 32
9D014480  8FBF001C   LW RA, 28(SP)
9D014484  3C02A000   LUI V0, -24576
9D014488  24030001   ADDIU V1, ZERO, 1
9D01448C  8FB10018   LW S1, 24(SP)
9D014490  8FB00014   LW S0, 20(SP)
9D014494  A0432C8E   SB V1, 11406(V0)
9D014498  03E00008   JR RA
9D01449C  27BD0020   ADDIU SP, SP, 32
9D0144A0  3C10A000   LUI S0, -24576
9D0144A4  8E042C6C   LW A0, 11372(S0)
9D0144A8  0F405E80   JAL USB_DEVICE_Attach
9D0144AC  26102C6C   ADDIU S0, S0, 11372
9D0144B0  8FBF001C   LW RA, 28(SP)
9D0144B4  24020001   ADDIU V0, ZERO, 1
9D0144B8  A2020034   SB V0, 52(S0)
9D0144BC  8FB10018   LW S1, 24(SP)
9D0144C0  8FB00014   LW S0, 20(SP)
9D0144C4  03E00008   JR RA
9D0144C8  27BD0020   ADDIU SP, SP, 32
9D0144CC  03E00008   JR RA
9D0144D0  00000000   NOP
9D015C80  2CA20009   SLTIU V0, A1, 9
9D015C84  10400012   BEQ V0, ZERO, 0x9D015CD0
9D015C88  00051080   SLL V0, A1, 2
9D015C8C  3C059D01   LUI A1, -25343
9D015C90  24A55CA4   ADDIU A1, A1, 23716
9D015C94  00A22821   ADDU A1, A1, V0
9D015C98  8CA20000   LW V0, 0(A1)
9D015C9C  00400008   JR V0
9D015CA0  00000000   NOP
9D015CC8  24020001   ADDIU V0, ZERO, 1
9D015CD0  03E00008   JR RA
9D015CD4  00000000   NOP
9D015CD8  8CC20004   LW V0, 4(A2)
9D015CDC  24030001   ADDIU V1, ZERO, 1
9D015CE0  A0E30020   SB V1, 32(A3)
9D015CE4  03E00008   JR RA
9D015CE8  ACE20030   SW V0, 48(A3)
9D015CEC  8CE40000   LW A0, 0(A3)
9D015CF0  0B405CF7   J USB_DEVICE_ControlStatus
9D015CF4  00002825   OR A1, ZERO, ZERO
9D015CF8  8CE40000   LW A0, 0(A3)
9D015CFC  24060007   ADDIU A2, ZERO, 7
9D015D00  0B4061DC   J USB_DEVICE_ControlReceive
9D015D04  24E50008   ADDIU A1, A3, 8
9D015D08  8CE40000   LW A0, 0(A3)
9D015D0C  24060007   ADDIU A2, ZERO, 7
9D015D10  0B405B29   J USB_DEVICE_ControlSend
9D015D14  24E50010   ADDIU A1, A3, 16
9D015D18  90C30000   LBU V1, 0(A2)
9D015D1C  90E20017   LBU V0, 23(A3)
9D015D20  8CE40000   LW A0, 0(A3)
9D015D24  00002825   OR A1, ZERO, ZERO
9D015D28  7C620004   INS V0, V1, 0, 1
9D015D2C  A0E20017   SB V0, 23(A3)
9D015D30  90C30000   LBU V1, 0(A2)
9D015D34  7C630040   EXT V1, V1, 1, 1
9D015D38  7C620844   INS V0, V1, 1, 1
9D015D3C  0B405CF7   J USB_DEVICE_ControlStatus
9D015D40  A0E20017   SB V0, 23(A3)
9D015D44  94C20000   LHU V0, 0(A2)
9D015D48  8CE40000   LW A0, 0(A3)
9D015D4C  00002825   OR A1, ZERO, ZERO
9D015D50  0B405CF7   J USB_DEVICE_ControlStatus
9D015D54  A4E20024   SH V0, 36(A3)
9D015D58  8C8A001C   LW T2, 28(A0)
9D0162E8  3C07A000   LUI A3, -24576
9D0162EC  24E22C6C   ADDIU V0, A3, 11372
9D0162F0  2403FFFF   ADDIU V1, ZERO, -1
9D0162F4  ACE32C6C   SW V1, 11372(A3)
9D0162F8  AC430018   SW V1, 24(V0)
9D0162FC  AC43001C   SW V1, 28(V0)
9D016300  24030101   ADDIU V1, ZERO, 257
9D016304  A4430020   SH V1, 32(V0)
9D016308  3C03A000   LUI V1, -24576
9D01630C  27BDFFE0   ADDIU SP, SP, -32
9D016310  24631C88   ADDIU V1, V1, 7304
9D016314  AFB10018   SW S1, 24(SP)
9D016318  AC430028   SW V1, 40(V0)
9D01631C  3C11A000   LUI S1, -24576
9D016320  24072580   ADDIU A3, ZERO, 9600
9D016324  3C05A000   LUI A1, -24576
9D016328  3C03A000   LUI V1, -24576
9D01632C  26242CA4   ADDIU A0, S1, 11428
9D016330  AC470010   SW A3, 16(V0)
9D016334  24631488   ADDIU V1, V1, 5256
9D016338  24070008   ADDIU A3, ZERO, 8
9D01633C  24060900   ADDIU A2, ZERO, 2304
9D016340  24A50B88   ADDIU A1, A1, 2952
9D016344  AFBF001C   SW RA, 28(SP)
9D016348  AFB00014   SW S0, 20(SP)
9D01634C  A0470016   SB A3, 22(V0)
9D016350  AC43002C   SW V1, 44(V0)
9D016354  AC400004   SW ZERO, 4(V0)
9D016358  A040000F   SB ZERO, 15(V0)
9D01635C  A0400015   SB ZERO, 21(V0)
9D016360  AC400030   SW ZERO, 48(V0)
9D016364  A0400022   SB ZERO, 34(V0)
9D016368  0F402CD2   JAL RB_Init
9D01636C  3C10A000   LUI S0, -24576
9D016370  3C05A000   LUI A1, -24576
9D016374  26312CA4   ADDIU S1, S1, 11428
9D016378  26042CB4   ADDIU A0, S0, 11444
9D01637C  24060900   ADDIU A2, ZERO, 2304
9D016380  24A50288   ADDIU A1, A1, 648
9D016384  0F402CD2   JAL RB_Init
9D016388  AF91803C   SW S1, -32708(GP)
9D01638C  8FBF001C   LW RA, 28(SP)
9D016390  26102CB4   ADDIU S0, S0, 11444
9D016394  AF908038   SW S0, -32712(GP)
9D016398  8FB10018   LW S1, 24(SP)
9D01639C  8FB00014   LW S0, 20(SP)
9D0163A0  03E00008   JR RA
9D0163A4  27BD0020   ADDIU SP, SP, 32
9D018A70  3C02A000   LUI V0, -24576
9D018A78  2403FFFF   ADDIU V1, ZERO, -1
9D018A7C  AC430018   SW V1, 24(V0)
9D018A80  AC43001C   SW V1, 28(V0)
9D018A84  24040001   ADDIU A0, ZERO, 1
9D018A88  24030101   ADDIU V1, ZERO, 257
9D018A8C  AC440004   SW A0, 4(V0)
9D018A90  AC400030   SW ZERO, 48(V0)
9D018A94  A4430020   SH V1, 32(V0)
9D018A98  03E00008   JR RA
9D018A9C  24020001   ADDIU V0, ZERO, 1
---  c:/users/db/desktop/nano_tx/firmware/src/app_ble.c  ------------------------------------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       app_ble.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It
15:                      implements the logic of the application's state machine and it may call
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // *****************************************************************************
25:                  // *****************************************************************************
26:                  // Section: Included Files
27:                  // *****************************************************************************
28:                  // *****************************************************************************
29:                  
30:                  #include "app_ble.h"
31:                  #include "user_hal/bm7x.h"
32:                  #include <stdint.h>
33:                  
34:                  // *****************************************************************************
35:                  // *****************************************************************************
36:                  // Section: Global Data Definitions
37:                  // *****************************************************************************
38:                  // *****************************************************************************
39:                  
40:                  extern bool taskBusy;
41:                  uint8_t appBleHostOutStreamBuffer[APP_BLE_STREAM_BUFFER_SIZE];
42:                  uint8_t appBleHostInStreamBuffer[APP_BLE_STREAM_BUFFER_SIZE];
43:                  RINGBUFFER* appBleRbHostOut = NULL;
44:                  RINGBUFFER* appBleRbHostIn = NULL;
45:                  
46:                  // *****************************************************************************
47:                  /* Application Data
48:                  
49:                    Summary:
50:                      Holds application data
51:                  
52:                    Description:
53:                      This structure holds the application's data.
54:                  
55:                    Remarks:
56:                      This structure should be initialized by the APP_BLE_Initialize function.
57:                  
58:                      Application strings and buffers are be defined outside this structure.
59:                  */
60:                  
61:                  APP_BLE_DATA appBleData;
62:                  
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  // Section: Application Callback Functions
66:                  // *****************************************************************************
67:                  // *****************************************************************************
68:                  
69:                  /* TODO:  Add any necessary callback functions.
70:                  */
71:                  
72:                  // *****************************************************************************
73:                  // *****************************************************************************
74:                  // Section: Application Local Functions
75:                  // *****************************************************************************
76:                  // *****************************************************************************
77:                  
78:                  
79:                  /* TODO:  Add any necessary local functions.
80:                  */
81:                  
82:                  
83:                  // *****************************************************************************
84:                  // *****************************************************************************
85:                  // Section: Application Initialization and State Machine Functions
86:                  // *****************************************************************************
87:                  // *****************************************************************************
88:                  
89:                  /*******************************************************************************
90:                    Function:
91:                      void APP_BLE_Initialize ( void )
92:                  
93:                    Remarks:
94:                      See prototype in app_ble.h.
95:                   */
96:                  
97:                  void APP_BLE_Initialize ( void )
98:                  {
99:                      /* Place the App state machine in its initial state. */
100:                     appBleData.state = APP_BLE_STATE_INIT;
101:                 
102:                     /* Set up the host output stream buffer */
103:                     RB_Init(&appBleData.rbHostOut,
104:                             appBleHostOutStreamBuffer,
105:                             sizeof(appBleHostOutStreamBuffer));
106:                     appBleRbHostOut = &appBleData.rbHostOut;
107:                     
108:                     /* Set up the host input stream buffer */
109:                     RB_Init(&appBleData.rbHostIn,
110:                             appBleHostInStreamBuffer,
111:                             sizeof(appBleHostInStreamBuffer));
112:                     appBleRbHostIn = &appBleData.rbHostIn;
113:                 }
114:                 
115:                 
116:                 /******************************************************************************
117:                   Function:
118:                     void APP_BLE_Tasks ( void )
119:                 
120:                   Remarks:
121:                     See prototype in app_ble.h.
122:                  */
123:                 
124:                 void APP_BLE_Tasks ( void )
125:                 {
126:                 
127:                     /* Check the application's current state. */
128:                     switch (appBleData.state)
129:                     {
130:                         /* Application's initial state. */
131:                         case APP_BLE_STATE_INIT:
132:                         {
133:                             BM7X_Initialize();
134:                             appBleData.state = APP_BLE_STATE_SERVICE_TASKS;
135:                             break;
136:                         }
137:                 
138:                         case APP_BLE_STATE_SERVICE_TASKS:
139:                         {
140:                 //            // Test mode: send incoming character + 1
141:                 //            char* buffer[128];
142:                 //            uint32_t size = BM7X_Read(buffer, sizeof(buffer) - 1);
143:                 //            buffer[size] = '\0';
144:                 //            dprintf("APP_BLE_Tasks: read <%s>\n", buffer);
145:                 //            int i;
146:                 //            for (i = 0; i < size; i++) {
147:                 //                buffer[i]++;
148:                 //            }
149:                 //            BM7X_Write(buffer, size);
150:                             
151:                             // Forward error messages
152:                             gwsError |= BM7X_GetError();
153:                             
154:                             // Forward incoming data to BLE ring buffer
155:                             uint8_t buffer[128];
156:                             uint32_t size = RB_GetFree(&appBleData.rbHostOut);
157:                             size = (size <= sizeof(buffer))? size : sizeof(buffer);
158:                             size = BM7X_Read(buffer, size);
159:                             RB_Write(&appBleData.rbHostOut, buffer, size);
160:                             if (size > 0) {
161:                                 buffer[sizeof(buffer) - 1] = '\0';
162:                                 if (size < sizeof(buffer)) {
163:                                     buffer[size] = '\0';
164:                                 }
165:                                 dprintf("APP_BLE_Tasks: read <%s>\n", buffer);
166:                             }
167:                             
168:                             // Forward outgoing data from BLE ring buffer
169:                             size = BM7X_GetWriteBufferFree();
170:                             size = (size <= sizeof(buffer))? size : sizeof(buffer);
171:                             size = RB_Read(&appBleData.rbHostIn, buffer, size);
172:                             uint32_t sent = BM7X_Write(buffer, size);            
173:                             if (sent != size) {
174:                                 gwsError |= BM7X_UART_TX_QUEUE_OVERFLOW;
175:                             }
176:                             if (sent > 0) {
177:                                 buffer[sizeof(buffer) - 1] = '\0';
178:                                 if (sent < sizeof(buffer)) {
179:                                     buffer[sent] = '\0';
180:                                 }
181:                                 dprintf("APP_BLE_Tasks: write <%s>\n", buffer);
182:                             }
183:                             
184:                             break;
185:                         }
186:                 
187:                         /* The default state should never be executed. */
188:                         default:
189:                         {
190:                             /* TODO: Handle error in application's state machine. */
191:                             break;
192:                         }
193:                     }
194:                 }
195:                 
196:                 
197:                 /*******************************************************************************
198:                  End of File
199:                  */
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D013A04  27BDFF60   ADDIU SP, SP, -160
9D013A08  AFB00094   SW S0, 148(SP)
9D013A0C  3C10A000   LUI S0, -24576
9D013A10  8E022DDC   LW V0, 11740(S0)
9D013A14  AFBF009C   SW RA, 156(SP)
9D013A18  10400044   BEQ V0, ZERO, 0x9D013B2C
9D013A1C  AFB10098   SW S1, 152(SP)
9D013A20  24030001   ADDIU V1, ZERO, 1
9D013A24  1443003D   BNE V0, V1, 0x9D013B1C
9D013A28  8FBF009C   LW RA, 156(SP)
9D013A2C  0F405EE6   JAL BM7X_GetError
9D013A30  3C11A000   LUI S1, -24576
9D013A34  8F838030   LW V1, -32720(GP)
9D013A38  26242DE0   ADDIU A0, S1, 11744
9D013A3C  00621025   OR V0, V1, V0
9D013A40  0F402CF2   JAL RB_GetFree
9D013A44  AF828030   SW V0, -32720(GP)
9D013A48  2C450081   SLTIU A1, V0, 129
9D013A4C  24030080   ADDIU V1, ZERO, 128
9D013A50  0045180B   MOVN V1, V0, A1
9D013A54  27A40010   ADDIU A0, SP, 16
9D013A58  0F402D16   JAL BM7X_Read
9D013A5C  00602825   OR A1, V1, ZERO
9D013A60  00408025   OR S0, V0, ZERO
9D013A64  00403025   OR A2, V0, ZERO
9D013A68  27A50010   ADDIU A1, SP, 16
9D013A6C  0F405F17   JAL RB_Write
9D013A70  26242DE0   ADDIU A0, S1, 11744
9D013A74  1200000A   BEQ S0, ZERO, 0x9D013AA0
9D013A78  2E020080   SLTIU V0, S0, 128
9D013A7C  10400004   BEQ V0, ZERO, 0x9D013A90
9D013A80  A3A0008F   SB ZERO, 143(SP)
9D013A84  27A20010   ADDIU V0, SP, 16
9D013A88  00508021   ADDU S0, V0, S0
9D013A8C  A2000000   SB ZERO, 0(S0)
9D013A90  3C049D02   LUI A0, -25342
9D013A94  27A50010   ADDIU A1, SP, 16
9D013A98  0F405C23   JAL dprintf
9D013A9C  248487A8   ADDIU A0, A0, -30808
9D013AA0  0F402D2A   JAL BM7X_GetWriteBufferFree
9D013AA4  00000000   NOP
9D013AA8  2C460081   SLTIU A2, V0, 129
9D013AAC  24030080   ADDIU V1, ZERO, 128
9D013AB0  0046180B   MOVN V1, V0, A2
9D013AB4  3C04A000   LUI A0, -24576
9D013AB8  27A50010   ADDIU A1, SP, 16
9D013ABC  24842DF0   ADDIU A0, A0, 11760
9D013AC0  0F405F2E   JAL RB_Read
9D013AC4  00603025   OR A2, V1, ZERO
9D013AC8  00402825   OR A1, V0, ZERO
9D013ACC  27A40010   ADDIU A0, SP, 16
9D013AD0  0F402D25   JAL BM7X_Write
9D013AD4  00408025   OR S0, V0, ZERO
9D013AD8  12020003   BEQ S0, V0, 0x9D013AE8
9D013ADC  8F838030   LW V1, -32720(GP)
9D013AE0  34630008   ORI V1, V1, 8
9D013AE4  AF838030   SW V1, -32720(GP)
9D013AE8  1040000C   BEQ V0, ZERO, 0x9D013B1C
9D013AEC  8FBF009C   LW RA, 156(SP)
9D013AF0  2C430080   SLTIU V1, V0, 128
9D013AF4  10600004   BEQ V1, ZERO, 0x9D013B08
9D013AF8  A3A0008F   SB ZERO, 143(SP)
9D013AFC  27A30010   ADDIU V1, SP, 16
9D013B00  00621021   ADDU V0, V1, V0
9D013B04  A0400000   SB ZERO, 0(V0)
9D013B08  3C049D02   LUI A0, -25342
9D013B0C  27A50010   ADDIU A1, SP, 16
9D013B10  0F405C23   JAL dprintf
9D013B14  248487C4   ADDIU A0, A0, -30780
9D013B18  8FBF009C   LW RA, 156(SP)
9D013B1C  8FB10098   LW S1, 152(SP)
9D013B20  8FB00094   LW S0, 148(SP)
9D013B24  03E00008   JR RA
9D013B28  27BD00A0   ADDIU SP, SP, 160
9D013B2C  0F406339   JAL BM7X_Initialize
9D013B30  00000000   NOP
9D013B34  8FBF009C   LW RA, 156(SP)
9D013B38  24020001   ADDIU V0, ZERO, 1
9D013B3C  AE022DDC   SW V0, 11740(S0)
9D013B40  8FB10098   LW S1, 152(SP)
9D013B44  8FB00094   LW S0, 148(SP)
9D013B48  03E00008   JR RA
9D013B4C  27BD00A0   ADDIU SP, SP, 160
9D017928  27BDFFE0   ADDIU SP, SP, -32
9D01792C  AFB10018   SW S1, 24(SP)
9D017930  3C05A000   LUI A1, -24576
9D017934  3C11A000   LUI S1, -24576
9D017938  26242DE0   ADDIU A0, S1, 11744
9D01793C  3C02A000   LUI V0, -24576
9D017940  24060100   ADDIU A2, ZERO, 256
9D017944  24A52688   ADDIU A1, A1, 9864
9D017948  AFBF001C   SW RA, 28(SP)
9D01794C  AFB00014   SW S0, 20(SP)
9D017950  AC402DDC   SW ZERO, 11740(V0)
9D017954  0F402CD2   JAL RB_Init
9D017958  3C10A000   LUI S0, -24576
9D01795C  3C05A000   LUI A1, -24576
9D017960  26312DE0   ADDIU S1, S1, 11744
9D017964  26042DF0   ADDIU A0, S0, 11760
9D017968  24060100   ADDIU A2, ZERO, 256
9D01796C  24A52588   ADDIU A1, A1, 9608
9D017970  0F402CD2   JAL RB_Init
9D017974  AF918044   SW S1, -32700(GP)
9D017978  8FBF001C   LW RA, 28(SP)
9D01797C  26102DF0   ADDIU S0, S0, 11760
9D017980  AF908040   SW S0, -32704(GP)
9D017984  8FB10018   LW S1, 24(SP)
9D017988  8FB00014   LW S0, 20(SP)
9D01798C  03E00008   JR RA
9D017990  27BD0020   ADDIU SP, SP, 32
---  c:/users/db/desktop/nano_tx/firmware/src/app.c  ----------------------------------------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       app.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It
15:                      implements the logic of the application's state machine and it may call
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // *****************************************************************************
25:                  // *****************************************************************************
26:                  // Section: Included Files
27:                  // *****************************************************************************
28:                  // *****************************************************************************
29:                  
30:                  #include "app.h"
31:                  #include "app_x1txo.h"
32:                  #include "definitions.h"                // GPIO
33:                  #include "user_hal/crc.h"
34:                  //#include "user_hal/iis2iclx.h"
35:                  #include "user_hal/lsm6dsv16x.h"
36:                  //#include "user_hal/lps22hh.h"
37:                  //#include "user_hal/sdp3x.h"
38:                  //#include "user_hal/w25q.h"
39:                  #include "user_hal/debug.h"
40:                  #include "user_hal/config.h"
41:                  #include <math.h>
42:                  #include <stdio.h>
43:                  
44:                  #define TS_FREQ 1000
45:                  #define TS_TICKS (CORE_TIMER_FREQUENCY / TS_FREQ)
46:                  
47:                  #if CORE_TIMER_FREQUENCY==36000000
48:                      #define TS_120S_MASK    0xFFFFFFFF
49:                      #define TS_8S_MASK      0x0FFFFFFF
50:                      #define TS_2S_MASK      0x03FFFFFF
51:                      #define TS_1S_MASK      0x01FFFFFF
52:                      #define TS_30MS_MASK    0x000FFFFF
53:                  #endif
54:                  
55:                  /// Debounce low time: >= 0.1 s
56:                  #define BUTTON_T_LOW_LONG (0.1 * CORE_TIMER_FREQUENCY)
57:                      
58:                  /// Long button press high time: >= 2 s
59:                  #define BUTTON_T_HIGH_LONG (2 * CORE_TIMER_FREQUENCY)
60:                  
61:                  /// Power up button hold time: >= 2 s
62:                  #define BUTTON_T_HOLD (2 * CORE_TIMER_FREQUENCY)
63:                      
64:                  /// Battery low warning threshold: 3.6 V
65:                  #define VBAT_LOW_WARN 3.6
66:                  #define VBAT_LOW_RELEASE 3.7
67:                  
68:                  /// 2.716619E-04: 3.58 V measured reads as 3.5 V in PIC
69:                  //#define CAL_ADC_VBAT_GAIN 2.716619E-04f
70:                  /// 2.778713E-04: 3.5 V measured should read as 3.5 V in PIC (not yet tested)
71:                  #define CAL_ADC_VBAT_GAIN 2.778713E-04f
72:                  
73:                  /// Beep time: 0.1 s
74:                  #define BEEP_T (0.1 * CORE_TIMER_FREQUENCY)
75:                  
76:                  // *****************************************************************************
77:                  // *****************************************************************************
78:                  // Section: Global Data Definitions
79:                  // *****************************************************************************
80:                  // *****************************************************************************
81:                  
82:                  // *****************************************************************************
83:                  /* Application Data
84:                  
85:                    Summary:
86:                      Holds application data
87:                  
88:                    Description:
89:                      This structure holds the application's data.
90:                  
91:                    Remarks:
92:                      This structure should be initialized by the APP_Initialize function.
93:                  
94:                      Application strings and buffers are be defined outside this structure.
95:                  */
96:                  
97:                  APP_DATA appData;
98:                  
99:                  // Non-volatile memory
100:                 uint8_t appDataNvm[1024] __attribute__((section(".nvm_mem"), used));
101:                 
102:                 // *****************************************************************************
103:                 // *****************************************************************************
104:                 // Section: Application Callback Functions
105:                 // *****************************************************************************
106:                 // *****************************************************************************
107:                 
108:                 /* TODO:  Add any necessary callback functions.
109:                 */
110:                 
111:                 // *****************************************************************************
112:                 // *****************************************************************************
113:                 // Section: Application Local Functions
114:                 // *****************************************************************************
115:                 // *****************************************************************************
116:                 
117:                 void getParam(char** rem, char** param)
118:                 {
119:                     int i;
120:                 
121:                     // Return with no parameter if buffer empty
122:                     if ((*rem == NULL) || ((*rem)[0] == '\0')) {
123:                         *param = NULL;
124:                         return;
125:                     }
126:                     // Skip leading white spaces
127:                     for (; ; (*rem)++) {
128:                         if ((**rem != ' ') && (**rem != ',')) {
129:                             break;
130:                         }
131:                     }
132:                     // Find end of parameter
133:                     *param = *rem;
134:                     char *pend;
135:                     for (i = 0; ; i++) {
136:                         if ((*rem)[i] == ',') {
137:                             (*rem)[i] = '\0';
138:                             pend = (*rem) + i + 0;
139:                             *rem = (*rem) + i + 1;
140:                             break;
141:                         } else  if (((*rem)[i] == '\0') || ((*rem)[i] == '\r')) {
142:                             (*rem)[i] = '\0';
143:                             pend = (*rem) + i + 0;
144:                             *rem = NULL;
145:                             break;
146:                         }
147:                     }
148:                     // Skip trailing white spaces
149:                     for (i = 1; pend - i > *param; i++) {
150:                         if ((*(pend - i) != ' ') && (*(pend - i) != ',')) {
151:                             break;
152:                         }
153:                         *(pend - i) = '\0';
154:                     }
155:                 }
156:                 
157:                 int isCmd(char* buf, char* cmd, char** rem)
158:                 {
159:                     if (buf == NULL) {
160:                         return 0;
161:                     }
162:                     int i;
163:                     if (rem != NULL) {
164:                         *rem = NULL;
165:                     }
166:                     for (i = 0; ; i++) {
167:                         if ((buf[i] == ' ') && (cmd[i] == '\0')) {
168:                             if (rem != NULL) {
169:                                 *rem = &buf[i+1];
170:                             }
171:                             return 1;
172:                         } else  if ((buf[i] == '\0') && (cmd[i] == '\0')) {
173:                             return 1;
174:                         } else  if ((buf[i] == '\r') && (cmd[i] == '\0')) {
175:                             return 1;
176:                         } else if (buf[i] != cmd[i]) {
177:                             return 0;
178:                         }
179:                     }
180:                 }
181:                 
182:                 bool paramToInt(char* param, int* value)
183:                 {
184:                     if (param == NULL) {
185:                         return false;
186:                     }
187:                     char* pend;
188:                     int valueStrtol = (int)strtol(param, &pend, 10);
189:                     if (*pend == '\0') {
190:                         *value = valueStrtol;
191:                         return true;
192:                     }
193:                     return false;
194:                 }
195:                 
196:                 // *****************************************************************************
197:                 // *****************************************************************************
198:                 // Section: Application Initialization and State Machine Functions
199:                 // *****************************************************************************
200:                 // *****************************************************************************
201:                 
202:                 /*******************************************************************************
203:                   Function:
204:                     void APP_Initialize ( void )
205:                 
206:                   Remarks:
207:                     See prototype in app.h.
208:                  */
209:                 
210:                 void APP_Initialize ( void )
211:                 {
212:                     memset(&appData, 0, sizeof(APP_DATA));
213:                     
214:                     /* Place the App state machine in its initial state. */
215:                     appData.state = APP_STATE_INIT;
216:                 
217:                     /* Start core timer */
218:                     CORETIMER_Start();
219:                 }
220:                 
221:                 
222:                 /******************************************************************************
223:                   Function:
224:                     void APP_Tasks ( void )
225:                 
226:                   Remarks:
227:                     See prototype in app.h.
228:                  */
229:                 
230:                 void APP_Tasks ( void )
231:                 {
232:                     // User button
233:                     uint32_t button = (GPIO_RA7_BUTTON_Get())? 0 : 1;
234:                     uint32_t ts32 = _CP0_GET_COUNT();    
235:                 
236:                     /* Check the application's current state. */
237:                     switch ( appData.state )
238:                     {
239:                         /* Application's initial state. */
240:                         case APP_STATE_INIT:
241:                         {
242:                             //Debug_Enable(appUsbRbHostIn);
243:                             GPIO_RA10_LED_Set();
244:                             
245:                             crcInit();
246:                             //IIS2ICLX_Init();
247:                             //LPS22HH_Init();
248:                             LSM6DSV16X_Init();
249:                             AD1CON1SET = _AD1CON1_ASAM_MASK;
250:                             //W25Q_Init();
251:                             //Capture_Init();
252:                             appData.state = APP_STATE_SERVICE_TASKS;
253:                             
254:                             // Enter bind mode
255:                             APP_X1TXO_setMode(X1TXO_MODE_INIT);
256:                             
257:                             // Initialize edge and short/long/hold button detection
258:                             appData.button = button;
259:                             appData.buttonTRise = ts32;
260:                             appData.buttonTFall = ts32;
261:                             appData.buttonHold = button;
262:                             appData.tBeep = ts32 + BEEP_T;
263:                             
264:                             GPIO_RC4_SPI_NCS_ACC_Clear();
265:                             break;
266:                         }
267:                 
268:                         case APP_STATE_SERVICE_TASKS:
269:                         {   
270:                             // Identify state to end binding mode
271:                             if (button == 0) {
272:                                 APP_X1TXO_setMode(X1TXO_MODE_NORMAL);
273:                             }
274:                             
275:                             // Identify edges and store edge timestamps
276:                             if ((button != 0) && (appData.button == 0)) {
277:                                 // Rising edge
278:                                 dprintf("<BUTTON T HIGH STARTS>\n");
279:                                 appData.buttonTRise = ts32;
280:                                 appData.buttonEventPending |= appData.buttonEventArmed;
281:                                 appData.buttonEventArmed = false;
282:                             } else if ((button == 0) && (appData.button != 0)) {
283:                                 // Falling edge
284:                                 dprintf("<BUTTON T LOW STARTS>\n");
285:                                 appData.buttonTFall = ts32;
286:                             }
287:                             appData.button = button;
288:                 
289:                             // Identify short event when low time reaches threshold
290:                             uint32_t tLow = ts32 - appData.buttonTFall;
291:                             if ((button == 0) && (tLow >= BUTTON_T_LOW_LONG)) {
292:                                 appData.buttonEventArmed = true;
293:                                 if (appData.buttonEventPending) {
294:                                     dprintf("<SHORT BUTTON PRESS EVENT>\n");
295:                                     appData.buttonEventPending = false;
296:                                 }
297:                             }
298:                 
299:                             // Identify long event when high time reaches threshold
300:                             uint32_t tHigh = ts32 - appData.buttonTRise;
301:                             if ((button == 1) && (tHigh >= BUTTON_T_HIGH_LONG)) {
302:                                 if (appData.buttonEventPending) {
303:                                     dprintf("<LONG BUTTON PRESS EVENT>\n");
304:                                     appData.buttonEventPending = false;
305:                                     appData.shutdown = true;
306:                                 }
307:                             }
308:                             
309:                             // Identify hold after power up event
310:                             appData.buttonHold = (button == 0)? 0: appData.buttonHold;
311:                             uint32_t tHold = ts32 - appData.buttonTRise;
312:                             if (tHold >= BUTTON_T_HOLD) {
313:                                 if ((button == 1) && appData.buttonHold) {
314:                                     dprintf("<BUTTON HOLD EVENT>\n");
315:                                     APP_X1TXO_setMode(X1TXO_MODE_BIND);
316:                                 }
317:                                 appData.buttonHold = 0;
318:                             }
319:                             
320:                             // Shutdown mode: wait until capture is no longer pending, then
321:                             // disable power supply
322:                             if (appData.shutdown /*&& !Capture_IsPending()*/) {
323:                                 GPIO_RC6_LDOEN_Clear();
324:                                 appData.tBeep = ts32 + BEEP_T;
325:                             }
326:                             
327:                             // Command line interface
328:                             char* rem;
329:                             char command[128];
330:                             uint32_t link;
331:                             for (link = 0; link < 2; link++) {
332:                                 // Select link
333:                                 RINGBUFFER* rbHostOut;
334:                                 RINGBUFFER* rbHostIn;
335:                                 if (link == 0) {
336:                                     rbHostOut = appUsbRbHostOut;
337:                                     rbHostIn = appUsbRbHostIn;
338:                                 } else {
339:                                     rbHostOut = appBleRbHostOut;
340:                                     rbHostIn = appBleRbHostIn;
341:                                 }
342:                                 
343:                                 // Handle link
344:                                 uint32_t len = RB_ReadLine(rbHostOut, command, sizeof(command), "\r\n");
345:                                 if (len == 0) {
346:                                     continue;
347:                                 }
348:                                 
349:                                 char ans[256] = "";
350:                                 if (strstr(command, "HALLO?") != NULL) {
351:                                     sprintf(ans, "AU HOI!%s", config.ansEol);
352:                                 } else if (isCmd(command, "DIAG:ACC?", NULL)) {
353:                                     //LSM6DSV16X_ReadDiagnostic();
354:                                     sprintf(ans, "id: %d, t: %d, ax: %d, ay: %d, az: %d, gx: %d, gy: %d, gz: %d%s",
355:                                             lsm6dsv16xData.id, lsm6dsv16xData.t,
356:                                             lsm6dsv16xData.ax, lsm6dsv16xData.ay, lsm6dsv16xData.az,
357:                                             lsm6dsv16xData.gx, lsm6dsv16xData.gy, lsm6dsv16xData.gz,
358:                                             config.ansEol);
359:                 
360:                                 } else if (isCmd(command, "DIAG:APP?", NULL)) {
361:                                     sprintf(ans, "appData.maxCycleTime: %d, .lastCycleTime: %d%s",
362:                                             appData.maxCycleTime, appData.lastCycleTime,
363:                                             config.ansEol);
364:                                 } else if (strstr(command, "DIAG:ADC?") != NULL) {
365:                                     sprintf(ans, "X %u, Y %u, BATMS %u (%f V)%s",
366:                                             appData.adcAd0GimbalX,
367:                                             appData.adcAd1GimbalY,
368:                                             appData.adcAd9Batms,
369:                                             (float)appData.adcAd9Batms * CAL_ADC_VBAT_GAIN,
370:                                             config.ansEol);
371:                                 } else if (isCmd(command, "DIAG:DEBUG", &rem)) {
372:                                     char* param;
373:                                     int value = 0;
374:                                     getParam(&rem, &param);
375:                                     if (paramToInt(param, &value) == false) {
376:                                         // Invalid parameter
377:                                     } else if (value) {
378:                                         Debug_Enable(rbHostIn);
379:                                         sprintf(ans, "Enable debug output%s", config.ansEol);
380:                                     } else {
381:                                         Debug_Disable();
382:                                         sprintf(ans, "Disable debug output%s", config.ansEol);
383:                                     }
384:                                 } else if (isCmd(command, "DIAG:ERR?", NULL)) {
385:                                     sprintf(ans, "%d%s", gwsError, config.ansEol);
386:                                 } else if (isCmd(command, "DIAG:INT?", &rem)) {
387:                                     char* param;
388:                                     int value = 0;
389:                                     getParam(&rem, &param);
390:                                     if (paramToInt(param, &value) == false) {
391:                                         // Invalid parameter
392:                                     } else {
393:                                         appX1txoData.interval =
394:                                                 value * 0.001 * CORE_TIMER_FREQUENCY;
395:                                     }
396:                                     sprintf(ans, "%f ms, %d raw%s",
397:                                             appX1txoData.interval * 1000.0 / CORE_TIMER_FREQUENCY,
398:                                             appX1txoData.interval,
399:                                             config.ansEol);                    
400:                                 } else if (isCmd(command, "DIAG:PAUS?", &rem)) {
401:                                     char* param;
402:                                     int value = 0;
403:                                     getParam(&rem, &param);
404:                                     if (paramToInt(param, &value) == false) {
405:                                         // Invalid parameter
406:                                     } else {
407:                                         appX1txoData.pause = value;
408:                                     }
409:                                     sprintf(ans, "%f us, %d raw%s",
410:                                             (float)appX1txoData.pause,
411:                                             appX1txoData.pause,
412:                                             config.ansEol);                    
413:                                 } else if (isCmd(command, "TIME?", NULL)) {
414:                                     sprintf(ans, "%llu%s", appData.ts64, config.ansEol);
415:                                 }
416:                 
417:                                 // Return answer
418:                                 if (ans[0] != '\0') {
419:                                     RB_Write(rbHostIn, ans, strlen(ans));
420:                                 }
421:                             }
422:                             
423:                             // High resolution cycle time measurement
424:                             uint32_t ts32d = (uint32_t)(appData.ts64 & 0x00000000FFFFFFFFllu);
425:                             appData.lastCycleTime = ts32 - ts32d;
426:                             if ((appData.ts64 > 0)
427:                                     && (appData.lastCycleTime > appData.maxCycleTime)) {
428:                                 appData.maxCycleTime = appData.lastCycleTime;
429:                             }
430:                             
431:                             // High resolution 64 bits timestamp
432:                             if (ts32 < (uint32_t)(appData.ts64 & 0x00000000FFFFFFFFllu)) {
433:                                 appData.ts64 += 0x0000000100000000llu;
434:                             };
435:                             appData.ts64 = ((uint64_t)ts32)
436:                                     | (appData.ts64 & 0xFFFFFFFF00000000llu);
437:                             
438:                             // LED flasher
439:                             uint32_t tsLed = ts32 >> 18;
440:                             //extern CORETIMER_OBJECT coreTmr;
441:                             if (appData.shutdown) {
442:                                 GPIO_RA10_LED_Clear();
443:                             } else if ((tsLed & 0x78) == 0x00) {
444:                                 GPIO_RA10_LED_Set();
445:                 //            } else if (((tsLed & 0x78) == 0x10) && (appX1txoData.mode != X1TXO_MODE_NORMAL)) {
446:                 //                GPIO_RA10_LED_Set();
447:                 //            } else if (((tsLed & 0x78) == 0x10) && (appX1txoData.mode != X1TXO_MODE_NORMAL)) {
448:                 //                GPIO_RA10_LED_Set();
449:                 //            } else if (((tsLed & 0x78) == 0x20) && (appX1txoData.mode != X1TXO_MODE_NORMAL)) {
450:                 //                GPIO_RA10_LED_Set();
451:                 //            } else if (((tsLed & 0x78) == 0x30) && (appX1txoData.mode != X1TXO_MODE_NORMAL)) {
452:                 //                GPIO_RA10_LED_Set();
453:                             } else if (((tsLed & 0x08) == 0x00) && (appX1txoData.mode != X1TXO_MODE_NORMAL)) {
454:                                 GPIO_RA10_LED_Set();
455:                             } else if (appX1txoData.mode == X1TXO_MODE_INIT) {
456:                                 GPIO_RA10_LED_Set();
457:                             } else {
458:                                 GPIO_RA10_LED_Clear();
459:                             }
460:                 
461:                             // Read LSM6DSV16(B)X accelerometer/gyroscope
462:                 //            if ((appData.counter & 0x1F) == 0) {
463:                 //                LSM6DSV16X_ReadTAG();
464:                 //            }
465:                             
466:                             // ADC battery voltage
467:                             // (I don't like the generated plib_adc.c library, write own one)
468:                             //
469:                             // In case of problems with the ADC:
470:                             // MCC may have misconfigured the input scan:
471:                             // The correct setup in "plib_adc.c" is "AD1CSSL = 0xa8f;"
472:                             // (see GIT history)
473:                             if (IFS0bits.AD1IF) {
474:                                 // ADC input scan stores samples from selected sources in an
475:                                 // array of result buffers, the order is as shown in MCC
476:                                 appData.adcAd0GimbalX = appData.adcAd0GimbalX * 15 / 16
477:                                         + ADC_ResultGet(ADC_RESULT_BUFFER_0);
478:                                 appData.adcAd1GimbalY = appData.adcAd1GimbalY * 15 / 16
479:                                         + ADC_ResultGet(ADC_RESULT_BUFFER_1);
480:                                 appData.adcAd9Batms = appData.adcAd9Batms * 15 / 16
481:                                         + ADC_ResultGet(ADC_RESULT_BUFFER_5);
482:                                 
483:                                 appX1txoData.ch[0] = appData.adcAd0GimbalX >> 4; // compensate filter gain
484:                                 appX1txoData.ch[1] = appData.adcAd1GimbalY >> 4; // compensate filter gain
485:                                 appX1txoData.ch[2] = appData.adcAd0GimbalX >> 4; // compensate filter gain
486:                                 appX1txoData.ch[3] = appData.adcAd1GimbalY >> 4; // compensate filter gain
487:                                 appX1txoData.ch[4] = appData.adcAd0GimbalX >> 4; // compensate filter gain
488:                                 appX1txoData.ch[5] = appData.adcAd1GimbalY >> 4; // compensate filter gain
489:                                 IFS0CLR = _IFS0_AD1IF_MASK;
490:                             }
491:                             
492:                 //            // Low battery voltage shutdown
493:                 //            if ((ts32 & TS_2S_MASK) < (ts32d & TS_2S_MASK)) {
494:                 //                float vBat = (float)appData.adcAd9Batms * CAL_ADC_VBAT_GAIN;
495:                 //                if (vBat < VBAT_LOW_SHUTDOWN) {
496:                 //                    //appData.shutdown = true;
497:                 //                    //Capture_Stop();
498:                 //                    //RB_Printf(appUsbRbHostIn, "LOW BATTERY VOLTAGE\n");
499:                 //                }
500:                 //            }
501:                             
502:                             // Low battery voltage alarm
503:                             float vBat = (float)appData.adcAd9Batms * CAL_ADC_VBAT_GAIN;
504:                             if (vBat <= VBAT_LOW_WARN) {
505:                                 appData.vBatAlarm = TRUE;
506:                             } else if (vBat >= VBAT_LOW_RELEASE) {
507:                                 appData.vBatAlarm = FALSE;
508:                             }
509:                             
510:                             // Beeper
511:                             // We use GPIO_RC4_SPI_NCS_ACC since in the original PCB design
512:                             // there was no beeper
513:                             if (appData.vBatAlarm) {
514:                                 if ((tsLed & 0x08) == 0x00) {
515:                                     GPIO_RC4_SPI_NCS_ACC_Set();
516:                                 } else {
517:                                     GPIO_RC4_SPI_NCS_ACC_Clear();
518:                                 }
519:                             } else {
520:                                 // Difference appData.tBeep - ts32 does overflow, but being
521:                                 // unsigned, it is still correct
522:                                 // Low values (just above zero) indicate the beep time has not
523:                                 // yet completed
524:                                 // High values (just below may) indicate the beep time has
525:                                 // completed (appData.tBeep is from the past, thus less than
526:                                 // ts32)
527:                                 // We simply test for it being below or above midscale
528:                                 uint32_t tBeep = appData.tBeep - ts32;
529:                                 if ((tBeep > 0) && (tBeep < UINT32_MAX / 2)) {
530:                                     GPIO_RC4_SPI_NCS_ACC_Set();
531:                                 } else {
532:                                     appData.tBeep = ts32;
533:                                     GPIO_RC4_SPI_NCS_ACC_Clear();
534:                                 }
535:                             }
536:                 
537:                             appData.counter++;
538:                             break;
539:                         }
540:                 
541:                         /* The default state should never be executed. */
542:                         default:
543:                         {
544:                             /* Handle error in application's state machine. */
545:                             break;
546:                         }
547:                     }
548:                 }
549:                 
550:                 /*******************************************************************************
551:                  End of File
552:                  */
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000008  00000000   NOP
00000010  00000000   NOP
00000018  00000000   NOP
9D00B768  27BDFDE8   ADDIU SP, SP, -536
9D00B76C  AFB101F4   SW S1, 500(SP)
9D00B770  3C11BF88   LUI S1, -16504
9D00B774  8E226020   LW V0, 24608(S1)
9D00B778  AFBF0214   SW RA, 532(SP)
9D00B77C  AFBE0210   SW FP, 528(SP)
9D00B780  000211C2   SRL V0, V0, 7
9D00B784  AFB7020C   SW S7, 524(SP)
9D00B788  AFB60208   SW S6, 520(SP)
9D00B78C  AFB50204   SW S5, 516(SP)
9D00B790  AFB40200   SW S4, 512(SP)
9D00B794  AFB301FC   SW S3, 508(SP)
9D00B798  AFB201F8   SW S2, 504(SP)
9D00B79C  AFB001F0   SW S0, 496(SP)
9D00B7A0  40104800   MFC0 S0, Count
9D00B7A4  3C1EA000   LUI FP, -24576
9D00B7A8  8FD22CC8   LW S2, 11464(FP)
9D00B7AC  124000BA   BEQ S2, ZERO, 0x9D00BA98
9D00B7B0  24030001   ADDIU V1, ZERO, 1
9D00B7B4  164300AD   BNE S2, V1, 0x9D00BA6C
9D00B7B8  8FBF0214   LW RA, 532(SP)
9D00B7BC  30420001   ANDI V0, V0, 1
9D00B7C0  144000E2   BNE V0, ZERO, 0x9D00BB4C
9D00B7C4  24040002   ADDIU A0, ZERO, 2
9D00B7C8  27DE2CC8   ADDIU FP, FP, 11464
9D00B7CC  8FC20020   LW V0, 32(FP)
9D00B7D0  10400185   BEQ V0, ZERO, 0x9D00BDE8
9D00B7D4  3C13044A   LUI S3, 1098
9D00B7D8  8FC20028   LW V0, 40(FP)
9D00B7DC  3673A200   ORI S3, S3, -24064
9D00B7E0  02021023   SUBU V0, S0, V0
9D00B7E4  0053102B   SLTU V0, V0, S3
9D00B7E8  1440000D   BNE V0, ZERO, 0x9D00B820
9D00B7EC  AFD20020   SW S2, 32(FP)
9D00B7F0  93C20034   LBU V0, 52(FP)
9D00B7F4  14400191   BNE V0, ZERO, 0x9D00BE3C
9D00B7F8  3C049D01   LUI A0, -25343
9D00B7FC  8FC20024   LW V0, 36(FP)
9D00B800  50400007   BEQL V0, ZERO, 0x9D00B820
9D00B804  AFC00024   SW ZERO, 36(FP)
9D00B808  3C049D01   LUI A0, -25343
9D00B80C  0F405C23   JAL dprintf
9D00B810  24842404   ADDIU A0, A0, 9220
9D00B814  0F405F5C   JAL APP_X1TXO_setMode
9D00B818  24040003   ADDIU A0, ZERO, 3
9D00B81C  AFC00024   SW ZERO, 36(FP)
9D00B820  93C2003C   LBU V0, 60(FP)
9D00B824  10400011   BEQ V0, ZERO, 0x9D00B86C
9D00B828  3C029D02   LUI V0, -25342
9D00B82C  24020040   ADDIU V0, ZERO, 64
9D00B830  02002025   OR A0, S0, ZERO
9D00B834  AE226234   SW V0, 25140(S1)
9D00B838  0F406165   JAL __floatunsidf
9D00B83C  00000000   NOP
9D00B840  3C049D02   LUI A0, -25342
9D00B844  8C868A40   LW A2, -30144(A0)
9D00B848  8C878A44   LW A3, -30140(A0)
9D00B84C  00602825   OR A1, V1, ZERO
9D00B850  0F403C67   JAL __adddf3
9D00B854  00402025   OR A0, V0, ZERO
9D00B858  00402025   OR A0, V0, ZERO
9D00B85C  0F405C91   JAL __fixunsdfsi
9D00B860  00602825   OR A1, V1, ZERO
9D00B864  AFC20030   SW V0, 48(FP)
9D00B868  3C029D02   LUI V0, -25342
9D00B86C  8C438A5C   LW V1, -30116(V0)
9D00B870  8C428A58   LW V0, -30120(V0)
9D00B874  3C049D02   LUI A0, -25342
9D00B878  AFA301CC   SW V1, 460(SP)
9D00B87C  AFA201C8   SW V0, 456(SP)
9D00B880  3C029D02   LUI V0, -25342
9D00B884  8C438A4C   LW V1, -30132(V0)
9D00B888  8C428A48   LW V0, -30136(V0)
9D00B88C  AFA401C4   SW A0, 452(SP)
9D00B890  AFA301D4   SW V1, 468(SP)
9D00B894  AFA201D0   SW V0, 464(SP)
9D00B898  8C828A50   LW V0, -30128(A0)
9D00B89C  8C838A54   LW V1, -30124(A0)
9D00B8A0  00009825   OR S3, ZERO, ZERO
9D00B8A4  AFA201D8   SW V0, 472(SP)
9D00B8A8  3C029D01   LUI V0, -25343
9D00B8AC  AFA301DC   SW V1, 476(SP)
9D00B8B0  3C149D01   LUI S4, -25343
9D00B8B4  3C179D01   LUI S7, -25343
9D00B8B8  3C169D01   LUI S6, -25343
9D00B8BC  AFA201C0   SW V0, 448(SP)
9D00B8C0  126000B9   BEQ S3, ZERO, 0x9D00BBA8
9D00B8C4  8F848044   LW A0, -32700(GP)
9D00B8C8  2687241C   ADDIU A3, S4, 9244
9D00B8CC  24060080   ADDIU A2, ZERO, 128
9D00B8D0  27A50130   ADDIU A1, SP, 304
9D00B8D4  0F402C00   JAL RB_ReadLine
9D00B8D8  8F958040   LW S5, -32704(GP)
9D00B8DC  10400013   BEQ V0, ZERO, 0x9D00B92C
9D00B8E0  24020001   ADDIU V0, ZERO, 1
9D00B8E4  00002825   OR A1, ZERO, ZERO
9D00B8E8  27A40034   ADDIU A0, SP, 52
9D00B8EC  240600FC   ADDIU A2, ZERO, 252
9D00B8F0  0F405B7D   JAL memset
9D00B8F4  AFA00030   SW ZERO, 48(SP)
9D00B8F8  26C52420   ADDIU A1, S6, 9248
9D00B8FC  0F405FB6   JAL strstr
9D00B900  27A40130   ADDIU A0, SP, 304
9D00B904  104000F0   BEQ V0, ZERO, isCmd
9D00B908  3C059D01   LUI A1, -25343
9D00B90C  27868010   ADDIU A2, GP, -32752
9D00B910  24A52428   ADDIU A1, A1, 9256
9D00B914  0F406357   JAL __wrap_sprintf
9D00B918  27A40030   ADDIU A0, SP, 48
9D00B91C  83A20030   LB V0, 48(SP)
9D00B920  144000E1   BNE V0, ZERO, 0x9D00BCA8
9D00B924  00000000   NOP
9D00B928  24020001   ADDIU V0, ZERO, 1
9D00B92C  5662FFE4   BNEL S3, V0, 0x9D00B8C0
9D00B930  02409825   OR S3, S2, ZERO
9D00B934  8FC20008   LW V0, 8(FP)
9D00B938  8FC3000C   LW V1, 12(FP)
9D00B93C  02022023   SUBU A0, S0, V0
9D00B940  00432825   OR A1, V0, V1
9D00B944  10A00007   BEQ A1, ZERO, 0x9D00B964
9D00B948  AFC40018   SW A0, 24(FP)
9D00B94C  8FC5001C   LW A1, 28(FP)
9D00B950  00A4282B   SLTU A1, A1, A0
9D00B954  54A00001   BNEL A1, ZERO, 0x9D00B95C
9D00B958  AFC4001C   SW A0, 28(FP)
9D00B95C  0202102B   SLTU V0, S0, V0
9D00B960  00621821   ADDU V1, V1, V0
9D00B964  93C2003C   LBU V0, 60(FP)
9D00B968  AFD00008   SW S0, 8(FP)
9D00B96C  AFC3000C   SW V1, 12(FP)
9D00B970  14400099   BNE V0, ZERO, 0x9D00BBD8
9D00B974  00109C82   SRL S3, S0, 18
9D00B978  32620078   ANDI V0, S3, 120
9D00B97C  10400008   BEQ V0, ZERO, 0x9D00B9A0
9D00B980  24020400   ADDIU V0, ZERO, 1024
9D00B984  3C03A000   LUI V1, -24576
9D00B988  32620008   ANDI V0, S3, 8
9D00B98C  14400090   BNE V0, ZERO, 0x9D00BBD0
9D00B990  8C632E04   LW V1, 11780(V1)
9D00B994  24020002   ADDIU V0, ZERO, 2
9D00B998  10620090   BEQ V1, V0, 0x9D00BBDC
9D00B99C  24020400   ADDIU V0, ZERO, 1024
9D00B9A0  AE226038   SW V0, 24632(S1)
9D00B9A4  8E221030   LW V0, 4144(S1)
9D00B9A8  7C420700   EXT V0, V0, 28, 1
9D00B9AC  50400091   BEQL V0, ZERO, 0x9D00BBF4
9D00B9B0  8FC40048   LW A0, 72(FP)
9D00B9B4  8FC20040   LW V0, 64(FP)
9D00B9B8  00002025   OR A0, ZERO, ZERO
9D00B9BC  00029100   SLL S2, V0, 4
9D00B9C0  0F4063CA   JAL ADC_ResultGet
9D00B9C4  02429023   SUBU S2, S2, V0
9D00B9C8  8FC30044   LW V1, 68(FP)
9D00B9CC  00129102   SRL S2, S2, 4
9D00B9D0  02421021   ADDU V0, S2, V0
9D00B9D4  0003A100   SLL S4, V1, 4
9D00B9D8  24040001   ADDIU A0, ZERO, 1
9D00B9DC  0283A023   SUBU S4, S4, V1
9D00B9E0  0F4063CA   JAL ADC_ResultGet
9D00B9E4  AFC20040   SW V0, 64(FP)
9D00B9E8  8FC30048   LW V1, 72(FP)
9D00B9EC  0014A102   SRL S4, S4, 4
9D00B9F0  02821021   ADDU V0, S4, V0
9D00B9F4  00039100   SLL S2, V1, 4
9D00B9F8  24040005   ADDIU A0, ZERO, 5
9D00B9FC  02439023   SUBU S2, S2, V1
9D00BA00  0F4063CA   JAL ADC_ResultGet
9D00BA04  AFC20044   SW V0, 68(FP)
9D00BA08  8FC60040   LW A2, 64(FP)
9D00BA0C  8FC50044   LW A1, 68(FP)
9D00BA10  00129102   SRL S2, S2, 4
9D00BA14  3C03A000   LUI V1, -24576
9D00BA18  24632E00   ADDIU V1, V1, 11776
9D00BA1C  7CC67900   EXT A2, A2, 4, 16
9D00BA20  7CA57900   EXT A1, A1, 4, 16
9D00BA24  02422021   ADDU A0, S2, V0
9D00BA28  3C021000   LUI V0, 4096
9D00BA2C  AFC40048   SW A0, 72(FP)
9D00BA30  A4660014   SH A2, 20(V1)
9D00BA34  A4650016   SH A1, 22(V1)
9D00BA38  A4660018   SH A2, 24(V1)
9D00BA3C  A465001A   SH A1, 26(V1)
9D00BA40  A466001C   SH A2, 28(V1)
9D00BA44  A465001E   SH A1, 30(V1)
9D00BA48  AE221034   SW V0, 4148(S1)
9D00BA4C  10000069   BEQ ZERO, ZERO, 0x9D00BBF4
9D00BA50  00000000   NOP
9D00BA54  24020010   ADDIU V0, ZERO, 16
9D00BA58  AE226234   SW V0, 25140(S1)
9D00BA5C  8FC20038   LW V0, 56(FP)
9D00BA60  24420001   ADDIU V0, V0, 1
9D00BA64  AFC20038   SW V0, 56(FP)
9D00BA68  8FBF0214   LW RA, 532(SP)
9D00BA6C  8FBE0210   LW FP, 528(SP)
9D00BA70  8FB7020C   LW S7, 524(SP)
9D00BA74  8FB60208   LW S6, 520(SP)
9D00BA78  8FB50204   LW S5, 516(SP)
9D00BA7C  8FB40200   LW S4, 512(SP)
9D00BA80  8FB301FC   LW S3, 508(SP)
9D00BA84  8FB201F8   LW S2, 504(SP)
9D00BA88  8FB101F4   LW S1, 500(SP)
9D00BA8C  8FB001F0   LW S0, 496(SP)
9D00BA90  03E00008   JR RA
9D00BA94  27BD0218   ADDIU SP, SP, 536
9D00BA98  24030400   ADDIU V1, ZERO, 1024
9D00BA9C  00021027   NOR V0, ZERO, V0
9D00BAA0  30520001   ANDI S2, V0, 1
9D00BAA4  AE236038   SW V1, 24632(S1)
9D00BAA8  0F405F45   JAL crcInit
9D00BAAC  27D42CC8   ADDIU S4, FP, 11464
9D00BAB0  0F405F8A   JAL LSM6DSV16X_Init
9D00BAB4  00000000   NOP
9D00BAB8  24030004   ADDIU V1, ZERO, 4
9D00BABC  3C02BF81   LUI V0, -16511
9D00BAC0  AC439008   SW V1, -28664(V0)
9D00BAC4  00002025   OR A0, ZERO, ZERO
9D00BAC8  24020001   ADDIU V0, ZERO, 1
9D00BACC  0F405F5C   JAL APP_X1TXO_setMode
9D00BAD0  AFC22CC8   SW V0, 11464(FP)
9D00BAD4  02002025   OR A0, S0, ZERO
9D00BAD8  AE920020   SW S2, 32(S4)
9D00BADC  AE900028   SW S0, 40(S4)
9D00BAE0  AE90002C   SW S0, 44(S4)
9D00BAE4  0F406165   JAL __floatunsidf
9D00BAE8  AE920024   SW S2, 36(S4)
9D00BAEC  3C049D02   LUI A0, -25342
9D00BAF0  8C868A40   LW A2, -30144(A0)
9D00BAF4  8C878A44   LW A3, -30140(A0)
9D00BAF8  00602825   OR A1, V1, ZERO
9D00BAFC  0F403C67   JAL __adddf3
9D00BB00  00402025   OR A0, V0, ZERO
9D00BB04  00402025   OR A0, V0, ZERO
9D00BB08  0F405C91   JAL __fixunsdfsi
9D00BB0C  00602825   OR A1, V1, ZERO
9D00BB10  8FBF0214   LW RA, 532(SP)
9D00BB14  AE820030   SW V0, 48(S4)
9D00BB18  24020010   ADDIU V0, ZERO, 16
9D00BB1C  AE226234   SW V0, 25140(S1)
9D00BB20  8FBE0210   LW FP, 528(SP)
9D00BB24  8FB7020C   LW S7, 524(SP)
9D00BB28  8FB60208   LW S6, 520(SP)
9D00BB2C  8FB50204   LW S5, 516(SP)
9D00BB30  8FB40200   LW S4, 512(SP)
9D00BB34  8FB301FC   LW S3, 508(SP)
9D00BB38  8FB201F8   LW S2, 504(SP)
9D00BB3C  8FB101F4   LW S1, 500(SP)
9D00BB40  8FB001F0   LW S0, 496(SP)
9D00BB44  03E00008   JR RA
9D00BB48  27BD0218   ADDIU SP, SP, 536
9D00BB4C  0F405F5C   JAL APP_X1TXO_setMode
9D00BB50  27DE2CC8   ADDIU FP, FP, 11464
9D00BB54  8FC20020   LW V0, 32(FP)
9D00BB58  144000C2   BNE V0, ZERO, 0x9D00BE64
9D00BB5C  3C030036   LUI V1, 54
9D00BB60  8FC2002C   LW V0, 44(FP)
9D00BB64  3463EE80   ORI V1, V1, -4480
9D00BB68  02021023   SUBU V0, S0, V0
9D00BB6C  0043102B   SLTU V0, V0, V1
9D00BB70  54400005   BNEL V0, ZERO, 0x9D00BB88
9D00BB74  8FC20028   LW V0, 40(FP)
9D00BB78  93C20034   LBU V0, 52(FP)
9D00BB7C  144000BF   BNE V0, ZERO, 0x9D00BE7C
9D00BB80  A3D20035   SB S2, 53(FP)
9D00BB84  8FC20028   LW V0, 40(FP)
9D00BB88  3C03044A   LUI V1, 1098
9D00BB8C  3463A200   ORI V1, V1, -24064
9D00BB90  02021023   SUBU V0, S0, V0
9D00BB94  0043102B   SLTU V0, V0, V1
9D00BB98  1440FF21   BNE V0, ZERO, 0x9D00B820
9D00BB9C  AFC00024   SW ZERO, 36(FP)
9D00BBA0  1000FF20   BEQ ZERO, ZERO, 0x9D00B824
9D00BBA4  93C2003C   LBU V0, 60(FP)
9D00BBA8  8F84803C   LW A0, -32708(GP)
9D00BBAC  2687241C   ADDIU A3, S4, 9244
9D00BBB0  24060080   ADDIU A2, ZERO, 128
9D00BBB4  27A50130   ADDIU A1, SP, 304
9D00BBB8  0F402C00   JAL RB_ReadLine
9D00BBBC  8F958038   LW S5, -32712(GP)
9D00BBC0  1440FF49   BNE V0, ZERO, 0x9D00B8E8
9D00BBC4  00002825   OR A1, ZERO, ZERO
9D00BBC8  1000FF3D   BEQ ZERO, ZERO, 0x9D00B8C0
9D00BBCC  02409825   OR S3, S2, ZERO
9D00BBD0  1060FF73   BEQ V1, ZERO, 0x9D00B9A0
9D00BBD4  24020400   ADDIU V0, ZERO, 1024
9D00BBD8  24020400   ADDIU V0, ZERO, 1024
9D00BBDC  AE226034   SW V0, 24628(S1)
9D00BBE0  8E221030   LW V0, 4144(S1)
9D00BBE4  7C420700   EXT V0, V0, 28, 1
9D00BBE8  5440FF73   BNEL V0, ZERO, 0x9D00B9B8
9D00BBEC  8FC20040   LW V0, 64(FP)
9D00BBF0  8FC40048   LW A0, 72(FP)
9D00BBF4  0F4060CD   JAL __floatunsisf
9D00BBF8  00000000   NOP
9D00BBFC  8EE5B2DC   LW A1, -19748(S7)
9D00BC00  0F404B34   JAL __mulsf3
9D00BC04  00402025   OR A0, V0, ZERO
9D00BC08  0F405A56   JAL __extendsfdf2
9D00BC0C  00402025   OR A0, V0, ZERO
9D00BC10  0040A025   OR S4, V0, ZERO
9D00BC14  3C029D02   LUI V0, -25342
9D00BC18  8C468A60   LW A2, -30112(V0)
9D00BC1C  8C478A64   LW A3, -30108(V0)
9D00BC20  02802025   OR A0, S4, ZERO
9D00BC24  00602825   OR A1, V1, ZERO
9D00BC28  0F405056   JAL __ltdf2
9D00BC2C  0060A825   OR S5, V1, ZERO
9D00BC30  5C400009   BGTZL V0, 0x9D00BC58
9D00BC34  3C029D02   LUI V0, -25342
9D00BC38  24020001   ADDIU V0, ZERO, 1
9D00BC3C  A3C2003D   SB V0, 61(FP)
9D00BC40  32730008   ANDI S3, S3, 8
9D00BC44  1660FF84   BNE S3, ZERO, 0x9D00BA58
9D00BC48  24020010   ADDIU V0, ZERO, 16
9D00BC4C  AE226238   SW V0, 25144(S1)
9D00BC50  1000FF83   BEQ ZERO, ZERO, 0x9D00BA60
9D00BC54  8FC20038   LW V0, 56(FP)
9D00BC58  8C468A68   LW A2, -30104(V0)
9D00BC5C  8C478A6C   LW A3, -30100(V0)
9D00BC60  02802025   OR A0, S4, ZERO
9D00BC64  0F40500B   JAL __eqdf2
9D00BC68  02A02825   OR A1, S5, ZERO
9D00BC6C  04420035   BLTZL V0, 0x9D00BD44
9D00BC70  93C2003D   LBU V0, 61(FP)
9D00BC74  A3C0003D   SB ZERO, 61(FP)
9D00BC78  8FC20030   LW V0, 48(FP)
9D00BC7C  3C037FFF   LUI V1, 32767
9D00BC80  3463FFFE   ORI V1, V1, -2
9D00BC84  2442FFFF   ADDIU V0, V0, -1
9D00BC88  00501023   SUBU V0, V0, S0
9D00BC8C  0043102B   SLTU V0, V0, V1
9D00BC90  5040FF70   BEQL V0, ZERO, 0x9D00BA54
9D00BC94  AFD00030   SW S0, 48(FP)
9D00BC98  24020010   ADDIU V0, ZERO, 16
9D00BC9C  AE226238   SW V0, 25144(S1)
9D00BCA0  1000FF6F   BEQ ZERO, ZERO, 0x9D00BA60
9D00BCA4  8FC20038   LW V0, 56(FP)
9D00BCA8  0F404D29   JAL strlen
9D00BCAC  27A40030   ADDIU A0, SP, 48
9D00BCB0  00403025   OR A2, V0, ZERO
9D00BCB4  27A50030   ADDIU A1, SP, 48
9D00BCB8  0F405F17   JAL RB_Write
9D00BCBC  02A02025   OR A0, S5, ZERO
9D00BCC0  1000FF1A   BEQ ZERO, ZERO, 0x9D00B92C
9D00BCC4  24020001   ADDIU V0, ZERO, 1
9D00BCC8  8FA201C0   LW V0, 448(SP)
9D00BCCC  00003025   OR A2, ZERO, ZERO
9D00BCD0  27A40130   ADDIU A0, SP, 304
9D00BCD4  0F405DD6   JAL isCmd
9D00BCD8  24452434   ADDIU A1, V0, 9268
9D00BCDC  1040001D   BEQ V0, ZERO, isCmd
9D00BCE0  3C059D01   LUI A1, -25343
9D00BCE4  3C03A000   LUI V1, -24576
9D00BCE8  24622E34   ADDIU V0, V1, 11828
9D00BCEC  84450006   LH A1, 6(V0)
9D00BCF0  844C000E   LH T4, 14(V0)
9D00BCF4  844B000C   LH T3, 12(V0)
9D00BCF8  844A000A   LH T2, 10(V0)
9D00BCFC  84490008   LH T1, 8(V0)
9D00BD00  84440004   LH A0, 4(V0)
9D00BD04  84470002   LH A3, 2(V0)
9D00BD08  84662E34   LH A2, 11828(V1)
9D00BD0C  27828010   ADDIU V0, GP, -32752
9D00BD10  AFA50014   SW A1, 20(SP)
9D00BD14  3C059D01   LUI A1, -25343
9D00BD18  AFA40010   SW A0, 16(SP)
9D00BD1C  AFA20028   SW V0, 40(SP)
9D00BD20  AFAC0024   SW T4, 36(SP)
9D00BD24  AFAB0020   SW T3, 32(SP)
9D00BD28  AFAA001C   SW T2, 28(SP)
9D00BD2C  AFA90018   SW T1, 24(SP)
9D00BD30  24A52440   ADDIU A1, A1, 9280
9D00BD34  0F406357   JAL __wrap_sprintf
9D00BD38  27A40030   ADDIU A0, SP, 48
9D00BD3C  1000FEF8   BEQ ZERO, ZERO, 0x9D00B920
9D00BD40  83A20030   LB V0, 48(SP)
9D00BD44  5040FFCD   BEQL V0, ZERO, 0x9D00BC7C
9D00BD48  8FC20030   LW V0, 48(FP)
9D00BD4C  1000FFBD   BEQ ZERO, ZERO, 0x9D00BC44
9D00BD50  32730008   ANDI S3, S3, 8
9D00BD54  00003025   OR A2, ZERO, ZERO
9D00BD5C  0F405DD6   JAL isCmd
9D00BD64  1440002B   BNE V0, ZERO, 0x9D00BE14
9D00BD68  3C059D01   LUI A1, -25343
9D00BD6C  24A524BC   ADDIU A1, A1, 9404
9D00BD70  0F405FB6   JAL strstr
9D00BD74  27A40130   ADDIU A0, SP, 304
9D00BD78  10400045   BEQ V0, ZERO, isCmd
9D00BD7C  27828010   ADDIU V0, GP, -32752
9D00BD80  8FC90048   LW T1, 72(FP)
9D00BD84  8FC70044   LW A3, 68(FP)
9D00BD88  8FC60040   LW A2, 64(FP)
9D00BD8C  01202025   OR A0, T1, ZERO
9D00BD90  AFA701E8   SW A3, 488(SP)
9D00BD94  AFA901E4   SW T1, 484(SP)
9D00BD98  AFA601E0   SW A2, 480(SP)
9D00BD9C  0F4060CD   JAL __floatunsisf
9D00BDA0  AFA20020   SW V0, 32(SP)
9D00BDA4  8EE5B2DC   LW A1, -19748(S7)
9D00BDA8  0F404B34   JAL __mulsf3
9D00BDAC  00402025   OR A0, V0, ZERO
9D00BDB0  0F405A56   JAL __extendsfdf2
9D00BDB4  00402025   OR A0, V0, ZERO
9D00BDB8  8FA901E4   LW T1, 484(SP)
9D00BDBC  8FA701E8   LW A3, 488(SP)
9D00BDC0  8FA601E0   LW A2, 480(SP)
9D00BDC4  3C059D01   LUI A1, -25343
9D00BDC8  AFA20018   SW V0, 24(SP)
9D00BDCC  AFA3001C   SW V1, 28(SP)
9D00BDD0  AFA90010   SW T1, 16(SP)
9D00BDD4  24A524C8   ADDIU A1, A1, 9416
9D00BDD8  0F406357   JAL __wrap_sprintf
9D00BDDC  27A40030   ADDIU A0, SP, 48
9D00BDE0  1000FECF   BEQ ZERO, ZERO, 0x9D00B920
9D00BDE4  83A20030   LB V0, 48(SP)
9D00BDE8  3C049D01   LUI A0, -25343
9D00BDEC  0F405C23   JAL dprintf
9D00BDF0  2484239C   ADDIU A0, A0, 9116
9D00BDF4  93C20034   LBU V0, 52(FP)
9D00BDF8  93C30035   LBU V1, 53(FP)
9D00BDFC  AFD00028   SW S0, 40(FP)
9D00BE00  A3C00035   SB ZERO, 53(FP)
9D00BE04  00431025   OR V0, V0, V1
9D00BE08  A3C20034   SB V0, 52(FP)
9D00BE0C  1000FE84   BEQ ZERO, ZERO, 0x9D00B820
9D00BE10  AFD20020   SW S2, 32(FP)
9D00BE14  8FC70018   LW A3, 24(FP)
9D00BE18  8FC6001C   LW A2, 28(FP)
9D00BE1C  27828010   ADDIU V0, GP, -32752
9D00BE20  3C059D01   LUI A1, -25343
9D00BE24  AFA20010   SW V0, 16(SP)
9D00BE28  24A5248C   ADDIU A1, A1, 9356
9D00BE2C  0F406357   JAL __wrap_sprintf
9D00BE30  27A40030   ADDIU A0, SP, 48
9D00BE34  1000FEBA   BEQ ZERO, ZERO, 0x9D00B920
9D00BE38  83A20030   LB V0, 48(SP)
9D00BE3C  0F405C23   JAL dprintf
9D00BE40  248423E8   ADDIU A0, A0, 9192
9D00BE44  8FC20028   LW V0, 40(FP)
9D00BE48  A3C00034   SB ZERO, 52(FP)
9D00BE4C  02021023   SUBU V0, S0, V0
9D00BE50  0053982B   SLTU S3, V0, S3
9D00BE54  1260FE69   BEQ S3, ZERO, 0x9D00B7FC
9D00BE58  A3D2003C   SB S2, 60(FP)
9D00BE5C  1000FE71   BEQ ZERO, ZERO, 0x9D00B824
9D00BE60  93C2003C   LBU V0, 60(FP)
9D00BE64  3C049D01   LUI A0, -25343
9D00BE68  0F405C23   JAL dprintf
9D00BE6C  248423B4   ADDIU A0, A0, 9140
9D00BE70  AFD0002C   SW S0, 44(FP)
9D00BE74  1000FF43   BEQ ZERO, ZERO, 0x9D00BB84
9D00BE78  AFC00020   SW ZERO, 32(FP)
9D00BE7C  3C049D01   LUI A0, -25343
9D00BE80  0F405C23   JAL dprintf
9D00BE84  248423CC   ADDIU A0, A0, 9164
9D00BE88  1000FF3E   BEQ ZERO, ZERO, 0x9D00BB84
9D00BE8C  A3C00034   SB ZERO, 52(FP)
9D00BE90  3C059D01   LUI A1, -25343
9D00BE98  24A524E8   ADDIU A1, A1, 9448
9D00BEA0  0F405DD6   JAL isCmd
9D00BEA8  10400018   BEQ V0, ZERO, isCmd
9D00BEAC  3C059D01   LUI A1, -25343
9D00BEB0  27A401B8   ADDIU A0, SP, 440
9D00BEB4  27A501B4   ADDIU A1, SP, 436
9D00BEB8  0F40532C   JAL getParam
9D00BEBC  AFA001B0   SW ZERO, 432(SP)
9D00BEC0  8FA401B4   LW A0, 436(SP)
9D00BEC4  1080FE96   BEQ A0, ZERO, 0x9D00B920
9D00BECC  0F40605B   JAL paramToInt
9D00BED4  1040FE92   BEQ V0, ZERO, 0x9D00B920
9D00BED8  83A20030   LB V0, 48(SP)
9D00BEDC  8FA201B0   LW V0, 432(SP)
9D00BEE0  1040007F   BEQ V0, ZERO, 0x9D00C0E0
9D00BEE4  00000000   NOP
9D00BEE8  0F402D0E   JAL Debug_Enable
9D00BEEC  02A02025   OR A0, S5, ZERO
9D00BEF0  3C059D01   LUI A1, -25343
9D00BEF4  27868010   ADDIU A2, GP, -32752
9D00BEF8  24A524F4   ADDIU A1, A1, 9460
9D00BEFC  0F406357   JAL __wrap_sprintf
9D00BF00  27A40030   ADDIU A0, SP, 48
9D00BF04  1000FE86   BEQ ZERO, ZERO, 0x9D00B920
9D00BF08  83A20030   LB V0, 48(SP)
9D00BF0C  00003025   OR A2, ZERO, ZERO
9D00BF14  0F405DD6   JAL isCmd
9D00BF1C  10400009   BEQ V0, ZERO, isCmd
9D00BF20  3C059D01   LUI A1, -25343
9D00BF24  8F868030   LW A2, -32720(GP)
9D00BF28  3C059D01   LUI A1, -25343
9D00BF2C  27878010   ADDIU A3, GP, -32752
9D00BF30  24A52530   ADDIU A1, A1, 9520
9D00BF34  0F406357   JAL __wrap_sprintf
9D00BF38  27A40030   ADDIU A0, SP, 48
9D00BF3C  1000FE78   BEQ ZERO, ZERO, 0x9D00B920
9D00BF40  83A20030   LB V0, 48(SP)
9D00BF44  27A601B8   ADDIU A2, SP, 440
9D00BF48  24A52538   ADDIU A1, A1, 9528
9D00BF4C  27A40130   ADDIU A0, SP, 304
9D00BF50  0F405DD6   JAL isCmd
9D00BF54  AFA001B8   SW ZERO, 440(SP)
9D00BF58  1040003A   BEQ V0, ZERO, isCmd
9D00BF5C  3C059D01   LUI A1, -25343
9D00BF60  27A401B8   ADDIU A0, SP, 440
9D00BF64  27A501B4   ADDIU A1, SP, 436
9D00BF68  0F40532C   JAL getParam
9D00BF6C  AFA001B0   SW ZERO, 432(SP)
9D00BF70  8FA401B4   LW A0, 436(SP)
9D00BF74  10800063   BEQ A0, ZERO, 0x9D00C104
9D00BF7C  0F40605B   JAL paramToInt
9D00BF84  1040005F   BEQ V0, ZERO, 0x9D00C104
9D00BF88  3C09A000   LUI T1, -24576
9D00BF8C  8FA401B0   LW A0, 432(SP)
9D00BF90  25292E00   ADDIU T1, T1, 11776
9D00BF94  0F405DF4   JAL __floatsidf
9D00BF98  AFA901E0   SW T1, 480(SP)
9D00BF9C  8FA601D0   LW A2, 464(SP)
9D00BFA0  8FA701D4   LW A3, 468(SP)
9D00BFA4  00402025   OR A0, V0, ZERO
9D00BFA8  0F404121   JAL dpmul
9D00BFAC  00602825   OR A1, V1, ZERO
9D00BFB0  8FA601D8   LW A2, 472(SP)
9D00BFB4  8FA701DC   LW A3, 476(SP)
9D00BFB8  00402025   OR A0, V0, ZERO
9D00BFBC  0F404121   JAL dpmul
9D00BFC0  00602825   OR A1, V1, ZERO
9D00BFC4  00402025   OR A0, V0, ZERO
9D00BFC8  0F405C91   JAL __fixunsdfsi
9D00BFCC  00602825   OR A1, V1, ZERO
9D00BFD0  8FA901E0   LW T1, 480(SP)
9D00BFD4  AD22000C   SW V0, 12(T1)
9D00BFD8  8D29000C   LW T1, 12(T1)
9D00BFDC  01202025   OR A0, T1, ZERO
9D00BFE0  0F406165   JAL __floatunsidf
9D00BFE4  AFA901E0   SW T1, 480(SP)
9D00BFE8  8FA601C8   LW A2, 456(SP)
9D00BFEC  8FA701CC   LW A3, 460(SP)
9D00BFF0  00402025   OR A0, V0, ZERO
9D00BFF4  0F404121   JAL dpmul
9D00BFF8  00602825   OR A1, V1, ZERO
9D00BFFC  8FA401C4   LW A0, 452(SP)
9D00C000  00602825   OR A1, V1, ZERO
9D00C004  8C868A50   LW A2, -30128(A0)
9D00C008  8C878A54   LW A3, -30124(A0)
9D00C00C  0F403B37   JAL dpdiv
9D00C010  00402025   OR A0, V0, ZERO
9D00C014  8FA901E0   LW T1, 480(SP)
9D00C018  27848010   ADDIU A0, GP, -32752
9D00C01C  3C059D01   LUI A1, -25343
9D00C020  AFA40014   SW A0, 20(SP)
9D00C024  AFA90010   SW T1, 16(SP)
9D00C028  00403025   OR A2, V0, ZERO
9D00C02C  00603825   OR A3, V1, ZERO
9D00C030  24A52544   ADDIU A1, A1, 9540
9D00C034  0F406357   JAL __wrap_sprintf
9D00C038  27A40030   ADDIU A0, SP, 48
9D00C03C  1000FE38   BEQ ZERO, ZERO, 0x9D00B920
9D00C040  83A20030   LB V0, 48(SP)
9D00C044  27A601B8   ADDIU A2, SP, 440
9D00C048  24A52554   ADDIU A1, A1, 9556
9D00C04C  27A40130   ADDIU A0, SP, 304
9D00C050  0F405DD6   JAL isCmd
9D00C054  AFA001B8   SW ZERO, 440(SP)
9D00C058  1040002C   BEQ V0, ZERO, isCmd
9D00C05C  3C059D01   LUI A1, -25343
9D00C060  27A401B8   ADDIU A0, SP, 440
9D00C064  27A501B4   ADDIU A1, SP, 436
9D00C068  0F40532C   JAL getParam
9D00C06C  AFA001B0   SW ZERO, 432(SP)
9D00C070  8FA401B4   LW A0, 436(SP)
9D00C074  50800035   BEQL A0, ZERO, 0x9D00C14C
9D00C07C  0F40605B   JAL paramToInt
9D00C084  3C09A000   LUI T1, -24576
9D00C088  10400003   BEQ V0, ZERO, 0x9D00C098
9D00C08C  25292E00   ADDIU T1, T1, 11776
9D00C090  8FA201B0   LW V0, 432(SP)
9D00C094  AD220010   SW V0, 16(T1)
9D00C098  8D250010   LW A1, 16(T1)
9D00C09C  00A02025   OR A0, A1, ZERO
9D00C0A0  0F4060CD   JAL __floatunsisf
9D00C0A4  AFA501E0   SW A1, 480(SP)
9D00C0A8  0F405A56   JAL __extendsfdf2
9D00C0AC  00402025   OR A0, V0, ZERO
9D00C0B0  8FA501E0   LW A1, 480(SP)
9D00C0B4  27848010   ADDIU A0, GP, -32752
9D00C0B8  AFA40014   SW A0, 20(SP)
9D00C0BC  AFA50010   SW A1, 16(SP)
9D00C0C0  3C059D01   LUI A1, -25343
9D00C0C4  00403025   OR A2, V0, ZERO
9D00C0C8  00603825   OR A3, V1, ZERO
9D00C0CC  24A52560   ADDIU A1, A1, 9568
9D00C0D0  0F406357   JAL __wrap_sprintf
9D00C0D4  27A40030   ADDIU A0, SP, 48
9D00C0D8  1000FE11   BEQ ZERO, ZERO, 0x9D00B920
9D00C0DC  83A20030   LB V0, 48(SP)
9D00C0E0  0F402D06   JAL Debug_Disable
9D00C0E4  00000000   NOP
9D00C0E8  3C059D01   LUI A1, -25343
9D00C0EC  27868010   ADDIU A2, GP, -32752
9D00C0F0  24A5250C   ADDIU A1, A1, 9484
9D00C0F4  0F406357   JAL __wrap_sprintf
9D00C0F8  27A40030   ADDIU A0, SP, 48
9D00C0FC  1000FE08   BEQ ZERO, ZERO, 0x9D00B920
9D00C100  83A20030   LB V0, 48(SP)
9D00C104  1000FFB4   BEQ ZERO, ZERO, 0x9D00BFD8
9D00C108  25292E00   ADDIU T1, T1, 11776
9D00C10C  00003025   OR A2, ZERO, ZERO
9D00C110  24A52570   ADDIU A1, A1, 9584
9D00C114  0F405DD6   JAL isCmd
9D00C118  27A40130   ADDIU A0, SP, 304
9D00C11C  5040FE00   BEQL V0, ZERO, 0x9D00B920
9D00C120  83A20030   LB V0, 48(SP)
9D00C124  8FC60008   LW A2, 8(FP)
9D00C128  8FC7000C   LW A3, 12(FP)
9D00C12C  27828010   ADDIU V0, GP, -32752
9D00C130  3C059D01   LUI A1, -25343
9D00C134  AFA20010   SW V0, 16(SP)
9D00C138  24A52578   ADDIU A1, A1, 9592
9D00C13C  0F406357   JAL __wrap_sprintf
9D00C140  27A40030   ADDIU A0, SP, 48
9D00C144  1000FDF6   BEQ ZERO, ZERO, 0x9D00B920
9D00C148  83A20030   LB V0, 48(SP)
9D00C14C  1000FFD2   BEQ ZERO, ZERO, 0x9D00C098
9D00C150  25292E00   ADDIU T1, T1, 11776
9D014CB0  8C820000   LW V0, 0(A0)
9D014CB4  10400028   BEQ V0, ZERO, getParam
9D014CB8  00000000   NOP
9D014CBC  80430000   LB V1, 0(V0)
9D014CC0  10600025   BEQ V1, ZERO, getParam
9D014CC4  24060020   ADDIU A2, ZERO, 32
9D014CC8  10000003   BEQ ZERO, ZERO, getParam
9D014CCC  2407002C   ADDIU A3, ZERO, 44
9D014CD0  AC820000   SW V0, 0(A0)
9D014CD4  80430000   LB V1, 0(V0)
9D014CD8  5066FFFD   BEQL V1, A2, getParam
9D014CDC  24420001   ADDIU V0, V0, 1
9D014CE0  5067FFFB   BEQL V1, A3, getParam
9D014CE4  24420001   ADDIU V0, V0, 1
9D014CE8  ACA20000   SW V0, 0(A1)
9D014CEC  80430000   LB V1, 0(V0)
9D014CF0  10670033   BEQ V1, A3, getParam
9D014CF4  24080001   ADDIU T0, ZERO, 1
9D014CF8  10600019   BEQ V1, ZERO, getParam::getParam
9D014CFC  00003825   OR A3, ZERO, ZERO
9D014D00  2406000D   ADDIU A2, ZERO, 13
9D014D04  10660016   BEQ V1, A2, getParam::getParam
9D014D08  24430001   ADDIU V1, V0, 1
9D014D0C  00004025   OR T0, ZERO, ZERO
9D014D10  2409002C   ADDIU T1, ZERO, 44
9D014D14  10000005   BEQ ZERO, ZERO, getParam
9D014D18  240A000D   ADDIU T2, ZERO, 13
9D014D1C  10C00010   BEQ A2, ZERO, getParam::getParam
9D014D20  24630001   ADDIU V1, V1, 1
9D014D24  10CA000E   BEQ A2, T2, getParam::getParam
9D014D28  00E04025   OR T0, A3, ZERO
9D014D2C  80660000   LB A2, 0(V1)
9D014D30  25070001   ADDIU A3, T0, 1
9D014D34  14C9FFF9   BNE A2, T1, getParam::getParam
9D014D38  00601025   OR V0, V1, ZERO
9D014D3C  25080002   ADDIU T0, T0, 2
9D014D40  A0400000   SB ZERO, 0(V0)
9D014D44  8C820000   LW V0, 0(A0)
9D014D48  00484021   ADDU T0, V0, T0
9D014D4C  00473821   ADDU A3, V0, A3
9D014D50  10000007   BEQ ZERO, ZERO, getParam
9D014D54  AC880000   SW T0, 0(A0)
9D014D58  03E00008   JR RA
9D014D5C  ACA00000   SW ZERO, 0(A1)
9D014D60  A0400000   SB ZERO, 0(V0)
9D014D64  8C820000   LW V0, 0(A0)
9D014D68  AC800000   SW ZERO, 0(A0)
9D014D6C  00473821   ADDU A3, V0, A3
9D014D70  8CA30000   LW V1, 0(A1)
9D014D74  24E7FFFF   ADDIU A3, A3, -1
9D014D78  00E01025   OR V0, A3, ZERO
9D014D7C  0067382B   SLTU A3, V1, A3
9D014D80  24040020   ADDIU A0, ZERO, 32
9D014D84  10E0000C   BEQ A3, ZERO, getParam
9D014D88  2406002C   ADDIU A2, ZERO, 44
9D014D8C  80430000   LB V1, 0(V0)
9D014D90  50640004   BEQL V1, A0, getParam
9D014D94  A0400000   SB ZERO, 0(V0)
9D014D98  14660007   BNE V1, A2, getParam
9D014D9C  00000000   NOP
9D014DA0  A0400000   SB ZERO, 0(V0)
9D014DA4  8CA30000   LW V1, 0(A1)
9D014DA8  2442FFFF   ADDIU V0, V0, -1
9D014DAC  0062182B   SLTU V1, V1, V0
9D014DB0  5460FFF7   BNEL V1, ZERO, getParam
9D014DB4  80430000   LB V1, 0(V0)
9D014DB8  03E00008   JR RA
9D014DBC  00000000   NOP
9D014DC0  1000FFDF   BEQ ZERO, ZERO, getParam
9D014DC4  00003825   OR A3, ZERO, ZERO
9D017758  00001825   OR V1, ZERO, ZERO
9D01775C  24080020   ADDIU T0, ZERO, 32
9D017760  2409000D   ADDIU T1, ZERO, 13
9D017764  00831021   ADDU V0, A0, V1
9D017768  80470000   LB A3, 0(V0)
9D01776C  00A31021   ADDU V0, A1, V1
9D017770  10E80005   BEQ A3, T0, isCmd.part.1
9D017774  80420000   LB V0, 0(V0)
9D017778  14E00009   BNE A3, ZERO, isCmd.part.1
9D01777C  00000000   NOP
9D017780  03E00008   JR RA
9D017784  2C420001   SLTIU V0, V0, 1
9D017788  1040000B   BEQ V0, ZERO, isCmd.part.1
9D01778C  00000000   NOP
9D017790  10E2FFF4   BEQ A3, V0, isCmd.part.1
9D017794  24630001   ADDIU V1, V1, 1
9D017798  03E00008   JR RA
9D01779C  00001025   OR V0, ZERO, ZERO
9D0177A0  14E9FFFB   BNE A3, T1, isCmd.part.1
9D0177A4  00000000   NOP
9D0177A8  1440FFF9   BNE V0, ZERO, isCmd.part.1
9D0177AC  00000000   NOP
9D0177B0  03E00008   JR RA
9D0177B4  24020001   ADDIU V0, ZERO, 1
9D0177B8  10C0FFFD   BEQ A2, ZERO, isCmd.part.1
9D0177BC  24630001   ADDIU V1, V1, 1
9D0177C0  00831821   ADDU V1, A0, V1
9D0177C4  ACC30000   SW V1, 0(A2)
9D0177C8  03E00008   JR RA
9D0177CC  24020001   ADDIU V0, ZERO, 1
9D01816C  27BDFFE0   ADDIU SP, SP, -32
9D018174  2406000A   ADDIU A2, ZERO, 10
9D018178  00A08025   OR S0, A1, ZERO
9D01817C  AFBF001C   SW RA, 28(SP)
9D018180  0F4062C9   JAL strtol
9D018184  27A50010   ADDIU A1, SP, 16
9D018188  8FA30010   LW V1, 16(SP)
9D01818C  80630000   LB V1, 0(V1)
9D018190  10600005   BEQ V1, ZERO, paramToInt.part.2
9D018194  8FBF001C   LW RA, 28(SP)
9D018198  00001025   OR V0, ZERO, ZERO
9D01819C  8FB00018   LW S0, 24(SP)
9D0181A0  03E00008   JR RA
9D0181A4  27BD0020   ADDIU SP, SP, 32
9D0181A8  AE020000   SW V0, 0(S0)
9D0181AC  24020001   ADDIU V0, ZERO, 1
9D0181B0  8FB00018   LW S0, 24(SP)
9D0181B4  03E00008   JR RA
9D0181B8  27BD0020   ADDIU SP, SP, 32
9D018D0C  3C04A000   LUI A0, -24576
9D018D10  27BDFFE8   ADDIU SP, SP, -24
9D018D14  24060050   ADDIU A2, ZERO, 80
9D018D18  00002825   OR A1, ZERO, ZERO
9D018D1C  AFBF0014   SW RA, 20(SP)
9D018D20  0F405B7D   JAL memset
9D018D24  24842CC8   ADDIU A0, A0, 11464
9D018D28  8FBF0014   LW RA, 20(SP)
9D018D2C  0B405EB4   J CORETIMER_Start
9D018D30  27BD0018   ADDIU SP, SP, 24
---  D:/MPLABX/v6.05/packs/Microchip/PIC32MX_DFP/1.5.259/xc32/startup/crt0.S  ---------------------------
                                                  1:     /*********************************************************************
                                                  2:      *
                                                  3:      *                  C Runtime Startup
                                                  4:      *
                                                  5:      *********************************************************************
                                                  6:      * Filename:        crt0.S
                                                  7:      *
                                                  8:      * Processor:       PIC32
                                                  9:      *
                                                  10:     * Compiler:        MPLAB XC32
                                                  11:     *                  MPLAB X IDE
                                                  12:     * Company:         Microchip Technology Inc.
                                                  13:     *
                                                  14:     * Software License Agreement
                                                  15:     *
                                                  16:     * Copyright (c) 2014, Microchip Technology Inc. and its subsidiaries ("Microchip")
                                                  17:     * All rights reserved.
                                                  18:     *
                                                  19:     * This software is developed by Microchip Technology Inc. and its
                                                  20:     * subsidiaries ("Microchip").
                                                  21:     *
                                                  22:     * Redistribution and use in source and binary forms, with or without
                                                  23:     * modification, are permitted provided that the following conditions are met:
                                                  24:     *
                                                  25:     * 1.      Redistributions of source code must retain the above copyright
                                                  26:     * notice, this list of conditions and the following disclaimer.
                                                  27:     *
                                                  28:     * 2.      Redistributions in binary form must reproduce the above copyright
                                                  29:     * notice, this list of conditions and the following disclaimer in the
                                                  30:     * documentation and/or other materials provided with the distribution.
                                                  31:     * Publication is not required when this file is used in an embedded 
                                                  32:     * application.
                                                  33:     *
                                                  34:     * 3.      Microchip's name may not be used to endorse or promote products
                                                  35:     * derived from this software without specific prior written permission.
                                                  36:     *
                                                  37:     * THIS SOFTWARE IS PROVIDED BY MICROCHIP "AS IS" AND ANY EXPRESS OR IMPLIED
                                                  38:     * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
                                                  39:     * MERCHANTABILITY AND FITNESS FOR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
                                                  40:     * MICROCHIP BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                                                  41:     * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING BUT NOT LIMITED TO
                                                  42:     * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA OR PROFITS;
                                                  43:     * OR BUSINESS INTERRUPTION) HOWSOEVER CAUSED AND ON ANY THEORY OF LIABILITY,
                                                  44:     * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
                                                  45:     * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
                                                  46:     * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                  47:     *
                                                  48:     ********************************************************************/
                                                  49:    
                                                  50:    #include "xc.h"
                                                  51:    #include <cp0defs.h>
                                                  52:    
                                                  53:    #ifdef __LIBBUILD__
                                                  54:       # Replace the standard debugging information with a simple filename. This
                                                  55:       # prevents the library build directory from showing up in MPLAB IDE. It
                                                  56:       # also effectively disables source-line debugging.
                                                  57:       .file 1 "libpic32/startup/crt0.S"
                                                  58:       .loc 1 0
                                                  59:    #endif
                                                  60:    
                                                  61:    #if (__XC32_VERSION > 1000) && !defined(CPP_INIT)
                                                  62:    #define CPP_INIT
                                                  63:    #endif
                                                  64:    
                                                  65:    #if !defined(PIC32_SRS_SET_COUNT)
                                                  66:    #  if defined(__PIC32_SRS_SET_COUNT)
                                                  67:    #    define PIC32_SRS_SET_COUNT __PIC32_SRS_SET_COUNT
                                                  68:    #  else
                                                  69:    #    warning PIC32_SRS_SET_COUNT not defined on build line
                                                  70:    #    define PIC32_SRS_SET_COUNT 2
                                                  71:    #  endif
                                                  72:    #endif
                                                  73:    
                                                  74:    #if defined(__PIC32MX) || defined(__PIC32MM) || defined(__PIC32MZ)
                                                  75:    #define INIT_DATA 1
                                                  76:    #endif
                                                  77:    
                                                  78:    /* This file contains 32-bit assembly code */
                                                  79:           .set nomips16
                                                  80:    
                                                  81:            ##################################################################
                                                  82:            # Entry point of the entire application
                                                  83:            ##################################################################
                                                  84:            .section .reset,code,keep
                                                  85:            .align 2
                                                  86:            .set noreorder
                                                  87:            .ent _reset
                                                  88:    
                                                  89:    ############################
                                                  90:    # Begin ISA switching code #
                                                  91:    ############################
                                                  92:    
                                                  93:    #if defined (__mips_micromips)
                                                  94:            .set micromips
                                                  95:    #endif
                                                  96:    
                                                  97:    #if (defined(__PIC32_HAS_MICROMIPS)) && (defined(__PIC32_HAS_MIPS32R2))
                                                  98:    _reset:
                                                  99:            .word 0x10000003     /* MIPS32:    branch forward 0x10 bytes from here  */
                                                  100:                                /* MicroMIPS: ADDI32 $0, $0, 0x0007 (nop)          */
                                                  101:                                /* DO NOT change the relative branch               */
                                                  102:   
                                                  103:           .word 0x00000000     /* NOP */
                                                  104:   __reset_micromips_isa:
                                                  105:           .set    micromips
                                                  106:           jal     _startup
                                                  107:           nop
                                                  108:   
                                                  109:           .align 2
                                                  110:           /* Device not in proper ISA mode */
                                                  111:           .set nomicromips
                                                  112:   __reset_switch_isa:
                                                  113:           jal _startup
                                                  114:           nop
                                                  115:   
                                                  116:   #else
                                                  117:   
                                                  118:   _reset:
BD00A000  0F402802   JAL 0xBD00A008               119:           jal _startup
BD00A004  00000000   NOP                          120:           nop
                                                  121:   
                                                  122:   #endif  /* __PIC32_HAS_MICROMIPS */
                                                  123:   
                                                  124:           .align 2
                                                  125:           .end _reset
                                                  126:           .globl _reset
                                                  127:           .size _reset, .-_reset
                                                  128:   
                                                  129:           .section .reset.startup,code,keep
                                                  130:           .align 2
                                                  131:           .set noreorder
                                                  132:   
                                                  133:   #if defined (__mips_micromips)
                                                  134:           .set micromips
                                                  135:   #else
                                                  136:           .set nomicromips
                                                  137:   #endif
                                                  138:   
                                                  139:   ############################
                                                  140:   # End ISA switching code   #
                                                  141:   ############################
                                                  142:   
                                                  143:           ##################################################################
                                                  144:           # Startup code
                                                  145:           ##################################################################
                                                  146:           .align 2
                                                  147:           .globl _startup
                                                  148:           .set noreorder
                                                  149:           .ent _startup
                                                  150:   _startup:
                                                  151:           ##################################################################
                                                  152:           # If entered because of an NMI, jump to the NMI handler.
                                                  153:           ##################################################################
BD00A008  401A6000   MFC0 K0, Status              154:           mfc0    k0,_CP0_STATUS
BD00A00C  7F5A04C0   EXT K0, K0, 19, 1            155:           ext     k0,k0,19,1              # Extract NMI bit
BD00A010  13400005   BEQ K0, ZERO, 0xBD00A028     156:           beqz    k0,_no_nmi
BD00A014  00000000   NOP                          157:           nop
BD00A018  3C1A9D01   LUI K0, -25343               158:           la      k0,_nmi_handler
BD00A020  03400008   JR K0                        159:           jr      k0
BD00A024  00000000   NOP                          160:           nop
                                                  161:   _no_nmi:
                                                  162:   
                                                  163:           ##################################################################
                                                  164:           # Initialize Stack Pointer
                                                  165:           #   _stack is initialized by the linker script to point to the
                                                  166:           #    starting location of the stack in DRM
                                                  167:           ##################################################################
BD00A028  3C1DA001   LUI SP, -24575               168:           la      sp,_stack
                                                  169:   
                                                  170:           ##################################################################
                                                  171:           # Initialize Global Pointer
                                                  172:           #   _gp is initialized by the linker script to point to "middle"
                                                  173:           #   of the small variables region
                                                  174:           ##################################################################
BD00A030  3C1CA001   LUI GP, -24575               175:           la      gp,_gp
                                                  176:   
                                                  177:   #if (PIC32_SRS_SET_COUNT == 2)
                                                  178:           ##################################################################
                                                  179:           # Initialize Global Pointer in Shadow Set
                                                  180:           #   The SRSCtl's PSS field must be set to the shadow set in which
                                                  181:           #   to initialize the global pointer.  Since we have only a
                                                  182:           #   single shadow set (besides the normal), we will initialize
                                                  183:           #   SRSCtl<PSS> to SRSCtl<HSS>.  We then write the global pointer
                                                  184:           #   to the previous shadow set to ensure that on interrupt, the
                                                  185:           #   global pointer has been initialized.
                                                  186:           ##################################################################
                                                  187:           mfc0    t1,_CP0_SRSCTL          # Read SRSCtl register
                                                  188:           add     t3,t1,zero              # Save off current SRSCtl
                                                  189:           ext     t2,t1,26,4              # to obtain HSS field
                                                  190:           ins     t1,t2,6,4               # Put HSS field
                                                  191:           mtc0    t1,_CP0_SRSCTL          # into SRSCtl<PSS>
                                                  192:           ehb                             # Clear hazard before using new SRSCTL
                                                  193:           wrpgpr  gp,gp                   # Set global pointer in PSS
                                                  194:           mtc0    t3,_CP0_SRSCTL          # Restore SRSCtl
                                                  195:           ehb
                                                  196:   
                                                  197:   #elif (PIC32_SRS_SET_COUNT > 2)
                                                  198:           ##################################################################
                                                  199:           # Initialize Global Pointer in Shadow Set(s)
                                                  200:           #   The SRSCtl PSS field must be set to the shadow set in which
                                                  201:           #   to initialize the global pointer.  We will initialize
                                                  202:           #   SRSCtl<PSS> to the number of reg sets and work down to set zero.
                                                  203:           #   We write the global pointer to the previous shadow set to
                                                  204:           #   ensure that on interrupt, the global pointer has been
                                                  205:           #   initialized.
                                                  206:           ##################################################################
                                                  207:           mfc0    t1,_CP0_SRSCTL          # Read SRSCtl register
                                                  208:           add     t3,t1,zero              # Save off current SRSCtl
                                                  209:   
                                                  210:           li      t2,(PIC32_SRS_SET_COUNT-1)
                                                  211:   
                                                  212:   1:      ins     t1,t2,6,4               # Put next shadow set field
                                                  213:           mtc0    t1,_CP0_SRSCTL          # into SRSCtl<PSS>
                                                  214:           ehb                             # Clear hazard before using new SRSCTL
                                                  215:           wrpgpr  gp,gp                   # Set global pointer in PSS
                                                  216:   
                                                  217:           addiu   t2,t2,-1                # Next lower shadow set
                                                  218:                                           # Loop for all sets
                                                  219:           bne     t2,$0,1b                # Down to zero (normal GPR set)
                                                  220:           nop
                                                  221:   
                                                  222:           mtc0    t3,_CP0_SRSCTL          # Restore SRSCtl
                                                  223:           ehb
                                                  224:   
                                                  225:   #endif /* (PIC32_SRS_SET_COUNT > 2) */
                                                  226:   
                                                  227:           ##################################################################
                                                  228:           # Call the "on reset" procedure
                                                  229:           ##################################################################
BD00A038  3C089D01   LUI T0, -25343               230:           la      t0,_on_reset
BD00A040  0100F809   JALR T0                      231:           jalr    t0
BD00A044  00000000   NOP                          232:           nop
                                                  233:   
                                                  234:   #if defined(INIT_MMU_MZ_FIXED) || defined(__PIC32_HAS_MMU_MZ_FIXED)
                                                  235:           ##################################################################
                                                  236:           # Initialize TLB for fixed mapping to EBI and SQI
                                                  237:           ##################################################################
                                                  238:           .extern __pic32_tlb_init_ebi_sqi
                                                  239:           la      t0,__pic32_tlb_init_ebi_sqi
                                                  240:           jalr    t0
                                                  241:           nop
                                                  242:   #endif
                                                  243:   
                                                  244:           ##################################################################
                                                  245:           # Clear uninitialized data sections
                                                  246:           ##################################################################
                                                  247:   _start_bss_init:
BD00A048  3C08A000   LUI T0, -24576               248:           la      t0,_bss_begin
BD00A050  3C09A000   LUI T1, -24576               249:           la      t1,_bss_end
BD00A058  10000003   BEQ ZERO, ZERO, 0xBD00A068   250:           b       _bss_check
BD00A05C  00000000   NOP                          251:           nop
                                                  252:   
                                                  253:   _bss_init:
BD00A060  AD000000   SW ZERO, 0(T0)               254:           sw      zero,0x0(t0)
BD00A064  25080004   ADDIU T0, T0, 4              255:           addu    t0,4
                                                  256:   _bss_check:
BD00A068  0109082B   SLTU AT, T0, T1              257:           bltu    t0,t1,_bss_init
BD00A070  00000000   NOP                          258:           nop
                                                  259:   
                                                  260:   #if defined(INIT_L1_CACHE) || defined(__PIC32_HAS_L1CACHE)
                                                  261:           ##################################################################
                                                  262:           # Initialize L1 cache. This must be done after bss clearing
                                                  263:           # since the _bss_end symbol may not be cache-line aligned.
                                                  264:           ##################################################################
                                                  265:           .extern   __pic32_init_cache
                                                  266:           la      t0,__pic32_init_cache
                                                  267:           jalr    t0
                                                  268:           nop
                                                  269:   #endif
                                                  270:   
                                                  271:   #if defined(INIT_DATA) || defined(__PIC32_HAS_INIT_DATA)
                                                  272:   
                                                  273:   #if defined(__LIBBUILD__) /* Prebuilt crt0.o file */
                                                  274:   
                                                  275:           ##################################################################
                                                  276:           # Initialize data using the linker-generated .dinit table
                                                  277:           # For use with XC32 versions prior to XC32 v2.10 only.
                                                  278:           ##################################################################
                                                  279:           .equiv FMT_CLEAR,0
                                                  280:           .equiv FMT_COPY,1
                                                  281:   _dinit_init:
                                                  282:           la      t0,_dinit_addr
                                                  283:   
                                                  284:   #define SRC t0
                                                  285:   #define DST t1
                                                  286:   #define LEN t2
                                                  287:   #define FMT t3
                                                  288:   
                                                  289:   0:      lw      DST,0(SRC)
                                                  290:           beqz    DST,9f
                                                  291:           addu    SRC,4
                                                  292:           lw      LEN,0(SRC)
                                                  293:           addu    SRC,4
                                                  294:           lw      FMT,0(SRC)
                                                  295:           beq     FMT,$0,_dinit_clear
                                                  296:           addu    SRC,4
                                                  297:   
                                                  298:   _dinit_copy:
                                                  299:           lbu     t4,0(SRC)
                                                  300:           subu    LEN,1
                                                  301:           addu    SRC,1
                                                  302:           sb      t4,0(DST)
                                                  303:           bne     LEN,$0,_dinit_copy
                                                  304:           addu    DST,1
                                                  305:   
                                                  306:           b       _dinit_end
                                                  307:           nop
                                                  308:   
                                                  309:   _dinit_clear:
                                                  310:           sb      $0,(DST)
                                                  311:           subu    LEN,1
                                                  312:           bne     LEN,$0,_dinit_clear
                                                  313:           addu    DST,1
                                                  314:   
                                                  315:   _dinit_end:
                                                  316:           addu    SRC,3
                                                  317:           addiu   LEN,$0,-4
                                                  318:           and     SRC,LEN,SRC
                                                  319:           lw      DST,0(SRC)
                                                  320:           bne     DST,$0,0b
                                                  321:           nop
                                                  322:   9:
                                                  323:   
                                                  324:   #else
                                                  325:           #####################################################################
                                                  326:           # Initialize data using the linker-generated .dinit table
                                                  327:           # XC32 v2.10 and later provide the data-init code in a separate file
                                                  328:           # packaged with the compiler rather than the DFP. Use that init
                                                  329:           # code instead.
                                                  330:           #####################################################################
                                                  331:           .extern   __pic32_data_init
BD00A074  3C089D02   LUI T0, -25342               332:           la      t0, __pic32_data_init
BD00A07C  0100F809   JALR T0                      333:           jalr    t0
BD00A080  00000000   NOP                          334:           nop
                                                  335:   
                                                  336:   #if defined(_OFF168_VOFF_POSITION)
                                                  337:           lui	t1,%hi(OFF168)
                                                  338:           lui	t2,%hi(__vector_offset_168)
                                                  339:           addiu	t2,t2,%lo(__vector_offset_168)
                                                  340:           sw	t2,%lo(OFF168)(t1)
                                                  341:   #endif
                                                  342:   
                                                  343:   #endif /* __LIBBUILD__ */
                                                  344:   
                                                  345:   #endif /* INIT_DATA */
                                                  346:   
                                                  347:           ##################################################################
                                                  348:           # If there are no RAM functions, skip the next section --
                                                  349:           # initializing bus matrix registers.
                                                  350:           ##################################################################
BD00A084  3C090000   LUI T1, 0                    351:           la      t1,_ramfunc_begin
BD00A08C  11200010   BEQ T1, ZERO, 0xBD00A0D0     352:           beqz    t1,_ramfunc_done
BD00A090  00000000   NOP                          353:           nop
                                                  354:   
                                                  355:   #if defined(INIT_SSX) || defined(__PIC32_HAS_SSX)
                                                  356:     /* No initialization required */
                                                  357:   #else /* Use BMX */
                                                  358:           ##################################################################
                                                  359:           # Initialize bus matrix registers if RAM functions exist in the
                                                  360:           # application
                                                  361:           ##################################################################
BD00A094  3C090001   LUI T1, 1                    362:           la      t1,_bmxdkpba_address
BD00A09C  3C0ABF88   LUI T2, -16504               363:           la      t2,BMXDKPBA
BD00A0A4  AD490000   SW T1, 0(T2)                 364:           sw      t1,0(t2)
BD00A0A8  3C090001   LUI T1, 1                    365:           la      t1,_bmxdudba_address
BD00A0B0  3C0ABF88   LUI T2, -16504               366:           la      t2,BMXDUDBA
BD00A0B8  AD490000   SW T1, 0(T2)                 367:           sw      t1,0(t2)
BD00A0BC  3C090001   LUI T1, 1                    368:           la      t1,_bmxdupba_address
BD00A0C4  3C0ABF88   LUI T2, -16504               369:           la      t2,BMXDUPBA
BD00A0CC  AD490000   SW T1, 0(T2)                 370:           sw      t1,0(t2)
                                                  371:   #endif /* INIT_SSX */
                                                  372:   
                                                  373:   _ramfunc_done:
                                                  374:   
                                                  375:           ##################################################################
                                                  376:           # Initialize CP0 registers
                                                  377:           ##################################################################
                                                  378:           # Initialize Count register
                                                  379:           ##################################################################
BD00A0D0  40804800   MTC0 ZERO, Count             380:           mtc0    zero,_CP0_COUNT
                                                  381:   
                                                  382:           ##################################################################
                                                  383:           # Initialize Compare register
                                                  384:           ##################################################################
BD00A0D4  240AFFFF   ADDIU T2, ZERO, -1           385:           li      t2,-1
BD00A0D8  408A5800   MTC0 T2, Compare             386:           mtc0    t2,_CP0_COMPARE
                                                  387:   
                                                  388:           ##################################################################
                                                  389:           # Ensure BEV set and Initialize EBase register
                                                  390:           ##################################################################
BD00A0DC  3C080040   LUI T0, 64                   391:           li      t0, (1<<22)
BD00A0E0  400A6000   MFC0 T2, Status              392:           mfc0    t2,_CP0_STATUS
BD00A0E4  010A5025   OR T2, T0, T2                393:           or      t2,t0,t2               # Set BEV bit 22
BD00A0E8  408A6000   MTC0 T2, Status              394:           mtc0    t2,_CP0_STATUS
                                                  395:   
BD00A0EC  3C099D01   LUI T1, -25343               396:           la      t1,_ebase_address
BD00A0F4  000000C0   EHB                          397:           ehb
BD00A0F8  40897801   MTC0 T1, EBase               398:           mtc0    t1,_CP0_EBASE
                                                  399:           
                                                  400:           ##################################################################
                                                  401:           # Initialize PRISS register to a safer default for devices that 
                                                  402:           # have it. The application should re-initialize it to an
                                                  403:           # application-specific value.
                                                  404:           #
                                                  405:           # We do NOT do this by default.
                                                  406:           ##################################################################
                                                  407:   #if defined(USE_DEFAULT_PRISS_VALUE) 
                                                  408:   #if defined(_PRISS_PRI7SS_POSITION)
                                                  409:   #if (PIC32_SRS_SET_COUNT >= 7)
                                                  410:           li	    t2, 0x76540000
                                                  411:           addiu	t2, t2, 0x3210
                                                  412:           lui	    t1, %hi(PRISS)
                                                  413:           sw	    t2, %lo(PRISS)(t1)
                                                  414:   #elif (PIC32_SRS_SET_COUNT <= 2)
                                                  415:           li	    t2, 0x10000000
                                                  416:           lui	    t1, %hi(PRISS)
                                                  417:           sw	    t2, %lo(PRISS)(t1)
                                                  418:   #endif /* PIC32_SRS_SET_COUNT */
                                                  419:   #endif /* _PRISS_PRI7SS_POSITION */
                                                  420:   #endif /* USE_DEFAULT_PRISS_VALUE */
                                                  421:           
                                                  422:           ##################################################################
                                                  423:           # Initialize IntCtl/INTCON.VS register with _vector_spacing
                                                  424:           ##################################################################
BD00A0FC  3C090000   LUI T1, 0                    425:           la      t1,_vector_spacing
                                                  426:   #if defined(INIT_INTCONVS) || defined(__PIC32_HAS_INTCONVS)
                                                  427:           la      t0, INTCON
                                                  428:           lw      t2, 0(t0)
                                                  429:           li      t2, 0
                                                  430:           ins     t2, t1, 16, 7
                                                  431:   #if defined(__PIC32MM) && defined(_INTCON_MVEC_MASK)
                                                  432:           ori     t2, t2, _INTCON_MVEC_MASK
                                                  433:   #endif
                                                  434:           sw      t2, 0(t0)
                                                  435:   #endif
BD00A104  240A0000   ADDIU T2, ZERO, 0            436:           li      t2,0                    # Clear t2 and
BD00A108  7D2A4944   INS T2, T1, 5, 5             437:           ins     t2,t1,5,5               # shift value to VS field
BD00A10C  408A6001   MTC0 T2, IntCtl              438:           mtc0    t2,_CP0_INTCTL
                                                  439:   
                                                  440:           ##################################################################
                                                  441:           # Initialize CAUSE registers
                                                  442:           # - Enable counting of Count register <DC = 0>
                                                  443:           # - Use special exception vector <IV = 1>
                                                  444:           # - Clear pending software interrupts <IP1:IP0 = 0>
                                                  445:           ##################################################################
BD00A110  3C090080   LUI T1, 128                  446:           li      t1,0x00800000
BD00A114  40896800   MTC0 T1, Cause               447:           mtc0    t1,_CP0_CAUSE
                                                  448:   
                                                  449:           ##################################################################
                                                  450:           # Initialize STATUS register
                                                  451:           # - Access to Coprocessor 0 not allowed in user mode <CU0 = 0>
                                                  452:           # - User mode uses configured endianness <RE = 0>
                                                  453:           # - Preserve Bootstrap Exception vectors <BEV>
                                                  454:           # - Preserve soft reset <SR> and non-maskable interrupt <NMI>
                                                  455:           # - CorExtend enabled based on whether CorExtend User Defined
                                                  456:           #   Instructions have been implemented <CEE = Config<UDI>>
                                                  457:           # - Disable any pending interrupts <IM7..IM2 = 0, IM1..IM0 = 0>
                                                  458:           # - Disable hardware interrupts <IPL7:IPL2 = 0>
                                                  459:           # - Base mode is Kernel mode <UM = 0>
                                                  460:           # - Error level is normal <ERL = 0>
                                                  461:           # - Exception level is normal <EXL = 0>
                                                  462:           # - Interrupts are disabled <IE = 0>
                                                  463:           # - DSPr2 ASE is enabled for devices that support it <MX = 1>
                                                  464:           # - FPU64 is enabled for devices that support it <CU1=1> & <FR=1>
                                                  465:           ##################################################################
BD00A118  40088000   MFC0 T0, Config              466:           mfc0    t0,_CP0_CONFIG
BD00A11C  7D090580   EXT T1, T0, 22, 1            467:           ext     t1,t0,22,1              # Extract UDI from Config register
BD00A120  00094C40   SLL T1, T1, 17               468:           sll     t1,t1,17                # Move UDI to Status.CEE location
BD00A124  40086000   MFC0 T0, Status              469:           mfc0    t0,_CP0_STATUS
BD00A128  3C010058   LUI AT, 88                   470:           and     t0,t0,0x00580000        # Preserve SR, NMI, and BEV
                                                  471:   #if defined(INIT_DSPR2) || defined(__PIC32_HAS_DSPR2)
                                                  472:           li      t2, 0x01000000          # Set the Status.MX bit to enable DSP
                                                  473:           or      t0,t2,t0
                                                  474:   #endif
                                                  475:   #if defined(INIT_FPU64) || defined(__PIC32_HAS_FPU64)
                                                  476:           li      t2, 0x24000000          # Set the Status.CU1 and Status.FR bits to
                                                  477:           or      t0,t2,t0                # enable the FPU in FR64 mode
                                                  478:   #endif
                                                  479:   
BD00A130  01284025   OR T0, T1, T0                480:           or      t0,t1,t0                # Include Status.CEE (from UDI)
BD00A134  40886000   MTC0 T0, Status              481:           mtc0    t0,_CP0_STATUS
                                                  482:           
                                                  483:   #if defined(PIC32WK) && defined(_CP0_CONFIG3) && defined (__mips_micromips)
                                                  484:           # Ensure that the ISAONEXEC bit is set for the microMIPS ISA for the PIC32WK family
                                                  485:           # _bsc0 (_CP0_CONFIG3, _CP0_CONFIG3_SELECT, ISAONEXEC_MASK)
                                                  486:           li      t1,0x10000              # ISAONEXEC bit
                                                  487:           mfc0    t0,_CP0_CONFIG3
                                                  488:           or      t1,t0,t1
                                                  489:           mtc0    t1,_CP0_CONFIG3
                                                  490:   
                                                  491:   #endif /* PIC32WK && __mips_micromips */
                                                  492:   
                                                  493:   #if defined(INIT_FPU64) || defined(__PIC32_HAS_FPU64)
                                                  494:                                           # FPU Control and Status
                                                  495:           li      t2,0x1000000            # FCSR: RM=0, FS=1, FO=0, FN=0
                                                  496:                                           # Enables: 0b00000 E=1, V=0, Z=0, O=0, U=0, I=0
                                                  497:           ctc1    t2, $31                 # High perf on denormal operands & tiny results
                                                  498:   #endif
BD00A138  000000C0   EHB                          499:           ehb
                                                  500:   
                                                  501:           ##################################################################
                                                  502:           # Call the "on bootstrap" procedure
                                                  503:           ##################################################################
BD00A13C  3C089D01   LUI T0, -25343               504:           la      t0,_on_bootstrap
BD00A144  0100F809   JALR T0                      505:           jalr    t0
BD00A148  00000000   NOP                          506:           nop
                                                  507:   
                                                  508:           ##################################################################
                                                  509:           # Initialize Status<BEV> for normal exception vectors
                                                  510:           ##################################################################
BD00A14C  40086000   MFC0 T0, Status              511:           mfc0    t0,_CP0_STATUS
BD00A150  3C01FFBF   LUI AT, -65                  512:           and     t0,t0,0xffbfffff        # Clear BEV
BD00A15C  40886000   MTC0 T0, Status              513:           mtc0    t0,_CP0_STATUS
                                                  514:   
                                                  515:           ##################################################################
                                                  516:           # Call main. We do this via a thunk in the text section so that
                                                  517:           # a normal jump and link can be used, enabling the startup code
                                                  518:           # to work properly whether main is written in MIPS16 or MIPS32
                                                  519:           # code. I.e., the linker will correctly adjust the JAL to JALX if
                                                  520:           # necessary
                                                  521:           ##################################################################
BD00A160  30840000   ANDI A0, A0, 0               522:           and     a0,a0,0
BD00A164  30A50000   ANDI A1, A1, 0               523:           and     a1,a1,0
BD00A168  3C089D01   LUI T0, -25343               524:           la      t0,_main_entry
BD00A170  01000008   JR T0                        525:           jr      t0
BD00A174  00000000   NOP                          526:           nop
                                                  527:   
                                                  528:           .end _startup
                                                  529:   
                                                  530:           ##################################################################
                                                  531:           # Boot Exception Vector Handler
                                                  532:           # Jumps to _bootstrap_exception_handler
                                                  533:           ##################################################################
                                                  534:           .section .bev_handler,code,keep
                                                  535:           .align 2
                                                  536:           .set noreorder
                                                  537:           .ent _bev_exception
                                                  538:   _bev_exception:
9D00B3E8  3C1A9D01   LUI K0, -25343               539:           la        k0,_bootstrap_exception_handler
9D00B3F0  03400008   JR K0                        540:           jr        k0
9D00B3F4  00000000   NOP                          541:           nop
                                                  542:   
                                                  543:           .end _bev_exception
                                                  544:   
                                                  545:           ##################################################################
                                                  546:           # General Exception Vector Handler
                                                  547:           # Jumps to _general_exception_context
                                                  548:           ##################################################################
                                                  549:           .section .gen_handler,code
                                                  550:           .align 2
                                                  551:           .set noreorder
                                                  552:           .ent _gen_exception
                                                  553:   _gen_exception:
9D00B180  3C1A9D01   LUI K0, -25343               554:   0:      la      k0,_general_exception_context
9D00B188  03400008   JR K0                        555:           jr      k0
9D00B18C  00000000   NOP                          556:           nop
                                                  557:   
                                                  558:           .end _gen_exception
                                                  559:   
                                                  560:   #if defined(INIT_MMU_MZ_FIXED) || defined(__PIC32_HAS_MMU_MZ_FIXED)
                                                  561:           ##################################################################
                                                  562:           # Simple TLB-Refill Exception Vector
                                                  563:           # Jumps to _simple_tlb_refill_exception_context
                                                  564:           ##################################################################
                                                  565:           .section .simple_tlb_refill_vector,code,keep
                                                  566:           .align 2
                                                  567:           .set noreorder
                                                  568:           .ent simple_tlb_refill_vector
                                                  569:   simple_tlb_refill_vector:
                                                  570:           la      k0,_simple_tlb_refill_exception_context
                                                  571:           jr      k0
                                                  572:           nop
                                                  573:   
                                                  574:           .end simple_tlb_refill_vector
                                                  575:   #endif
                                                  576:   
                                                  577:   #if defined(INIT_L1_CACHE) || defined(__PIC32_HAS_L1CACHE)
                                                  578:           ##################################################################
                                                  579:           # Cache-Error Exception Vector Handler
                                                  580:           # Jumps to _cache_err_exception_context
                                                  581:           ##################################################################
                                                  582:           .section .cache_err_vector,code,keep
                                                  583:           .align 2
                                                  584:           .set noreorder
                                                  585:           .ent _cache_err_vector
                                                  586:   _cache_err_vector:
                                                  587:           la      k0,_cache_err_exception_context
                                                  588:           jr      k0
                                                  589:           nop
                                                  590:   
                                                  591:           .end _cache_err_vector
                                                  592:   #endif
                                                  593:   
                                                  594:           .section .text.main_entry,code,keep
                                                  595:           .align 2
                                                  596:           .ent _main_entry
                                                  597:   _main_entry:
                                                  598:   
                                                  599:   #if defined(CPP_INIT)
                                                  600:           .weak _init
                                                  601:           # call .init section to run constructors etc
9D017F84  3C040000   LUI A0, 0                    602:           lui	a0,%hi(_init)
9D017F88  27BDFFE8   ADDIU SP, SP, -24            603:           addiu	sp,sp,-24
9D017F8C  24840000   ADDIU A0, A0, 0              604:           addiu	a0,a0,%lo(_init)
9D017F90  10800003   BEQ A0, ZERO, 0x9D017FA0     605:           beq	a0,$0,2f
9D017F94  AFBF0014   SW RA, 20(SP)                606:           sw	$31,20(sp)	 #,
9D017F98  0080F809   JALR A0                      607:           jalr	a0
9D017F9C  00000000   NOP                          608:           nop
                                                  609:   2:
                                                  610:   #endif
9D017FA0  30840000   ANDI A0, A0, 0               611:           and     a0,a0,0
9D017FA4  30A50000   ANDI A1, A1, 0               612:           and     a1,a1,0
                                                  613:   
                                                  614:           ##################################################################
                                                  615:   
                                                  616:           # Call main
                                                  617:           ##################################################################
9D017FA8  3C089D02   LUI T0, -25342               618:           la    	t0,main
9D017FB0  0100F809   JALR T0                      619:           jalr 	t0
9D017FB4  00000000   NOP                          620:           nop
                                                  621:   
                                                  622:   #if defined(CALL_EXIT)
                                                  623:           ##################################################################
                                                  624:           # Call exit()
                                                  625:           ##################################################################
                                                  626:           jal exit
                                                  627:           nop
                                                  628:   #endif
                                                  629:   
                                                  630:           ##################################################################
                                                  631:           # Just in case, go into infinite loop
                                                  632:           # Call a software breakpoint only with -mdebugger compiler option
                                                  633:           ##################################################################
                                                  634:           .weak __exception_handler_break
                                                  635:   __crt0_exit:
                                                  636:   1:
9D017FB8  3C029D01   LUI V0, -25343               637:           la      v0,__exception_handler_break
9D017FC0  10400003   BEQ V0, ZERO, 0x9D017FD0     638:           beq     v0,0,0f
9D017FC4  00000000   NOP                          639:           nop
9D017FC8  0040F809   JALR V0                      640:           jalr    v0
9D017FCC  00000000   NOP                          641:           nop
                                                  642:   
9D017FD0  1000FFF9   BEQ ZERO, ZERO, 0x9D017FB8   643:   0:      b       1b
9D017FD4  00000000   NOP                          644:           nop
                                                  645:   
                                                  646:           .globl __crt0_exit
                                                  647:           .end _main_entry
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/string/xc32/strstr.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D017ED8  00801025   OR V0, A0, ZERO
9D017EDC  80A40000   LB A0, 0(A1)
9D017EE0  1080000C   BEQ A0, ZERO, 0x9D017F14
9D017EE4  00000000   NOP
9D017EE8  80430000   LB V1, 0(V0)
9D017EEC  14600003   BNE V1, ZERO, 0x9D017EFC
9D017EF0  00000000   NOP
9D017EF4  03E00008   JR RA
9D017EF8  00001025   OR V0, ZERO, ZERO
9D017EFC  1483000A   BNE A0, V1, 0x9D017F28
9D017F00  24030001   ADDIU V1, ZERO, 1
9D017F04  00A33021   ADDU A2, A1, V1
9D017F08  80C60000   LB A2, 0(A2)
9D017F0C  14C00003   BNE A2, ZERO, 0x9D017F1C
9D017F10  00433821   ADDU A3, V0, V1
9D017F14  03E00008   JR RA
9D017F18  00000000   NOP
9D017F1C  80E70000   LB A3, 0(A3)
9D017F20  10E6FFF8   BEQ A3, A2, 0x9D017F04
9D017F24  24630001   ADDIU V1, V1, 1
9D017F28  1000FFEF   BEQ ZERO, ZERO, 0x9D017EE8
9D017F2C  24420001   ADDIU V0, V0, 1
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/string/xc32/stpcpy.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D018EE8  24A50001   ADDIU A1, A1, 1
9D018EEC  80A3FFFF   LB V1, -1(A1)
9D018EF0  00801025   OR V0, A0, ZERO
9D018EF4  24840001   ADDIU A0, A0, 1
9D018EF8  1460FFFB   BNE V1, ZERO, stpcpy
9D018EFC  A083FFFF   SB V1, -1(A0)
9D018F00  03E00008   JR RA
9D018F04  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/string/strcpy.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D018D84  27BDFFE8   ADDIU SP, SP, -24
9D018D88  AFB00010   SW S0, 16(SP)
9D018D8C  AFBF0014   SW RA, 20(SP)
9D018D90  0F4063BA   JAL stpcpy
9D018D94  00808025   OR S0, A0, ZERO
9D018D98  8FBF0014   LW RA, 20(SP)
9D018D9C  02001025   OR V0, S0, ZERO
9D018DA0  8FB00010   LW S0, 16(SP)
9D018DA4  03E00008   JR RA
9D018DA8  27BD0018   ADDIU SP, SP, 24
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/stdlib/mchp/strtol.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
00000010  00000000   NOP
00000014  00000000   NOP
00000018  00000000   NOP
00000020  00000000   NOP
9D016690  27BDFF78   ADDIU SP, SP, -136
9D016694  AFB20080   SW S2, 128(SP)
9D016698  AFB1007C   SW S1, 124(SP)
9D01669C  AFB00078   SW S0, 120(SP)
9D0166A0  AFBF0084   SW RA, 132(SP)
9D0166A4  00808025   OR S0, A0, ZERO
9D0166A8  00A08825   OR S1, A1, ZERO
9D0166AC  00C09025   OR S2, A2, ZERO
9D0166B0  AFA0001C   SW ZERO, 28(SP)
9D0166B4  AFA40054   SW A0, 84(SP)
9D0166B8  AFA40020   SW A0, 32(SP)
9D0166BC  04800004   BLTZ A0, strtox
9D0166C0  2402FFFF   ADDIU V0, ZERO, -1
9D0166C4  3C027FFF   LUI V0, 32767
9D0166C8  3442FFFF   ORI V0, V0, -1
9D0166CC  00821021   ADDU V0, A0, V0
9D0166D0  00002825   OR A1, ZERO, ZERO
9D0166D4  27A40018   ADDIU A0, SP, 24
9D0166D8  0F4062D4   JAL __shlim
9D0166DC  AFA20058   SW V0, 88(SP)
9D0166E0  8FA20098   LW V0, 152(SP)
9D0166E4  8FA3009C   LW V1, 156(SP)
9D0166E8  02402825   OR A1, S2, ZERO
9D0166EC  27A40018   ADDIU A0, SP, 24
9D0166F0  AFA20010   SW V0, 16(SP)
9D0166F4  AFA30014   SW V1, 20(SP)
9D0166F8  0F403671   JAL __intscan
9D0166FC  24060001   ADDIU A2, ZERO, 1
9D016700  00402025   OR A0, V0, ZERO
9D016704  12200008   BEQ S1, ZERO, strtox
9D016708  00602825   OR A1, V1, ZERO
9D01670C  8FA20058   LW V0, 88(SP)
9D016710  8FA30054   LW V1, 84(SP)
9D016714  00621823   SUBU V1, V1, V0
9D016718  8FA2006C   LW V0, 108(SP)
9D01671C  00621821   ADDU V1, V1, V0
9D016720  02038021   ADDU S0, S0, V1
9D016724  AE300000   SW S0, 0(S1)
9D016728  8FBF0084   LW RA, 132(SP)
9D01672C  00801025   OR V0, A0, ZERO
9D016730  00A01825   OR V1, A1, ZERO
9D016734  8FB20080   LW S2, 128(SP)
9D016738  8FB1007C   LW S1, 124(SP)
9D01673C  8FB00078   LW S0, 120(SP)
9D016740  03E00008   JR RA
9D016744  27BD0088   ADDIU SP, SP, 136
9D018B24  27BDFFE0   ADDIU SP, SP, -32
9D018B28  3C028000   LUI V0, -32768
9D018B2C  00001825   OR V1, ZERO, ZERO
9D018B30  AFA20010   SW V0, 16(SP)
9D018B34  AFA30014   SW V1, 20(SP)
9D018B38  AFBF001C   SW RA, 28(SP)
9D018B3C  0F4059A4   JAL strtox
9D018B40  00000000   NOP
9D018B44  8FBF001C   LW RA, 28(SP)
9D018B48  03E00008   JR RA
9D018B4C  27BD0020   ADDIU SP, SP, 32
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/stdlib/atoi.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0176DC  24050020   ADDIU A1, ZERO, 32
9D0176E0  80820000   LB V0, 0(A0)
9D0176F8  1043000A   BEQ V0, V1, 0x9D017724
9D0176FC  2403002D   ADDIU V1, ZERO, 45
9D017700  14430003   BNE V0, V1, 0x9D017710
9D017704  00002825   OR A1, ZERO, ZERO
9D017708  24050001   ADDIU A1, ZERO, 1
9D01770C  24840001   ADDIU A0, A0, 1
9D017710  00001025   OR V0, ZERO, ZERO
9D017714  10000007   BEQ ZERO, ZERO, 0x9D017734
9D017718  2407000A   ADDIU A3, ZERO, 10
9D01771C  1000FFF0   BEQ ZERO, ZERO, 0x9D0176E0
9D017720  24840001   ADDIU A0, A0, 1
9D017724  1000FFF9   BEQ ZERO, ZERO, 0x9D01770C
9D017728  00002825   OR A1, ZERO, ZERO
9D01772C  24840001   ADDIU A0, A0, 1
9D017730  00431023   SUBU V0, V0, V1
9D017734  80830000   LB V1, 0(A0)
9D017738  2463FFD0   ADDIU V1, V1, -48
9D01773C  2C66000A   SLTIU A2, V1, 10
9D017740  54C0FFFA   BNEL A2, ZERO, 0x9D01772C
9D017744  70471002   MUL V0, V0, A3
9D017748  50A00001   BEQL A1, ZERO, 0x9D017750
9D01774C  00021023   SUBU V0, ZERO, V0
9D017750  03E00008   JR RA
9D017754  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/stdio/mchp/vsnprintf.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D016464  27BDFF70   ADDIU SP, SP, -144
9D016468  AFB20084   SW S2, 132(SP)
9D01646C  AFB10080   SW S1, 128(SP)
9D016470  AFB0007C   SW S0, 124(SP)
9D016474  00A08825   OR S1, A1, ZERO
9D016478  00808025   OR S0, A0, ZERO
9D01647C  00C09025   OR S2, A2, ZERO
9D016480  00002825   OR A1, ZERO, ZERO
9D016484  2406004C   ADDIU A2, ZERO, 76
9D016488  27A40024   ADDIU A0, SP, 36
9D01648C  AFB30088   SW S3, 136(SP)
9D016490  AFBF008C   SW RA, 140(SP)
9D016494  0F405B7D   JAL memset
9D016498  00E09825   OR S3, A3, ZERO
9D01649C  2402FFFF   ADDIU V0, ZERO, -1
9D0164A0  AFA20010   SW V0, 16(SP)
9D0164A4  24020102   ADDIU V0, ZERO, 258
9D0164A8  16000002   BNE S0, ZERO, 0x9D0164B4
9D0164AC  AFA20014   SW V0, 20(SP)
9D0164B0  27B00070   ADDIU S0, SP, 112
9D0164B4  AFB00018   SW S0, 24(SP)
9D0164B8  AFB1001C   SW S1, 28(SP)
9D0164BC  12200002   BEQ S1, ZERO, 0x9D0164C8
9D0164C0  00001025   OR V0, ZERO, ZERO
9D0164C4  2622FFFF   ADDIU V0, S1, -1
9D0164C8  0621000C   BGEZ S1, 0x9D0164FC
9D0164CC  AFA20020   SW V0, 32(SP)
9D0164D0  3C02A000   LUI V0, -24576
9D0164D4  2403004F   ADDIU V1, ZERO, 79
9D0164D8  AC432CC4   SW V1, 11460(V0)
9D0164DC  2402FFFF   ADDIU V0, ZERO, -1
9D0164E0  8FBF008C   LW RA, 140(SP)
9D0164E4  8FB30088   LW S3, 136(SP)
9D0164E8  8FB20084   LW S2, 132(SP)
9D0164EC  8FB10080   LW S1, 128(SP)
9D0164F0  8FB0007C   LW S0, 124(SP)
9D0164F4  03E00008   JR RA
9D0164F8  27BD0090   ADDIU SP, SP, 144
9D0164FC  A2000000   SB ZERO, 0(S0)
9D016500  02603025   OR A2, S3, ZERO
9D016504  02402825   OR A1, S2, ZERO
9D016508  27A40010   ADDIU A0, SP, 16
9D01650C  AFB00028   SW S0, 40(SP)
9D016510  0F406184   JAL vfprintf
9D016514  AFB00024   SW S0, 36(SP)
9D016518  1000FFF2   BEQ ZERO, ZERO, 0x9D0164E4
9D01651C  8FBF008C   LW RA, 140(SP)
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/stdio/mchp/vfprintf.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000018  00000000   NOP
9D018610  27BDFFE0   ADDIU SP, SP, -32
9D018614  AFB00018   SW S0, 24(SP)
9D018618  AFA60010   SW A2, 16(SP)
9D01861C  00808025   OR S0, A0, ZERO
9D018620  AFBF001C   SW RA, 28(SP)
9D018624  0F4039D7   JAL __printf_core
9D018628  27A60010   ADDIU A2, SP, 16
9D01862C  8E030004   LW V1, 4(S0)
9D018630  8FBF001C   LW RA, 28(SP)
9D018634  2404FFFF   ADDIU A0, ZERO, -1
9D018638  30630010   ANDI V1, V1, 16
9D01863C  0083100B   MOVN V0, A0, V1
9D018640  8FB00018   LW S0, 24(SP)
9D018644  03E00008   JR RA
9D018648  27BD0020   ADDIU SP, SP, 32
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/stdio/mchp/__stdio_exit.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000008  00000000   NOP
00000010  00000000   NOP
00000020  00000000   NOP
00000030  00000000   NOP
00000040  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/stdio/mchp/__printf_core.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
9D00E75C  27BDFF18   ADDIU SP, SP, -232
9D00E760  AFB500D8   SW S5, 216(SP)
9D00E764  3C159D01   LUI S5, -25343
9D00E768  AFB600DC   SW S6, 220(SP)
9D00E76C  AFB400D4   SW S4, 212(SP)
9D00E770  AFB300D0   SW S3, 208(SP)
9D00E774  AFB200CC   SW S2, 204(SP)
9D00E778  AFB100C8   SW S1, 200(SP)
9D00E77C  AFBF00E4   SW RA, 228(SP)
9D00E780  AFB700E0   SW S7, 224(SP)
9D00E784  AFB000C4   SW S0, 196(SP)
9D00E788  00809025   OR S2, A0, ZERO
9D00E78C  00C08825   OR S1, A2, ZERO
9D00E790  AFA500B0   SW A1, 176(SP)
9D00E794  00009825   OR S3, ZERO, ZERO
9D00E798  27B60010   ADDIU S6, SP, 16
9D00E79C  24140025   ADDIU S4, ZERO, 37
9D00E7A0  26B5B4D0   ADDIU S5, S5, -19248
9D00E7A4  8FA500B0   LW A1, 176(SP)
9D00E7A8  80A20000   LB V0, 0(A1)
9D00E7AC  104000E0   BEQ V0, ZERO, 0x9D00EB30
9D00E7B0  2402FFFF   ADDIU V0, ZERO, -1
9D00E7B4  AFA20094   SW V0, 148(SP)
9D00E7B8  24020080   ADDIU V0, ZERO, 128
9D00E7BC  AFA00090   SW ZERO, 144(SP)
9D00E7C0  AFA00098   SW ZERO, 152(SP)
9D00E7C4  AFB6009C   SW S6, 156(SP)
9D00E7C8  AFA200A0   SW V0, 160(SP)
9D00E7CC  00008025   OR S0, ZERO, ZERO
9D00E7D0  00B01021   ADDU V0, A1, S0
9D00E7D4  80420000   LB V0, 0(V0)
9D00E7D8  10400003   BEQ V0, ZERO, 0x9D00E7E8
9D00E7DC  00000000   NOP
9D00E7E0  5454FFFB   BNEL V0, S4, 0x9D00E7D0
9D00E7E4  26100001   ADDIU S0, S0, 1
9D00E7E8  12000006   BEQ S0, ZERO, 0x9D00E804
9D00E7EC  02003025   OR A2, S0, ZERO
9D00E7F0  0F405F73   JAL __string_out
9D00E7F4  02402025   OR A0, S2, ZERO
9D00E7F8  8FA200B0   LW V0, 176(SP)
9D00E7FC  00501021   ADDU V0, V0, S0
9D00E800  AFA200B0   SW V0, 176(SP)
9D00E804  8FB700B0   LW S7, 176(SP)
9D00E808  82E20000   LB V0, 0(S7)
9D00E80C  145400C1   BNE V0, S4, 0x9D00EB14
9D00E810  26F70001   ADDIU S7, S7, 1
9D00E814  AFB700B0   SW S7, 176(SP)
9D00E818  2405002B   ADDIU A1, ZERO, 43
9D00E81C  2406002D   ADDIU A2, ZERO, 45
9D00E820  24030030   ADDIU V1, ZERO, 48
9D00E824  24070020   ADDIU A3, ZERO, 32
9D00E828  24080023   ADDIU T0, ZERO, 35
9D00E82C  8FA400B0   LW A0, 176(SP)
9D00E830  80820000   LB V0, 0(A0)
9D00E834  5045001B   BEQL V0, A1, 0x9D00E8A4
9D00E838  8FA20090   LW V0, 144(SP)
9D00E83C  2849002C   SLTI T1, V0, 44
9D00E840  1120001E   BEQ T1, ZERO, __printf_core::vfpfcnvrt
9D00E844  00000000   NOP
9D00E848  50470018   BEQL V0, A3, 0x9D00E8AC
9D00E84C  8FA20090   LW V0, 144(SP)
9D00E850  50480018   BEQL V0, T0, 0x9D00E8B4
9D00E854  8FA20090   LW V0, 144(SP)
9D00E858  2403002A   ADDIU V1, ZERO, 42
9D00E85C  5043001E   BEQL V0, V1, __printf_core::vfpfcnvrt
9D00E860  8E220000   LW V0, 0(S1)
9D00E864  0F405DB7   JAL atoi
9D00E868  00000000   NOP
9D00E86C  AFA20098   SW V0, 152(SP)
9D00E870  8FA300B0   LW V1, 176(SP)
9D00E874  80620000   LB V0, 0(V1)
9D00E878  2442FFD0   ADDIU V0, V0, -48
9D00E87C  2C42000A   SLTIU V0, V0, 10
9D00E880  10400021   BEQ V0, ZERO, 0x9D00E908
9D00E884  24630001   ADDIU V1, V1, 1
9D00E888  1000FFF9   BEQ ZERO, ZERO, 0x9D00E870
9D00E88C  AFA300B0   SW V1, 176(SP)
9D00E890  34420001   ORI V0, V0, 1
9D00E894  24840001   ADDIU A0, A0, 1
9D00E898  AFA20090   SW V0, 144(SP)
9D00E89C  1000FFE3   BEQ ZERO, ZERO, 0x9D00E82C
9D00E8A0  AFA400B0   SW A0, 176(SP)
9D00E8A4  1000FFFB   BEQ ZERO, ZERO, 0x9D00E894
9D00E8A8  34420004   ORI V0, V0, 4
9D00E8AC  1000FFF9   BEQ ZERO, ZERO, 0x9D00E894
9D00E8B0  34420008   ORI V0, V0, 8
9D00E8B4  1000FFF7   BEQ ZERO, ZERO, 0x9D00E894
9D00E8B8  34420010   ORI V0, V0, 16
9D00E8BC  5046FFF4   BEQL V0, A2, __printf_core::vfpfcnvrt
9D00E8C0  8FA20090   LW V0, 144(SP)
9D00E8C4  5443FFE5   BNEL V0, V1, 0x9D00E85C
9D00E8C8  2403002A   ADDIU V1, ZERO, 42
9D00E8CC  8FA20090   LW V0, 144(SP)
9D00E8D0  1000FFF0   BEQ ZERO, ZERO, 0x9D00E894
9D00E8D4  34420002   ORI V0, V0, 2
9D00E8D8  24840001   ADDIU A0, A0, 1
9D00E8DC  AFA400B0   SW A0, 176(SP)
9D00E8E0  24430004   ADDIU V1, V0, 4
9D00E8E4  8C420000   LW V0, 0(V0)
9D00E8E8  AE230000   SW V1, 0(S1)
9D00E8EC  04410006   BGEZ V0, 0x9D00E908
9D00E8F0  AFA20098   SW V0, 152(SP)
9D00E8F4  8FA30090   LW V1, 144(SP)
9D00E8F8  00021023   SUBU V0, ZERO, V0
9D00E8FC  AFA20098   SW V0, 152(SP)
9D00E900  38630001   XORI V1, V1, 1
9D00E904  AFA30090   SW V1, 144(SP)
9D00E908  8FA20090   LW V0, 144(SP)
9D00E90C  30430001   ANDI V1, V0, 1
9D00E910  10600002   BEQ V1, ZERO, 0x9D00E91C
9D00E914  7C020844   INS V0, ZERO, 1, 1
9D00E918  AFA20090   SW V0, 144(SP)
9D00E91C  8FA200B0   LW V0, 176(SP)
9D00E920  2403002E   ADDIU V1, ZERO, 46
9D00E924  80440000   LB A0, 0(V0)
9D00E928  1483000D   BNE A0, V1, 0x9D00E960
9D00E92C  24440001   ADDIU A0, V0, 1
9D00E930  AFA00094   SW ZERO, 148(SP)
9D00E934  AFA400B0   SW A0, 176(SP)
9D00E938  80450001   LB A1, 1(V0)
9D00E93C  2403002A   ADDIU V1, ZERO, 42
9D00E940  14A30023   BNE A1, V1, __printf_core::vfpfcnvrt
9D00E944  24420002   ADDIU V0, V0, 2
9D00E948  AFA200B0   SW V0, 176(SP)
9D00E94C  8E220000   LW V0, 0(S1)
9D00E950  24430004   ADDIU V1, V0, 4
9D00E954  8C420000   LW V0, 0(V0)
9D00E958  AE230000   SW V1, 0(S1)
9D00E95C  AFA20094   SW V0, 148(SP)
9D00E960  0F405FA0   JAL __fmt_state
9D00E964  27A400B0   ADDIU A0, SP, 176
9D00E968  AFA200B8   SW V0, 184(SP)
9D00E96C  8FA200B0   LW V0, 176(SP)
9D00E970  0F4063D1   JAL tolower
9D00E974  80440000   LB A0, 0(V0)
9D00E978  24030069   ADDIU V1, ZERO, 105
9D00E97C  10430078   BEQ V0, V1, __printf_core::vfpfcnvrt
9D00E980  8FA500B8   LW A1, 184(SP)
9D00E984  2843006A   SLTI V1, V0, 106
9D00E988  1060002E   BEQ V1, ZERO, __printf_core::vfpfcnvrt
9D00E98C  24030063   ADDIU V1, ZERO, 99
9D00E990  104300BC   BEQ V0, V1, __printf_core::vfpfcnvrt
9D00E994  28430064   SLTI V1, V0, 100
9D00E998  10600018   BEQ V1, ZERO, __printf_core::vfpfcnvrt
9D00E99C  24030064   ADDIU V1, ZERO, 100
9D00E9A0  105400C5   BEQ V0, S4, __printf_core::vfpfcnvrt
9D00E9A4  24030061   ADDIU V1, ZERO, 97
9D00E9A8  5043004E   BEQL V0, V1, __printf_core::vfpfcnvrt
9D00E9AC  02203025   OR A2, S1, ZERO
9D00E9B0  24020025   ADDIU V0, ZERO, 37
9D00E9B4  A3A200A8   SB V0, 168(SP)
9D00E9B8  2402FFFF   ADDIU V0, ZERO, -1
9D00E9BC  AFB700B0   SW S7, 176(SP)
9D00E9C0  AFA00090   SW ZERO, 144(SP)
9D00E9C4  AFA00098   SW ZERO, 152(SP)
9D00E9C8  100000B8   BEQ ZERO, ZERO, 0x9D00ECAC
9D00E9CC  AFA20094   SW V0, 148(SP)
9D00E9D0  0F405DB7   JAL atoi
9D00E9D4  00000000   NOP
9D00E9D8  AFA20094   SW V0, 148(SP)
9D00E9DC  8FA300B0   LW V1, 176(SP)
9D00E9E0  80620000   LB V0, 0(V1)
9D00E9E4  2442FFD0   ADDIU V0, V0, -48
9D00E9E8  2C42000A   SLTIU V0, V0, 10
9D00E9EC  1040FFDC   BEQ V0, ZERO, 0x9D00E960
9D00E9F0  24630001   ADDIU V1, V1, 1
9D00E9F4  1000FFF9   BEQ ZERO, ZERO, 0x9D00E9DC
9D00E9F8  AFA300B0   SW V1, 176(SP)
9D00E9FC  10430058   BEQ V0, V1, __printf_core::vfpfcnvrt
9D00EA00  28420068   SLTI V0, V0, 104
9D00EA04  1040FFEB   BEQ V0, ZERO, 0x9D00E9B4
9D00EA08  24020025   ADDIU V0, ZERO, 37
9D00EA0C  02203025   OR A2, S1, ZERO
9D00EA10  0F40606F   JAL __pop_float
9D00EA14  27A400A8   ADDIU A0, SP, 168
9D00EA18  10400096   BEQ V0, ZERO, 0x9D00EC74
9D00EA1C  8FA200B0   LW V0, 176(SP)
9D00EA20  27A600A8   ADDIU A2, SP, 168
9D00EA24  27A50090   ADDIU A1, SP, 144
9D00EA28  24430001   ADDIU V1, V0, 1
9D00EA2C  AFA300B0   SW V1, 176(SP)
9D00EA30  80470000   LB A3, 0(V0)
9D00EA34  0F403055   JAL __fmt_fp
9D00EA38  02402025   OR A0, S2, ZERO
9D00EA3C  10000035   BEQ ZERO, ZERO, 0x9D00EB14
9D00EA40  02028021   ADDU S0, S0, V0
9D00EA44  24030070   ADDIU V1, ZERO, 112
9D00EA48  10430070   BEQ V0, V1, __printf_core::vfpfcnvrt
9D00EA4C  28430071   SLTI V1, V0, 113
9D00EA50  10600013   BEQ V1, ZERO, __printf_core::vfpfcnvrt
9D00EA54  2403006E   ADDIU V1, ZERO, 110
9D00EA58  10430082   BEQ V0, V1, __printf_core::vfpfcnvrt
9D00EA5C  2403006F   ADDIU V1, ZERO, 111
9D00EA60  1443FFD4   BNE V0, V1, 0x9D00E9B4
9D00EA64  24020025   ADDIU V0, ZERO, 37
9D00EA68  02203825   OR A3, S1, ZERO
9D00EA6C  00003025   OR A2, ZERO, ZERO
9D00EA70  0F404C6D   JAL __pop_int
9D00EA74  27A400A8   ADDIU A0, SP, 168
9D00EA78  1040007E   BEQ V0, ZERO, 0x9D00EC74
9D00EA7C  8FA200B0   LW V0, 176(SP)
9D00EA80  27A600A8   ADDIU A2, SP, 168
9D00EA84  27A50090   ADDIU A1, SP, 144
9D00EA88  24420001   ADDIU V0, V0, 1
9D00EA8C  02402025   OR A0, S2, ZERO
9D00EA90  0F4055C3   JAL __fmt_o
9D00EA94  AFA200B0   SW V0, 176(SP)
9D00EA98  1000001E   BEQ ZERO, ZERO, 0x9D00EB14
9D00EA9C  02028021   ADDU S0, S0, V0
9D00EAA0  24030075   ADDIU V1, ZERO, 117
9D00EAA4  1043003C   BEQ V0, V1, __printf_core::vfpfcnvrt
9D00EAA8  24030078   ADDIU V1, ZERO, 120
9D00EAAC  10430048   BEQ V0, V1, __printf_core::vfpfcnvrt
9D00EAB0  24030073   ADDIU V1, ZERO, 115
9D00EAB4  1443FFBE   BNE V0, V1, 0x9D00E9B0
9D00EAB8  24020080   ADDIU V0, ZERO, 128
9D00EABC  14A2006D   BNE A1, V0, 0x9D00EC74
9D00EAC0  8FA200B0   LW V0, 176(SP)
9D00EAC4  00003825   OR A3, ZERO, ZERO
9D00EAC8  24420001   ADDIU V0, V0, 1
9D00EACC  AFA200B0   SW V0, 176(SP)
9D00EAD0  8E220000   LW V0, 0(S1)
9D00EAD4  24430004   ADDIU V1, V0, 4
9D00EAD8  AE230000   SW V1, 0(S1)
9D00EADC  1000005A   BEQ ZERO, ZERO, 0x9D00EC48
9D00EAE0  8C460000   LW A2, 0(V0)
9D00EAE4  0F40606F   JAL __pop_float
9D00EAE8  27A400A8   ADDIU A0, SP, 168
9D00EAEC  10400061   BEQ V0, ZERO, 0x9D00EC74
9D00EAF0  8FA200B0   LW V0, 176(SP)
9D00EAF4  27A600A8   ADDIU A2, SP, 168
9D00EAF8  27A50090   ADDIU A1, SP, 144
9D00EAFC  24430001   ADDIU V1, V0, 1
9D00EB00  AFA300B0   SW V1, 176(SP)
9D00EB04  80470000   LB A3, 0(V0)
9D00EB08  0F403287   JAL __fmt_a
9D00EB0C  02402025   OR A0, S2, ZERO
9D00EB10  02028021   ADDU S0, S0, V0
9D00EB14  02708021   ADDU S0, S3, S0
9D00EB18  0213982A   SLT S3, S0, S3
9D00EB1C  1260006D   BEQ S3, ZERO, 0x9D00ECD4
9D00EB20  3C02A000   LUI V0, -24576
9D00EB24  2403004F   ADDIU V1, ZERO, 79
9D00EB28  AC432CC4   SW V1, 11460(V0)
9D00EB2C  2413FFFF   ADDIU S3, ZERO, -1
9D00EB30  8FBF00E4   LW RA, 228(SP)
9D00EB34  02601025   OR V0, S3, ZERO
9D00EB38  8FB700E0   LW S7, 224(SP)
9D00EB3C  8FB600DC   LW S6, 220(SP)
9D00EB40  8FB500D8   LW S5, 216(SP)
9D00EB44  8FB400D4   LW S4, 212(SP)
9D00EB48  8FB300D0   LW S3, 208(SP)
9D00EB4C  8FB200CC   LW S2, 204(SP)
9D00EB50  8FB100C8   LW S1, 200(SP)
9D00EB54  8FB000C4   LW S0, 196(SP)
9D00EB58  03E00008   JR RA
9D00EB5C  27BD00E8   ADDIU SP, SP, 232
9D00EB60  02203825   OR A3, S1, ZERO
9D00EB64  24060001   ADDIU A2, ZERO, 1
9D00EB68  0F404C6D   JAL __pop_int
9D00EB6C  27A400A8   ADDIU A0, SP, 168
9D00EB70  10400040   BEQ V0, ZERO, 0x9D00EC74
9D00EB74  8FA200B0   LW V0, 176(SP)
9D00EB78  27A600A8   ADDIU A2, SP, 168
9D00EB7C  27A50090   ADDIU A1, SP, 144
9D00EB80  24420001   ADDIU V0, V0, 1
9D00EB84  02402025   OR A0, S2, ZERO
9D00EB88  0F404E2D   JAL __fmt_d
9D00EB8C  AFA200B0   SW V0, 176(SP)
9D00EB90  1000FFE0   BEQ ZERO, ZERO, 0x9D00EB14
9D00EB94  02028021   ADDU S0, S0, V0
9D00EB98  02203825   OR A3, S1, ZERO
9D00EB9C  00003025   OR A2, ZERO, ZERO
9D00EBA0  0F404C6D   JAL __pop_int
9D00EBA4  27A400A8   ADDIU A0, SP, 168
9D00EBA8  10400032   BEQ V0, ZERO, 0x9D00EC74
9D00EBAC  8FA200B0   LW V0, 176(SP)
9D00EBB0  27A600A8   ADDIU A2, SP, 168
9D00EBB4  27A50090   ADDIU A1, SP, 144
9D00EBB8  24420001   ADDIU V0, V0, 1
9D00EBBC  02402025   OR A0, S2, ZERO
9D00EBC0  0F4058EA   JAL __fmt_u
9D00EBC4  AFA200B0   SW V0, 176(SP)
9D00EBC8  1000FFD2   BEQ ZERO, ZERO, 0x9D00EB14
9D00EBCC  02028021   ADDU S0, S0, V0
9D00EBD0  02203825   OR A3, S1, ZERO
9D00EBD4  00003025   OR A2, ZERO, ZERO
9D00EBD8  0F404C6D   JAL __pop_int
9D00EBDC  27A400A8   ADDIU A0, SP, 168
9D00EBE0  10400024   BEQ V0, ZERO, 0x9D00EC74
9D00EBE4  8FA200B0   LW V0, 176(SP)
9D00EBE8  24430001   ADDIU V1, V0, 1
9D00EBEC  AFA300B0   SW V1, 176(SP)
9D00EBF0  80470000   LB A3, 0(V0)
9D00EBF4  27A600A8   ADDIU A2, SP, 168
9D00EBF8  27A50090   ADDIU A1, SP, 144
9D00EBFC  0F404768   JAL __fmt_x
9D00EC00  02402025   OR A0, S2, ZERO
9D00EC04  1000FFC3   BEQ ZERO, ZERO, 0x9D00EB14
9D00EC08  02028021   ADDU S0, S0, V0
9D00EC0C  02203825   OR A3, S1, ZERO
9D00EC10  00003025   OR A2, ZERO, ZERO
9D00EC14  240500F0   ADDIU A1, ZERO, 240
9D00EC18  0F404C6D   JAL __pop_int
9D00EC1C  27A400A8   ADDIU A0, SP, 168
9D00EC20  10400014   BEQ V0, ZERO, 0x9D00EC74
9D00EC24  8FA200B0   LW V0, 176(SP)
9D00EC28  8FA300AC   LW V1, 172(SP)
9D00EC2C  24420001   ADDIU V0, V0, 1
9D00EC30  AFA200B0   SW V0, 176(SP)
9D00EC34  8FA200A8   LW V0, 168(SP)
9D00EC38  00431025   OR V0, V0, V1
9D00EC3C  14400007   BNE V0, ZERO, 0x9D00EC5C
9D00EC40  02A03025   OR A2, S5, ZERO
9D00EC44  00003825   OR A3, ZERO, ZERO
9D00EC48  27A50090   ADDIU A1, SP, 144
9D00EC4C  0F405BFA   JAL __fmt_s
9D00EC50  02402025   OR A0, S2, ZERO
9D00EC54  1000FFAF   BEQ ZERO, ZERO, 0x9D00EB14
9D00EC58  02028021   ADDU S0, S0, V0
9D00EC5C  1000FFE5   BEQ ZERO, ZERO, 0x9D00EBF4
9D00EC60  24070078   ADDIU A3, ZERO, 120
9D00EC64  02203825   OR A3, S1, ZERO
9D00EC68  02703021   ADDU A2, S3, S0
9D00EC6C  0F4056B0   JAL __pop_ptr
9D00EC70  27A400A8   ADDIU A0, SP, 168
9D00EC74  8FA200B0   LW V0, 176(SP)
9D00EC78  24420001   ADDIU V0, V0, 1
9D00EC7C  1000FFA5   BEQ ZERO, ZERO, 0x9D00EB14
9D00EC80  AFA200B0   SW V0, 176(SP)
9D00EC84  24020080   ADDIU V0, ZERO, 128
9D00EC88  14A2FFFA   BNE A1, V0, 0x9D00EC74
9D00EC8C  8FA200B0   LW V0, 176(SP)
9D00EC90  24420001   ADDIU V0, V0, 1
9D00EC94  AFA200B0   SW V0, 176(SP)
9D00EC98  8E220000   LW V0, 0(S1)
9D00EC9C  24430004   ADDIU V1, V0, 4
9D00ECA0  8C420000   LW V0, 0(V0)
9D00ECA4  AE230000   SW V1, 0(S1)
9D00ECA8  A3A200A8   SB V0, 168(SP)
9D00ECAC  24070001   ADDIU A3, ZERO, 1
9D00ECB0  1000FFE5   BEQ ZERO, ZERO, 0x9D00EC48
9D00ECB4  27A600A8   ADDIU A2, SP, 168
9D00ECB8  24020080   ADDIU V0, ZERO, 128
9D00ECBC  14A2FFED   BNE A1, V0, 0x9D00EC74
9D00ECC0  8FA200B0   LW V0, 176(SP)
9D00ECC4  A3B400A8   SB S4, 168(SP)
9D00ECC8  24420001   ADDIU V0, V0, 1
9D00ECCC  1000FFF7   BEQ ZERO, ZERO, 0x9D00ECAC
9D00ECD0  AFA200B0   SW V0, 176(SP)
9D00ECD4  1000FEB3   BEQ ZERO, ZERO, 0x9D00E7A4
9D00ECD8  02009825   OR S3, S0, ZERO
9D01550C  27BDFFC0   ADDIU SP, SP, -64
9D015510  AFB3002C   SW S3, 44(SP)
9D015514  8FB30050   LW S3, 80(SP)
9D015518  AFB60038   SW S6, 56(SP)
9D01551C  AFB40030   SW S4, 48(SP)
9D015520  32730001   ANDI S3, S3, 1
9D015524  AFB20028   SW S2, 40(SP)
9D015528  AFB10024   SW S1, 36(SP)
9D01552C  AFB00020   SW S0, 32(SP)
9D015530  AFBF003C   SW RA, 60(SP)
9D015534  AFB50034   SW S5, 52(SP)
9D015538  00809025   OR S2, A0, ZERO
9D01553C  00A0B025   OR S6, A1, ZERO
9D015540  00C08025   OR S0, A2, ZERO
9D015544  00E08825   OR S1, A3, ZERO
9D015548  16600003   BNE S3, ZERO, 0x9D015558
9D01554C  00C7A02B   SLTU S4, A2, A3
9D015550  56800013   BNEL S4, ZERO, 0x9D0155A0
9D015554  0230A023   SUBU S4, S1, S0
9D015558  02003025   OR A2, S0, ZERO
9D01555C  02C02825   OR A1, S6, ZERO
9D015560  0F405F73   JAL __string_out
9D015564  02402025   OR A0, S2, ZERO
9D015568  1680000D   BNE S4, ZERO, 0x9D0155A0
9D01556C  0230A023   SUBU S4, S1, S0
9D015570  02008825   OR S1, S0, ZERO
9D015574  8FBF003C   LW RA, 60(SP)
9D015578  02201025   OR V0, S1, ZERO
9D01557C  8FB60038   LW S6, 56(SP)
9D015580  8FB50034   LW S5, 52(SP)
9D015584  8FB40030   LW S4, 48(SP)
9D015588  8FB3002C   LW S3, 44(SP)
9D01558C  8FB20028   LW S2, 40(SP)
9D015590  8FB10024   LW S1, 36(SP)
9D015594  8FB00020   LW S0, 32(SP)
9D015598  03E00008   JR RA
9D01559C  27BD0040   ADDIU SP, SP, 64
9D0155A0  2E860011   SLTIU A2, S4, 17
9D0155A4  24020010   ADDIU V0, ZERO, 16
9D0155A8  0286100B   MOVN V0, S4, A2
9D0155AC  00403025   OR A2, V0, ZERO
9D0155B0  24050020   ADDIU A1, ZERO, 32
9D0155B4  27A40010   ADDIU A0, SP, 16
9D0155B8  0F405B7D   JAL memset
9D0155BC  0280A825   OR S5, S4, ZERO
9D0155C0  2EA20010   SLTIU V0, S5, 16
9D0155C4  1040000B   BEQ V0, ZERO, 0x9D0155F4
9D0155C8  3286000F   ANDI A2, S4, 15
9D0155CC  27A50010   ADDIU A1, SP, 16
9D0155D0  0F405F73   JAL __string_out
9D0155D4  02402025   OR A0, S2, ZERO
9D0155D8  1660FFE6   BNE S3, ZERO, 0x9D015574
9D0155DC  02003025   OR A2, S0, ZERO
9D0155E0  02C02825   OR A1, S6, ZERO
9D0155E4  0F405F73   JAL __string_out
9D0155E8  02402025   OR A0, S2, ZERO
9D0155EC  1000FFE2   BEQ ZERO, ZERO, 0x9D015578
9D0155F0  8FBF003C   LW RA, 60(SP)
9D0155F4  24060010   ADDIU A2, ZERO, 16
9D0155F8  27A50010   ADDIU A1, SP, 16
9D0155FC  0F405F73   JAL __string_out
9D015600  02402025   OR A0, S2, ZERO
9D015604  1000FFEE   BEQ ZERO, ZERO, 0x9D0155C0
9D015608  26B5FFF0   ADDIU S5, S5, -16
9D017DCC  8C820010   LW V0, 16(A0)
9D017DD0  27BDFFE0   ADDIU SP, SP, -32
9D017DD4  AFB00014   SW S0, 20(SP)
9D017DD8  00808025   OR S0, A0, ZERO
9D017DDC  8C840014   LW A0, 20(A0)
9D017DE0  AFB10018   SW S1, 24(SP)
9D017DE4  00C2882B   SLTU S1, A2, V0
9D017DE8  0051300A   MOVZ A2, V0, S1
9D017DEC  AFBF001C   SW RA, 28(SP)
9D017DF0  0F404CCF   JAL memcpy
9D017DF4  00C08825   OR S1, A2, ZERO
9D017DF8  8E020014   LW V0, 20(S0)
9D017DFC  8E060010   LW A2, 16(S0)
9D017E00  00511021   ADDU V0, V0, S1
9D017E04  00D18823   SUBU S1, A2, S1
9D017E08  AE110010   SW S1, 16(S0)
9D017E0C  AE020014   SW V0, 20(S0)
9D017E10  A0400000   SB ZERO, 0(V0)
9D017E14  8FBF001C   LW RA, 28(SP)
9D017E18  8FB10018   LW S1, 24(SP)
9D017E1C  8FB00014   LW S0, 20(SP)
9D017E20  03E00008   JR RA
9D017E24  27BD0020   ADDIU SP, SP, 32
9D017E80  3C069D01   LUI A2, -25343
9D017E84  00001025   OR V0, ZERO, ZERO
9D017E88  24C6B2A8   ADDIU A2, A2, -19800
9D017E8C  00021840   SLL V1, V0, 1
9D017E90  00661821   ADDU V1, V1, A2
9D017E94  80670000   LB A3, 0(V1)
9D017E98  54E00003   BNEL A3, ZERO, 0x9D017EA8
9D017E9C  8C850000   LW A1, 0(A0)
9D017EA0  03E00008   JR RA
9D017EA4  90620001   LBU V0, 1(V1)
9D017EA8  24420001   ADDIU V0, V0, 1
9D017EAC  80A80000   LB T0, 0(A1)
9D017EB0  15070004   BNE T0, A3, 0x9D017EC4
9D017EB4  304200FF   ANDI V0, V0, 255
9D017EB8  90620001   LBU V0, 1(V1)
9D017EBC  24A50001   ADDIU A1, A1, 1
9D017EC0  AC850000   SW A1, 0(A0)
9D017EC4  2C43000B   SLTIU V1, V0, 11
9D017EC8  1460FFF1   BNE V1, ZERO, 0x9D017E90
9D017ECC  00021840   SLL V1, V0, 1
9D017ED0  03E00008   JR RA
9D017ED4  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/stdio/mchp/__pop_ptr.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D015AC0  24020084   ADDIU V0, ZERO, 132
9D015AC4  50A20022   BEQL A1, V0, __pop_ptr_needed
9D015AC8  8CE20000   LW V0, 0(A3)
9D015ACC  28A20085   SLTI V0, A1, 133
9D015AD0  10400010   BEQ V0, ZERO, __pop_ptr_needed
9D015AD4  24020081   ADDIU V0, ZERO, 129
9D015AD8  50A20008   BEQL A1, V0, __pop_ptr_needed
9D015ADC  8CE20000   LW V0, 0(A3)
9D015AE0  24020082   ADDIU V0, ZERO, 130
9D015AE4  50A20027   BEQL A1, V0, __pop_ptr_needed
9D015AE8  8CE20000   LW V0, 0(A3)
9D015AEC  24020080   ADDIU V0, ZERO, 128
9D015AF0  14A20010   BNE A1, V0, __pop_ptr_needed
9D015AF4  00000000   NOP
9D015AF8  8CE20000   LW V0, 0(A3)
9D015AFC  24430004   ADDIU V1, V0, 4
9D015B00  ACE30000   SW V1, 0(A3)
9D015B04  8C420000   LW V0, 0(V0)
9D015B08  AC820000   SW V0, 0(A0)
9D015B0C  10000015   BEQ ZERO, ZERO, __pop_ptr_needed
9D015B10  AC460000   SW A2, 0(V0)
9D015B14  24020090   ADDIU V0, ZERO, 144
9D015B18  50A2001A   BEQL A1, V0, __pop_ptr_needed
9D015B1C  8CE20000   LW V0, 0(A3)
9D015B20  28A20091   SLTI V0, A1, 145
9D015B24  10400005   BEQ V0, ZERO, __pop_ptr_needed
9D015B28  24020088   ADDIU V0, ZERO, 136
9D015B2C  50A2000F   BEQL A1, V0, __pop_ptr_needed
9D015B30  8CE20000   LW V0, 0(A3)
9D015B34  03E00008   JR RA
9D015B38  00001025   OR V0, ZERO, ZERO
9D015B3C  240200A0   ADDIU V0, ZERO, 160
9D015B40  50A2FFEE   BEQL A1, V0, __pop_ptr_needed
9D015B44  8CE20000   LW V0, 0(A3)
9D015B48  1000FFE9   BEQ ZERO, ZERO, __pop_ptr_needed
9D015B4C  240200C0   ADDIU V0, ZERO, 192
9D015B50  24430004   ADDIU V1, V0, 4
9D015B54  ACE30000   SW V1, 0(A3)
9D015B58  8C420000   LW V0, 0(V0)
9D015B5C  AC820000   SW V0, 0(A0)
9D015B60  A4460000   SH A2, 0(V0)
9D015B64  03E00008   JR RA
9D015B68  24020001   ADDIU V0, ZERO, 1
9D015B6C  24430004   ADDIU V1, V0, 4
9D015B70  ACE30000   SW V1, 0(A3)
9D015B74  8C420000   LW V0, 0(V0)
9D015B78  AC820000   SW V0, 0(A0)
9D015B7C  1000FFF9   BEQ ZERO, ZERO, __pop_ptr_needed
9D015B80  A0460000   SB A2, 0(V0)
9D015B84  24430004   ADDIU V1, V0, 4
9D015B88  ACE30000   SW V1, 0(A3)
9D015B8C  8C420000   LW V0, 0(V0)
9D015B90  AC820000   SW V0, 0(A0)
9D015B94  AC460000   SW A2, 0(V0)
9D015B98  000637C3   SRA A2, A2, 31
9D015B9C  1000FFF1   BEQ ZERO, ZERO, __pop_ptr_needed
9D015BA0  AC460004   SW A2, 4(V0)
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/stdio/mchp/__pop_int.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0131B4  24020088   ADDIU V0, ZERO, 136
9D0131E0  03E00008   JR RA
9D0131E4  00001025   OR V0, ZERO, ZERO
9D0131E8  24020082   ADDIU V0, ZERO, 130
9D0131EC  50A2003B   BEQL A1, V0, __pop_int_needed
9D0131F0  8CE20000   LW V0, 0(A3)
9D0131F4  24020084   ADDIU V0, ZERO, 132
9D0131F8  14A2FFF9   BNE A1, V0, __pop_int_needed
9D0131FC  00000000   NOP
9D013200  8CE20000   LW V0, 0(A3)
9D013204  24430004   ADDIU V1, V0, 4
9D013208  8C420000   LW V0, 0(V0)
9D01320C  10C00027   BEQ A2, ZERO, __pop_int_needed
9D013210  ACE30000   SW V1, 0(A3)
9D013214  7C021620   SEH V0, V0
9D013218  AC820000   SW V0, 0(A0)
9D01321C  000217C3   SRA V0, V0, 31
9D013220  AC820004   SW V0, 4(A0)
9D013224  03E00008   JR RA
9D013228  24020001   ADDIU V0, ZERO, 1
9D01322C  240200A0   ADDIU V0, ZERO, 160
9D013230  50A20036   BEQL A1, V0, __pop_int_needed
9D013234  8CE20000   LW V0, 0(A3)
9D013238  28A200A1   SLTI V0, A1, 161
9D01323C  10400010   BEQ V0, ZERO, __pop_int_needed
9D013240  24020090   ADDIU V0, ZERO, 144
9D013244  14A2FFE6   BNE A1, V0, __pop_int_needed
9D013248  00000000   NOP
9D01324C  8CE20000   LW V0, 0(A3)
9D013250  24420007   ADDIU V0, V0, 7
9D013254  7C021004   INS V0, ZERO, 0, 3
9D013258  8C480000   LW T0, 0(V0)
9D01325C  8C490004   LW T1, 4(V0)
9D013260  24420008   ADDIU V0, V0, 8
9D013264  ACE20000   SW V0, 0(A3)
9D013268  AC880000   SW T0, 0(A0)
9D01326C  AC890004   SW T1, 4(A0)
9D013270  10C00001   BEQ A2, ZERO, __pop_int_needed
9D013274  24020001   ADDIU V0, ZERO, 1
9D013278  03E00008   JR RA
9D01327C  00000000   NOP
9D013280  240200C0   ADDIU V0, ZERO, 192
9D013284  50A20005   BEQL A1, V0, __pop_int_needed
9D013288  8CE20000   LW V0, 0(A3)
9D01328C  240200F0   ADDIU V0, ZERO, 240
9D013290  14A2FFD3   BNE A1, V0, __pop_int_needed
9D013294  00000000   NOP
9D013298  8CE20000   LW V0, 0(A3)
9D01329C  24430004   ADDIU V1, V0, 4
9D0132A0  ACE30000   SW V1, 0(A3)
9D0132A4  10000002   BEQ ZERO, ZERO, __pop_int_needed
9D0132A8  8C420000   LW V0, 0(V0)
9D0132AC  3042FFFF   ANDI V0, V0, -1
9D0132B0  10000020   BEQ ZERO, ZERO, __pop_int_needed
9D0132B4  AC820000   SW V0, 0(A0)
9D0132B8  8CE20000   LW V0, 0(A3)
9D0132BC  24430004   ADDIU V1, V0, 4
9D0132C0  8C420000   LW V0, 0(V0)
9D0132C4  10C00003   BEQ A2, ZERO, __pop_int_needed
9D0132C8  ACE30000   SW V1, 0(A3)
9D0132CC  1000FFD2   BEQ ZERO, ZERO, __pop_int_needed
9D0132D0  7C021420   SEB V0, V0
9D0132D4  1000FFF6   BEQ ZERO, ZERO, __pop_int_needed
9D0132D8  304200FF   ANDI V0, V0, 255
9D0132DC  24420007   ADDIU V0, V0, 7
9D0132E0  7C021004   INS V0, ZERO, 0, 3
9D0132E4  8C480000   LW T0, 0(V0)
9D0132E8  8C490004   LW T1, 4(V0)
9D0132EC  24420008   ADDIU V0, V0, 8
9D0132F0  ACE20000   SW V0, 0(A3)
9D0132F4  AC880000   SW T0, 0(A0)
9D0132F8  AC890004   SW T1, 4(A0)
9D0132FC  10C0FFDE   BEQ A2, ZERO, __pop_int_needed
9D013300  24020001   ADDIU V0, ZERO, 1
9D013304  03E00008   JR RA
9D013308  00000000   NOP
9D01330C  24430004   ADDIU V1, V0, 4
9D013310  ACE30000   SW V1, 0(A3)
9D013314  1000FFC0   BEQ ZERO, ZERO, __pop_int_needed
9D013318  8C420000   LW V0, 0(V0)
9D01331C  8CE20000   LW V0, 0(A3)
9D013320  24430004   ADDIU V1, V0, 4
9D013324  ACE30000   SW V1, 0(A3)
9D013328  8C420000   LW V0, 0(V0)
9D01332C  14C0FFBB   BNE A2, ZERO, __pop_int_needed
9D013330  AC820000   SW V0, 0(A0)
9D013334  1000FFBB   BEQ ZERO, ZERO, __pop_int_needed
9D013338  AC800004   SW ZERO, 4(A0)
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/stdio/mchp/__pop_float.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0181BC  28A30080   SLTI V1, A1, 128
9D0181DC  8CC20000   LW V0, 0(A2)
9D0181E0  24420007   ADDIU V0, V0, 7
9D0181E4  7C021004   INS V0, ZERO, 0, 3
9D0181E8  24430008   ADDIU V1, V0, 8
9D0181EC  ACC30000   SW V1, 0(A2)
9D0181F0  8C430004   LW V1, 4(V0)
9D0181F4  8C420000   LW V0, 0(V0)
9D0181F8  AC830004   SW V1, 4(A0)
9D0181FC  AC820000   SW V0, 0(A0)
9D018200  24020001   ADDIU V0, ZERO, 1
9D018204  03E00008   JR RA
9D018208  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/stdio/mchp/__io_fmt_needed.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000024  00000000   NOP
00000028  00000000   NOP
0000002C  00000000   NOP
00000030  00000000   NOP
0000003C  00000000   NOP
00000040  00000000   NOP
00000044  00000000   NOP
0000004C  00000000   NOP
0000005C  00000000   NOP
0000006C  00000000   NOP
00000070  00000000   NOP
0000007C  00000000   NOP
00000080  00000000   NOP
0000008C  00000000   NOP
00000090  00000000   NOP
0000009C  00000000   NOP
000000AC  00000000   NOP
000000B0  00000000   NOP
000000B4  00000000   NOP
000000B8  00000000   NOP
000000BC  00000000   NOP
000000C0  00000000   NOP
000000CC  00000000   NOP
000000D0  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/stdio/mchp/__fmt_x.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D011DA0  8CA20004   LW V0, 4(A1)
9D011DA4  27BDFFA8   ADDIU SP, SP, -88
9D011DA8  AFB60048   SW S6, 72(SP)
9D011DAC  AFB3003C   SW S3, 60(SP)
9D011DB0  AFB20038   SW S2, 56(SP)
9D011DB4  AFBF0054   SW RA, 84(SP)
9D011DB8  AFBE0050   SW FP, 80(SP)
9D011DBC  AFB7004C   SW S7, 76(SP)
9D011DC0  AFB50044   SW S5, 68(SP)
9D011DC4  AFB40040   SW S4, 64(SP)
9D011DC8  AFB10034   SW S1, 52(SP)
9D011DCC  AFB00030   SW S0, 48(SP)
9D011DD0  00809825   OR S3, A0, ZERO
9D011DD4  00A09025   OR S2, A1, ZERO
9D011DD8  00E04025   OR T0, A3, ZERO
9D011DDC  0440004D   BLTZ V0, __fmt_x_needed
9D011DE0  8CB60000   LW S6, 0(A1)
9D011DE4  7C160844   INS S6, ZERO, 1, 1
9D011DE8  8E470008   LW A3, 8(S2)
9D011DEC  32C90010   ANDI T1, S6, 16
9D011DF0  8CD40000   LW S4, 0(A2)
9D011DF4  8CD70004   LW S7, 4(A2)
9D011DF8  11200004   BEQ T1, ZERO, __fmt_x_needed
9D011DFC  00E08825   OR S1, A3, ZERO
9D011E00  02971825   OR V1, S4, S7
9D011E04  54600001   BNEL V1, ZERO, __fmt_x_needed
9D011E08  24F1FFFE   ADDIU S1, A3, -2
9D011E0C  32CA0008   ANDI T2, S6, 8
9D011E10  55400001   BNEL T2, ZERO, __fmt_x_needed
9D011E14  2631FFFF   ADDIU S1, S1, -1
9D011E18  8E500010   LW S0, 16(S2)
9D011E1C  8E55000C   LW S5, 12(S2)
9D011E20  251EFFBF   ADDIU FP, T0, -65
9D011E24  2610FFFF   ADDIU S0, S0, -1
9D011E28  02B01821   ADDU V1, S5, S0
9D011E2C  A0600000   SB ZERO, 0(V1)
9D011E30  00512823   SUBU A1, V0, S1
9D011E34  32CB0002   ANDI T3, S6, 2
9D011E38  2FDE001A   SLTIU FP, FP, 26
9D011E3C  2A020002   SLTI V0, S0, 2
9D011E40  1440000A   BNE V0, ZERO, __fmt_x_needed
9D011E44  02971025   OR V0, S4, S7
9D011E48  14400034   BNE V0, ZERO, __fmt_x_needed
9D011E4C  3283000F   ANDI V1, S4, 15
9D011E50  00B11021   ADDU V0, A1, S1
9D011E54  1C400032   BGTZ V0, __fmt_x_needed
9D011E58  2864000A   SLTI A0, V1, 10
9D011E5C  1A200003   BLEZ S1, __fmt_x_needed
9D011E60  00000000   NOP
9D011E64  1560002E   BNE T3, ZERO, __fmt_x_needed
9D011E68  00000000   NOP
9D011E6C  1120000B   BEQ T1, ZERO, __fmt_x_needed
9D011E70  00000000   NOP
9D011E74  8CC20000   LW V0, 0(A2)
9D011E78  8CC30004   LW V1, 4(A2)
9D011E7C  00431025   OR V0, V0, V1
9D011E80  10400006   BEQ V0, ZERO, __fmt_x_needed
9D011E84  02B01021   ADDU V0, S5, S0
9D011E88  2610FFFE   ADDIU S0, S0, -2
9D011E8C  A048FFFF   SB T0, -1(V0)
9D011E90  24030030   ADDIU V1, ZERO, 48
9D011E94  02B01021   ADDU V0, S5, S0
9D011E98  A0430000   SB V1, 0(V0)
9D011E9C  11400004   BEQ T2, ZERO, __fmt_x_needed
9D011EA0  24030020   ADDIU V1, ZERO, 32
9D011EA4  2610FFFF   ADDIU S0, S0, -1
9D011EA8  02B01021   ADDU V0, S5, S0
9D011EAC  A0430000   SB V1, 0(V0)
9D011EB0  8E460010   LW A2, 16(S2)
9D011EB4  AFB60010   SW S6, 16(SP)
9D011EB8  02B02821   ADDU A1, S5, S0
9D011EBC  24C6FFFF   ADDIU A2, A2, -1
9D011EC0  00D03023   SUBU A2, A2, S0
9D011EC4  0F405543   JAL __pad
9D011EC8  02602025   OR A0, S3, ZERO
9D011ECC  8E630004   LW V1, 4(S3)
9D011ED0  30630100   ANDI V1, V1, 256
9D011ED4  10600004   BEQ V1, ZERO, __fmt_x_needed
9D011ED8  8FBF0054   LW RA, 84(SP)
9D011EDC  8E430004   LW V1, 4(S2)
9D011EE0  0043202A   SLT A0, V0, V1
9D011EE4  0064100B   MOVN V0, V1, A0
9D011EE8  8FBE0050   LW FP, 80(SP)
9D011EEC  8FB7004C   LW S7, 76(SP)
9D011EF0  8FB60048   LW S6, 72(SP)
9D011EF4  8FB50044   LW S5, 68(SP)
9D011EF8  8FB40040   LW S4, 64(SP)
9D011EFC  8FB3003C   LW S3, 60(SP)
9D011F00  8FB20038   LW S2, 56(SP)
9D011F04  8FB10034   LW S1, 52(SP)
9D011F08  8FB00030   LW S0, 48(SP)
9D011F0C  03E00008   JR RA
9D011F10  27BD0058   ADDIU SP, SP, 88
9D011F14  1000FFB4   BEQ ZERO, ZERO, __fmt_x_needed
9D011F18  24020001   ADDIU V0, ZERO, 1
9D011F1C  2864000A   SLTI A0, V1, 10
9D011F20  10800002   BEQ A0, ZERO, __fmt_x_needed
9D011F24  24620057   ADDIU V0, V1, 87
9D011F28  24620030   ADDIU V0, V1, 48
9D011F2C  13C00015   BEQ FP, ZERO, __fmt_x_needed
9D011F30  34430020   ORI V1, V0, 32
9D011F34  2463FF9F   ADDIU V1, V1, -97
9D011F38  2C63001A   SLTIU V1, V1, 26
9D011F3C  50600012   BEQL V1, ZERO, __fmt_x_needed
9D011F40  2610FFFF   ADDIU S0, S0, -1
9D011F44  00402025   OR A0, V0, ZERO
9D011F48  AFAB0028   SW T3, 40(SP)
9D011F4C  AFA50024   SW A1, 36(SP)
9D011F50  AFA80064   SW T0, 100(SP)
9D011F54  AFA60060   SW A2, 96(SP)
9D011F58  AFA70020   SW A3, 32(SP)
9D011F5C  AFAA001C   SW T2, 28(SP)
9D011F60  0F4063D8   JAL toupper
9D011F64  AFA90018   SW T1, 24(SP)
9D011F68  8FAB0028   LW T3, 40(SP)
9D011F6C  8FA50024   LW A1, 36(SP)
9D011F70  8FA80064   LW T0, 100(SP)
9D011F74  8FA60060   LW A2, 96(SP)
9D011F78  8FA70020   LW A3, 32(SP)
9D011F7C  8FAA001C   LW T2, 28(SP)
9D011F80  8FA90018   LW T1, 24(SP)
9D011F84  2610FFFF   ADDIU S0, S0, -1
9D011F88  02B01821   ADDU V1, S5, S0
9D011F8C  A0620000   SB V0, 0(V1)
9D011F90  0014A102   SRL S4, S4, 4
9D011F94  00171700   SLL V0, S7, 28
9D011F98  2631FFFF   ADDIU S1, S1, -1
9D011F9C  0054A025   OR S4, V0, S4
9D011FA0  1000FFA6   BEQ ZERO, ZERO, __fmt_x_needed
9D011FA4  0017B902   SRL S7, S7, 4
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/stdio/mchp/__fmt_u.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D013C90  8C820004   LW V0, 4(A0)
9D013C94  27BDFFC0   ADDIU SP, SP, -64
9D013C98  AFBE0038   SW FP, 56(SP)
9D013C9C  AFB40028   SW S4, 40(SP)
9D013CA0  AFB20020   SW S2, 32(SP)
9D013CA4  AFB1001C   SW S1, 28(SP)
9D013CA8  AFBF003C   SW RA, 60(SP)
9D013CAC  AFB70034   SW S7, 52(SP)
9D013CB0  AFB60030   SW S6, 48(SP)
9D013CB4  AFB5002C   SW S5, 44(SP)
9D013CB8  AFB30024   SW S3, 36(SP)
9D013CBC  AFB00018   SW S0, 24(SP)
9D013CC0  00C08825   OR S1, A2, ZERO
9D013CC4  00E09025   OR S2, A3, ZERO
9D013CC8  8FB40054   LW S4, 84(SP)
9D013CCC  04410002   BGEZ V0, 0x9D013CD8
9D013CD0  8FBE0058   LW FP, 88(SP)
9D013CD4  24020001   ADDIU V0, ZERO, 1
9D013CD8  8C900010   LW S0, 16(A0)
9D013CDC  8C95000C   LW S5, 12(A0)
9D013CE0  8FD70000   LW S7, 0(FP)
9D013CE4  8FB30050   LW S3, 80(SP)
9D013CE8  2610FFFF   ADDIU S0, S0, -1
9D013CEC  02B01821   ADDU V1, S5, S0
9D013CF0  A0600000   SB ZERO, 0(V1)
9D013CF4  24090001   ADDIU T1, ZERO, 1
9D013CF8  00534023   SUBU T0, V0, S3
9D013CFC  32F70002   ANDI S7, S7, 2
9D013D00  0014B7C3   SRA S6, S4, 31
9D013D04  1E000010   BGTZ S0, 0x9D013D48
9D013D08  02321025   OR V0, S1, S2
9D013D0C  5120002C   BEQL T1, ZERO, 0x9D013DC0
9D013D10  8FC20000   LW V0, 0(FP)
9D013D14  8FBF003C   LW RA, 60(SP)
9D013D18  02001025   OR V0, S0, ZERO
9D013D1C  8FBE0038   LW FP, 56(SP)
9D013D20  8FB70034   LW S7, 52(SP)
9D013D24  8FB60030   LW S6, 48(SP)
9D013D28  8FB5002C   LW S5, 44(SP)
9D013D2C  8FB40028   LW S4, 40(SP)
9D013D30  8FB30024   LW S3, 36(SP)
9D013D34  8FB20020   LW S2, 32(SP)
9D013D38  8FB1001C   LW S1, 28(SP)
9D013D3C  8FB00018   LW S0, 24(SP)
9D013D40  03E00008   JR RA
9D013D44  27BD0040   ADDIU SP, SP, 64
9D013D48  14400007   BNE V0, ZERO, 0x9D013D68
9D013D4C  01131021   ADDU V0, T0, S3
9D013D50  1C400006   BGTZ V0, 0x9D013D6C
9D013D54  02202025   OR A0, S1, ZERO
9D013D58  1A60FFEC   BLEZ S3, 0x9D013D0C
9D013D5C  00000000   NOP
9D013D60  12E0FFEA   BEQ S7, ZERO, 0x9D013D0C
9D013D64  00000000   NOP
9D013D68  02202025   OR A0, S1, ZERO
9D013D6C  02402825   OR A1, S2, ZERO
9D013D70  02803025   OR A2, S4, ZERO
9D013D74  02C03825   OR A3, S6, ZERO
9D013D78  AFA80014   SW T0, 20(SP)
9D013D7C  0F403E60   JAL __umoddi3
9D013D80  2610FFFF   ADDIU S0, S0, -1
9D013D84  AFA20010   SW V0, 16(SP)
9D013D88  02B01821   ADDU V1, S5, S0
9D013D8C  24420030   ADDIU V0, V0, 48
9D013D90  02202025   OR A0, S1, ZERO
9D013D94  02402825   OR A1, S2, ZERO
9D013D98  A0620000   SB V0, 0(V1)
9D013D9C  02803025   OR A2, S4, ZERO
9D013DA0  0F403D71   JAL __udivdi3
9D013DA4  02C03825   OR A3, S6, ZERO
9D013DA8  2673FFFF   ADDIU S3, S3, -1
9D013DAC  00408825   OR S1, V0, ZERO
9D013DB0  00609025   OR S2, V1, ZERO
9D013DB4  8FA80014   LW T0, 20(SP)
9D013DB8  1000FFD2   BEQ ZERO, ZERO, 0x9D013D04
9D013DBC  8FA90010   LW T1, 16(SP)
9D013DC0  7C022104   INS V0, ZERO, 4, 1
9D013DC4  1000FFD3   BEQ ZERO, ZERO, 0x9D013D14
9D013DC8  AFC20000   SW V0, 0(FP)
9D0163A8  8CA20000   LW V0, 0(A1)
9D0163AC  8CA30004   LW V1, 4(A1)
9D0163B0  27BDFFC0   ADDIU SP, SP, -64
9D0163B4  AFB30038   SW S3, 56(SP)
9D0163B8  AFB20034   SW S2, 52(SP)
9D0163BC  AFB10030   SW S1, 48(SP)
9D0163C0  AFB0002C   SW S0, 44(SP)
9D0163C4  AFBF003C   SW RA, 60(SP)
9D0163C8  00808825   OR S1, A0, ZERO
9D0163CC  00A08025   OR S0, A1, ZERO
9D0163D0  8CB20008   LW S2, 8(A1)
9D0163D4  AFA20020   SW V0, 32(SP)
9D0163D8  04600003   BLTZ V1, __fmt_u_needed
9D0163DC  8CB3000C   LW S3, 12(A1)
9D0163E0  7C020844   INS V0, ZERO, 1, 1
9D0163E4  AFA20020   SW V0, 32(SP)
9D0163E8  27A20020   ADDIU V0, SP, 32
9D0163EC  AFA20018   SW V0, 24(SP)
9D0163F0  2402000A   ADDIU V0, ZERO, 10
9D0163F4  AFA20014   SW V0, 20(SP)
9D0163F8  AFB20010   SW S2, 16(SP)
9D0163FC  8CC70004   LW A3, 4(A2)
9D016400  8CC60000   LW A2, 0(A2)
9D016404  0F404F24   JAL __cvt_u
9D016408  02002025   OR A0, S0, ZERO
9D01640C  8E060010   LW A2, 16(S0)
9D016410  8FA30020   LW V1, 32(SP)
9D016414  02403825   OR A3, S2, ZERO
9D016418  24C6FFFF   ADDIU A2, A2, -1
9D01641C  AFA30010   SW V1, 16(SP)
9D016420  00C23023   SUBU A2, A2, V0
9D016424  02622821   ADDU A1, S3, V0
9D016428  0F405543   JAL __pad
9D01642C  02202025   OR A0, S1, ZERO
9D016430  8E230004   LW V1, 4(S1)
9D016434  30630100   ANDI V1, V1, 256
9D016438  10600004   BEQ V1, ZERO, __fmt_u_needed
9D01643C  8FBF003C   LW RA, 60(SP)
9D016440  8E030004   LW V1, 4(S0)
9D016444  0043202A   SLT A0, V0, V1
9D016448  0064100B   MOVN V0, V1, A0
9D01644C  8FB30038   LW S3, 56(SP)
9D016450  8FB20034   LW S2, 52(SP)
9D016454  8FB10030   LW S1, 48(SP)
9D016458  8FB0002C   LW S0, 44(SP)
9D01645C  03E00008   JR RA
9D016460  27BD0040   ADDIU SP, SP, 64
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/stdio/mchp/__fmt_s.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D016FE8  3C036C75   LUI V1, 27765
9D016FEC  27BDFFC8   ADDIU SP, SP, -56
9D016FF0  24636E28   ADDIU V1, V1, 28200
9D016FF4  AFA30018   SW V1, 24(SP)
9D016FF8  2403296C   ADDIU V1, ZERO, 10604
9D016FFC  AFB20028   SW S2, 40(SP)
9D017000  AFB00020   SW S0, 32(SP)
9D017004  AFBF0034   SW RA, 52(SP)
9D017008  AFB40030   SW S4, 48(SP)
9D01700C  AFB3002C   SW S3, 44(SP)
9D017010  AFB10024   SW S1, 36(SP)
9D017014  00809025   OR S2, A0, ZERO
9D017018  00E01025   OR V0, A3, ZERO
9D01701C  A7A3001C   SH V1, 28(SP)
9D017020  A3A0001E   SB ZERO, 30(SP)
9D017024  10C00002   BEQ A2, ZERO, __fmt_0_needed, __fmt_s_needed
9D017028  27B00018   ADDIU S0, SP, 24
9D01702C  00C08025   OR S0, A2, ZERO
9D017030  8CB10004   LW S1, 4(A1)
9D017034  8CB30008   LW S3, 8(A1)
9D017038  14400003   BNE V0, ZERO, __fmt_0_needed, __fmt_s_needed
9D01703C  8CB40000   LW S4, 0(A1)
9D017040  0F404D29   JAL strlen
9D017044  02002025   OR A0, S0, ZERO
9D017048  06200002   BLTZ S1, __fmt_0_needed, __fmt_s_needed
9D01704C  0222182B   SLTU V1, S1, V0
9D017050  0223100B   MOVN V0, S1, V1
9D017054  AFB40010   SW S4, 16(SP)
9D017058  02603825   OR A3, S3, ZERO
9D01705C  02002825   OR A1, S0, ZERO
9D017060  02402025   OR A0, S2, ZERO
9D017064  0F405543   JAL __pad
9D017068  00403025   OR A2, V0, ZERO
9D01706C  8FBF0034   LW RA, 52(SP)
9D017070  8FB40030   LW S4, 48(SP)
9D017074  8FB3002C   LW S3, 44(SP)
9D017078  8FB20028   LW S2, 40(SP)
9D01707C  8FB10024   LW S1, 36(SP)
9D017080  8FB00020   LW S0, 32(SP)
9D017084  03E00008   JR RA
9D017088  27BD0038   ADDIU SP, SP, 56
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/stdio/mchp/__fmt_o.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D01570C  8CA20000   LW V0, 0(A1)
9D015710  8CA30004   LW V1, 4(A1)
9D015714  27BDFFC0   ADDIU SP, SP, -64
9D015718  AFB30038   SW S3, 56(SP)
9D01571C  AFB20034   SW S2, 52(SP)
9D015720  AFB10030   SW S1, 48(SP)
9D015724  AFB0002C   SW S0, 44(SP)
9D015728  AFBF003C   SW RA, 60(SP)
9D01572C  00809025   OR S2, A0, ZERO
9D015730  00A08025   OR S0, A1, ZERO
9D015734  8CB30008   LW S3, 8(A1)
9D015738  AFA20020   SW V0, 32(SP)
9D01573C  04600003   BLTZ V1, __fmt_o_needed
9D015740  8CB1000C   LW S1, 12(A1)
9D015744  7C020844   INS V0, ZERO, 1, 1
9D015748  AFA20020   SW V0, 32(SP)
9D01574C  27A20020   ADDIU V0, SP, 32
9D015750  AFA20018   SW V0, 24(SP)
9D015754  24020008   ADDIU V0, ZERO, 8
9D015758  AFA20014   SW V0, 20(SP)
9D01575C  AFB30010   SW S3, 16(SP)
9D015760  8CC70004   LW A3, 4(A2)
9D015764  8CC60000   LW A2, 0(A2)
9D015768  0F404F24   JAL __cvt_u
9D01576C  02002025   OR A0, S0, ZERO
9D015770  8FA30020   LW V1, 32(SP)
9D015774  30630010   ANDI V1, V1, 16
9D015778  10600004   BEQ V1, ZERO, __fmt_o_needed
9D01577C  24040030   ADDIU A0, ZERO, 48
9D015780  2442FFFF   ADDIU V0, V0, -1
9D015784  02221821   ADDU V1, S1, V0
9D015788  A0640000   SB A0, 0(V1)
9D01578C  8FA30020   LW V1, 32(SP)
9D015790  30630008   ANDI V1, V1, 8
9D015794  10600004   BEQ V1, ZERO, __fmt_o_needed
9D015798  24040020   ADDIU A0, ZERO, 32
9D01579C  2442FFFF   ADDIU V0, V0, -1
9D0157A0  02221821   ADDU V1, S1, V0
9D0157A4  A0640000   SB A0, 0(V1)
9D0157A8  8E060010   LW A2, 16(S0)
9D0157AC  8FA30020   LW V1, 32(SP)
9D0157B0  02603825   OR A3, S3, ZERO
9D0157B4  24C6FFFF   ADDIU A2, A2, -1
9D0157B8  AFA30010   SW V1, 16(SP)
9D0157BC  00C23023   SUBU A2, A2, V0
9D0157C0  02222821   ADDU A1, S1, V0
9D0157C4  0F405543   JAL __pad
9D0157C8  02402025   OR A0, S2, ZERO
9D0157CC  8E430004   LW V1, 4(S2)
9D0157D0  30630100   ANDI V1, V1, 256
9D0157D4  10600004   BEQ V1, ZERO, __fmt_o_needed
9D0157D8  8FBF003C   LW RA, 60(SP)
9D0157DC  8E030004   LW V1, 4(S0)
9D0157E0  0043202A   SLT A0, V0, V1
9D0157E4  0064100B   MOVN V0, V1, A0
9D0157E8  8FB30038   LW S3, 56(SP)
9D0157EC  8FB20034   LW S2, 52(SP)
9D0157F0  8FB10030   LW S1, 48(SP)
9D0157F4  8FB0002C   LW S0, 44(SP)
9D0157F8  03E00008   JR RA
9D0157FC  27BD0040   ADDIU SP, SP, 64
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/stdio/mchp/__fmt_fp.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00C154  27BDFF68   ADDIU SP, SP, -152
9D00C15C  8CA20000   LW V0, 0(A1)
9D00C160  AFB60088   SW S6, 136(SP)
9D00C164  AFB40080   SW S4, 128(SP)
9D00C168  AFA2001C   SW V0, 28(SP)
9D00C16C  8CA20008   LW V0, 8(A1)
9D00C170  8CD60000   LW S6, 0(A2)
9D00C174  8CD40004   LW S4, 4(A2)
9D00C178  AFA20020   SW V0, 32(SP)
9D00C17C  8CA20010   LW V0, 16(A1)
9D00C180  AFB50084   SW S5, 132(SP)
9D00C184  AFB00070   SW S0, 112(SP)
9D00C188  AFA40098   SW A0, 152(SP)
9D00C18C  AFA5009C   SW A1, 156(SP)
9D00C190  8CB00004   LW S0, 4(A1)
9D00C194  8CB5000C   LW S5, 12(A1)
9D00C198  00003025   OR A2, ZERO, ZERO
9D00C19C  00003825   OR A3, ZERO, ZERO
9D00C1A0  02C02025   OR A0, S6, ZERO
9D00C1A4  02802825   OR A1, S4, ZERO
9D00C1A8  AFBF0094   SW RA, 148(SP)
9D00C1AC  AFBE0090   SW FP, 144(SP)
9D00C1B0  AFB7008C   SW S7, 140(SP)
9D00C1B4  AFB3007C   SW S3, 124(SP)
9D00C1B8  AFB20078   SW S2, 120(SP)
9D00C1BC  AFB10074   SW S1, 116(SP)
9D00C1C0  0F405056   JAL __ltdf2
9D00C1C4  AFA20050   SW V0, 80(SP)
9D00C1C8  0440000E   BLTZ V0, __fmt_f_needed
9D00C1CC  8FA2001C   LW V0, 28(SP)
9D00C1D0  30420004   ANDI V0, V0, 4
9D00C1D4  1440000E   BNE V0, ZERO, __fmt_f_needed
9D00C1D8  2402002B   ADDIU V0, ZERO, 43
9D00C1DC  8FA2001C   LW V0, 28(SP)
9D00C1E0  30420008   ANDI V0, V0, 8
9D00C1E4  AFA20024   SW V0, 36(SP)
9D00C1E8  8FA20020   LW V0, 32(SP)
9D00C1EC  AFA20018   SW V0, 24(SP)
9D00C1F0  8FA20024   LW V0, 36(SP)
9D00C1F4  1040000C   BEQ V0, ZERO, __fmt_fp::__DOUBLE_BITS
9D00C1F8  24020020   ADDIU V0, ZERO, 32
9D00C1FC  10000005   BEQ ZERO, ZERO, __fmt_f_needed
9D00C200  A2A20000   SB V0, 0(S5)
9D00C204  3C028000   LUI V0, -32768
9D00C208  0054A026   XOR S4, V0, S4
9D00C20C  2402002D   ADDIU V0, ZERO, 45
9D00C210  A2A20000   SB V0, 0(S5)
9D00C214  8FA20020   LW V0, 32(SP)
9D00C218  2442FFFF   ADDIU V0, V0, -1
9D00C21C  AFA20018   SW V0, 24(SP)
9D00C220  24020001   ADDIU V0, ZERO, 1
9D00C224  AFA20024   SW V0, 36(SP)
9D00C228  8FA30024   LW V1, 36(SP)
9D00C22C  7E82F000   EXT V0, S4, 0, 31
9D00C230  02A31821   ADDU V1, S5, V1
9D00C234  16C00024   BNE S6, ZERO, __fmt_fp::__DOUBLE_BITS
9D00C238  AFA3002C   SW V1, 44(SP)
9D00C23C  3C037FF0   LUI V1, 32752
9D00C240  14430022   BNE V0, V1, __fmt_f_needed
9D00C244  3C047FF0   LUI A0, 32752
9D00C248  8FA200A4   LW V0, 164(SP)
9D00C24C  2442FFBF   ADDIU V0, V0, -65
9D00C250  2C42001A   SLTIU V0, V0, 26
9D00C254  1040001A   BEQ V0, ZERO, __fmt_f_needed
9D00C258  3C059D01   LUI A1, -25343
9D00C25C  3C059D01   LUI A1, -25343
9D00C260  24A5B408   ADDIU A1, A1, -19448
9D00C264  0F406361   JAL strcpy
9D00C268  8FA4002C   LW A0, 44(SP)
9D00C26C  0F404D29   JAL strlen
9D00C270  02A02025   OR A0, S5, ZERO
9D00C274  8FA3001C   LW V1, 28(SP)
9D00C278  8FA70020   LW A3, 32(SP)
9D00C27C  8FA40098   LW A0, 152(SP)
9D00C280  AFA30010   SW V1, 16(SP)
9D00C284  02A02825   OR A1, S5, ZERO
9D00C288  0F405543   JAL __pad
9D00C28C  00403025   OR A2, V0, ZERO
9D00C290  8FBF0094   LW RA, 148(SP)
9D00C294  8FBE0090   LW FP, 144(SP)
9D00C298  8FB7008C   LW S7, 140(SP)
9D00C29C  8FB60088   LW S6, 136(SP)
9D00C2A0  8FB50084   LW S5, 132(SP)
9D00C2A4  8FB40080   LW S4, 128(SP)
9D00C2A8  8FB3007C   LW S3, 124(SP)
9D00C2AC  8FB20078   LW S2, 120(SP)
9D00C2B0  8FB10074   LW S1, 116(SP)
9D00C2B4  8FB00070   LW S0, 112(SP)
9D00C2B8  03E00008   JR RA
9D00C2BC  27BD0098   ADDIU SP, SP, 152
9D00C2C0  1000FFE8   BEQ ZERO, ZERO, __fmt_f_needed
9D00C2C4  24A5B40C   ADDIU A1, A1, -19444
9D00C2C8  3C047FF0   LUI A0, 32752
9D00C2EC  2442FFBF   ADDIU V0, V0, -65
9D00C2F0  2C42001A   SLTIU V0, V0, 26
9D00C2F4  50400004   BEQL V0, ZERO, __fmt_f_needed
9D00C2F8  3C059D01   LUI A1, -25343
9D00C2FC  3C059D01   LUI A1, -25343
9D00C300  1000FFD8   BEQ ZERO, ZERO, __fmt_f_needed
9D00C304  24A5B410   ADDIU A1, A1, -19440
9D00C308  1000FFD6   BEQ ZERO, ZERO, __fmt_f_needed
9D00C30C  24A5B414   ADDIU A1, A1, -19436
9D00C310  00003825   OR A3, ZERO, ZERO
9D00C314  02C02025   OR A0, S6, ZERO
9D00C318  0F40500B   JAL __eqdf2
9D00C31C  02802825   OR A1, S4, ZERO
9D00C320  3C139D02   LUI S3, -25342
9D00C324  3C039D02   LUI V1, -25342
9D00C328  AFA30030   SW V1, 48(SP)
9D00C32C  8E718EC8   LW S1, -28984(S3)
9D00C330  8E728ECC   LW S2, -28980(S3)
9D00C334  14400013   BNE V0, ZERO, __fmt_f_needed
9D00C338  0000B825   OR S7, ZERO, ZERO
9D00C33C  0F4063D1   JAL tolower
9D00C340  8FA400A4   LW A0, 164(SP)
9D00C344  7C021420   SEB V0, V0
9D00C348  AFA20028   SW V0, 40(SP)
9D00C34C  8FA30028   LW V1, 40(SP)
9D00C350  060001AE   BLTZ S0, __fmt_f_needed
9D00C354  24020067   ADDIU V0, ZERO, 103
9D00C358  14620055   BNE V1, V0, __fmt_f_needed
9D00C35C  8FBE0028   LW FP, 40(SP)
9D00C360  52000001   BEQL S0, ZERO, __fmt_f_needed
9D00C364  24100001   ADDIU S0, ZERO, 1
9D00C368  2AE2FFFC   SLTI V0, S7, -4
9D00C36C  14400003   BNE V0, ZERO, __fmt_f_needed
9D00C370  02F0102A   SLT V0, S7, S0
9D00C374  1440019F   BNE V0, ZERO, __fmt_f_needed
9D00C378  00000000   NOP
9D00C37C  10000058   BEQ ZERO, ZERO, __fmt_f_needed
9D00C380  241E0065   ADDIU FP, ZERO, 101
9D00C384  3C029D02   LUI V0, -25342
9D00C388  8C4A8ED0   LW T2, -28976(V0)
9D00C38C  8C4B8ED4   LW T3, -28972(V0)
9D00C390  01403025   OR A2, T2, ZERO
9D00C394  01603825   OR A3, T3, ZERO
9D00C398  02202025   OR A0, S1, ZERO
9D00C39C  02402825   OR A1, S2, ZERO
9D00C3A0  AFAA0038   SW T2, 56(SP)
9D00C3A4  0F404121   JAL dpmul
9D00C3A8  AFAB003C   SW T3, 60(SP)
9D00C3AC  00402025   OR A0, V0, ZERO
9D00C3B0  02C03025   OR A2, S6, ZERO
9D00C3B4  02803825   OR A3, S4, ZERO
9D00C3B8  00602825   OR A1, V1, ZERO
9D00C3BC  0040F025   OR FP, V0, ZERO
9D00C3C0  0F40500B   JAL __eqdf2
9D00C3C4  AFA30028   SW V1, 40(SP)
9D00C3C8  1C40002A   BGTZ V0, __fmt_f_needed
9D00C3CC  8FA80028   LW T0, 40(SP)
9D00C3D0  8FAA0038   LW T2, 56(SP)
9D00C3D4  8FAB003C   LW T3, 60(SP)
9D00C3D8  26F70001   ADDIU S7, S7, 1
9D00C3DC  03C08825   OR S1, FP, ZERO
9D00C3E0  1000FFEB   BEQ ZERO, ZERO, __fmt_f_needed
9D00C3E4  01009025   OR S2, T0, ZERO
9D00C3E8  10400012   BEQ V0, ZERO, __fmt_f_needed
9D00C3EC  8FA60040   LW A2, 64(SP)
9D00C3F0  17C0000F   BNE FP, ZERO, __fmt_f_needed
9D00C3F4  8FA60028   LW A2, 40(SP)
9D00C3F8  8FA70038   LW A3, 56(SP)
9D00C3FC  02C02025   OR A0, S6, ZERO
9D00C400  0F404121   JAL dpmul
9D00C404  02802825   OR A1, S4, ZERO
9D00C408  8FA60048   LW A2, 72(SP)
9D00C40C  8FA70054   LW A3, 84(SP)
9D00C410  02202025   OR A0, S1, ZERO
9D00C414  02402825   OR A1, S2, ZERO
9D00C418  0040B025   OR S6, V0, ZERO
9D00C41C  0F404121   JAL dpmul
9D00C420  0060A025   OR S4, V1, ZERO
9D00C424  00408825   OR S1, V0, ZERO
9D00C428  00609025   OR S2, V1, ZERO
9D00C42C  241E0001   ADDIU FP, ZERO, 1
9D00C430  8FA60040   LW A2, 64(SP)
9D00C434  8FA70044   LW A3, 68(SP)
9D00C438  02202025   OR A0, S1, ZERO
9D00C43C  0F403B37   JAL dpdiv
9D00C440  02402825   OR A1, S2, ZERO
9D00C444  00408825   OR S1, V0, ZERO
9D00C448  00609025   OR S2, V1, ZERO
9D00C44C  26F7FFFF   ADDIU S7, S7, -1
9D00C450  02203025   OR A2, S1, ZERO
9D00C454  02403825   OR A3, S2, ZERO
9D00C458  02C02025   OR A0, S6, ZERO
9D00C45C  0F405056   JAL __ltdf2
9D00C460  02802825   OR A1, S4, ZERO
9D00C464  0442FFE0   BLTZL V0, __fmt_f_needed
9D00C468  2AE2FED4   SLTI V0, S7, -300
9D00C46C  1000FFB3   BEQ ZERO, ZERO, __fmt_f_needed
9D00C470  00000000   NOP
9D00C474  3C029D02   LUI V0, -25342
9D00C478  8C438ED8   LW V1, -28968(V0)
9D00C47C  8C428EDC   LW V0, -28964(V0)
9D00C480  0000F025   OR FP, ZERO, ZERO
9D00C484  AFA30028   SW V1, 40(SP)
9D00C488  AFA20038   SW V0, 56(SP)
9D00C48C  8FA20038   LW V0, 56(SP)
9D00C490  AFA30048   SW V1, 72(SP)
9D00C494  AFA20054   SW V0, 84(SP)
9D00C498  8FA20030   LW V0, 48(SP)
9D00C49C  8C438ED4   LW V1, -28972(V0)
9D00C4A0  8C428ED0   LW V0, -28976(V0)
9D00C4A4  AFA30044   SW V1, 68(SP)
9D00C4A8  1000FFE9   BEQ ZERO, ZERO, __fmt_f_needed
9D00C4AC  AFA20040   SW V0, 64(SP)
9D00C4B0  24020066   ADDIU V0, ZERO, 102
9D00C4B4  17C2000A   BNE FP, V0, __fmt_f_needed
9D00C4B8  26100001   ADDIU S0, S0, 1
9D00C4BC  06E10004   BGEZ S7, __fmt_f_needed
9D00C4C0  8FA30028   LW V1, 40(SP)
9D00C4C4  8E718EC8   LW S1, -28984(S3)
9D00C4C8  8E728ECC   LW S2, -28980(S3)
9D00C4CC  0000B825   OR S7, ZERO, ZERO
9D00C4D0  24020067   ADDIU V0, ZERO, 103
9D00C4D4  10620002   BEQ V1, V0, __fmt_f_needed
9D00C4D8  241E0066   ADDIU FP, ZERO, 102
9D00C4DC  02178021   ADDU S0, S0, S7
9D00C4E0  8FA20030   LW V0, 48(SP)
9D00C4E4  02205025   OR T2, S1, ZERO
9D00C4E8  02404825   OR T1, S2, ZERO
9D00C4EC  8C438ED4   LW V1, -28972(V0)
9D00C4F0  8C428ED0   LW V0, -28976(V0)
9D00C4F4  02C06025   OR T4, S6, ZERO
9D00C4F8  02809825   OR S3, S4, ZERO
9D00C4FC  00005825   OR T3, ZERO, ZERO
9D00C500  AFA20048   SW V0, 72(SP)
9D00C504  AFA3004C   SW V1, 76(SP)
9D00C508  01403025   OR A2, T2, ZERO
9D00C50C  01203825   OR A3, T1, ZERO
9D00C510  01802025   OR A0, T4, ZERO
9D00C514  02602825   OR A1, S3, ZERO
9D00C518  AFAB0068   SW T3, 104(SP)
9D00C51C  AFAA0060   SW T2, 96(SP)
9D00C520  AFA90064   SW T1, 100(SP)
9D00C524  AFAC0058   SW T4, 88(SP)
9D00C528  0F403B37   JAL dpdiv
9D00C52C  AFB30054   SW S3, 84(SP)
9D00C530  00402025   OR A0, V0, ZERO
9D00C534  0F4054C1   JAL dpfloor
9D00C538  00602825   OR A1, V1, ZERO
9D00C53C  00602825   OR A1, V1, ZERO
9D00C540  00402025   OR A0, V0, ZERO
9D00C544  AFA3003C   SW V1, 60(SP)
9D00C548  0F405C6D   JAL __fixdfsi
9D00C54C  AFA20038   SW V0, 56(SP)
9D00C550  8FA80054   LW T0, 84(SP)
9D00C554  8FAC0038   LW T4, 56(SP)
9D00C558  8FAE0058   LW T6, 88(SP)
9D00C55C  8FA90064   LW T1, 100(SP)
9D00C560  8FAA0060   LW T2, 96(SP)
9D00C564  8FAD003C   LW T5, 60(SP)
9D00C568  3C138000   LUI S3, -32768
9D00C56C  02682026   XOR A0, S3, T0
9D00C570  01403025   OR A2, T2, ZERO
9D00C574  01203825   OR A3, T1, ZERO
9D00C578  01A02825   OR A1, T5, ZERO
9D00C57C  AFAE0010   SW T6, 16(SP)
9D00C580  AFA40014   SW A0, 20(SP)
9D00C584  01802025   OR A0, T4, ZERO
9D00C588  AFA90058   SW T1, 88(SP)
9D00C58C  0F40349D   JAL fma
9D00C590  AFA20040   SW V0, 64(SP)
9D00C594  8FAA0060   LW T2, 96(SP)
9D00C598  8FA90058   LW T1, 88(SP)
9D00C59C  8FA60048   LW A2, 72(SP)
9D00C5A0  8FA7004C   LW A3, 76(SP)
9D00C5A4  01402025   OR A0, T2, ZERO
9D00C5A8  01202825   OR A1, T1, ZERO
9D00C5AC  AFA20038   SW V0, 56(SP)
9D00C5B0  AFA20054   SW V0, 84(SP)
9D00C5B4  0F403B37   JAL dpdiv
9D00C5B8  02639826   XOR S3, S3, V1
9D00C5BC  8FAB0068   LW T3, 104(SP)
9D00C5C0  00405025   OR T2, V0, ZERO
9D00C5C4  00604825   OR T1, V1, ZERO
9D00C5C8  256B0001   ADDIU T3, T3, 1
9D00C5CC  160BFFCE   BNE S0, T3, __fmt_f_needed
9D00C5D0  8FAC0054   LW T4, 84(SP)
9D00C5D4  3C029D02   LUI V0, -25342
9D00C5D8  8C468EE0   LW A2, -28960(V0)
9D00C5DC  8C478EE4   LW A3, -28956(V0)
9D00C5E0  01402025   OR A0, T2, ZERO
9D00C5E4  0F404121   JAL dpmul
9D00C5E8  00602825   OR A1, V1, ZERO
9D00C5EC  00603825   OR A3, V1, ZERO
9D00C5F0  AFA3004C   SW V1, 76(SP)
9D00C5F4  8FA30038   LW V1, 56(SP)
9D00C5F8  00403025   OR A2, V0, ZERO
9D00C5FC  02602825   OR A1, S3, ZERO
9D00C600  00602025   OR A0, V1, ZERO
9D00C604  0F405056   JAL __ltdf2
9D00C608  AFA20048   SW V0, 72(SP)
9D00C60C  0440000F   BLTZ V0, __fmt_f_needed
9D00C610  8FAA0048   LW T2, 72(SP)
9D00C614  8FAB004C   LW T3, 76(SP)
9D00C618  8FA30038   LW V1, 56(SP)
9D00C61C  01403025   OR A2, T2, ZERO
9D00C620  01603825   OR A3, T3, ZERO
9D00C624  00602025   OR A0, V1, ZERO
9D00C628  0F40500B   JAL __eqdf2
9D00C62C  02602825   OR A1, S3, ZERO
9D00C630  8FAA0048   LW T2, 72(SP)
9D00C634  14400007   BNE V0, ZERO, __fmt_f_needed
9D00C638  8FAB004C   LW T3, 76(SP)
9D00C63C  8FA20040   LW V0, 64(SP)
9D00C640  30420001   ANDI V0, V0, 1
9D00C644  14400004   BNE V0, ZERO, __fmt_f_needed
9D00C648  01403025   OR A2, T2, ZERO
9D00C64C  00005025   OR T2, ZERO, ZERO
9D00C650  00005825   OR T3, ZERO, ZERO
9D00C654  01403025   OR A2, T2, ZERO
9D00C658  01603825   OR A3, T3, ZERO
9D00C65C  02C02025   OR A0, S6, ZERO
9D00C660  0F403C67   JAL __adddf3
9D00C664  02802825   OR A1, S4, ZERO
9D00C668  0040B025   OR S6, V0, ZERO
9D00C66C  AFA20038   SW V0, 56(SP)
9D00C670  8FA20030   LW V0, 48(SP)
9D00C674  02202025   OR A0, S1, ZERO
9D00C678  02402825   OR A1, S2, ZERO
9D00C67C  8C468ED0   LW A2, -28976(V0)
9D00C680  8C478ED4   LW A3, -28972(V0)
9D00C684  AFA30040   SW V1, 64(SP)
9D00C688  0F404121   JAL dpmul
9D00C68C  AFA30048   SW V1, 72(SP)
9D00C690  8FA80048   LW T0, 72(SP)
9D00C694  02C03025   OR A2, S6, ZERO
9D00C698  00402025   OR A0, V0, ZERO
9D00C69C  01003825   OR A3, T0, ZERO
9D00C6A0  00602825   OR A1, V1, ZERO
9D00C6A4  00409825   OR S3, V0, ZERO
9D00C6A8  0F405056   JAL __ltdf2
9D00C6AC  0060A025   OR S4, V1, ZERO
9D00C6B0  1C40005E   BGTZ V0, __fmt_f_needed
9D00C6B4  24020066   ADDIU V0, ZERO, 102
9D00C6B8  17C2005E   BNE FP, V0, __fmt_f_needed
9D00C6BC  26F70001   ADDIU S7, S7, 1
9D00C6C0  26100001   ADDIU S0, S0, 1
9D00C6C4  02E08825   OR S1, S7, ZERO
9D00C6C8  02301023   SUBU V0, S1, S0
9D00C6CC  AFA20048   SW V0, 72(SP)
9D00C6D0  8FA2001C   LW V0, 28(SP)
9D00C6D4  8FB60024   LW S6, 36(SP)
9D00C6D8  00005825   OR T3, ZERO, ZERO
9D00C6DC  30420010   ANDI V0, V0, 16
9D00C6E0  AFA20054   SW V0, 84(SP)
9D00C6E4  8FA20030   LW V0, 48(SP)
9D00C6E8  00008025   OR S0, ZERO, ZERO
9D00C6EC  24120009   ADDIU S2, ZERO, 9
9D00C6F0  8C438ED4   LW V1, -28972(V0)
9D00C6F4  8C428ED0   LW V0, -28976(V0)
9D00C6F8  AFA30034   SW V1, 52(SP)
9D00C6FC  AFA20030   SW V0, 48(SP)
9D00C700  8FA20048   LW V0, 72(SP)
9D00C704  10510007   BEQ V0, S1, __fmt_f_needed
9D00C708  02C05025   OR T2, S6, ZERO
9D00C70C  8FA2009C   LW V0, 156(SP)
9D00C710  8C420010   LW V0, 16(V0)
9D00C714  2442FFFB   ADDIU V0, V0, -5
9D00C718  02C2102B   SLTU V0, S6, V0
9D00C71C  14400049   BNE V0, ZERO, __fmt_f_needed
9D00C720  8FA30038   LW V1, 56(SP)
9D00C724  16000007   BNE S0, ZERO, __fmt_f_needed
9D00C728  8FA2001C   LW V0, 28(SP)
9D00C72C  30420010   ANDI V0, V0, 16
9D00C730  10400004   BEQ V0, ZERO, __fmt_f_needed
9D00C734  02AA5021   ADDU T2, S5, T2
9D00C738  2402002E   ADDIU V0, ZERO, 46
9D00C73C  26D60001   ADDIU S6, S6, 1
9D00C740  A1420000   SB V0, 0(T2)
9D00C744  02B62021   ADDU A0, S5, S6
9D00C748  24020065   ADDIU V0, ZERO, 101
9D00C74C  17C20025   BNE FP, V0, __fmt_f_needed
9D00C750  A0800000   SB ZERO, 0(A0)
9D00C754  06E10003   BGEZ S7, __fmt_f_needed
9D00C758  00001825   OR V1, ZERO, ZERO
9D00C75C  0017B823   SUBU S7, ZERO, S7
9D00C760  24030001   ADDIU V1, ZERO, 1
9D00C764  8FA20050   LW V0, 80(SP)
9D00C768  8FA60018   LW A2, 24(SP)
9D00C76C  2407000A   ADDIU A3, ZERO, 10
9D00C770  2442FFFF   ADDIU V0, V0, -1
9D00C774  02A22821   ADDU A1, S5, V0
9D00C778  A0A00000   SB ZERO, 0(A1)
9D00C77C  24C9FFFE   ADDIU T1, A2, -2
9D00C780  24050002   ADDIU A1, ZERO, 2
9D00C784  16E00089   BNE S7, ZERO, __fmt_f_needed
9D00C788  01253021   ADDU A2, T1, A1
9D00C78C  1CA00087   BGTZ A1, __fmt_f_needed
9D00C790  00000000   NOP
9D00C794  2407002D   ADDIU A3, ZERO, 45
9D00C798  2405002B   ADDIU A1, ZERO, 43
9D00C79C  00E3280B   MOVN A1, A3, V1
9D00C7A0  00A01825   OR V1, A1, ZERO
9D00C7A4  02A22821   ADDU A1, S5, V0
9D00C7A8  A0A3FFFF   SB V1, -1(A1)
9D00C7AC  8FA300A4   LW V1, 164(SP)
9D00C7B0  24050045   ADDIU A1, ZERO, 69
9D00C7B4  2442FFFE   ADDIU V0, V0, -2
9D00C7B8  2463FFBF   ADDIU V1, V1, -65
9D00C7BC  2C63001A   SLTIU V1, V1, 26
9D00C7C0  00A3F00B   MOVN FP, A1, V1
9D00C7C4  02C2B02A   SLT S6, S6, V0
9D00C7C8  02A22821   ADDU A1, S5, V0
9D00C7CC  24C3FFFE   ADDIU V1, A2, -2
9D00C7D0  A0BE0000   SB FP, 0(A1)
9D00C7D4  12C00003   BEQ S6, ZERO, __fmt_f_needed
9D00C7D8  AFA30018   SW V1, 24(SP)
9D00C7DC  0F406361   JAL strcpy
9D00C7E0  00000000   NOP
9D00C7E4  8FA2001C   LW V0, 28(SP)
9D00C7E8  24030002   ADDIU V1, ZERO, 2
9D00C7EC  30420003   ANDI V0, V0, 3
9D00C7F0  1443FE9E   BNE V0, V1, __fmt_f_needed
9D00C7F4  8FA20018   LW V0, 24(SP)
9D00C7F8  1840FE9C   BLEZ V0, __fmt_f_needed
9D00C7FC  00000000   NOP
9D00C800  0F404D29   JAL strlen
9D00C804  02A02025   OR A0, S5, ZERO
9D00C808  8FA30024   LW V1, 36(SP)
9D00C80C  0043182A   SLT V1, V0, V1
9D00C810  10600070   BEQ V1, ZERO, __fmt_f_needed
9D00C814  8FA60018   LW A2, 24(SP)
9D00C818  8FA4002C   LW A0, 44(SP)
9D00C81C  0F405B7D   JAL memset
9D00C820  24050030   ADDIU A1, ZERO, 48
9D00C824  1000FE91   BEQ ZERO, ZERO, __fmt_f_needed
9D00C828  AFA00020   SW ZERO, 32(SP)
9D00C82C  02209825   OR S3, S1, ZERO
9D00C830  0240A025   OR S4, S2, ZERO
9D00C834  3BC90065   XORI T1, FP, 101
9D00C838  02E08825   OR S1, S7, ZERO
9D00C83C  1000FFA2   BEQ ZERO, ZERO, __fmt_f_needed
9D00C840  0009880A   MOVZ S1, ZERO, T1
9D00C844  8FA20040   LW V0, 64(SP)
9D00C848  02603025   OR A2, S3, ZERO
9D00C84C  02803825   OR A3, S4, ZERO
9D00C850  00602025   OR A0, V1, ZERO
9D00C854  00402825   OR A1, V0, ZERO
9D00C858  AFAB0064   SW T3, 100(SP)
9D00C85C  0F403B37   JAL dpdiv
9D00C860  AFAA0060   SW T2, 96(SP)
9D00C864  00402025   OR A0, V0, ZERO
9D00C868  0F4054C1   JAL dpfloor
9D00C86C  00602825   OR A1, V1, ZERO
9D00C870  00602825   OR A1, V1, ZERO
9D00C874  00402025   OR A0, V0, ZERO
9D00C878  AFA3005C   SW V1, 92(SP)
9D00C87C  0F405C6D   JAL __fixdfsi
9D00C880  AFA20058   SW V0, 88(SP)
9D00C884  2843000A   SLTI V1, V0, 10
9D00C888  0243100A   MOVZ V0, S2, V1
9D00C88C  8FA30054   LW V1, 84(SP)
9D00C890  8FB80058   LW T8, 88(SP)
9D00C894  8FB9005C   LW T9, 92(SP)
9D00C898  00621825   OR V1, V1, V0
9D00C89C  8FAA0060   LW T2, 96(SP)
9D00C8A0  1460000B   BNE V1, ZERO, __fmt_f_needed
9D00C8A4  8FAB0064   LW T3, 100(SP)
9D00C8A8  8FA40028   LW A0, 40(SP)
9D00C8AC  24030067   ADDIU V1, ZERO, 103
9D00C8B0  14830007   BNE A0, V1, __fmt_f_needed
9D00C8B4  00000000   NOP
9D00C8B8  06200021   BLTZ S1, __fmt_f_needed
9D00C8BC  256A0001   ADDIU T2, T3, 1
9D00C8C0  02C01825   OR V1, S6, ZERO
9D00C8C4  02B62021   ADDU A0, S5, S6
9D00C8C8  10000011   BEQ ZERO, ZERO, __fmt_f_needed
9D00C8CC  01605025   OR T2, T3, ZERO
9D00C8D0  1600FFFC   BNE S0, ZERO, __fmt_f_needed
9D00C8D4  02C01825   OR V1, S6, ZERO
9D00C8D8  0623FFFB   BGEZL S1, __fmt_f_needed
9D00C8DC  02B62021   ADDU A0, S5, S6
9D00C8E0  8FA30018   LW V1, 24(SP)
9D00C8E4  02AA5021   ADDU T2, S5, T2
9D00C8E8  26D60001   ADDIU S6, S6, 1
9D00C8EC  2463FFFF   ADDIU V1, V1, -1
9D00C8F0  AFA30018   SW V1, 24(SP)
9D00C8F4  2403002E   ADDIU V1, ZERO, 46
9D00C8F8  A1430000   SB V1, 0(T2)
9D00C8FC  1000FFF0   BEQ ZERO, ZERO, __fmt_f_needed
9D00C900  24100001   ADDIU S0, ZERO, 1
9D00C904  A0850000   SB A1, 0(A0)
9D00C908  254AFFFF   ADDIU T2, T2, -1
9D00C90C  24840001   ADDIU A0, A0, 1
9D00C910  1540FFFC   BNE T2, ZERO, __fmt_f_needed
9D00C914  24050030   ADDIU A1, ZERO, 48
9D00C918  8FA40018   LW A0, 24(SP)
9D00C91C  26D60001   ADDIU S6, S6, 1
9D00C920  02A31821   ADDU V1, S5, V1
9D00C924  2484FFFF   ADDIU A0, A0, -1
9D00C928  008B2023   SUBU A0, A0, T3
9D00C92C  02CBB021   ADDU S6, S6, T3
9D00C930  24420030   ADDIU V0, V0, 48
9D00C934  006B5821   ADDU T3, V1, T3
9D00C938  AFA40018   SW A0, 24(SP)
9D00C93C  A1620000   SB V0, 0(T3)
9D00C940  8FA20040   LW V0, 64(SP)
9D00C944  8FA50038   LW A1, 56(SP)
9D00C948  3C0B8000   LUI T3, -32768
9D00C94C  01622026   XOR A0, T3, V0
9D00C950  02603025   OR A2, S3, ZERO
9D00C954  02803825   OR A3, S4, ZERO
9D00C958  AFA50010   SW A1, 16(SP)
9D00C95C  AFA40014   SW A0, 20(SP)
9D00C960  03202825   OR A1, T9, ZERO
9D00C964  03002025   OR A0, T8, ZERO
9D00C968  0F40349D   JAL fma
9D00C96C  AFAA0058   SW T2, 88(SP)
9D00C970  8FA60030   LW A2, 48(SP)
9D00C974  8FA70034   LW A3, 52(SP)
9D00C978  3C0B8000   LUI T3, -32768
9D00C97C  AFA20038   SW V0, 56(SP)
9D00C980  02602025   OR A0, S3, ZERO
9D00C984  01631026   XOR V0, T3, V1
9D00C988  02802825   OR A1, S4, ZERO
9D00C98C  0F403B37   JAL dpdiv
9D00C990  AFA20040   SW V0, 64(SP)
9D00C994  8FAA0058   LW T2, 88(SP)
9D00C998  00409825   OR S3, V0, ZERO
9D00C99C  0060A025   OR S4, V1, ZERO
9D00C9A0  2631FFFF   ADDIU S1, S1, -1
9D00C9A4  1000FF56   BEQ ZERO, ZERO, __fmt_f_needed
9D00C9A8  01405825   OR T3, T2, ZERO
9D00C9AC  02E7001A   DIV S7, A3
9D00C9B0  00E001F4   TEQ A3, ZERO
9D00C9B4  2442FFFF   ADDIU V0, V0, -1
9D00C9B8  02A25021   ADDU T2, S5, V0
9D00C9BC  24A5FFFF   ADDIU A1, A1, -1
9D00C9C0  00003010   MFHI A2
9D00C9C4  24C60030   ADDIU A2, A2, 48
9D00C9C8  A1460000   SB A2, 0(T2)
9D00C9CC  1000FF6D   BEQ ZERO, ZERO, __fmt_f_needed
9D00C9D0  0000B812   MFLO S7
9D00C9D4  02A21821   ADDU V1, S5, V0
9D00C9D8  80640000   LB A0, 0(V1)
9D00C9DC  8FA30018   LW V1, 24(SP)
9D00C9E0  00621821   ADDU V1, V1, V0
9D00C9E4  02A31821   ADDU V1, S5, V1
9D00C9E8  A0640000   SB A0, 0(V1)
9D00C9EC  1000FF86   BEQ ZERO, ZERO, __fmt_f_needed
9D00C9F0  2442FFFF   ADDIU V0, V0, -1
9D00C9F4  06E1FEB6   BGEZ S7, __fmt_f_needed
9D00C9F8  8FA30028   LW V1, 40(SP)
9D00C9FC  1000FEAC   BEQ ZERO, ZERO, __fmt_f_needed
9D00CA00  241E0066   ADDIU FP, ZERO, 102
9D00CA04  1000FE58   BEQ ZERO, ZERO, __fmt_f_needed
9D00CA08  24100006   ADDIU S0, ZERO, 6
9D00CA0C  1062FE56   BEQ V1, V0, __fmt_f_needed
9D00CA10  24100006   ADDIU S0, ZERO, 6
9D00CA14  1000FEA6   BEQ ZERO, ZERO, __fmt_f_needed
9D00CA18  0060F025   OR FP, V1, ZERO
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/stdio/mchp/__fmt_d.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0138B4  27BDFFC0   ADDIU SP, SP, -64
9D0138B8  AFB1002C   SW S1, 44(SP)
9D0138BC  00808825   OR S1, A0, ZERO
9D0138C0  00C02025   OR A0, A2, ZERO
9D0138C4  8C870004   LW A3, 4(A0)
9D0138C8  8CA20000   LW V0, 0(A1)
9D0138CC  AFB40038   SW S4, 56(SP)
9D0138D0  0007A7C2   SRL S4, A3, 31
9D0138D4  AFB30034   SW S3, 52(SP)
9D0138D8  AFB20030   SW S2, 48(SP)
9D0138DC  AFB00028   SW S0, 40(SP)
9D0138E0  AFBF003C   SW RA, 60(SP)
9D0138E4  00A08025   OR S0, A1, ZERO
9D0138E8  8CA30004   LW V1, 4(A1)
9D0138EC  8CB20008   LW S2, 8(A1)
9D0138F0  AFA20020   SW V0, 32(SP)
9D0138F4  8CB3000C   LW S3, 12(A1)
9D0138F8  1280003E   BEQ S4, ZERO, __fmt_d_needed
9D0138FC  8CC60000   LW A2, 0(A2)
9D013900  00063023   SUBU A2, ZERO, A2
9D013904  0006202B   SLTU A0, ZERO, A2
9D013908  00073823   SUBU A3, ZERO, A3
9D01390C  04600008   BLTZ V1, __fmt_d_needed
9D013910  00E43823   SUBU A3, A3, A0
9D013914  7C020844   INS V0, ZERO, 1, 1
9D013918  16800005   BNE S4, ZERO, __fmt_d_needed
9D01391C  AFA20020   SW V0, 32(SP)
9D013920  8FA20020   LW V0, 32(SP)
9D013924  30430004   ANDI V1, V0, 4
9D013928  1060002A   BEQ V1, ZERO, __fmt_d_needed
9D01392C  7C4200C0   EXT V0, V0, 3, 1
9D013930  2642FFFF   ADDIU V0, S2, -1
9D013934  27A30020   ADDIU V1, SP, 32
9D013938  AFA30018   SW V1, 24(SP)
9D01393C  2403000A   ADDIU V1, ZERO, 10
9D013940  AFA30014   SW V1, 20(SP)
9D013944  AFA20010   SW V0, 16(SP)
9D013948  0F404F24   JAL __cvt_u
9D01394C  02002025   OR A0, S0, ZERO
9D013950  16800006   BNE S4, ZERO, __fmt_d_needed
9D013954  2403002D   ADDIU V1, ZERO, 45
9D013958  8FA30020   LW V1, 32(SP)
9D01395C  30640004   ANDI A0, V1, 4
9D013960  1080001E   BEQ A0, ZERO, __fmt_d_needed
9D013964  30630008   ANDI V1, V1, 8
9D013968  2403002B   ADDIU V1, ZERO, 43
9D01396C  2442FFFF   ADDIU V0, V0, -1
9D013970  02622021   ADDU A0, S3, V0
9D013974  A0830000   SB V1, 0(A0)
9D013978  8E060010   LW A2, 16(S0)
9D01397C  8FA30020   LW V1, 32(SP)
9D013980  02403825   OR A3, S2, ZERO
9D013984  24C6FFFF   ADDIU A2, A2, -1
9D013988  AFA30010   SW V1, 16(SP)
9D01398C  00C23023   SUBU A2, A2, V0
9D013990  02622821   ADDU A1, S3, V0
9D013994  0F405543   JAL __pad
9D013998  02202025   OR A0, S1, ZERO
9D01399C  8E230004   LW V1, 4(S1)
9D0139A0  30630100   ANDI V1, V1, 256
9D0139A4  10600004   BEQ V1, ZERO, __fmt_d_needed
9D0139A8  8FBF003C   LW RA, 60(SP)
9D0139AC  8E030004   LW V1, 4(S0)
9D0139B0  0043202A   SLT A0, V0, V1
9D0139B4  0064100B   MOVN V0, V1, A0
9D0139B8  8FB40038   LW S4, 56(SP)
9D0139BC  8FB30034   LW S3, 52(SP)
9D0139C0  8FB20030   LW S2, 48(SP)
9D0139C4  8FB1002C   LW S1, 44(SP)
9D0139C8  8FB00028   LW S0, 40(SP)
9D0139CC  03E00008   JR RA
9D0139D0  27BD0040   ADDIU SP, SP, 64
9D0139D4  1000FFD7   BEQ ZERO, ZERO, __fmt_d_needed
9D0139D8  02421023   SUBU V0, S2, V0
9D0139DC  1060FFE6   BEQ V1, ZERO, __fmt_d_needed
9D0139E0  24040020   ADDIU A0, ZERO, 32
9D0139E4  2442FFFF   ADDIU V0, V0, -1
9D0139E8  02621821   ADDU V1, S3, V0
9D0139EC  1000FFE2   BEQ ZERO, ZERO, __fmt_d_needed
9D0139F0  A0640000   SB A0, 0(V1)
9D0139F4  0463FFC8   BGEZL V1, __fmt_d_needed
9D0139F8  7C020844   INS V0, ZERO, 1, 1
9D0139FC  1000FFC9   BEQ ZERO, ZERO, __fmt_d_needed
9D013A00  8FA20020   LW V0, 32(SP)
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/stdio/mchp/__fmt_a.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00CA1C  8CA20000   LW V0, 0(A1)
9D00CA20  27BDFF70   ADDIU SP, SP, -144
9D00CA24  AFB70084   SW S7, 132(SP)
9D00CA28  AFA20024   SW V0, 36(SP)
9D00CA2C  8CA20004   LW V0, 4(A1)
9D00CA30  AFB1006C   SW S1, 108(SP)
9D00CA34  8CD70000   LW S7, 0(A2)
9D00CA38  AFA2002C   SW V0, 44(SP)
9D00CA3C  8CA20008   LW V0, 8(A1)
9D00CA40  8CD10004   LW S1, 4(A2)
9D00CA44  AFB20070   SW S2, 112(SP)
9D00CA48  AFA20028   SW V0, 40(SP)
9D00CA4C  8CA20010   LW V0, 16(A1)
9D00CA50  AFB00068   SW S0, 104(SP)
9D00CA54  AFA40090   SW A0, 144(SP)
9D00CA58  00E09025   OR S2, A3, ZERO
9D00CA5C  8CB0000C   LW S0, 12(A1)
9D00CA60  00003025   OR A2, ZERO, ZERO
9D00CA64  00003825   OR A3, ZERO, ZERO
9D00CA68  02E02025   OR A0, S7, ZERO
9D00CA6C  02202825   OR A1, S1, ZERO
9D00CA70  AFBF008C   SW RA, 140(SP)
9D00CA74  AFBE0088   SW FP, 136(SP)
9D00CA78  AFB60080   SW S6, 128(SP)
9D00CA7C  AFB5007C   SW S5, 124(SP)
9D00CA80  AFB40078   SW S4, 120(SP)
9D00CA84  AFB30074   SW S3, 116(SP)
9D00CA88  0F405056   JAL __ltdf2
9D00CA8C  AFA20040   SW V0, 64(SP)
9D00CA90  0440000E   BLTZ V0, __fmt_a_needed
9D00CA94  8FA20024   LW V0, 36(SP)
9D00CA98  30420004   ANDI V0, V0, 4
9D00CA9C  1440000E   BNE V0, ZERO, __fmt_a_needed
9D00CAA0  2402002B   ADDIU V0, ZERO, 43
9D00CAA4  8FA20024   LW V0, 36(SP)
9D00CAA8  30420008   ANDI V0, V0, 8
9D00CAAC  AFA20020   SW V0, 32(SP)
9D00CAB0  8FA20028   LW V0, 40(SP)
9D00CAB4  AFA20038   SW V0, 56(SP)
9D00CAB8  8FA20020   LW V0, 32(SP)
9D00CABC  1040000C   BEQ V0, ZERO, __fmt_a::__DOUBLE_BITS
9D00CAC0  24020020   ADDIU V0, ZERO, 32
9D00CAC4  10000005   BEQ ZERO, ZERO, __fmt_a_needed
9D00CAC8  A2020000   SB V0, 0(S0)
9D00CACC  3C028000   LUI V0, -32768
9D00CAD0  00518826   XOR S1, V0, S1
9D00CAD4  2402002D   ADDIU V0, ZERO, 45
9D00CAD8  A2020000   SB V0, 0(S0)
9D00CADC  8FA20028   LW V0, 40(SP)
9D00CAE0  2442FFFF   ADDIU V0, V0, -1
9D00CAE4  AFA20038   SW V0, 56(SP)
9D00CAE8  24020001   ADDIU V0, ZERO, 1
9D00CAEC  AFA20020   SW V0, 32(SP)
9D00CAF0  2643FFBF   ADDIU V1, S2, -65
9D00CAF4  7E22F000   EXT V0, S1, 0, 31
9D00CAF8  16E00025   BNE S7, ZERO, __fmt_a_needed
9D00CAFC  AFA30030   SW V1, 48(SP)
9D00CB00  3C037FF0   LUI V1, 32752
9D00CB04  14430023   BNE V0, V1, __fmt_a_needed
9D00CB08  8FA30020   LW V1, 32(SP)
9D00CB0C  8FA20020   LW V0, 32(SP)
9D00CB10  3C119D01   LUI S1, -25343
9D00CB14  02022021   ADDU A0, S0, V0
9D00CB18  8FA20030   LW V0, 48(SP)
9D00CB1C  2C42001A   SLTIU V0, V0, 26
9D00CB20  10400003   BEQ V0, ZERO, __fmt_a_needed
9D00CB24  2625B42C   ADDIU A1, S1, -19412
9D00CB28  3C059D01   LUI A1, -25343
9D00CB2C  24A5B428   ADDIU A1, A1, -19416
9D00CB30  0F406361   JAL strcpy
9D00CB34  00000000   NOP
9D00CB38  2624B42C   ADDIU A0, S1, -19412
9D00CB3C  0F404D29   JAL strlen
9D00CB40  00000000   NOP
9D00CB44  8FA30024   LW V1, 36(SP)
9D00CB48  8FA70028   LW A3, 40(SP)
9D00CB4C  8FA40090   LW A0, 144(SP)
9D00CB50  AFA30010   SW V1, 16(SP)
9D00CB54  02002825   OR A1, S0, ZERO
9D00CB58  0F405543   JAL __pad
9D00CB5C  00403025   OR A2, V0, ZERO
9D00CB60  8FBF008C   LW RA, 140(SP)
9D00CB64  8FBE0088   LW FP, 136(SP)
9D00CB68  8FB70084   LW S7, 132(SP)
9D00CB6C  8FB60080   LW S6, 128(SP)
9D00CB70  8FB5007C   LW S5, 124(SP)
9D00CB74  8FB40078   LW S4, 120(SP)
9D00CB78  8FB30074   LW S3, 116(SP)
9D00CB7C  8FB20070   LW S2, 112(SP)
9D00CB80  8FB1006C   LW S1, 108(SP)
9D00CB84  8FB00068   LW S0, 104(SP)
9D00CB88  03E00008   JR RA
9D00CB8C  27BD0090   ADDIU SP, SP, 144
9D00CB90  8FA30020   LW V1, 32(SP)
9D00CB94  3C057FF0   LUI A1, 32752
9D00CB98  8FA40030   LW A0, 48(SP)
9D00CB9C  02039021   ADDU S2, S0, V1
9D00CBA0  24A30001   ADDIU V1, A1, 1
9D00CBC0  3C119D01   LUI S1, -25343
9D00CBC4  10800003   BEQ A0, ZERO, __fmt_a_needed
9D00CBC8  2625B434   ADDIU A1, S1, -19404
9D00CBCC  3C059D01   LUI A1, -25343
9D00CBD0  24A5B430   ADDIU A1, A1, -19408
9D00CBD4  0F406361   JAL strcpy
9D00CBD8  02402025   OR A0, S2, ZERO
9D00CBDC  1000FFD7   BEQ ZERO, ZERO, __fmt_a_needed
9D00CBE0  2624B434   ADDIU A0, S1, -19404
9D00CBE4  24030058   ADDIU V1, ZERO, 88
9D00CBE8  A2420000   SB V0, 0(S2)
9D00CBEC  24020078   ADDIU V0, ZERO, 120
9D00CBF0  0064100B   MOVN V0, V1, A0
9D00CBF4  00003025   OR A2, ZERO, ZERO
9D00CBF8  00003825   OR A3, ZERO, ZERO
9D00CBFC  02E02025   OR A0, S7, ZERO
9D00CC00  02202825   OR A1, S1, ZERO
9D00CC04  0F40500B   JAL __eqdf2
9D00CC08  AFA20034   SW V0, 52(SP)
9D00CC0C  3C039D02   LUI V1, -25342
9D00CC10  AFA0001C   SW ZERO, 28(SP)
9D00CC14  1440014F   BNE V0, ZERO, __fmt_a_needed
9D00CC18  8C768DD8   LW S6, -29224(V1)
9D00CC1C  8C628DDC   LW V0, -29220(V1)
9D00CC20  AFA20018   SW V0, 24(SP)
9D00CC24  8FA2002C   LW V0, 44(SP)
9D00CC28  8FA3002C   LW V1, 44(SP)
9D00CC2C  8FBE0018   LW FP, 24(SP)
9D00CC30  28550000   SLTI S5, V0, 0
9D00CC34  24020018   ADDIU V0, ZERO, 24
9D00CC38  0055180B   MOVN V1, V0, S5
9D00CC3C  8FA20034   LW V0, 52(SP)
9D00CC40  0060A825   OR S5, V1, ZERO
9D00CC44  02C0A025   OR S4, S6, ZERO
9D00CC48  A2420001   SB V0, 1(S2)
9D00CC4C  24620001   ADDIU V0, V1, 1
9D00CC50  AFA20044   SW V0, 68(SP)
9D00CC54  3C029D02   LUI V0, -25342
9D00CC58  8C448DF0   LW A0, -29200(V0)
9D00CC5C  8C458DF4   LW A1, -29196(V0)
9D00CC60  AFB70034   SW S7, 52(SP)
9D00CC64  02209825   OR S3, S1, ZERO
9D00CC68  00009025   OR S2, ZERO, ZERO
9D00CC6C  AFA40058   SW A0, 88(SP)
9D00CC70  AFA5005C   SW A1, 92(SP)
9D00CC74  AFA20050   SW V0, 80(SP)
9D00CC78  8FAA0034   LW T2, 52(SP)
9D00CC7C  02803025   OR A2, S4, ZERO
9D00CC80  03C03825   OR A3, FP, ZERO
9D00CC84  01402025   OR A0, T2, ZERO
9D00CC88  02602825   OR A1, S3, ZERO
9D00CC8C  AFAA0060   SW T2, 96(SP)
9D00CC90  0F403B37   JAL dpdiv
9D00CC94  AFB30034   SW S3, 52(SP)
9D00CC98  00402025   OR A0, V0, ZERO
9D00CC9C  0F4054C1   JAL dpfloor
9D00CCA0  00602825   OR A1, V1, ZERO
9D00CCA4  00402025   OR A0, V0, ZERO
9D00CCA8  02803025   OR A2, S4, ZERO
9D00CCAC  03C03825   OR A3, FP, ZERO
9D00CCB0  00602825   OR A1, V1, ZERO
9D00CCB4  AFA20048   SW V0, 72(SP)
9D00CCB8  0F404121   JAL dpmul
9D00CCBC  AFA3004C   SW V1, 76(SP)
9D00CCC0  8FAA0060   LW T2, 96(SP)
9D00CCC4  8FA90034   LW T1, 52(SP)
9D00CCC8  00403025   OR A2, V0, ZERO
9D00CCCC  01402025   OR A0, T2, ZERO
9D00CCD0  01202825   OR A1, T1, ZERO
9D00CCD4  0F403C65   JAL dpsub
9D00CCD8  00603825   OR A3, V1, ZERO
9D00CCDC  8FA60058   LW A2, 88(SP)
9D00CCE0  8FA7005C   LW A3, 92(SP)
9D00CCE4  02802025   OR A0, S4, ZERO
9D00CCE8  03C02825   OR A1, FP, ZERO
9D00CCEC  AFA20034   SW V0, 52(SP)
9D00CCF0  AFA20064   SW V0, 100(SP)
9D00CCF4  00609825   OR S3, V1, ZERO
9D00CCF8  0F404121   JAL dpmul
9D00CCFC  AFA30060   SW V1, 96(SP)
9D00CD00  0040A025   OR S4, V0, ZERO
9D00CD04  8FA2002C   LW V0, 44(SP)
9D00CD08  0060F025   OR FP, V1, ZERO
9D00CD0C  0441000A   BGEZ V0, __fmt_a_needed
9D00CD10  26520001   ADDIU S2, S2, 1
9D00CD14  8FAA0064   LW T2, 100(SP)
9D00CD18  8FA90060   LW T1, 96(SP)
9D00CD1C  00003025   OR A2, ZERO, ZERO
9D00CD20  00003825   OR A3, ZERO, ZERO
9D00CD24  01402025   OR A0, T2, ZERO
9D00CD28  0F40500B   JAL __eqdf2
9D00CD2C  01202825   OR A1, T1, ZERO
9D00CD30  10400005   BEQ V0, ZERO, __fmt_a_needed
9D00CD34  3C029D02   LUI V0, -25342
9D00CD38  8FA20044   LW V0, 68(SP)
9D00CD3C  1452FFCE   BNE V0, S2, __fmt_a_needed
9D00CD40  3C029D02   LUI V0, -25342
9D00CD44  26B20001   ADDIU S2, S5, 1
9D00CD48  8C468DF8   LW A2, -29192(V0)
9D00CD4C  8C478DFC   LW A3, -29188(V0)
9D00CD50  02802025   OR A0, S4, ZERO
9D00CD54  0F404121   JAL dpmul
9D00CD58  03C02825   OR A1, FP, ZERO
9D00CD5C  0060A825   OR S5, V1, ZERO
9D00CD60  00603825   OR A3, V1, ZERO
9D00CD64  8FA30034   LW V1, 52(SP)
9D00CD68  00403025   OR A2, V0, ZERO
9D00CD6C  02602825   OR A1, S3, ZERO
9D00CD70  00602025   OR A0, V1, ZERO
9D00CD74  0F405056   JAL __ltdf2
9D00CD78  0040A025   OR S4, V0, ZERO
9D00CD7C  0440000D   BLTZ V0, __fmt_a_needed
9D00CD80  02803025   OR A2, S4, ZERO
9D00CD84  8FA30034   LW V1, 52(SP)
9D00CD88  02A03825   OR A3, S5, ZERO
9D00CD8C  00602025   OR A0, V1, ZERO
9D00CD90  0F40500B   JAL __eqdf2
9D00CD94  02602825   OR A1, S3, ZERO
9D00CD98  14400008   BNE V0, ZERO, __fmt_a_needed
9D00CD9C  8FA40048   LW A0, 72(SP)
9D00CDA0  0F405C6D   JAL __fixdfsi
9D00CDA4  8FA5004C   LW A1, 76(SP)
9D00CDA8  30420001   ANDI V0, V0, 1
9D00CDAC  14400004   BNE V0, ZERO, __fmt_a_needed
9D00CDB0  8FA20020   LW V0, 32(SP)
9D00CDB4  0000A025   OR S4, ZERO, ZERO
9D00CDB8  0000A825   OR S5, ZERO, ZERO
9D00CDBC  8FA20020   LW V0, 32(SP)
9D00CDC0  02202825   OR A1, S1, ZERO
9D00CDC4  02803025   OR A2, S4, ZERO
9D00CDC8  24420002   ADDIU V0, V0, 2
9D00CDCC  02A03825   OR A3, S5, ZERO
9D00CDD0  02E02025   OR A0, S7, ZERO
9D00CDD4  0F403C67   JAL __adddf3
9D00CDD8  AFA20020   SW V0, 32(SP)
9D00CDDC  00408825   OR S1, V0, ZERO
9D00CDE0  AFA30034   SW V1, 52(SP)
9D00CDE4  16200004   BNE S1, ZERO, __fmt_a_needed
9D00CDF0  1062FF47   BEQ V1, V0, __fmt_a_needed
9D00CDF4  8FA20020   LW V0, 32(SP)
9D00CDF8  8FA20038   LW V0, 56(SP)
9D00CDFC  8FBE0020   LW FP, 32(SP)
9D00CE00  0000A025   OR S4, ZERO, ZERO
9D00CE04  2453FFFE   ADDIU S3, V0, -2
9D00CE08  00121023   SUBU V0, ZERO, S2
9D00CE0C  AFA20048   SW V0, 72(SP)
9D00CE10  8FA20040   LW V0, 64(SP)
9D00CE14  00009025   OR S2, ZERO, ZERO
9D00CE18  0000A825   OR S5, ZERO, ZERO
9D00CE1C  2442FFFB   ADDIU V0, V0, -5
9D00CE20  AFA20044   SW V0, 68(SP)
9D00CE24  8FA20030   LW V0, 48(SP)
9D00CE28  2C42001A   SLTIU V0, V0, 26
9D00CE2C  AFA20058   SW V0, 88(SP)
9D00CE30  8FA20050   LW V0, 80(SP)
9D00CE34  8C438DF4   LW V1, -29196(V0)
9D00CE38  8C428DF0   LW V0, -29200(V0)
9D00CE3C  AFA30054   SW V1, 84(SP)
9D00CE40  AFA20050   SW V0, 80(SP)
9D00CE44  8FA20044   LW V0, 68(SP)
9D00CE48  03C2102B   SLTU V0, FP, V0
9D00CE4C  1040002B   BEQ V0, ZERO, __fmt_a_needed
9D00CE50  03C0B825   OR S7, FP, ZERO
9D00CE54  8FA20034   LW V0, 52(SP)
9D00CE58  8FA70018   LW A3, 24(SP)
9D00CE5C  02C03025   OR A2, S6, ZERO
9D00CE60  02202025   OR A0, S1, ZERO
9D00CE64  0F403B37   JAL dpdiv
9D00CE68  00402825   OR A1, V0, ZERO
9D00CE6C  00402025   OR A0, V0, ZERO
9D00CE70  0F4054C1   JAL dpfloor
9D00CE74  00602825   OR A1, V1, ZERO
9D00CE78  00402025   OR A0, V0, ZERO
9D00CE7C  00602825   OR A1, V1, ZERO
9D00CE80  AFA20038   SW V0, 56(SP)
9D00CE84  0F405C6D   JAL __fixdfsi
9D00CE88  AFA3003C   SW V1, 60(SP)
9D00CE8C  144000B4   BNE V0, ZERO, __fmt_a_needed
9D00CE90  00000000   NOP
9D00CE94  52A000BC   BEQL S5, ZERO, __fmt_a_needed
9D00CE98  0012902B   SLTU S2, ZERO, S2
9D00CE9C  26940001   ADDIU S4, S4, 1
9D00CEA0  8FA70018   LW A3, 24(SP)
9D00CEA4  8FA40038   LW A0, 56(SP)
9D00CEA8  8FA5003C   LW A1, 60(SP)
9D00CEAC  02C03025   OR A2, S6, ZERO
9D00CEB0  0F404121   JAL dpmul
9D00CEB4  26B5FFFF   ADDIU S5, S5, -1
9D00CEB8  00403025   OR A2, V0, ZERO
9D00CEBC  8FA20034   LW V0, 52(SP)
9D00CEC0  02202025   OR A0, S1, ZERO
9D00CEC4  00603825   OR A3, V1, ZERO
9D00CEC8  0F403C65   JAL dpsub
9D00CECC  00402825   OR A1, V0, ZERO
9D00CED0  8FA50018   LW A1, 24(SP)
9D00CED4  8FA60050   LW A2, 80(SP)
9D00CED8  8FA70054   LW A3, 84(SP)
9D00CEDC  02C02025   OR A0, S6, ZERO
9D00CEE0  00408825   OR S1, V0, ZERO
9D00CEE4  0F404121   JAL dpmul
9D00CEE8  AFA30034   SW V1, 52(SP)
9D00CEEC  0040B025   OR S6, V0, ZERO
9D00CEF0  8FA20048   LW V0, 72(SP)
9D00CEF4  1455FFD3   BNE V0, S5, __fmt_a_needed
9D00CEF8  AFA30018   SW V1, 24(SP)
9D00CEFC  56400015   BNEL S2, ZERO, __fmt_a_needed
9D00CF00  8FA2001C   LW V0, 28(SP)
9D00CF04  128000D3   BEQ S4, ZERO, __fmt_a_needed
9D00CF08  021E1021   ADDU V0, S0, FP
9D00CF0C  8FA3002C   LW V1, 44(SP)
9D00CF10  186000D0   BLEZ V1, __fmt_a_needed
9D00CF14  8FA30024   LW V1, 36(SP)
9D00CF18  30630001   ANDI V1, V1, 1
9D00CF1C  146000CD   BNE V1, ZERO, __fmt_a_needed
9D00CF20  2403002E   ADDIU V1, ZERO, 46
9D00CF24  A0430000   SB V1, 0(V0)
9D00CF28  029E1821   ADDU V1, S4, FP
9D00CF2C  02031821   ADDU V1, S0, V1
9D00CF30  24040030   ADDIU A0, ZERO, 48
9D00CF34  A0440001   SB A0, 1(V0)
9D00CF38  24420001   ADDIU V0, V0, 1
9D00CF3C  1443FFFD   BNE V0, V1, __fmt_a_needed
9D00CF40  00144027   NOR T0, ZERO, S4
9D00CF44  029EF021   ADDU FP, S4, FP
9D00CF48  27DE0001   ADDIU FP, FP, 1
9D00CF4C  01139821   ADDU S3, T0, S3
9D00CF50  8FA2001C   LW V0, 28(SP)
9D00CF54  021E2021   ADDU A0, S0, FP
9D00CF58  A0800000   SB ZERO, 0(A0)
9D00CF5C  04410004   BGEZ V0, __fmt_a_needed
9D00CF60  00001825   OR V1, ZERO, ZERO
9D00CF64  00021023   SUBU V0, ZERO, V0
9D00CF68  AFA2001C   SW V0, 28(SP)
9D00CF6C  24030001   ADDIU V1, ZERO, 1
9D00CF70  8FA20040   LW V0, 64(SP)
9D00CF74  2669FFFF   ADDIU T1, S3, -1
9D00CF78  24080001   ADDIU T0, ZERO, 1
9D00CF7C  2442FFFF   ADDIU V0, V0, -1
9D00CF80  02022821   ADDU A1, S0, V0
9D00CF84  A0A00000   SB ZERO, 0(A1)
9D00CF88  2407000A   ADDIU A3, ZERO, 10
9D00CF8C  24050001   ADDIU A1, ZERO, 1
9D00CF90  8FA6001C   LW A2, 28(SP)
9D00CF94  14C0009D   BNE A2, ZERO, __fmt_a_needed
9D00CF98  01258821   ADDU S1, T1, A1
9D00CF9C  10A8009A   BEQ A1, T0, __fmt_a_needed
9D00CFA0  2406002D   ADDIU A2, ZERO, 45
9D00CFA4  2405002B   ADDIU A1, ZERO, 43
9D00CFA8  00C3280B   MOVN A1, A2, V1
9D00CFAC  00A01825   OR V1, A1, ZERO
9D00CFB0  02022821   ADDU A1, S0, V0
9D00CFB4  A0A3FFFF   SB V1, -1(A1)
9D00CFB8  8FA30030   LW V1, 48(SP)
9D00CFBC  24060050   ADDIU A2, ZERO, 80
9D00CFC0  24050070   ADDIU A1, ZERO, 112
9D00CFC4  2C63001A   SLTIU V1, V1, 26
9D00CFC8  00C3280B   MOVN A1, A2, V1
9D00CFCC  2442FFFE   ADDIU V0, V0, -2
9D00CFD0  00A01825   OR V1, A1, ZERO
9D00CFD4  02022821   ADDU A1, S0, V0
9D00CFD8  03C2102A   SLT V0, FP, V0
9D00CFDC  10400003   BEQ V0, ZERO, __fmt_a_needed
9D00CFE0  A0A30000   SB V1, 0(A1)
9D00CFE4  0F406361   JAL strcpy
9D00CFE8  00000000   NOP
9D00CFEC  8FA20024   LW V0, 36(SP)
9D00CFF0  24030002   ADDIU V1, ZERO, 2
9D00CFF4  30420003   ANDI V0, V0, 3
9D00CFF8  1443000E   BNE V0, V1, __fmt_a_needed
9D00CFFC  2632FFFE   ADDIU S2, S1, -2
9D00D000  1A40FECE   BLEZ S2, __fmt_a_needed
9D00D004  02002025   OR A0, S0, ZERO
9D00D008  0F404D29   JAL strlen
9D00D00C  02002025   OR A0, S0, ZERO
9D00D010  8FA30020   LW V1, 32(SP)
9D00D014  0043182A   SLT V1, V0, V1
9D00D018  10600087   BEQ V1, ZERO, __fmt_a_needed
9D00D01C  02403025   OR A2, S2, ZERO
9D00D020  8FA20020   LW V0, 32(SP)
9D00D024  24050030   ADDIU A1, ZERO, 48
9D00D028  0F405B7D   JAL memset
9D00D02C  02022021   ADDU A0, S0, V0
9D00D030  AFA00028   SW ZERO, 40(SP)
9D00D034  1000FEC1   BEQ ZERO, ZERO, __fmt_a_needed
9D00D038  02002025   OR A0, S0, ZERO
9D00D03C  8FA2001C   LW V0, 28(SP)
9D00D040  0280B025   OR S6, S4, ZERO
9D00D044  AFB30018   SW S3, 24(SP)
9D00D048  24420001   ADDIU V0, V0, 1
9D00D04C  AFA2001C   SW V0, 28(SP)
9D00D050  8FA70018   LW A3, 24(SP)
9D00D054  8FA50018   LW A1, 24(SP)
9D00D058  02C03025   OR A2, S6, ZERO
9D00D05C  0F403C67   JAL __adddf3
9D00D060  02C02025   OR A0, S6, ZERO
9D00D064  00403025   OR A2, V0, ZERO
9D00D068  00603825   OR A3, V1, ZERO
9D00D06C  02E02025   OR A0, S7, ZERO
9D00D070  02202825   OR A1, S1, ZERO
9D00D074  0040A025   OR S4, V0, ZERO
9D00D078  0F405056   JAL __ltdf2
9D00D07C  00609825   OR S3, V1, ZERO
9D00D080  0441FFEE   BGEZ V0, __fmt_a_needed
9D00D084  3C029D02   LUI V0, -25342
9D00D088  8C538DE0   LW S3, -29216(V0)
9D00D08C  8C548DE4   LW S4, -29212(V0)
9D00D090  3C029D02   LUI V0, -25342
9D00D094  8C558DE8   LW S5, -29208(V0)
9D00D098  8C5E8DEC   LW FP, -29204(V0)
9D00D09C  AFB30050   SW S3, 80(SP)
9D00D0A0  AFB50048   SW S5, 72(SP)
9D00D0A4  AFBE0044   SW FP, 68(SP)
9D00D0A8  AFB40058   SW S4, 88(SP)
9D00D0AC  8FA70018   LW A3, 24(SP)
9D00D0B0  02C03025   OR A2, S6, ZERO
9D00D0B4  02E02025   OR A0, S7, ZERO
9D00D0B8  0F405056   JAL __ltdf2
9D00D0BC  02202825   OR A1, S1, ZERO
9D00D0C0  0441FED8   BGEZ V0, __fmt_a_needed
9D00D0C4  02603025   OR A2, S3, ZERO
9D00D0C8  8FA50018   LW A1, 24(SP)
9D00D0CC  02803825   OR A3, S4, ZERO
9D00D0D0  0F404121   JAL dpmul
9D00D0D4  02C02025   OR A0, S6, ZERO
9D00D0D8  00402025   OR A0, V0, ZERO
9D00D0DC  00003025   OR A2, ZERO, ZERO
9D00D0E0  00003825   OR A3, ZERO, ZERO
9D00D0E4  0F40500B   JAL __eqdf2
9D00D0E8  00602825   OR A1, V1, ZERO
9D00D0EC  1440000E   BNE V0, ZERO, __fmt_a_needed
9D00D0F0  02A03025   OR A2, S5, ZERO
9D00D0F4  8FA50018   LW A1, 24(SP)
9D00D0F8  02C02025   OR A0, S6, ZERO
9D00D0FC  0F404121   JAL dpmul
9D00D100  03C03825   OR A3, FP, ZERO
9D00D104  8FA60048   LW A2, 72(SP)
9D00D108  8FA70044   LW A3, 68(SP)
9D00D10C  02E02025   OR A0, S7, ZERO
9D00D110  02202825   OR A1, S1, ZERO
9D00D114  0040B025   OR S6, V0, ZERO
9D00D118  0F404121   JAL dpmul
9D00D11C  AFA30018   SW V1, 24(SP)
9D00D120  0040B825   OR S7, V0, ZERO
9D00D124  00608825   OR S1, V1, ZERO
9D00D128  8FA50018   LW A1, 24(SP)
9D00D12C  8FA60050   LW A2, 80(SP)
9D00D130  8FA70058   LW A3, 88(SP)
9D00D134  0F404121   JAL dpmul
9D00D138  02C02025   OR A0, S6, ZERO
9D00D13C  0040B025   OR S6, V0, ZERO
9D00D140  8FA2001C   LW V0, 28(SP)
9D00D144  AFA30018   SW V1, 24(SP)
9D00D148  2442FFFF   ADDIU V0, V0, -1
9D00D14C  1000FFD7   BEQ ZERO, ZERO, __fmt_a_needed
9D00D150  AFA2001C   SW V0, 28(SP)
9D00D154  8C628DDC   LW V0, -29220(V1)
9D00D158  1000FFBD   BEQ ZERO, ZERO, __fmt_a_needed
9D00D15C  AFA20018   SW V0, 24(SP)
9D00D160  5640000A   BNEL S2, ZERO, __fmt_a_needed
9D00D164  03C0B825   OR S7, FP, ZERO
9D00D168  52A00008   BEQL S5, ZERO, __fmt_a_needed
9D00D16C  03C0B825   OR S7, FP, ZERO
9D00D170  0217B821   ADDU S7, S0, S7
9D00D174  2403002E   ADDIU V1, ZERO, 46
9D00D178  27DE0001   ADDIU FP, FP, 1
9D00D17C  2673FFFF   ADDIU S3, S3, -1
9D00D180  A2E30000   SB V1, 0(S7)
9D00D184  24120001   ADDIU S2, ZERO, 1
9D00D188  03C0B825   OR S7, FP, ZERO
9D00D18C  021E2021   ADDU A0, S0, FP
9D00D190  10000005   BEQ ZERO, ZERO, __fmt_a_needed
9D00D194  02801825   OR V1, S4, ZERO
9D00D198  24050030   ADDIU A1, ZERO, 48
9D00D19C  A0850000   SB A1, 0(A0)
9D00D1A0  2463FFFF   ADDIU V1, V1, -1
9D00D1A4  24840001   ADDIU A0, A0, 1
9D00D1A8  1460FFFB   BNE V1, ZERO, __fmt_a_needed
9D00D1AC  2669FFFF   ADDIU T1, S3, -1
9D00D1B0  27DE0001   ADDIU FP, FP, 1
9D00D1B4  02974021   ADDU T0, S4, S7
9D00D1B8  2843000A   SLTI V1, V0, 10
9D00D1BC  01349823   SUBU S3, T1, S4
9D00D1C0  03D4F021   ADDU FP, FP, S4
9D00D1C4  0208B821   ADDU S7, S0, T0
9D00D1C8  10600002   BEQ V1, ZERO, __fmt_a_needed
9D00D1CC  24440057   ADDIU A0, V0, 87
9D00D1D0  24440030   ADDIU A0, V0, 48
9D00D1D4  8FA20058   LW V0, 88(SP)
9D00D1D8  10400008   BEQ V0, ZERO, __fmt_a_needed
9D00D1DC  34820020   ORI V0, A0, 32
9D00D1E0  2442FF9F   ADDIU V0, V0, -97
9D00D1E4  2C42001A   SLTIU V0, V0, 26
9D00D1E8  50400005   BEQL V0, ZERO, __fmt_a_needed
9D00D1EC  A2E40000   SB A0, 0(S7)
9D00D1F0  0F4063D8   JAL toupper
9D00D1F4  00000000   NOP
9D00D1F8  00402025   OR A0, V0, ZERO
9D00D1FC  A2E40000   SB A0, 0(S7)
9D00D200  1000FF27   BEQ ZERO, ZERO, __fmt_a_needed
9D00D204  0000A025   OR S4, ZERO, ZERO
9D00D208  8FA6001C   LW A2, 28(SP)
9D00D20C  2442FFFF   ADDIU V0, V0, -1
9D00D210  02025021   ADDU T2, S0, V0
9D00D214  00C7001A   DIV A2, A3
9D00D218  00E001F4   TEQ A3, ZERO
9D00D21C  24A5FFFF   ADDIU A1, A1, -1
9D00D220  00003010   MFHI A2
9D00D224  24C60030   ADDIU A2, A2, 48
9D00D228  A1460000   SB A2, 0(T2)
9D00D22C  00003012   MFLO A2
9D00D230  1000FF57   BEQ ZERO, ZERO, __fmt_a_needed
9D00D234  AFA6001C   SW A2, 28(SP)
9D00D238  02021821   ADDU V1, S0, V0
9D00D23C  80640000   LB A0, 0(V1)
9D00D240  02221821   ADDU V1, S1, V0
9D00D244  02031821   ADDU V1, S0, V1
9D00D248  A064FFFE   SB A0, -2(V1)
9D00D24C  1000FF70   BEQ ZERO, ZERO, __fmt_a_needed
9D00D250  2442FFFF   ADDIU V0, V0, -1
9D00D254  8FA30024   LW V1, 36(SP)
9D00D258  30630010   ANDI V1, V1, 16
9D00D25C  5060FF3D   BEQL V1, ZERO, __fmt_a_needed
9D00D260  8FA2001C   LW V0, 28(SP)
9D00D264  2403002E   ADDIU V1, ZERO, 46
9D00D268  27DE0001   ADDIU FP, FP, 1
9D00D26C  1000FF38   BEQ ZERO, ZERO, __fmt_a_needed
9D00D270  A0430000   SB V1, 0(V0)
9D00D274  27BDFF78   ADDIU SP, SP, -136
9D00D278  AFA40088   SW A0, 136(SP)
9D00D27C  AFA60090   SW A2, 144(SP)
9D00D280  AFA70094   SW A3, 148(SP)
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/stdio/__uflow.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D017FD8  27BDFFE0   ADDIU SP, SP, -32
9D017FDC  AFB00018   SW S0, 24(SP)
9D017FE0  AFBF001C   SW RA, 28(SP)
9D017FE4  0F405C48   JAL __toread
9D017FE8  00808025   OR S0, A0, ZERO
9D017FEC  50400006   BEQL V0, ZERO, 0x9D018008
9D017FF0  8E020044   LW V0, 68(S0)
9D017FF4  2402FFFF   ADDIU V0, ZERO, -1
9D017FF8  8FBF001C   LW RA, 28(SP)
9D017FFC  8FB00018   LW S0, 24(SP)
9D018000  03E00008   JR RA
9D018004  27BD0020   ADDIU SP, SP, 32
9D018008  24060001   ADDIU A2, ZERO, 1
9D01800C  27A50010   ADDIU A1, SP, 16
9D018010  0040F809   JALR V0
9D018014  02002025   OR A0, S0, ZERO
9D018018  24030001   ADDIU V1, ZERO, 1
9D01801C  1443FFF5   BNE V0, V1, 0x9D017FF4
9D018020  93A20010   LBU V0, 16(SP)
9D018024  1000FFF5   BEQ ZERO, ZERO, 0x9D017FFC
9D018028  8FBF001C   LW RA, 28(SP)
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/stdio/__toread.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000008  00000000   NOP
00000010  00000000   NOP
9D017120  27BDFFE8   ADDIU SP, SP, -24
9D017124  AFB00010   SW S0, 16(SP)
9D017128  AFBF0014   SW RA, 20(SP)
9D01712C  80820048   LB V0, 72(A0)
9D017130  2443FFFF   ADDIU V1, V0, -1
9D017134  00431025   OR V0, V0, V1
9D017138  A0820048   SB V0, 72(A0)
9D01713C  8C830018   LW V1, 24(A0)
9D017140  8C820014   LW V0, 20(A0)
9D017144  0062102B   SLTU V0, V1, V0
9D017148  10400005   BEQ V0, ZERO, 0x9D017160
9D01714C  00808025   OR S0, A0, ZERO
9D017150  8C82002C   LW V0, 44(A0)
9D017154  00003025   OR A2, ZERO, ZERO
9D017158  0040F809   JALR V0
9D01715C  00002825   OR A1, ZERO, ZERO
9D017160  8E020004   LW V0, 4(S0)
9D017164  AE000028   SW ZERO, 40(S0)
9D017168  AE000018   SW ZERO, 24(S0)
9D01716C  30430002   ANDI V1, V0, 2
9D017170  10600008   BEQ V1, ZERO, 0x9D017194
9D017174  AE000014   SW ZERO, 20(S0)
9D017178  34420010   ORI V0, V0, 16
9D01717C  AE020004   SW V0, 4(S0)
9D017180  2402FFFF   ADDIU V0, ZERO, -1
9D017184  8FBF0014   LW RA, 20(SP)
9D017188  8FB00010   LW S0, 16(SP)
9D01718C  03E00008   JR RA
9D017190  27BD0018   ADDIU SP, SP, 24
9D017194  8E030008   LW V1, 8(S0)
9D017198  8E04000C   LW A0, 12(S0)
9D01719C  7C4200C0   EXT V0, V0, 3, 1
9D0171A0  00021023   SUBU V0, ZERO, V0
9D0171A4  00641821   ADDU V1, V1, A0
9D0171A8  AE030040   SW V1, 64(S0)
9D0171AC  1000FFF5   BEQ ZERO, ZERO, 0x9D017184
9D0171B0  AE03003C   SW V1, 60(S0)
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/smartio/__sio_sprintf_dfosux.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000008  00000000   NOP
00000010  00000000   NOP
00000018  00000000   NOP
00000020  00000000   NOP
00000028  00000000   NOP
00000030  00000000   NOP
00000038  00000000   NOP
00000040  00000000   NOP
00000048  00000000   NOP
00000050  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/smartio/__int_vsprintf.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D018DAC  00C03825   OR A3, A2, ZERO
9D018DB0  00A03025   OR A2, A1, ZERO
9D018DB4  3C057FFF   LUI A1, 32767
9D018DB8  27BDFFE8   ADDIU SP, SP, -24
9D018DBC  AFBF0014   SW RA, 20(SP)
9D018DC0  0F405D78   JAL __vsnprintf
9D018DC4  34A5FFFF   ORI A1, A1, -1
9D018DC8  8FBF0014   LW RA, 20(SP)
9D018DCC  03E00008   JR RA
9D018DD0  27BD0018   ADDIU SP, SP, 24
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/smartio/__int_vsnprintf.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D0175E0  27BDFFC8   ADDIU SP, SP, -56
9D0175E4  2403FFFF   ADDIU V1, ZERO, -1
9D0175E8  AFA30010   SW V1, 16(SP)
9D0175EC  24030102   ADDIU V1, ZERO, 258
9D0175F0  00A01025   OR V0, A1, ZERO
9D0175F4  AFBF0034   SW RA, 52(SP)
9D0175F8  00C02825   OR A1, A2, ZERO
9D0175FC  AFA30014   SW V1, 20(SP)
9D017600  14800002   BNE A0, ZERO, 0x9D01760C
9D017604  00E03025   OR A2, A3, ZERO
9D017608  27A4002C   ADDIU A0, SP, 44
9D01760C  AFA40018   SW A0, 24(SP)
9D017610  AFA2001C   SW V0, 28(SP)
9D017614  10400002   BEQ V0, ZERO, 0x9D017620
9D017618  00001825   OR V1, ZERO, ZERO
9D01761C  2443FFFF   ADDIU V1, V0, -1
9D017620  04410008   BGEZ V0, 0x9D017644
9D017624  AFA30020   SW V1, 32(SP)
9D017628  3C02A000   LUI V0, -24576
9D01762C  2403004F   ADDIU V1, ZERO, 79
9D017630  AC432CC4   SW V1, 11460(V0)
9D017634  2402FFFF   ADDIU V0, ZERO, -1
9D017638  8FBF0034   LW RA, 52(SP)
9D01763C  03E00008   JR RA
9D017640  27BD0038   ADDIU SP, SP, 56
9D017644  AFA40028   SW A0, 40(SP)
9D017648  AFA40024   SW A0, 36(SP)
9D01764C  A0800000   SB ZERO, 0(A0)
9D017650  0F406193   JAL __vfprintf
9D017654  27A40010   ADDIU A0, SP, 16
9D017658  1000FFF8   BEQ ZERO, ZERO, 0x9D01763C
9D01765C  8FBF0034   LW RA, 52(SP)
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/smartio/__int_vfprintf.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D01864C  27BDFFE0   ADDIU SP, SP, -32
9D018650  AFB00018   SW S0, 24(SP)
9D018654  AFA60010   SW A2, 16(SP)
9D018658  00808025   OR S0, A0, ZERO
9D01865C  AFBF001C   SW RA, 28(SP)
9D018660  0F4039D7   JAL __printf_core
9D018664  27A60010   ADDIU A2, SP, 16
9D018668  8E030004   LW V1, 4(S0)
9D01866C  8FBF001C   LW RA, 28(SP)
9D018670  2404FFFF   ADDIU A0, ZERO, -1
9D018674  30630010   ANDI V1, V1, 16
9D018678  0083100B   MOVN V0, A0, V1
9D01867C  8FB00018   LW S0, 24(SP)
9D018680  03E00008   JR RA
9D018684  27BD0020   ADDIU SP, SP, 32
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/smartio/__int_sprintf.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D018D5C  27BDFFE0   ADDIU SP, SP, -32
9D018D64  27A60028   ADDIU A2, SP, 40
9D018D68  AFBF001C   SW RA, 28(SP)
9D018D6C  AFA7002C   SW A3, 44(SP)
9D018D70  0F40636B   JAL __vsprintf
9D018D74  AFA60010   SW A2, 16(SP)
9D018D78  8FBF001C   LW RA, 28(SP)
9D018D7C  03E00008   JR RA
9D018D80  27BD0020   ADDIU SP, SP, 32
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/math/scalbn.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D015800  27BDFFE0   ADDIU SP, SP, -32
9D015804  AFB10014   SW S1, 20(SP)
9D015808  00C08825   OR S1, A2, ZERO
9D01580C  28C60400   SLTI A2, A2, 1024
9D015810  AFBF001C   SW RA, 28(SP)
9D015814  AFB20018   SW S2, 24(SP)
9D015818  14C0001F   BNE A2, ZERO, 0x9D015898
9D01581C  AFB00010   SW S0, 16(SP)
9D015820  3C129D01   LUI S2, -25343
9D015824  8E46B448   LW A2, -19384(S2)
9D015828  8E47B44C   LW A3, -19380(S2)
9D01582C  0F404121   JAL dpmul
9D015830  2630FC01   ADDIU S0, S1, -1023
9D015834  2A040400   SLTI A0, S0, 1024
9D015838  14800009   BNE A0, ZERO, 0x9D015860
9D01583C  8E46B448   LW A2, -19384(S2)
9D015840  8E47B44C   LW A3, -19380(S2)
9D015844  00402025   OR A0, V0, ZERO
9D015848  00602825   OR A1, V1, ZERO
9D01584C  0F404121   JAL dpmul
9D015850  2630F802   ADDIU S0, S1, -2046
9D015854  2A050400   SLTI A1, S0, 1024
9D015858  240403FF   ADDIU A0, ZERO, 1023
9D01585C  0085800A   MOVZ S0, A0, A1
9D015860  261003FF   ADDIU S0, S0, 1023
9D015864  00102500   SLL A0, S0, 20
9D015868  00002825   OR A1, ZERO, ZERO
9D01586C  00A03025   OR A2, A1, ZERO
9D015870  00803825   OR A3, A0, ZERO
9D015874  00602825   OR A1, V1, ZERO
9D015878  0F404121   JAL dpmul
9D01587C  00402025   OR A0, V0, ZERO
9D015880  8FBF001C   LW RA, 28(SP)
9D015884  8FB20018   LW S2, 24(SP)
9D015888  8FB10014   LW S1, 20(SP)
9D01588C  8FB00010   LW S0, 16(SP)
9D015890  03E00008   JR RA
9D015894  27BD0020   ADDIU SP, SP, 32
9D015898  2A26FC02   SLTI A2, S1, -1022
9D01589C  00801025   OR V0, A0, ZERO
9D0158A0  00A01825   OR V1, A1, ZERO
9D0158A4  10C0FFEE   BEQ A2, ZERO, 0x9D015860
9D0158A8  02208025   OR S0, S1, ZERO
9D0158AC  3C129D01   LUI S2, -25343
9D0158B0  8E46B450   LW A2, -19376(S2)
9D0158B4  8E47B454   LW A3, -19372(S2)
9D0158B8  0F404121   JAL dpmul
9D0158BC  263003C9   ADDIU S0, S1, 969
9D0158C0  2A04FC02   SLTI A0, S0, -1022
9D0158C4  1080FFE6   BEQ A0, ZERO, 0x9D015860
9D0158C8  8E46B450   LW A2, -19376(S2)
9D0158CC  8E47B454   LW A3, -19372(S2)
9D0158D0  00402025   OR A0, V0, ZERO
9D0158D4  00602825   OR A1, V1, ZERO
9D0158D8  0F404121   JAL dpmul
9D0158DC  26300792   ADDIU S0, S1, 1938
9D0158E0  2A05FC02   SLTI A1, S0, -1022
9D0158E4  2404FC02   ADDIU A0, ZERO, -1022
9D0158E8  1000FFDD   BEQ ZERO, ZERO, 0x9D015860
9D0158EC  0085800B   MOVN S0, A0, A1
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/math/fma.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00D274  27BDFF78   ADDIU SP, SP, -136
9D00D284  00803025   OR A2, A0, ZERO
9D00D288  00A03825   OR A3, A1, ZERO
9D00D28C  27A40030   ADDIU A0, SP, 48
9D00D290  AFBF0084   SW RA, 132(SP)
9D00D294  AFA5008C   SW A1, 140(SP)
9D00D298  AFBE0080   SW FP, 128(SP)
9D00D29C  AFB3006C   SW S3, 108(SP)
9D00D2A0  AFB20068   SW S2, 104(SP)
9D00D2A4  AFB10064   SW S1, 100(SP)
9D00D2A8  8FB20098   LW S2, 152(SP)
9D00D2AC  8FB3009C   LW S3, 156(SP)
9D00D2B0  AFB7007C   SW S7, 124(SP)
9D00D2B4  AFB60078   SW S6, 120(SP)
9D00D2B8  AFB50074   SW S5, 116(SP)
9D00D2BC  AFB40070   SW S4, 112(SP)
9D00D2C0  0F405BA7   JAL normalize
9D00D2C4  AFB00060   SW S0, 96(SP)
9D00D2C8  8FA60090   LW A2, 144(SP)
9D00D2CC  8FA70094   LW A3, 148(SP)
9D00D2D0  8FB10038   LW S1, 56(SP)
9D00D2D4  0F405BA7   JAL normalize
9D00D2D8  27A40020   ADDIU A0, SP, 32
9D00D2DC  02403025   OR A2, S2, ZERO
9D00D2E0  02603825   OR A3, S3, ZERO
9D00D2E4  27A40010   ADDIU A0, SP, 16
9D00D2E8  0F405BA7   JAL normalize
9D00D2EC  8FBE0028   LW FP, 40(SP)
9D00D2F0  2A2203CB   SLTI V0, S1, 971
9D00D2F4  10400003   BEQ V0, ZERO, 0x9D00D304
9D00D2F8  2BC203CB   SLTI V0, FP, 971
9D00D2FC  1440000E   BNE V0, ZERO, 0x9D00D338
9D00D300  8FB90018   LW T9, 24(SP)
9D00D304  8FA60090   LW A2, 144(SP)
9D00D308  8FA70094   LW A3, 148(SP)
9D00D30C  8FA40088   LW A0, 136(SP)
9D00D310  0F404121   JAL dpmul
9D00D314  8FA5008C   LW A1, 140(SP)
9D00D318  00403025   OR A2, V0, ZERO
9D00D31C  00603825   OR A3, V1, ZERO
9D00D320  02402025   OR A0, S2, ZERO
9D00D324  0F403C67   JAL __adddf3
9D00D328  02602825   OR A1, S3, ZERO
9D00D32C  00409025   OR S2, V0, ZERO
9D00D330  10000006   BEQ ZERO, ZERO, 0x9D00D34C
9D00D334  00609825   OR S3, V1, ZERO
9D00D338  2B2203CB   SLTI V0, T9, 971
9D00D33C  14400011   BNE V0, ZERO, 0x9D00D384
9D00D340  240203CB   ADDIU V0, ZERO, 971
9D00D344  1722FFF0   BNE T9, V0, 0x9D00D308
9D00D348  8FA60090   LW A2, 144(SP)
9D00D34C  8FBF0084   LW RA, 132(SP)
9D00D350  02401025   OR V0, S2, ZERO
9D00D354  02601825   OR V1, S3, ZERO
9D00D358  8FBE0080   LW FP, 128(SP)
9D00D35C  8FB7007C   LW S7, 124(SP)
9D00D360  8FB60078   LW S6, 120(SP)
9D00D364  8FB50074   LW S5, 116(SP)
9D00D368  8FB40070   LW S4, 112(SP)
9D00D36C  8FB3006C   LW S3, 108(SP)
9D00D370  8FB20068   LW S2, 104(SP)
9D00D374  8FB10064   LW S1, 100(SP)
9D00D378  8FB00060   LW S0, 96(SP)
9D00D37C  03E00008   JR RA
9D00D380  27BD0088   ADDIU SP, SP, 136
9D00D384  8FA20030   LW V0, 48(SP)
9D00D388  8FAA0020   LW T2, 32(SP)
9D00D38C  8FA40024   LW A0, 36(SP)
9D00D390  8FA60034   LW A2, 52(SP)
9D00D394  004A0019   MULTU 0, V0, T2
9D00D398  03D1F021   ADDU FP, FP, S1
9D00D39C  033E8823   SUBU S1, T9, FP
9D00D3A0  8FA70010   LW A3, 16(SP)
9D00D3A4  8FB70014   LW S7, 20(SP)
9D00D3A8  00004012   MFLO T0
9D00D3AC  AFA80040   SW T0, 64(SP)
9D00D3B0  8FAF0040   LW T7, 64(SP)
9D00D3B4  00004810   MFHI T1
9D00D3B8  AFA90044   SW T1, 68(SP)
9D00D3BC  00440019   MULTU 0, V0, A0
9D00D3C0  00001012   MFLO V0
9D00D3C4  00001810   MFHI V1
9D00D3C8  00CA0019   MULTU 0, A2, T2
9D00D3CC  00005012   MFLO T2
9D00D3D0  004AC021   ADDU T8, V0, T2
9D00D3D4  0302402B   SLTU T0, T8, V0
9D00D3D8  00005810   MFHI T3
9D00D3DC  8FA20044   LW V0, 68(SP)
9D00D3E0  006B5821   ADDU T3, V1, T3
9D00D3E4  00C40019   MULTU 0, A2, A0
9D00D3E8  010B4021   ADDU T0, T0, T3
9D00D3EC  0302C021   ADDU T8, T8, V0
9D00D3F0  0302302B   SLTU A2, T8, V0
9D00D3F4  00002012   MFLO A0
9D00D3F8  00884021   ADDU T0, A0, T0
9D00D3FC  01063021   ADDU A2, T0, A2
9D00D400  00002810   MFHI A1
9D00D404  0104582B   SLTU T3, T0, A0
9D00D408  01655821   ADDU T3, T3, A1
9D00D40C  00C8182B   SLTU V1, A2, T0
9D00D410  00C08025   OR S0, A2, ZERO
9D00D414  1A2000AB   BLEZ S1, 0x9D00D6C4
9D00D418  006BB021   ADDU S6, V1, T3
9D00D41C  2A220040   SLTI V0, S1, 64
9D00D420  10400078   BEQ V0, ZERO, 0x9D00D604
9D00D424  00E02025   OR A0, A3, ZERO
9D00D428  02E02825   OR A1, S7, ZERO
9D00D42C  02203025   OR A2, S1, ZERO
9D00D430  AFB80054   SW T8, 84(SP)
9D00D434  AFAF0050   SW T7, 80(SP)
9D00D438  0F4061B1   JAL __ashldi3
9D00D43C  AFA7004C   SW A3, 76(SP)
9D00D440  8FA7004C   LW A3, 76(SP)
9D00D444  24060040   ADDIU A2, ZERO, 64
9D00D448  02E02825   OR A1, S7, ZERO
9D00D44C  00E02025   OR A0, A3, ZERO
9D00D450  00D13023   SUBU A2, A2, S1
9D00D454  AFA20048   SW V0, 72(SP)
9D00D458  0F4061A2   JAL __lshrdi3
9D00D45C  AFA30040   SW V1, 64(SP)
9D00D460  8FB90040   LW T9, 64(SP)
9D00D464  8FA80048   LW T0, 72(SP)
9D00D468  8FAF0050   LW T7, 80(SP)
9D00D46C  8FB80054   LW T8, 84(SP)
9D00D470  00403825   OR A3, V0, ZERO
9D00D474  0060B825   OR S7, V1, ZERO
9D00D478  8FA2002C   LW V0, 44(SP)
9D00D47C  8FB1003C   LW S1, 60(SP)
9D00D480  02228826   XOR S1, S1, V0
9D00D484  8FA2001C   LW V0, 28(SP)
9D00D488  145100B5   BNE V0, S1, 0x9D00D760
9D00D48C  010F5021   ADDU T2, T0, T7
9D00D490  0148902B   SLTU S2, T2, T0
9D00D494  0338C021   ADDU T8, T9, T8
9D00D498  0258A021   ADDU S4, S2, T8
9D00D49C  0299102B   SLTU V0, S4, T9
9D00D4A0  0140A825   OR S5, T2, ZERO
9D00D4A4  14400006   BNE V0, ZERO, 0x9D00D4C0
9D00D4A8  24040001   ADDIU A0, ZERO, 1
9D00D4AC  17340003   BNE T9, S4, 0x9D00D4BC
9D00D4B0  0148402B   SLTU T0, T2, T0
9D00D4B4  15000003   BNE T0, ZERO, 0x9D00D4C4
9D00D4B8  00F06021   ADDU T4, A3, S0
9D00D4BC  00002025   OR A0, ZERO, ZERO
9D00D4C0  00F06021   ADDU T4, A3, S0
9D00D4C4  0187102B   SLTU V0, T4, A3
9D00D4C8  02F61821   ADDU V1, S7, S6
9D00D4CC  008C6021   ADDU T4, A0, T4
9D00D4D0  00431021   ADDU V0, V0, V1
9D00D4D4  0184202B   SLTU A0, T4, A0
9D00D4D8  00826821   ADDU T5, A0, V0
9D00D4DC  01802025   OR A0, T4, ZERO
9D00D4E0  01A02825   OR A1, T5, ZERO
9D00D4E4  AFAC0048   SW T4, 72(SP)
9D00D4E8  0F405E65   JAL a_clz_64
9D00D4EC  AFAD0040   SW T5, 64(SP)
9D00D4F0  2453FFFF   ADDIU S3, V0, -1
9D00D4F4  24060040   ADDIU A2, ZERO, 64
9D00D4F8  00D33023   SUBU A2, A2, S3
9D00D4FC  02A02025   OR A0, S5, ZERO
9D00D500  0F4061A2   JAL __lshrdi3
9D00D504  02802825   OR A1, S4, ZERO
9D00D508  8FAC0048   LW T4, 72(SP)
9D00D50C  8FAD0040   LW T5, 64(SP)
9D00D510  02603025   OR A2, S3, ZERO
9D00D514  01802025   OR A0, T4, ZERO
9D00D518  01A02825   OR A1, T5, ZERO
9D00D51C  00408025   OR S0, V0, ZERO
9D00D520  0F4061B1   JAL __ashldi3
9D00D524  00609025   OR S2, V1, ZERO
9D00D528  02603025   OR A2, S3, ZERO
9D00D52C  02A02025   OR A0, S5, ZERO
9D00D530  02802825   OR A1, S4, ZERO
9D00D534  02028025   OR S0, S0, V0
9D00D538  0F4061B1   JAL __ashldi3
9D00D53C  02439025   OR S2, S2, V1
9D00D540  00431025   OR V0, V0, V1
9D00D544  0002102B   SLTU V0, ZERO, V0
9D00D548  27DE0040   ADDIU FP, FP, 64
9D00D54C  02028025   OR S0, S0, V0
9D00D550  02002025   OR A0, S0, ZERO
9D00D554  12200005   BEQ S1, ZERO, 0x9D00D56C
9D00D558  02402825   OR A1, S2, ZERO
9D00D55C  00102023   SUBU A0, ZERO, S0
9D00D560  0004102B   SLTU V0, ZERO, A0
9D00D564  00122823   SUBU A1, ZERO, S2
9D00D568  00A22823   SUBU A1, A1, V0
9D00D56C  0F405E12   JAL __floatdidf
9D00D570  03D3F023   SUBU FP, FP, S3
9D00D574  0040B025   OR S6, V0, ZERO
9D00D578  2BC2FBC4   SLTI V0, FP, -1084
9D00D57C  104000F8   BEQ V0, ZERO, 0x9D00D960
9D00D580  0060B825   OR S7, V1, ZERO
9D00D584  2402FBC3   ADDIU V0, ZERO, -1085
9D00D588  17C200FB   BNE FP, V0, 0x9D00D978
9D00D58C  00102580   SLL A0, S0, 22
9D00D590  122000B4   BEQ S1, ZERO, 0x9D00D864
9D00D594  3C029D02   LUI V0, -25342
9D00D598  8C548F10   LW S4, -28912(V0)
9D00D59C  8C558F14   LW S5, -28908(V0)
9D00D5A0  02C03025   OR A2, S6, ZERO
9D00D5A4  02E03825   OR A3, S7, ZERO
9D00D5A8  02802025   OR A0, S4, ZERO
9D00D5AC  0F40500B   JAL __eqdf2
9D00D5B0  02A02825   OR A1, S5, ZERO
9D00D5B4  144000AF   BNE V0, ZERO, 0x9D00D874
9D00D5B8  3C029D02   LUI V0, -25342
9D00D5BC  8C468F18   LW A2, -28904(V0)
9D00D5C0  8C478F1C   LW A3, -28900(V0)
9D00D5C4  02C02025   OR A0, S6, ZERO
9D00D5C8  0F404121   JAL dpmul
9D00D5CC  02E02825   OR A1, S7, ZERO
9D00D5D0  00602825   OR A1, V1, ZERO
9D00D5D4  0F405583   JAL dptofp
9D00D5D8  00402025   OR A0, V0, ZERO
9D00D5DC  0F405A56   JAL __extendsfdf2
9D00D5E0  00402025   OR A0, V0, ZERO
9D00D5E4  3C049D02   LUI A0, -25342
9D00D5E8  8C868F20   LW A2, -28896(A0)
9D00D5EC  8C878F24   LW A3, -28892(A0)
9D00D5F0  00602825   OR A1, V1, ZERO
9D00D5F4  0F404121   JAL dpmul
9D00D5F8  00402025   OR A0, V0, ZERO
9D00D5FC  1000FF4C   BEQ ZERO, ZERO, 0x9D00D330
9D00D600  00409025   OR S2, V0, ZERO
9D00D604  2631FFC0   ADDIU S1, S1, -64
9D00D608  273EFFC0   ADDIU FP, T9, -64
9D00D60C  00004025   OR T0, ZERO, ZERO
9D00D610  1220FF99   BEQ S1, ZERO, 0x9D00D478
9D00D614  0000C825   OR T9, ZERO, ZERO
9D00D618  2A220040   SLTI V0, S1, 64
9D00D61C  10400043   BEQ V0, ZERO, 0x9D00D72C
9D00D620  8FA40040   LW A0, 64(SP)
9D00D624  240D0040   ADDIU T5, ZERO, 64
9D00D628  01B16823   SUBU T5, T5, S1
9D00D62C  01A03025   OR A2, T5, ZERO
9D00D630  03002825   OR A1, T8, ZERO
9D00D634  AFB90058   SW T9, 88(SP)
9D00D638  AFA80054   SW T0, 84(SP)
9D00D63C  AFA70050   SW A3, 80(SP)
9D00D640  AFAD004C   SW T5, 76(SP)
9D00D644  0F4061B1   JAL __ashldi3
9D00D648  AFB80048   SW T8, 72(SP)
9D00D64C  8FB80048   LW T8, 72(SP)
9D00D650  8FA40040   LW A0, 64(SP)
9D00D654  00431025   OR V0, V0, V1
9D00D658  03002825   OR A1, T8, ZERO
9D00D65C  02203025   OR A2, S1, ZERO
9D00D660  0F4061A2   JAL __lshrdi3
9D00D664  0002A82B   SLTU S5, ZERO, V0
9D00D668  8FAD004C   LW T5, 76(SP)
9D00D66C  02002025   OR A0, S0, ZERO
9D00D670  02C02825   OR A1, S6, ZERO
9D00D674  01A03025   OR A2, T5, ZERO
9D00D678  0060A025   OR S4, V1, ZERO
9D00D67C  0F4061B1   JAL __ashldi3
9D00D680  02A2A825   OR S5, S5, V0
9D00D684  02A27825   OR T7, S5, V0
9D00D688  0283C025   OR T8, S4, V1
9D00D68C  02002025   OR A0, S0, ZERO
9D00D690  02C02825   OR A1, S6, ZERO
9D00D694  02203025   OR A2, S1, ZERO
9D00D698  AFAF0048   SW T7, 72(SP)
9D00D69C  0F4061A2   JAL __lshrdi3
9D00D6A0  AFB80040   SW T8, 64(SP)
9D00D6A4  00408025   OR S0, V0, ZERO
9D00D6A8  0060B025   OR S6, V1, ZERO
9D00D6AC  8FB80040   LW T8, 64(SP)
9D00D6B0  8FAF0048   LW T7, 72(SP)
9D00D6B4  8FA70050   LW A3, 80(SP)
9D00D6B8  8FA80054   LW T0, 84(SP)
9D00D6BC  1000FF6E   BEQ ZERO, ZERO, 0x9D00D478
9D00D6C0  8FB90058   LW T9, 88(SP)
9D00D6C4  03D98823   SUBU S1, FP, T9
9D00D6C8  1220001D   BEQ S1, ZERO, 0x9D00D740
9D00D6CC  2A220040   SLTI V0, S1, 64
9D00D6D0  10400020   BEQ V0, ZERO, 0x9D00D754
9D00D6D4  24060040   ADDIU A2, ZERO, 64
9D00D6D8  00E02025   OR A0, A3, ZERO
9D00D6DC  02E02825   OR A1, S7, ZERO
9D00D6E0  00D13023   SUBU A2, A2, S1
9D00D6E4  AFB8004C   SW T8, 76(SP)
9D00D6E8  AFAF0048   SW T7, 72(SP)
9D00D6EC  0F4061B1   JAL __ashldi3
9D00D6F0  AFA70040   SW A3, 64(SP)
9D00D6F4  8FA70040   LW A3, 64(SP)
9D00D6F8  00431025   OR V0, V0, V1
9D00D6FC  02E02825   OR A1, S7, ZERO
9D00D700  00E02025   OR A0, A3, ZERO
9D00D704  02203025   OR A2, S1, ZERO
9D00D708  0F4061A2   JAL __lshrdi3
9D00D70C  0002A02B   SLTU S4, ZERO, V0
9D00D710  02824025   OR T0, S4, V0
9D00D714  0060C825   OR T9, V1, ZERO
9D00D718  00003825   OR A3, ZERO, ZERO
9D00D71C  0000B825   OR S7, ZERO, ZERO
9D00D720  8FAF0048   LW T7, 72(SP)
9D00D724  1000FF54   BEQ ZERO, ZERO, 0x9D00D478
9D00D728  8FB8004C   LW T8, 76(SP)
9D00D72C  240F0001   ADDIU T7, ZERO, 1
9D00D730  0000C025   OR T8, ZERO, ZERO
9D00D734  00008025   OR S0, ZERO, ZERO
9D00D738  1000FF4F   BEQ ZERO, ZERO, 0x9D00D478
9D00D73C  0000B025   OR S6, ZERO, ZERO
9D00D740  00E04025   OR T0, A3, ZERO
9D00D744  02E0C825   OR T9, S7, ZERO
9D00D748  00003825   OR A3, ZERO, ZERO
9D00D74C  1000FF4A   BEQ ZERO, ZERO, 0x9D00D478
9D00D750  0000B825   OR S7, ZERO, ZERO
9D00D754  24080001   ADDIU T0, ZERO, 1
9D00D758  1000FFFB   BEQ ZERO, ZERO, 0x9D00D748
9D00D75C  0000C825   OR T9, ZERO, ZERO
9D00D760  01E85023   SUBU T2, T7, T0
9D00D764  01EA182B   SLTU V1, T7, T2
9D00D768  03194823   SUBU T1, T8, T9
9D00D76C  0123A023   SUBU S4, T1, V1
9D00D770  0314102B   SLTU V0, T8, S4
9D00D774  0140A825   OR S5, T2, ZERO
9D00D778  241F0001   ADDIU RA, ZERO, 1
9D00D77C  14400006   BNE V0, ZERO, 0x9D00D798
9D00D780  00002025   OR A0, ZERO, ZERO
9D00D784  56980004   BNEL S4, T8, 0x9D00D798
9D00D788  0000F825   OR RA, ZERO, ZERO
9D00D78C  14600003   BNE V1, ZERO, 0x9D00D79C
9D00D790  02071823   SUBU V1, S0, A3
9D00D794  0000F825   OR RA, ZERO, ZERO
9D00D798  02071823   SUBU V1, S0, A3
9D00D79C  0203682B   SLTU T5, S0, V1
9D00D7A0  02D71023   SUBU V0, S6, S7
9D00D7A4  004D1023   SUBU V0, V0, T5
9D00D7A8  007F6023   SUBU T4, V1, RA
9D00D7AC  006C182B   SLTU V1, V1, T4
9D00D7B0  00441023   SUBU V0, V0, A0
9D00D7B4  00436823   SUBU T5, V0, V1
9D00D7B8  05A10013   BGEZ T5, 0x9D00D808
9D00D7BC  010F5023   SUBU T2, T0, T7
9D00D7C0  010A402B   SLTU T0, T0, T2
9D00D7C4  03384823   SUBU T1, T9, T8
9D00D7C8  00F03023   SUBU A2, A3, S0
9D00D7CC  0128A023   SUBU S4, T1, T0
9D00D7D0  00E6102B   SLTU V0, A3, A2
9D00D7D4  02F61823   SUBU V1, S7, S6
9D00D7D8  01546025   OR T4, T2, S4
9D00D7DC  00DFF821   ADDU RA, A2, RA
9D00D7E0  00621823   SUBU V1, V1, V0
9D00D7E4  000C602B   SLTU T4, ZERO, T4
9D00D7E8  03E6302B   SLTU A2, RA, A2
9D00D7EC  00641021   ADDU V0, V1, A0
9D00D7F0  03EC6023   SUBU T4, RA, T4
9D00D7F4  00C21021   ADDU V0, A2, V0
9D00D7F8  03ECF82B   SLTU RA, RA, T4
9D00D7FC  0140A825   OR S5, T2, ZERO
9D00D800  005F6823   SUBU T5, V0, RA
9D00D804  2E310001   SLTIU S1, S1, 1
9D00D808  018D1025   OR V0, T4, T5
9D00D80C  1440FF33   BNE V0, ZERO, 0x9D00D4DC
9D00D810  02B41025   OR V0, S5, S4
9D00D814  1040FEBB   BEQ V0, ZERO, 0x9D00D304
9D00D818  02A02025   OR A0, S5, ZERO
9D00D81C  0F405E65   JAL a_clz_64
9D00D820  02802825   OR A1, S4, ZERO
9D00D824  2453FFFF   ADDIU S3, V0, -1
9D00D828  06610007   BGEZ S3, 0x9D00D848
9D00D82C  001417C0   SLL V0, S4, 31
9D00D830  00158042   SRL S0, S5, 1
9D00D834  00508025   OR S0, V0, S0
9D00D838  32AA0001   ANDI T2, S5, 1
9D00D83C  020A8025   OR S0, S0, T2
9D00D840  1000FF43   BEQ ZERO, ZERO, 0x9D00D550
9D00D844  00149042   SRL S2, S4, 1
9D00D848  02603025   OR A2, S3, ZERO
9D00D84C  02A02025   OR A0, S5, ZERO
9D00D850  0F4061B1   JAL __ashldi3
9D00D854  02802825   OR A1, S4, ZERO
9D00D858  00408025   OR S0, V0, ZERO
9D00D85C  1000FF3C   BEQ ZERO, ZERO, 0x9D00D550
9D00D860  00609025   OR S2, V1, ZERO
9D00D864  3C029D02   LUI V0, -25342
9D00D868  8C548F08   LW S4, -28920(V0)
9D00D86C  1000FF4C   BEQ ZERO, ZERO, 0x9D00D5A0
9D00D870  8C558F0C   LW S5, -28916(V0)
9D00D874  00101540   SLL V0, S0, 21
9D00D878  10400039   BEQ V0, ZERO, 0x9D00D960
9D00D87C  001217C0   SLL V0, S2, 31
9D00D880  00102042   SRL A0, S0, 1
9D00D884  00442025   OR A0, V0, A0
9D00D888  00122842   SRL A1, S2, 1
9D00D88C  32100001   ANDI S0, S0, 1
9D00D890  3C024000   LUI V0, 16384
9D00D894  00902025   OR A0, A0, S0
9D00D898  12200005   BEQ S1, ZERO, 0x9D00D8B0
9D00D89C  00452825   OR A1, V0, A1
9D00D8A0  00042023   SUBU A0, ZERO, A0
9D00D8A4  0004102B   SLTU V0, ZERO, A0
9D00D8A8  00052823   SUBU A1, ZERO, A1
9D00D8AC  00A22823   SUBU A1, A1, V0
9D00D8B0  0F405E12   JAL __floatdidf
9D00D8B4  00000000   NOP
9D00D8B8  00403025   OR A2, V0, ZERO
9D00D8BC  00603825   OR A3, V1, ZERO
9D00D8C0  00402025   OR A0, V0, ZERO
9D00D8C4  0F403C67   JAL __adddf3
9D00D8C8  00602825   OR A1, V1, ZERO
9D00D8CC  00402025   OR A0, V0, ZERO
9D00D8D0  02803025   OR A2, S4, ZERO
9D00D8D4  02A03825   OR A3, S5, ZERO
9D00D8D8  0F403C65   JAL dpsub
9D00D8DC  00602825   OR A1, V1, ZERO
9D00D8E0  00408025   OR S0, V0, ZERO
9D00D8E4  3C029D02   LUI V0, -25342
9D00D8E8  8C468F20   LW A2, -28896(V0)
9D00D8EC  8C478F24   LW A3, -28892(V0)
9D00D8F0  02002025   OR A0, S0, ZERO
9D00D8F4  00602825   OR A1, V1, ZERO
9D00D8F8  0F404121   JAL dpmul
9D00D8FC  00608825   OR S1, V1, ZERO
9D00D900  00403025   OR A2, V0, ZERO
9D00D904  00603825   OR A3, V1, ZERO
9D00D908  00402025   OR A0, V0, ZERO
9D00D90C  0F404121   JAL dpmul
9D00D910  00602825   OR A1, V1, ZERO
9D00D914  02003025   OR A2, S0, ZERO
9D00D918  02203825   OR A3, S1, ZERO
9D00D91C  02002025   OR A0, S0, ZERO
9D00D920  02202825   OR A1, S1, ZERO
9D00D924  00409025   OR S2, V0, ZERO
9D00D928  0F403C65   JAL dpsub
9D00D92C  00609825   OR S3, V1, ZERO
9D00D930  00403025   OR A2, V0, ZERO
9D00D934  00603825   OR A3, V1, ZERO
9D00D938  02402025   OR A0, S2, ZERO
9D00D93C  0F404121   JAL dpmul
9D00D940  02602825   OR A1, S3, ZERO
9D00D944  00402025   OR A0, V0, ZERO
9D00D948  02003025   OR A2, S0, ZERO
9D00D94C  02203825   OR A3, S1, ZERO
9D00D950  0F403C67   JAL __adddf3
9D00D954  00602825   OR A1, V1, ZERO
9D00D958  0040B025   OR S6, V0, ZERO
9D00D95C  0060B825   OR S7, V1, ZERO
9D00D960  03C03025   OR A2, FP, ZERO
9D00D964  02C02025   OR A0, S6, ZERO
9D00D968  0F405600   JAL scalbn
9D00D96C  02E02825   OR A1, S7, ZERO
9D00D970  1000FE6F   BEQ ZERO, ZERO, 0x9D00D330
9D00D974  00409025   OR S2, V0, ZERO
9D00D978  00121580   SLL V0, S2, 22
9D00D97C  00108282   SRL S0, S0, 10
9D00D980  00508025   OR S0, V0, S0
9D00D984  0004202B   SLTU A0, ZERO, A0
9D00D988  00902025   OR A0, A0, S0
9D00D98C  02402825   OR A1, S2, ZERO
9D00D990  00041582   SRL V0, A0, 22
9D00D994  7C054804   INS A1, ZERO, 0, 10
9D00D998  00452825   OR A1, V0, A1
9D00D99C  12200005   BEQ S1, ZERO, 0x9D00D9B4
9D00D9A0  00042280   SLL A0, A0, 10
9D00D9A4  00042023   SUBU A0, ZERO, A0
9D00D9A8  0004102B   SLTU V0, ZERO, A0
9D00D9AC  00052823   SUBU A1, ZERO, A1
9D00D9B0  00A22823   SUBU A1, A1, V0
9D00D9B4  0F405E12   JAL __floatdidf
9D00D9B8  00000000   NOP
9D00D9BC  1000FFE7   BEQ ZERO, ZERO, 0x9D00D95C
9D00D9C0  0040B025   OR S6, V0, ZERO
9D016E9C  27BDFFE0   ADDIU SP, SP, -32
9D016EA0  AFB10018   SW S1, 24(SP)
9D016EA4  00078D02   SRL S1, A3, 20
9D016EA8  322507FF   ANDI A1, S1, 2047
9D016EAC  AFB00014   SW S0, 20(SP)
9D016EB0  AFBF001C   SW RA, 28(SP)
9D016EB4  00808025   OR S0, A0, ZERO
9D016EB8  00C01025   OR V0, A2, ZERO
9D016EBC  14A0000E   BNE A1, ZERO, normalize
9D016EC0  00E02025   OR A0, A3, ZERO
9D016EC4  3C029D02   LUI V0, -25342
9D016EC8  00C04025   OR T0, A2, ZERO
9D016ECC  00E01825   OR V1, A3, ZERO
9D016ED0  8C468F08   LW A2, -28920(V0)
9D016ED4  8C478F0C   LW A3, -28916(V0)
9D016ED8  01002025   OR A0, T0, ZERO
9D016EDC  0F404121   JAL dpmul
9D016EE0  00602825   OR A1, V1, ZERO
9D016EE4  00602025   OR A0, V1, ZERO
9D016EE8  7C635500   EXT V1, V1, 20, 11
9D016EEC  10600002   BEQ V1, ZERO, normalize
9D016EF0  24050800   ADDIU A1, ZERO, 2048
9D016EF4  2465FFC1   ADDIU A1, V1, -63
9D016EF8  000237C2   SRL A2, V0, 31
9D016EFC  00041840   SLL V1, A0, 1
9D016F00  00021040   SLL V0, V0, 1
9D016F04  00C31825   OR V1, A2, V1
9D016F08  8FBF001C   LW RA, 28(SP)
9D016F0C  AE020000   SW V0, 0(S0)
9D016F10  7C63A000   EXT V1, V1, 0, 21
9D016F14  3C020020   LUI V0, 32
9D016F18  00431825   OR V1, V0, V1
9D016F1C  32310800   ANDI S1, S1, 2048
9D016F20  24A5FBCC   ADDIU A1, A1, -1076
9D016F24  AE11000C   SW S1, 12(S0)
9D016F28  02001025   OR V0, S0, ZERO
9D016F2C  AE030004   SW V1, 4(S0)
9D016F30  AE050008   SW A1, 8(S0)
9D016F34  8FB10018   LW S1, 24(SP)
9D016F38  8FB00014   LW S0, 20(SP)
9D016F3C  03E00008   JR RA
9D016F40  27BD0020   ADDIU SP, SP, 32
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/internal/shgetc.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D016748  8C820050   LW V0, 80(A0)
9D01674C  27BDFFE8   ADDIU SP, SP, -24
9D016750  AFB00010   SW S0, 16(SP)
9D016754  AFBF0014   SW RA, 20(SP)
9D016758  1040000B   BEQ V0, ZERO, 0x9D016788
9D01675C  00808025   OR S0, A0, ZERO
9D016760  8C830054   LW V1, 84(A0)
9D016764  0062102A   SLT V0, V1, V0
9D016768  14400007   BNE V0, ZERO, 0x9D016788
9D01676C  00000000   NOP
9D016770  AE00004C   SW ZERO, 76(S0)
9D016774  2402FFFF   ADDIU V0, ZERO, -1
9D016778  8FBF0014   LW RA, 20(SP)
9D01677C  8FB00010   LW S0, 16(SP)
9D016780  03E00008   JR RA
9D016784  27BD0018   ADDIU SP, SP, 24
9D016788  0F405FF6   JAL __uflow
9D01678C  02002025   OR A0, S0, ZERO
9D016790  0442FFF8   BLTZL V0, 0x9D016774
9D016794  AE00004C   SW ZERO, 76(S0)
9D016798  8E030040   LW V1, 64(S0)
9D01679C  8E040050   LW A0, 80(S0)
9D0167A0  8E05003C   LW A1, 60(S0)
9D0167A4  10800009   BEQ A0, ZERO, 0x9D0167CC
9D0167A8  00603025   OR A2, V1, ZERO
9D0167AC  8E060054   LW A2, 84(S0)
9D0167B0  00653823   SUBU A3, V1, A1
9D0167B4  00862023   SUBU A0, A0, A2
9D0167B8  00E4382A   SLT A3, A3, A0
9D0167BC  14E00003   BNE A3, ZERO, 0x9D0167CC
9D0167C0  00603025   OR A2, V1, ZERO
9D0167C4  2484FFFF   ADDIU A0, A0, -1
9D0167C8  00A43021   ADDU A2, A1, A0
9D0167CC  10600006   BEQ V1, ZERO, 0x9D0167E8
9D0167D0  AE06004C   SW A2, 76(S0)
9D0167D4  8E040054   LW A0, 84(S0)
9D0167D8  00651823   SUBU V1, V1, A1
9D0167DC  24630001   ADDIU V1, V1, 1
9D0167E0  00831821   ADDU V1, A0, V1
9D0167E4  AE030054   SW V1, 84(S0)
9D0167E8  90A3FFFF   LBU V1, -1(A1)
9D0167EC  5462FFE2   BNEL V1, V0, 0x9D016778
9D0167F0  A0A2FFFF   SB V0, -1(A1)
9D0167F4  1000FFE1   BEQ ZERO, ZERO, 0x9D01677C
9D0167F8  8FBF0014   LW RA, 20(SP)
9D018B50  8C830040   LW V1, 64(A0)
9D018B54  8C86003C   LW A2, 60(A0)
9D018B58  AC850050   SW A1, 80(A0)
9D018B5C  00661023   SUBU V0, V1, A2
9D018B60  10A00004   BEQ A1, ZERO, 0x9D018B74
9D018B64  AC820054   SW V0, 84(A0)
9D018B68  00A2102A   SLT V0, A1, V0
9D018B6C  54400001   BNEL V0, ZERO, 0x9D018B74
9D018B70  00C51821   ADDU V1, A2, A1
9D018B74  03E00008   JR RA
9D018B78  AC83004C   SW V1, 76(A0)
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/internal/intscan.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00D9C4  27BDFFB8   ADDIU SP, SP, -72
9D00D9C8  8FA2005C   LW V0, 92(SP)
9D00D9CC  AFB20028   SW S2, 40(SP)
9D00D9D0  AFBF0044   SW RA, 68(SP)
9D00D9D4  AFA20010   SW V0, 16(SP)
9D00D9D8  2CA20025   SLTIU V0, A1, 37
9D00D9DC  AFBE0040   SW FP, 64(SP)
9D00D9E0  AFB7003C   SW S7, 60(SP)
9D00D9E4  AFB60038   SW S6, 56(SP)
9D00D9E8  AFB50034   SW S5, 52(SP)
9D00D9EC  AFB40030   SW S4, 48(SP)
9D00D9F0  AFB3002C   SW S3, 44(SP)
9D00D9F4  AFB10024   SW S1, 36(SP)
9D00D9F8  AFB00020   SW S0, 32(SP)
9D00D9FC  10400033   BEQ V0, ZERO, 0x9D00DACC
9D00DA00  8FB20058   LW S2, 88(SP)
9D00DA04  24020001   ADDIU V0, ZERO, 1
9D00DA08  10A20030   BEQ A1, V0, 0x9D00DACC
9D00DA0C  00808025   OR S0, A0, ZERO
9D00DA10  00A08825   OR S1, A1, ZERO
9D00DA14  00C09825   OR S3, A2, ZERO
9D00DA1C  8E02003C   LW V0, 60(S0)
9D00DA20  8E03004C   LW V1, 76(S0)
9D00DA24  0043182B   SLTU V1, V0, V1
9D00DA28  1060002C   BEQ V1, ZERO, 0x9D00DADC
9D00DA2C  24430001   ADDIU V1, V0, 1
9D00DA30  AE03003C   SW V1, 60(S0)
9D00DA34  90490000   LBU T1, 0(V0)
9D00DA4C  7C020844   INS V0, ZERO, 1, 1
9D00DA50  1440000B   BNE V0, ZERO, 0x9D00DA80
9D00DA54  0000A025   OR S4, ZERO, ZERO
9D00DA58  8E02003C   LW V0, 60(S0)
9D00DA5C  8E03004C   LW V1, 76(S0)
9D00DA60  3934002D   XORI S4, T1, 45
9D00DA64  2E940001   SLTIU S4, S4, 1
9D00DA68  0043182B   SLTU V1, V0, V1
9D00DA6C  1060001F   BEQ V1, ZERO, 0x9D00DAEC
9D00DA70  0014A023   SUBU S4, ZERO, S4
9D00DA74  24430001   ADDIU V1, V0, 1
9D00DA78  AE03003C   SW V1, 60(S0)
9D00DA7C  90490000   LBU T1, 0(V0)
9D00DA80  1220001E   BEQ S1, ZERO, 0x9D00DAFC
9D00DA84  8E03004C   LW V1, 76(S0)
9D00DA88  24020010   ADDIU V0, ZERO, 16
9D00DA8C  1222018E   BEQ S1, V0, 0x9D00E0C8
9D00DA90  24020030   ADDIU V0, ZERO, 48
9D00DA94  3C029D01   LUI V0, -25343
9D00DA98  24424EE9   ADDIU V0, V0, 20201
9D00DA9C  01221021   ADDU V0, T1, V0
9D00DAA0  90420000   LBU V0, 0(V0)
9D00DAA4  0051102B   SLTU V0, V0, S1
9D00DAA8  14400057   BNE V0, ZERO, 0x9D00DC08
9D00DAAC  2402000A   ADDIU V0, ZERO, 10
9D00DAB0  10600004   BEQ V1, ZERO, 0x9D00DAC4
9D00DAB4  00002825   OR A1, ZERO, ZERO
9D00DAB8  8E02003C   LW V0, 60(S0)
9D00DABC  2442FFFF   ADDIU V0, V0, -1
9D00DAC0  AE02003C   SW V0, 60(S0)
9D00DAC4  0F4062D4   JAL __shlim
9D00DAC8  02002025   OR A0, S0, ZERO
9D00DACC  3C02A000   LUI V0, -24576
9D00DAD0  24030016   ADDIU V1, ZERO, 22
9D00DAD4  1000002B   BEQ ZERO, ZERO, 0x9D00DB84
9D00DAD8  AC432CC4   SW V1, 11460(V0)
9D00DADC  0F4059D2   JAL __shgetc
9D00DAE0  02002025   OR A0, S0, ZERO
9D00DAE4  1000FFD4   BEQ ZERO, ZERO, __intscan::__isspace
9D00DAE8  00404825   OR T1, V0, ZERO
9D00DAEC  0F4059D2   JAL __shgetc
9D00DAF0  02002025   OR A0, S0, ZERO
9D00DAF4  1000FFE2   BEQ ZERO, ZERO, 0x9D00DA80
9D00DAF8  00404825   OR T1, V0, ZERO
9D00DAFC  24020030   ADDIU V0, ZERO, 48
9D00DB00  5522FFE4   BNEL T1, V0, 0x9D00DA94
9D00DB04  2411000A   ADDIU S1, ZERO, 10
9D00DB08  8E02003C   LW V0, 60(S0)
9D00DB0C  0043182B   SLTU V1, V0, V1
9D00DB10  1060002C   BEQ V1, ZERO, 0x9D00DBC4
9D00DB14  24430001   ADDIU V1, V0, 1
9D00DB18  AE03003C   SW V1, 60(S0)
9D00DB1C  90490000   LBU T1, 0(V0)
9D00DB20  35220020   ORI V0, T1, 32
9D00DB24  24030078   ADDIU V1, ZERO, 120
9D00DB28  14430035   BNE V0, V1, 0x9D00DC00
9D00DB2C  00000000   NOP
9D00DB30  8E02003C   LW V0, 60(S0)
9D00DB34  8E03004C   LW V1, 76(S0)
9D00DB38  0043182B   SLTU V1, V0, V1
9D00DB3C  10600025   BEQ V1, ZERO, 0x9D00DBD4
9D00DB40  24430001   ADDIU V1, V0, 1
9D00DB44  AE03003C   SW V1, 60(S0)
9D00DB48  90490000   LBU T1, 0(V0)
9D00DB4C  3C029D01   LUI V0, -25343
9D00DB50  24424EE9   ADDIU V0, V0, 20201
9D00DB54  01221021   ADDU V0, T1, V0
9D00DB58  90420000   LBU V0, 0(V0)
9D00DB5C  2C420010   SLTIU V0, V0, 16
9D00DB60  5440002B   BNEL V0, ZERO, 0x9D00DC10
9D00DB64  24110010   ADDIU S1, ZERO, 16
9D00DB68  8E02004C   LW V0, 76(S0)
9D00DB6C  10400152   BEQ V0, ZERO, 0x9D00E0B8
9D00DB70  00003825   OR A3, ZERO, ZERO
9D00DB74  1260001B   BEQ S3, ZERO, 0x9D00DBE4
9D00DB78  8E02003C   LW V0, 60(S0)
9D00DB7C  2442FFFE   ADDIU V0, V0, -2
9D00DB80  AE02003C   SW V0, 60(S0)
9D00DB84  00003825   OR A3, ZERO, ZERO
9D00DB88  00004025   OR T0, ZERO, ZERO
9D00DB8C  8FBF0044   LW RA, 68(SP)
9D00DB90  00E01025   OR V0, A3, ZERO
9D00DB94  01001825   OR V1, T0, ZERO
9D00DB98  8FBE0040   LW FP, 64(SP)
9D00DB9C  8FB7003C   LW S7, 60(SP)
9D00DBA0  8FB60038   LW S6, 56(SP)
9D00DBA4  8FB50034   LW S5, 52(SP)
9D00DBA8  8FB40030   LW S4, 48(SP)
9D00DBAC  8FB3002C   LW S3, 44(SP)
9D00DBB0  8FB20028   LW S2, 40(SP)
9D00DBB4  8FB10024   LW S1, 36(SP)
9D00DBB8  8FB00020   LW S0, 32(SP)
9D00DBBC  03E00008   JR RA
9D00DBC0  27BD0048   ADDIU SP, SP, 72
9D00DBC4  0F4059D2   JAL __shgetc
9D00DBC8  02002025   OR A0, S0, ZERO
9D00DBCC  1000FFD4   BEQ ZERO, ZERO, 0x9D00DB20
9D00DBD0  00404825   OR T1, V0, ZERO
9D00DBD4  0F4059D2   JAL __shgetc
9D00DBD8  02002025   OR A0, S0, ZERO
9D00DBDC  1000FFDB   BEQ ZERO, ZERO, 0x9D00DB4C
9D00DBE0  00404825   OR T1, V0, ZERO
9D00DBE4  2442FFFF   ADDIU V0, V0, -1
9D00DBE8  AE02003C   SW V0, 60(S0)
9D00DBEC  00002825   OR A1, ZERO, ZERO
9D00DBF0  0F4062D4   JAL __shlim
9D00DBF4  02002025   OR A0, S0, ZERO
9D00DBF8  1000FFE3   BEQ ZERO, ZERO, 0x9D00DB88
9D00DBFC  00003825   OR A3, ZERO, ZERO
9D00DC00  12200087   BEQ S1, ZERO, 0x9D00DE20
9D00DC04  2402000A   ADDIU V0, ZERO, 10
9D00DC08  1222007B   BEQ S1, V0, 0x9D00DDF8
9D00DC0C  3C151999   LUI S5, 6553
9D00DC10  2627FFFF   ADDIU A3, S1, -1
9D00DC14  3C139D01   LUI S3, -25343
9D00DC18  00F1A824   AND S5, A3, S1
9D00DC1C  16A000F9   BNE S5, ZERO, 0x9D00E004
9D00DC20  26734EE9   ADDIU S3, S3, 20201
9D00DC24  24020017   ADDIU V0, ZERO, 23
9D00DC28  72221002   MUL V0, S1, V0
9D00DC2C  3C039D01   LUI V1, -25343
9D00DC30  24634EDC   ADDIU V1, V1, 20188
9D00DC34  3C1E0800   LUI FP, 2048
9D00DC38  7C421140   EXT V0, V0, 5, 3
9D00DC3C  00431021   ADDU V0, V0, V1
9D00DC40  80560000   LB S6, 0(V0)
9D00DC44  02691021   ADDU V0, S3, T1
9D00DC48  90570000   LBU S7, 0(V0)
9D00DC4C  02F1102B   SLTU V0, S7, S1
9D00DC50  10400003   BEQ V0, ZERO, 0x9D00DC60
9D00DC54  02BE102B   SLTU V0, S5, FP
9D00DC58  54400073   BNEL V0, ZERO, 0x9D00DE28
9D00DC5C  8E02003C   LW V0, 60(S0)
9D00DC60  00004025   OR T0, ZERO, ZERO
9D00DC64  02C03025   OR A2, S6, ZERO
9D00DC68  2404FFFF   ADDIU A0, ZERO, -1
9D00DC6C  2405FFFF   ADDIU A1, ZERO, -1
9D00DC70  AFA9001C   SW T1, 28(SP)
9D00DC74  AFB50018   SW S5, 24(SP)
9D00DC78  0F4061A2   JAL __lshrdi3
9D00DC7C  AFA80014   SW T0, 20(SP)
9D00DC80  8FA80014   LW T0, 20(SP)
9D00DC84  8FA70018   LW A3, 24(SP)
9D00DC88  8FA9001C   LW T1, 28(SP)
9D00DC8C  0040B825   OR S7, V0, ZERO
9D00DC90  0060A825   OR S5, V1, ZERO
9D00DC94  02691021   ADDU V0, S3, T1
9D00DC98  905E0000   LBU FP, 0(V0)
9D00DC9C  03D1102B   SLTU V0, FP, S1
9D00DCA0  104000A0   BEQ V0, ZERO, 0x9D00DF24
9D00DCA4  02A8102B   SLTU V0, S5, T0
9D00DCA8  5440009F   BNEL V0, ZERO, 0x9D00DF28
9D00DCAC  3C139D01   LUI S3, -25343
9D00DCB0  15150003   BNE T0, S5, 0x9D00DCC0
9D00DCB4  02E7102B   SLTU V0, S7, A3
9D00DCB8  5440009B   BNEL V0, ZERO, 0x9D00DF28
9D00DCBC  3C139D01   LUI S3, -25343
9D00DCC0  8E02003C   LW V0, 60(S0)
9D00DCC4  8E03004C   LW V1, 76(S0)
9D00DCC8  0043182B   SLTU V1, V0, V1
9D00DCCC  10600063   BEQ V1, ZERO, 0x9D00DE5C
9D00DCD0  24430001   ADDIU V1, V0, 1
9D00DCD4  AE03003C   SW V1, 60(S0)
9D00DCD8  90490000   LBU T1, 0(V0)
9D00DCDC  00E02025   OR A0, A3, ZERO
9D00DCE0  01002825   OR A1, T0, ZERO
9D00DCE4  02C03025   OR A2, S6, ZERO
9D00DCE8  0F4061B1   JAL __ashldi3
9D00DCEC  AFA90014   SW T1, 20(SP)
9D00DCF0  03C23825   OR A3, FP, V0
9D00DCF4  00604025   OR T0, V1, ZERO
9D00DCF8  1000FFE6   BEQ ZERO, ZERO, 0x9D00DC94
9D00DCFC  8FA90014   LW T1, 20(SP)
9D00DD00  8E03004C   LW V1, 76(S0)
9D00DD04  0043182B   SLTU V1, V0, V1
9D00DD08  10600036   BEQ V1, ZERO, 0x9D00DDE4
9D00DD0C  24430001   ADDIU V1, V0, 1
9D00DD10  AE03003C   SW V1, 60(S0)
9D00DD14  90420000   LBU V0, 0(V0)
9D00DD18  72761802   MUL V1, S3, S6
9D00DD1C  00693821   ADDU A3, V1, T1
9D00DD20  24F3FFD0   ADDIU S3, A3, -48
9D00DD24  00404825   OR T1, V0, ZERO
9D00DD28  2522FFD0   ADDIU V0, T1, -48
9D00DD2C  2C42000A   SLTIU V0, V0, 10
9D00DD30  10400003   BEQ V0, ZERO, 0x9D00DD40
9D00DD34  0275102B   SLTU V0, S3, S5
9D00DD38  5440FFF1   BNEL V0, ZERO, 0x9D00DD00
9D00DD3C  8E02003C   LW V0, 60(S0)
9D00DD40  3C151999   LUI S5, 6553
9D00DD44  36B5999A   ORI S5, S5, -26214
9D00DD48  3C1E9999   LUI FP, -26215
9D00DD4C  02603825   OR A3, S3, ZERO
9D00DD50  00004025   OR T0, ZERO, ZERO
9D00DD54  26A5FFFF   ADDIU A1, S5, -1
9D00DD58  37DE999A   ORI FP, FP, -26214
9D00DD5C  2533FFD0   ADDIU S3, T1, -48
9D00DD60  2E62000A   SLTIU V0, S3, 10
9D00DD64  10400088   BEQ V0, ZERO, 0x9D00DF88
9D00DD68  0115102B   SLTU V0, T0, S5
9D00DD6C  5040006E   BEQL V0, ZERO, 0x9D00DF28
9D00DD70  3C139D01   LUI S3, -25343
9D00DD74  15050004   BNE T0, A1, 0x9D00DD88
9D00DD78  2402000A   ADDIU V0, ZERO, 10
9D00DD7C  00FE102B   SLTU V0, A3, FP
9D00DD80  10400068   BEQ V0, ZERO, 0x9D00DF24
9D00DD84  2402000A   ADDIU V0, ZERO, 10
9D00DD88  00470019   MULTU 0, V0, A3
9D00DD8C  0000B810   MFHI S7
9D00DD90  0000B012   MFLO S6
9D00DD94  70481802   MUL V1, V0, T0
9D00DD98  0077B821   ADDU S7, V1, S7
9D00DD9C  2403FFFF   ADDIU V1, ZERO, -1
9D00DDA0  16E30004   BNE S7, V1, 0x9D00DDB4
9D00DDA4  00131027   NOR V0, ZERO, S3
9D00DDA8  0056102B   SLTU V0, V0, S6
9D00DDAC  5440005E   BNEL V0, ZERO, 0x9D00DF28
9D00DDB0  3C139D01   LUI S3, -25343
9D00DDB4  8E02003C   LW V0, 60(S0)
9D00DDB8  8E03004C   LW V1, 76(S0)
9D00DDBC  0043182B   SLTU V1, V0, V1
9D00DDC0  10600011   BEQ V1, ZERO, 0x9D00DE08
9D00DDC4  00000000   NOP
9D00DDC8  24430001   ADDIU V1, V0, 1
9D00DDCC  AE03003C   SW V1, 60(S0)
9D00DDD0  90490000   LBU T1, 0(V0)
9D00DDD4  02763821   ADDU A3, S3, S6
9D00DDD8  00F6402B   SLTU T0, A3, S6
9D00DDDC  1000FFDF   BEQ ZERO, ZERO, 0x9D00DD5C
9D00DDE0  01174021   ADDU T0, T0, S7
9D00DDE4  02002025   OR A0, S0, ZERO
9D00DDE8  0F4059D2   JAL __shgetc
9D00DDEC  AFA90014   SW T1, 20(SP)
9D00DDF0  1000FFC9   BEQ ZERO, ZERO, 0x9D00DD18
9D00DDF4  8FA90014   LW T1, 20(SP)
9D00DDF8  00009825   OR S3, ZERO, ZERO
9D00DDFC  36B59999   ORI S5, S5, -26215
9D00DE00  1000FFC9   BEQ ZERO, ZERO, 0x9D00DD28
9D00DE04  2416000A   ADDIU S6, ZERO, 10
9D00DE08  0F4059D2   JAL __shgetc
9D00DE0C  02002025   OR A0, S0, ZERO
9D00DE10  00404825   OR T1, V0, ZERO
9D00DE14  3C021999   LUI V0, 6553
9D00DE18  1000FFEE   BEQ ZERO, ZERO, 0x9D00DDD4
9D00DE1C  34459999   ORI A1, V0, -26215
9D00DE20  1000FF7B   BEQ ZERO, ZERO, 0x9D00DC10
9D00DE24  24110008   ADDIU S1, ZERO, 8
9D00DE28  8E03004C   LW V1, 76(S0)
9D00DE2C  0043182B   SLTU V1, V0, V1
9D00DE30  10600006   BEQ V1, ZERO, 0x9D00DE4C
9D00DE34  24430001   ADDIU V1, V0, 1
9D00DE38  AE03003C   SW V1, 60(S0)
9D00DE3C  90490000   LBU T1, 0(V0)
9D00DE40  02D53804   SLLV A3, S5, S6
9D00DE44  1000FF7F   BEQ ZERO, ZERO, 0x9D00DC44
9D00DE48  00F7A825   OR S5, A3, S7
9D00DE4C  0F4059D2   JAL __shgetc
9D00DE50  02002025   OR A0, S0, ZERO
9D00DE54  1000FFFA   BEQ ZERO, ZERO, 0x9D00DE40
9D00DE58  00404825   OR T1, V0, ZERO
9D00DE5C  02002025   OR A0, S0, ZERO
9D00DE60  AFA80018   SW T0, 24(SP)
9D00DE64  0F4059D2   JAL __shgetc
9D00DE68  AFA70014   SW A3, 20(SP)
9D00DE6C  00404825   OR T1, V0, ZERO
9D00DE70  8FA80018   LW T0, 24(SP)
9D00DE74  1000FF99   BEQ ZERO, ZERO, 0x9D00DCDC
9D00DE78  8FA70014   LW A3, 20(SP)
9D00DE7C  8E03004C   LW V1, 76(S0)
9D00DE80  0043182B   SLTU V1, V0, V1
9D00DE84  1060005B   BEQ V1, ZERO, 0x9D00DFF4
9D00DE88  24430001   ADDIU V1, V0, 1
9D00DE8C  AE03003C   SW V1, 60(S0)
9D00DE90  90490000   LBU T1, 0(V0)
9D00DE94  72351002   MUL V0, S1, S5
9D00DE98  0057A821   ADDU S5, V0, S7
9D00DE9C  02691021   ADDU V0, S3, T1
9D00DEA0  90570000   LBU S7, 0(V0)
9D00DEA4  02F1102B   SLTU V0, S7, S1
9D00DEA8  10400003   BEQ V0, ZERO, 0x9D00DEB8
9D00DEAC  02B6102B   SLTU V0, S5, S6
9D00DEB0  5440FFF2   BNEL V0, ZERO, 0x9D00DE7C
9D00DEB4  8E02003C   LW V0, 60(S0)
9D00DEB8  02A03825   OR A3, S5, ZERO
9D00DEBC  00004025   OR T0, ZERO, ZERO
9D00DEC0  241EFFFF   ADDIU FP, ZERO, -1
9D00DEC4  02691021   ADDU V0, S3, T1
9D00DEC8  90550000   LBU S5, 0(V0)
9D00DECC  02B1102B   SLTU V0, S5, S1
9D00DED0  10400014   BEQ V0, ZERO, 0x9D00DF24
9D00DED4  00F10019   MULTU 0, A3, S1
9D00DED8  00002012   MFLO A0
9D00DEDC  11000009   BEQ T0, ZERO, 0x9D00DF04
9D00DEE0  00002810   MFHI A1
9D00DEE4  02280019   MULTU 0, S1, T0
9D00DEE8  00006012   MFLO T4
9D00DEEC  00AC1021   ADDU V0, A1, T4
9D00DEF0  004C102B   SLTU V0, V0, T4
9D00DEF4  00006810   MFHI T5
9D00DEF8  004D1021   ADDU V0, V0, T5
9D00DEFC  5440000A   BNEL V0, ZERO, 0x9D00DF28
9D00DF00  3C139D01   LUI S3, -25343
9D00DF04  71111002   MUL V0, T0, S1
9D00DF08  0080B025   OR S6, A0, ZERO
9D00DF0C  0045B821   ADDU S7, V0, A1
9D00DF10  16FE0040   BNE S7, FP, 0x9D00E014
9D00DF14  00151027   NOR V0, ZERO, S5
9D00DF18  0044102B   SLTU V0, V0, A0
9D00DF1C  5040003E   BEQL V0, ZERO, 0x9D00E018
9D00DF20  8E02003C   LW V0, 60(S0)
9D00DF24  3C139D01   LUI S3, -25343
9D00DF28  26734EE9   ADDIU S3, S3, 20201
9D00DF2C  01334821   ADDU T1, T1, S3
9D00DF30  91220000   LBU V0, 0(T1)
9D00DF34  0051102B   SLTU V0, V0, S1
9D00DF38  50400014   BEQL V0, ZERO, 0x9D00DF8C
9D00DF3C  8E02004C   LW V0, 76(S0)
9D00DF40  8E02003C   LW V0, 60(S0)
9D00DF44  8E03004C   LW V1, 76(S0)
9D00DF48  0043182B   SLTU V1, V0, V1
9D00DF4C  10600040   BEQ V1, ZERO, 0x9D00E050
9D00DF50  24430001   ADDIU V1, V0, 1
9D00DF54  AE03003C   SW V1, 60(S0)
9D00DF58  90420000   LBU V0, 0(V0)
9D00DF5C  02621021   ADDU V0, S3, V0
9D00DF60  90420000   LBU V0, 0(V0)
9D00DF64  0051102B   SLTU V0, V0, S1
9D00DF68  1440FFF5   BNE V0, ZERO, 0x9D00DF40
9D00DF6C  3C02A000   LUI V0, -24576
9D00DF70  24030022   ADDIU V1, ZERO, 34
9D00DF74  8FA80010   LW T0, 16(SP)
9D00DF78  AC432CC4   SW V1, 11460(V0)
9D00DF7C  32420001   ANDI V0, S2, 1
9D00DF80  02403825   OR A3, S2, ZERO
9D00DF84  0002A00B   MOVN S4, ZERO, V0
9D00DF88  8E02004C   LW V0, 76(S0)
9D00DF8C  10400005   BEQ V0, ZERO, 0x9D00DFA4
9D00DF90  8FA20010   LW V0, 16(SP)
9D00DF94  8E02003C   LW V0, 60(S0)
9D00DF98  2442FFFF   ADDIU V0, V0, -1
9D00DF9C  AE02003C   SW V0, 60(S0)
9D00DFA0  8FA20010   LW V0, 16(SP)
9D00DFA4  0102102B   SLTU V0, T0, V0
9D00DFA8  1440003B   BNE V0, ZERO, 0x9D00E098
9D00DFAC  8FA20010   LW V0, 16(SP)
9D00DFB0  14480003   BNE V0, T0, 0x9D00DFC0
9D00DFB4  00F2102B   SLTU V0, A3, S2
9D00DFB8  14400038   BNE V0, ZERO, 0x9D00E09C
9D00DFBC  2402FFFF   ADDIU V0, ZERO, -1
9D00DFC0  32420001   ANDI V0, S2, 1
9D00DFC4  14400027   BNE V0, ZERO, 0x9D00E064
9D00DFC8  8FA20010   LW V0, 16(SP)
9D00DFCC  16800024   BNE S4, ZERO, 0x9D00E060
9D00DFD0  3C02A000   LUI V0, -24576
9D00DFD4  24030022   ADDIU V1, ZERO, 34
9D00DFD8  AC432CC4   SW V1, 11460(V0)
9D00DFDC  8FA20010   LW V0, 16(SP)
9D00DFE0  2647FFFF   ADDIU A3, S2, -1
9D00DFE4  00F2902B   SLTU S2, A3, S2
9D00DFE8  2451FFFF   ADDIU S1, V0, -1
9D00DFEC  1000FEE7   BEQ ZERO, ZERO, 0x9D00DB8C
9D00DFF0  02514021   ADDU T0, S2, S1
9D00DFF4  0F4059D2   JAL __shgetc
9D00DFF8  02002025   OR A0, S0, ZERO
9D00DFFC  1000FFA5   BEQ ZERO, ZERO, 0x9D00DE94
9D00E000  00404825   OR T1, V0, ZERO
9D00E004  3C16071C   LUI S6, 1820
9D00E008  0000A825   OR S5, ZERO, ZERO
9D00E00C  1000FFA3   BEQ ZERO, ZERO, 0x9D00DE9C
9D00E010  26D671C7   ADDIU S6, S6, 29127
9D00E014  8E02003C   LW V0, 60(S0)
9D00E018  8E03004C   LW V1, 76(S0)
9D00E01C  0043182B   SLTU V1, V0, V1
9D00E020  10600007   BEQ V1, ZERO, 0x9D00E040
9D00E024  24430001   ADDIU V1, V0, 1
9D00E028  AE03003C   SW V1, 60(S0)
9D00E02C  90490000   LBU T1, 0(V0)
9D00E030  02B63821   ADDU A3, S5, S6
9D00E034  00F6402B   SLTU T0, A3, S6
9D00E038  1000FFA2   BEQ ZERO, ZERO, 0x9D00DEC4
9D00E03C  01174021   ADDU T0, T0, S7
9D00E040  0F4059D2   JAL __shgetc
9D00E044  02002025   OR A0, S0, ZERO
9D00E048  1000FFF9   BEQ ZERO, ZERO, 0x9D00E030
9D00E04C  00404825   OR T1, V0, ZERO
9D00E050  0F4059D2   JAL __shgetc
9D00E054  02002025   OR A0, S0, ZERO
9D00E058  1000FFC1   BEQ ZERO, ZERO, 0x9D00DF60
9D00E05C  02621021   ADDU V0, S3, V0
9D00E060  8FA20010   LW V0, 16(SP)
9D00E064  0048102B   SLTU V0, V0, T0
9D00E068  14400005   BNE V0, ZERO, 0x9D00E080
9D00E06C  8FA20010   LW V0, 16(SP)
9D00E070  15020009   BNE T0, V0, 0x9D00E098
9D00E074  0247102B   SLTU V0, S2, A3
9D00E078  10400008   BEQ V0, ZERO, 0x9D00E09C
9D00E07C  2402FFFF   ADDIU V0, ZERO, -1
9D00E080  3C02A000   LUI V0, -24576
9D00E084  24030022   ADDIU V1, ZERO, 34
9D00E088  AC432CC4   SW V1, 11460(V0)
9D00E08C  02403825   OR A3, S2, ZERO
9D00E090  1000FEBE   BEQ ZERO, ZERO, 0x9D00DB8C
9D00E094  8FA80010   LW T0, 16(SP)
9D00E098  2402FFFF   ADDIU V0, ZERO, -1
9D00E09C  1682FEBC   BNE S4, V0, 0x9D00DB90
9D00E0A0  8FBF0044   LW RA, 68(SP)
9D00E0A4  00073823   SUBU A3, ZERO, A3
9D00E0A8  0007102B   SLTU V0, ZERO, A3
9D00E0AC  00084023   SUBU T0, ZERO, T0
9D00E0B0  1000FEB7   BEQ ZERO, ZERO, 0x9D00DB90
9D00E0B4  01024023   SUBU T0, T0, V0
9D00E0B8  1660FEB4   BNE S3, ZERO, 0x9D00DB8C
9D00E0BC  00004025   OR T0, ZERO, ZERO
9D00E0C0  1000FECB   BEQ ZERO, ZERO, 0x9D00DBF0
9D00E0C4  00002825   OR A1, ZERO, ZERO
9D00E0C8  1122FE8F   BEQ T1, V0, 0x9D00DB08
9D00E0CC  3C029D01   LUI V0, -25343
9D00E0D0  1000FE72   BEQ ZERO, ZERO, 0x9D00DA9C
9D00E0D4  24424EE9   ADDIU V0, V0, 20201
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/ctype/toupper.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000008  00000000   NOP
00000010  00000000   NOP
9D018F60  2483FF9F   ADDIU V1, A0, -97
9D018F64  2C63001A   SLTIU V1, V1, 26
9D018F68  10600002   BEQ V1, ZERO, 0x9D018F74
9D018F6C  00801025   OR V0, A0, ZERO
9D018F70  3082005F   ANDI V0, A0, 95
9D018F74  03E00008   JR RA
9D018F78  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/src/ctype/tolower.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
00000000  00000000   NOP
00000008  00000000   NOP
00000010  00000000   NOP
9D018F44  2483FFBF   ADDIU V1, A0, -65
9D018F48  2C63001A   SLTIU V1, V1, 26
9D018F4C  10600002   BEQ V1, ZERO, 0x9D018F58
9D018F50  00801025   OR V0, A0, ZERO
9D018F54  34820020   ORI V0, A0, 32
9D018F58  03E00008   JR RA
9D018F5C  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/include/ctype.h
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00DA18  24140020   ADDIU S4, ZERO, 32
9D00DA1C  8E02003C   LW V0, 60(S0)
9D00DA38  1134FFF8   BEQ T1, S4, 0x9D00DA1C
9D00DA3C  2522FFF7   ADDIU V0, T1, -9
9D00DA40  2C420005   SLTIU V0, V0, 5
9D00DA44  1440FFF5   BNE V0, ZERO, 0x9D00DA1C
9D00DA48  2522FFD5   ADDIU V0, T1, -43
9D00DA4C  7C020844   INS V0, ZERO, 1, 1
9D0176DC  24050020   ADDIU A1, ZERO, 32
9D0176E0  80820000   LB V0, 0(A0)
9D0176E4  1045000D   BEQ V0, A1, 0x9D01771C
9D0176E8  2443FFF7   ADDIU V1, V0, -9
9D0176EC  2C630005   SLTIU V1, V1, 5
9D0176F0  1460000A   BNE V1, ZERO, 0x9D01771C
9D0176F4  2403002B   ADDIU V1, ZERO, 43
9D0176F8  1043000A   BEQ V0, V1, 0x9D017724
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/arch/pic32m/math.h
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00C228  8FA30024   LW V1, 36(SP)
9D00C2C8  3C047FF0   LUI A0, 32752
9D00C2CC  24830001   ADDIU V1, A0, 1
9D00C2D0  0043182B   SLTU V1, V0, V1
9D00C2D4  50600005   BEQL V1, ZERO, __fmt_f_needed
9D00C2D8  8FA200A4   LW V0, 164(SP)
9D00C2DC  1444000C   BNE V0, A0, __fmt_f_needed
9D00C2E0  00003025   OR A2, ZERO, ZERO
9D00C2E4  12C0000A   BEQ S6, ZERO, __fmt_f_needed
9D00C2E8  8FA200A4   LW V0, 164(SP)
9D00CAF0  2643FFBF   ADDIU V1, S2, -65
9D00CBA0  24A30001   ADDIU V1, A1, 1
9D00CBA4  0043182B   SLTU V1, V0, V1
9D00CBA8  10600005   BEQ V1, ZERO, __fmt_a_needed
9D00CBAC  2C84001A   SLTIU A0, A0, 26
9D00CBB0  1445000C   BNE V0, A1, __fmt_a_needed
9D00CBB4  24020030   ADDIU V0, ZERO, 48
9D00CBB8  12E0000B   BEQ S7, ZERO, __fmt_a_needed
9D00CBBC  24030058   ADDIU V1, ZERO, 88
9D00CDE4  16200004   BNE S1, ZERO, __fmt_a_needed
9D00CDE8  7C63F000   EXT V1, V1, 0, 31
9D00CDEC  3C027FF0   LUI V0, 32752
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-musl-stdlib/musl/musl-1.1.18/arch/mchp/atomic.h
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D017994  24030020   ADDIU V1, ZERO, 32
9D017998  00A5200B   MOVN A0, A1, A1
9D01799C  0005180B   MOVN V1, ZERO, A1
9D0179A0  00042C02   SRL A1, A0, 16
9D0179A4  14A00004   BNE A1, ZERO, a_clz_64
9D0179A8  00051202   SRL V0, A1, 8
9D0179AC  34630010   ORI V1, V1, 16
9D0179B0  00802825   OR A1, A0, ZERO
9D0179B4  00051202   SRL V0, A1, 8
9D0179B8  14400004   BNE V0, ZERO, a_clz_64
9D0179BC  00022102   SRL A0, V0, 4
9D0179C0  34630008   ORI V1, V1, 8
9D0179C4  00A01025   OR V0, A1, ZERO
9D0179C8  00022102   SRL A0, V0, 4
9D0179CC  54800004   BNEL A0, ZERO, a_clz_64
9D0179D0  00041082   SRL V0, A0, 2
9D0179D4  34630004   ORI V1, V1, 4
9D0179D8  00402025   OR A0, V0, ZERO
9D0179DC  00041082   SRL V0, A0, 2
9D0179E0  54400004   BNEL V0, ZERO, a_clz_64
9D0179E4  00021042   SRL V0, V0, 1
9D0179E8  34630002   ORI V1, V1, 2
9D0179EC  00801025   OR V0, A0, ZERO
9D0179F0  00021042   SRL V0, V0, 1
9D0179F4  38420001   XORI V0, V0, 1
9D0179F8  03E00008   JR RA
9D0179FC  00431025   OR V0, V0, V1
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-gcc/gcc/libgcc/libgcc2.c  -------
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00F5C4  00C04025   OR T0, A2, ZERO
9D00F5C8  00E01825   OR V1, A3, ZERO
9D00F5CC  00805025   OR T2, A0, ZERO
9D00F5D0  14E00098   BNE A3, ZERO, 0x9D00F834
9D00F5D4  00A01025   OR V0, A1, ZERO
9D00F5D8  00A6302B   SLTU A2, A1, A2
9D00F5DC  10C00035   BEQ A2, ZERO, 0x9D00F6B4
9D00F5E0  00000000   NOP
9D00F5E4  71052820   CLZ A1, T0
9D00F5E8  10A00006   BEQ A1, ZERO, 0x9D00F604
9D00F5EC  00052023   SUBU A0, ZERO, A1
9D00F5F0  008A2006   SRLV A0, T2, A0
9D00F5F4  00A21004   SLLV V0, V0, A1
9D00F5F8  00A84004   SLLV T0, T0, A1
9D00F5FC  00821025   OR V0, A0, V0
9D00F600  00AA5004   SLLV T2, T2, A1
9D00F604  00083402   SRL A2, T0, 16
9D00F608  0046001B   DIVU V0, A2
9D00F60C  00C001F4   TEQ A2, ZERO
9D00F610  3105FFFF   ANDI A1, T0, -1
9D00F614  000A2402   SRL A0, T2, 16
9D00F618  00003812   MFLO A3
9D00F61C  00001010   MFHI V0
9D00F620  00021400   SLL V0, V0, 16
9D00F624  00442025   OR A0, V0, A0
9D00F628  70A74802   MUL T1, A1, A3
9D00F62C  0089582B   SLTU T3, A0, T1
9D00F630  1160000A   BEQ T3, ZERO, 0x9D00F65C
9D00F634  00E01025   OR V0, A3, ZERO
9D00F638  00882021   ADDU A0, A0, T0
9D00F63C  0088582B   SLTU T3, A0, T0
9D00F640  15600006   BNE T3, ZERO, 0x9D00F65C
9D00F644  24E2FFFF   ADDIU V0, A3, -1
9D00F648  0089582B   SLTU T3, A0, T1
9D00F64C  51600004   BEQL T3, ZERO, 0x9D00F660
9D00F650  00892023   SUBU A0, A0, T1
9D00F654  24E2FFFE   ADDIU V0, A3, -2
9D00F658  00882021   ADDU A0, A0, T0
9D00F65C  00892023   SUBU A0, A0, T1
9D00F660  0086001B   DIVU A0, A2
9D00F664  00C001F4   TEQ A2, ZERO
9D00F668  00003010   MFHI A2
9D00F66C  00063400   SLL A2, A2, 16
9D00F670  00002012   MFLO A0
9D00F674  70A43802   MUL A3, A1, A0
9D00F678  3145FFFF   ANDI A1, T2, -1
9D00F67C  00C52825   OR A1, A2, A1
9D00F680  00A7482B   SLTU T1, A1, A3
9D00F684  11200008   BEQ T1, ZERO, 0x9D00F6A8
9D00F688  00803025   OR A2, A0, ZERO
9D00F68C  01052821   ADDU A1, T0, A1
9D00F690  00A8402B   SLTU T0, A1, T0
9D00F694  15000004   BNE T0, ZERO, 0x9D00F6A8
9D00F698  2486FFFF   ADDIU A2, A0, -1
9D00F69C  00A7282B   SLTU A1, A1, A3
9D00F6A0  54A00001   BNEL A1, ZERO, 0x9D00F6A8
9D00F6A4  2486FFFE   ADDIU A2, A0, -2
9D00F6A8  00021400   SLL V0, V0, 16
9D00F6AC  03E00008   JR RA
9D00F6B0  00461025   OR V0, V0, A2
9D00F6B4  15000004   BNE T0, ZERO, 0x9D00F6C8
9D00F6B8  24020001   ADDIU V0, ZERO, 1
9D00F6BC  0048001B   DIVU V0, T0
9D00F6C0  010001F4   TEQ T0, ZERO
9D00F6C4  00004012   MFLO T0
9D00F6C8  710B5820   CLZ T3, T0
9D00F6CC  15600023   BNE T3, ZERO, 0x9D00F75C
9D00F6D0  24070020   ADDIU A3, ZERO, 32
9D00F6D4  00A82823   SUBU A1, A1, T0
9D00F6D8  24030001   ADDIU V1, ZERO, 1
9D00F6DC  00083402   SRL A2, T0, 16
9D00F6E0  00A6001B   DIVU A1, A2
9D00F6E4  00C001F4   TEQ A2, ZERO
9D00F6E8  3107FFFF   ANDI A3, T0, -1
9D00F6EC  000A2402   SRL A0, T2, 16
9D00F6F0  00002812   MFLO A1
9D00F6F4  00001010   MFHI V0
9D00F6F8  00021400   SLL V0, V0, 16
9D00F6FC  00442025   OR A0, V0, A0
9D00F700  70E54802   MUL T1, A3, A1
9D00F704  0089582B   SLTU T3, A0, T1
9D00F708  1160000A   BEQ T3, ZERO, 0x9D00F734
9D00F70C  00A01025   OR V0, A1, ZERO
9D00F710  00882021   ADDU A0, A0, T0
9D00F714  0088582B   SLTU T3, A0, T0
9D00F718  15600006   BNE T3, ZERO, 0x9D00F734
9D00F71C  24A2FFFF   ADDIU V0, A1, -1
9D00F720  0089582B   SLTU T3, A0, T1
9D00F724  51600004   BEQL T3, ZERO, 0x9D00F738
9D00F728  00892023   SUBU A0, A0, T1
9D00F72C  24A2FFFE   ADDIU V0, A1, -2
9D00F730  00882021   ADDU A0, A0, T0
9D00F734  00892023   SUBU A0, A0, T1
9D00F738  0086001B   DIVU A0, A2
9D00F73C  00C001F4   TEQ A2, ZERO
9D00F740  314AFFFF   ANDI T2, T2, -1
9D00F744  00002810   MFHI A1
9D00F748  00052C00   SLL A1, A1, 16
9D00F74C  00AA2825   OR A1, A1, T2
9D00F750  00002012   MFLO A0
9D00F754  1000FFCA   BEQ ZERO, ZERO, 0x9D00F680
9D00F758  70E43802   MUL A3, A3, A0
9D00F75C  00EB3823   SUBU A3, A3, T3
9D00F760  01684004   SLLV T0, T0, T3
9D00F764  00E44806   SRLV T1, A0, A3
9D00F768  00083402   SRL A2, T0, 16
9D00F76C  00E53806   SRLV A3, A1, A3
9D00F770  00E6001B   DIVU A3, A2
9D00F774  00C001F4   TEQ A2, ZERO
9D00F778  01651004   SLLV V0, A1, T3
9D00F77C  01224825   OR T1, T1, V0
9D00F780  3102FFFF   ANDI V0, T0, -1
9D00F784  00091C02   SRL V1, T1, 16
9D00F788  00002812   MFLO A1
9D00F78C  00003810   MFHI A3
9D00F790  00073C00   SLL A3, A3, 16
9D00F794  00E33825   OR A3, A3, V1
9D00F798  70455002   MUL T2, V0, A1
9D00F79C  00EA602B   SLTU T4, A3, T2
9D00F7A0  1180000A   BEQ T4, ZERO, 0x9D00F7CC
9D00F7A4  00A01825   OR V1, A1, ZERO
9D00F7A8  00E83821   ADDU A3, A3, T0
9D00F7AC  00E8602B   SLTU T4, A3, T0
9D00F7B0  15800006   BNE T4, ZERO, 0x9D00F7CC
9D00F7B4  24A3FFFF   ADDIU V1, A1, -1
9D00F7B8  00EA602B   SLTU T4, A3, T2
9D00F7BC  51800004   BEQL T4, ZERO, 0x9D00F7D0
9D00F7C0  00EA3823   SUBU A3, A3, T2
9D00F7C4  24A3FFFE   ADDIU V1, A1, -2
9D00F7C8  00E83821   ADDU A3, A3, T0
9D00F7CC  00EA3823   SUBU A3, A3, T2
9D00F7D0  00E6001B   DIVU A3, A2
9D00F7D4  00C001F4   TEQ A2, ZERO
9D00F7D8  3125FFFF   ANDI A1, T1, -1
9D00F7DC  00003012   MFLO A2
9D00F7E0  00003810   MFHI A3
9D00F7E4  00073C00   SLL A3, A3, 16
9D00F7E8  00E52825   OR A1, A3, A1
9D00F7EC  70461002   MUL V0, V0, A2
9D00F7F0  00A2482B   SLTU T1, A1, V0
9D00F7F4  1120000A   BEQ T1, ZERO, 0x9D00F820
9D00F7F8  00C03825   OR A3, A2, ZERO
9D00F7FC  00A82821   ADDU A1, A1, T0
9D00F800  00A8482B   SLTU T1, A1, T0
9D00F804  15200006   BNE T1, ZERO, 0x9D00F820
9D00F808  24C7FFFF   ADDIU A3, A2, -1
9D00F80C  00A2482B   SLTU T1, A1, V0
9D00F810  51200004   BEQL T1, ZERO, 0x9D00F824
9D00F814  00031C00   SLL V1, V1, 16
9D00F818  24C7FFFE   ADDIU A3, A2, -2
9D00F81C  00A82821   ADDU A1, A1, T0
9D00F820  00031C00   SLL V1, V1, 16
9D00F824  01645004   SLLV T2, A0, T3
9D00F828  00A22823   SUBU A1, A1, V0
9D00F82C  1000FFAB   BEQ ZERO, ZERO, 0x9D00F6DC
9D00F830  00671825   OR V1, V1, A3
9D00F834  00A7402B   SLTU T0, A1, A3
9D00F838  00001825   OR V1, ZERO, ZERO
9D00F83C  1500004E   BNE T0, ZERO, 0x9D00F978
9D00F840  00001025   OR V0, ZERO, ZERO
9D00F844  70EA5020   CLZ T2, A3
9D00F848  15400007   BNE T2, ZERO, 0x9D00F868
9D00F84C  24090020   ADDIU T1, ZERO, 32
9D00F850  00E5282B   SLTU A1, A3, A1
9D00F854  14A00048   BNE A1, ZERO, 0x9D00F978
9D00F858  24020001   ADDIU V0, ZERO, 1
9D00F85C  0086102B   SLTU V0, A0, A2
9D00F860  03E00008   JR RA
9D00F864  38420001   XORI V0, V0, 1
9D00F868  012A4823   SUBU T1, T1, T2
9D00F86C  01261006   SRLV V0, A2, T1
9D00F870  01473804   SLLV A3, A3, T2
9D00F874  00473825   OR A3, V0, A3
9D00F878  01451804   SLLV V1, A1, T2
9D00F87C  00074402   SRL T0, A3, 16
9D00F880  01252806   SRLV A1, A1, T1
9D00F884  00A8001B   DIVU A1, T0
9D00F888  010001F4   TEQ T0, ZERO
9D00F88C  30EBFFFF   ANDI T3, A3, -1
9D00F890  01241006   SRLV V0, A0, T1
9D00F894  00431025   OR V0, V0, V1
9D00F898  00021C02   SRL V1, V0, 16
9D00F89C  00002812   MFLO A1
9D00F8A0  00004810   MFHI T1
9D00F8A4  00094C00   SLL T1, T1, 16
9D00F8A8  01234825   OR T1, T1, V1
9D00F8AC  71656002   MUL T4, T3, A1
9D00F8B0  012C682B   SLTU T5, T1, T4
9D00F8B4  11A0000A   BEQ T5, ZERO, 0x9D00F8E0
9D00F8B8  00A01825   OR V1, A1, ZERO
9D00F8BC  01274821   ADDU T1, T1, A3
9D00F8C0  0127682B   SLTU T5, T1, A3
9D00F8C4  15A00006   BNE T5, ZERO, 0x9D00F8E0
9D00F8C8  24A3FFFF   ADDIU V1, A1, -1
9D00F8CC  012C682B   SLTU T5, T1, T4
9D00F8D0  51A00004   BEQL T5, ZERO, 0x9D00F8E4
9D00F8D4  012C4823   SUBU T1, T1, T4
9D00F8D8  24A3FFFE   ADDIU V1, A1, -2
9D00F8DC  01274821   ADDU T1, T1, A3
9D00F8E0  012C4823   SUBU T1, T1, T4
9D00F8E4  0128001B   DIVU T1, T0
9D00F8E8  010001F4   TEQ T0, ZERO
9D00F8EC  3045FFFF   ANDI A1, V0, -1
9D00F8F0  00004012   MFLO T0
9D00F8F4  00004810   MFHI T1
9D00F8F8  00094C00   SLL T1, T1, 16
9D00F8FC  01252825   OR A1, T1, A1
9D00F900  71685802   MUL T3, T3, T0
9D00F904  00AB102B   SLTU V0, A1, T3
9D00F908  1040000A   BEQ V0, ZERO, 0x9D00F934
9D00F90C  01004825   OR T1, T0, ZERO
9D00F910  00A72821   ADDU A1, A1, A3
9D00F914  00A7102B   SLTU V0, A1, A3
9D00F918  14400006   BNE V0, ZERO, 0x9D00F934
9D00F91C  2509FFFF   ADDIU T1, T0, -1
9D00F920  00AB102B   SLTU V0, A1, T3
9D00F924  10400004   BEQ V0, ZERO, 0x9D00F938
9D00F928  00031400   SLL V0, V1, 16
9D00F92C  2509FFFE   ADDIU T1, T0, -2
9D00F930  00A72821   ADDU A1, A1, A3
9D00F934  00031400   SLL V0, V1, 16
9D00F938  01463004   SLLV A2, A2, T2
9D00F93C  00491025   OR V0, V0, T1
9D00F940  00C20019   MULTU 0, A2, V0
9D00F944  00AB2823   SUBU A1, A1, T3
9D00F948  00003810   MFHI A3
9D00F94C  00A7182B   SLTU V1, A1, A3
9D00F950  14600007   BNE V1, ZERO, 0x9D00F970
9D00F954  00003012   MFLO A2
9D00F958  14A70007   BNE A1, A3, 0x9D00F978
9D00F95C  00001825   OR V1, ZERO, ZERO
9D00F960  01442004   SLLV A0, A0, T2
9D00F964  0086202B   SLTU A0, A0, A2
9D00F968  10800003   BEQ A0, ZERO, 0x9D00F978
9D00F96C  00000000   NOP
9D00F970  2442FFFF   ADDIU V0, V0, -1
9D00F974  00001825   OR V1, ZERO, ZERO
9D00F978  03E00008   JR RA
9D00F97C  00000000   NOP
9D00F980  00C04825   OR T1, A2, ZERO
9D00F984  00801025   OR V0, A0, ZERO
9D00F988  14E0008B   BNE A3, ZERO, 0x9D00FBB8
9D00F98C  00A01825   OR V1, A1, ZERO
9D00F990  00A6302B   SLTU A2, A1, A2
9D00F994  10C00033   BEQ A2, ZERO, 0x9D00FA64
9D00F998  712A5020   CLZ T2, T1
9D00F99C  11400008   BEQ T2, ZERO, 0x9D00F9C0
9D00F9A0  00095C02   SRL T3, T1, 16
9D00F9A4  01451804   SLLV V1, A1, T2
9D00F9A8  000A2823   SUBU A1, ZERO, T2
9D00F9AC  00A42806   SRLV A1, A0, A1
9D00F9B0  01494804   SLLV T1, T1, T2
9D00F9B4  00A31825   OR V1, A1, V1
9D00F9B8  01441004   SLLV V0, A0, T2
9D00F9BC  00095C02   SRL T3, T1, 16
9D00F9C0  006B001B   DIVU V1, T3
9D00F9C4  016001F4   TEQ T3, ZERO
9D00F9C8  3124FFFF   ANDI A0, T1, -1
9D00F9CC  00001812   MFLO V1
9D00F9D0  00002810   MFHI A1
9D00F9D4  70643002   MUL A2, V1, A0
9D00F9D8  00051C00   SLL V1, A1, 16
9D00F9DC  00022C02   SRL A1, V0, 16
9D00F9E0  00651825   OR V1, V1, A1
9D00F9E4  0066282B   SLTU A1, V1, A2
9D00F9E8  50A00008   BEQL A1, ZERO, 0x9D00FA0C
9D00F9EC  00661823   SUBU V1, V1, A2
9D00F9F0  00691821   ADDU V1, V1, T1
9D00F9F4  0069282B   SLTU A1, V1, T1
9D00F9F8  14A00003   BNE A1, ZERO, 0x9D00FA08
9D00F9FC  0066282B   SLTU A1, V1, A2
9D00FA00  54A00001   BNEL A1, ZERO, 0x9D00FA08
9D00FA04  00691821   ADDU V1, V1, T1
9D00FA08  00661823   SUBU V1, V1, A2
9D00FA0C  006B001B   DIVU V1, T3
9D00FA10  016001F4   TEQ T3, ZERO
9D00FA14  3042FFFF   ANDI V0, V0, -1
9D00FA18  00003010   MFHI A2
9D00FA1C  00001812   MFLO V1
9D00FA20  70645802   MUL T3, V1, A0
9D00FA24  00061C00   SLL V1, A2, 16
9D00FA28  00621025   OR V0, V1, V0
9D00FA2C  004B182B   SLTU V1, V0, T3
9D00FA30  50600009   BEQL V1, ZERO, 0x9D00FA58
9D00FA34  004B1023   SUBU V0, V0, T3
9D00FA38  00491021   ADDU V0, V0, T1
9D00FA3C  0049182B   SLTU V1, V0, T1
9D00FA40  54600005   BNEL V1, ZERO, 0x9D00FA58
9D00FA44  004B1023   SUBU V0, V0, T3
9D00FA48  004B182B   SLTU V1, V0, T3
9D00FA4C  54600001   BNEL V1, ZERO, 0x9D00FA54
9D00FA50  00491021   ADDU V0, V0, T1
9D00FA54  004B1023   SUBU V0, V0, T3
9D00FA58  01421006   SRLV V0, V0, T2
9D00FA5C  03E00008   JR RA
9D00FA60  00001825   OR V1, ZERO, ZERO
9D00FA64  15200004   BNE T1, ZERO, 0x9D00FA78
9D00FA68  24030001   ADDIU V1, ZERO, 1
9D00FA6C  0069001B   DIVU V1, T1
9D00FA70  012001F4   TEQ T1, ZERO
9D00FA74  00004812   MFLO T1
9D00FA78  712A5020   CLZ T2, T1
9D00FA7C  1540001F   BNE T2, ZERO, 0x9D00FAFC
9D00FA80  24070020   ADDIU A3, ZERO, 32
9D00FA84  00A92823   SUBU A1, A1, T1
9D00FA88  00095C02   SRL T3, T1, 16
9D00FA8C  00AB001B   DIVU A1, T3
9D00FA90  016001F4   TEQ T3, ZERO
9D00FA94  3124FFFF   ANDI A0, T1, -1
9D00FA98  00002812   MFLO A1
9D00FA9C  00001810   MFHI V1
9D00FAA0  70A43002   MUL A2, A1, A0
9D00FAA4  00032C00   SLL A1, V1, 16
9D00FAA8  00021C02   SRL V1, V0, 16
9D00FAAC  00A32825   OR A1, A1, V1
9D00FAB0  00A6182B   SLTU V1, A1, A2
9D00FAB4  50600008   BEQL V1, ZERO, 0x9D00FAD8
9D00FAB8  00A63023   SUBU A2, A1, A2
9D00FABC  00A92821   ADDU A1, A1, T1
9D00FAC0  00A9182B   SLTU V1, A1, T1
9D00FAC4  14600003   BNE V1, ZERO, 0x9D00FAD4
9D00FAC8  00A6182B   SLTU V1, A1, A2
9D00FACC  54600001   BNEL V1, ZERO, 0x9D00FAD4
9D00FAD0  00A92821   ADDU A1, A1, T1
9D00FAD4  00A63023   SUBU A2, A1, A2
9D00FAD8  00CB001B   DIVU A2, T3
9D00FADC  016001F4   TEQ T3, ZERO
9D00FAE0  3042FFFF   ANDI V0, V0, -1
9D00FAE4  00002810   MFHI A1
9D00FAE8  00003012   MFLO A2
9D00FAEC  70C45802   MUL T3, A2, A0
9D00FAF0  00053400   SLL A2, A1, 16
9D00FAF4  1000FFCD   BEQ ZERO, ZERO, 0x9D00FA2C
9D00FAF8  00C21025   OR V0, A2, V0
9D00FAFC  00EA3823   SUBU A3, A3, T2
9D00FB00  01494804   SLLV T1, T1, T2
9D00FB04  00E41806   SRLV V1, A0, A3
9D00FB08  00093402   SRL A2, T1, 16
9D00FB0C  00E53806   SRLV A3, A1, A3
9D00FB10  00E6001B   DIVU A3, A2
9D00FB14  00C001F4   TEQ A2, ZERO
9D00FB18  01451004   SLLV V0, A1, T2
9D00FB1C  3128FFFF   ANDI T0, T1, -1
9D00FB20  00621825   OR V1, V1, V0
9D00FB24  00032C02   SRL A1, V1, 16
9D00FB28  00003812   MFLO A3
9D00FB2C  00006010   MFHI T4
9D00FB30  70E81002   MUL V0, A3, T0
9D00FB34  000C3C00   SLL A3, T4, 16
9D00FB38  00E53825   OR A3, A3, A1
9D00FB3C  00E2282B   SLTU A1, A3, V0
9D00FB40  50A00008   BEQL A1, ZERO, 0x9D00FB64
9D00FB44  00E23823   SUBU A3, A3, V0
9D00FB48  00E93821   ADDU A3, A3, T1
9D00FB4C  00E9282B   SLTU A1, A3, T1
9D00FB50  14A00003   BNE A1, ZERO, 0x9D00FB60
9D00FB54  00E2282B   SLTU A1, A3, V0
9D00FB58  54A00001   BNEL A1, ZERO, 0x9D00FB60
9D00FB5C  00E93821   ADDU A3, A3, T1
9D00FB60  00E23823   SUBU A3, A3, V0
9D00FB64  00E6001B   DIVU A3, A2
9D00FB68  00C001F4   TEQ A2, ZERO
9D00FB6C  3065FFFF   ANDI A1, V1, -1
9D00FB70  00003012   MFLO A2
9D00FB74  00003810   MFHI A3
9D00FB78  00073C00   SLL A3, A3, 16
9D00FB7C  00E52825   OR A1, A3, A1
9D00FB80  70C83002   MUL A2, A2, T0
9D00FB84  00A6102B   SLTU V0, A1, A2
9D00FB88  10400009   BEQ V0, ZERO, 0x9D00FBB0
9D00FB8C  01441004   SLLV V0, A0, T2
9D00FB90  00A92821   ADDU A1, A1, T1
9D00FB94  00A9102B   SLTU V0, A1, T1
9D00FB98  14400005   BNE V0, ZERO, 0x9D00FBB0
9D00FB9C  01441004   SLLV V0, A0, T2
9D00FBA0  00A6102B   SLTU V0, A1, A2
9D00FBA4  54400001   BNEL V0, ZERO, 0x9D00FBAC
9D00FBA8  00A92821   ADDU A1, A1, T1
9D00FBAC  01441004   SLLV V0, A0, T2
9D00FBB0  1000FFB5   BEQ ZERO, ZERO, 0x9D00FA88
9D00FBB4  00A62823   SUBU A1, A1, A2
9D00FBB8  00A7402B   SLTU T0, A1, A3
9D00FBBC  1500005C   BNE T0, ZERO, 0x9D00FD30
9D00FBC0  70EE7020   CLZ T6, A3
9D00FBC4  15C0000A   BNE T6, ZERO, 0x9D00FBF0
9D00FBC8  00E5402B   SLTU T0, A3, A1
9D00FBCC  15000003   BNE T0, ZERO, 0x9D00FBDC
9D00FBD0  0086402B   SLTU T0, A0, A2
9D00FBD4  15000056   BNE T0, ZERO, 0x9D00FD30
9D00FBD8  00000000   NOP
9D00FBDC  00861023   SUBU V0, A0, A2
9D00FBE0  00A72823   SUBU A1, A1, A3
9D00FBE4  0082182B   SLTU V1, A0, V0
9D00FBE8  03E00008   JR RA
9D00FBEC  00A31823   SUBU V1, A1, V1
9D00FBF0  240B0020   ADDIU T3, ZERO, 32
9D00FBF4  016E5823   SUBU T3, T3, T6
9D00FBF8  01666006   SRLV T4, A2, T3
9D00FBFC  01C73804   SLLV A3, A3, T6
9D00FC00  01873825   OR A3, T4, A3
9D00FC04  01C54004   SLLV T0, A1, T6
9D00FC08  00074C02   SRL T1, A3, 16
9D00FC0C  01652806   SRLV A1, A1, T3
9D00FC10  00A9001B   DIVU A1, T1
9D00FC14  012001F4   TEQ T1, ZERO
9D00FC18  01641006   SRLV V0, A0, T3
9D00FC1C  00481025   OR V0, V0, T0
9D00FC20  30E8FFFF   ANDI T0, A3, -1
9D00FC24  00026402   SRL T4, V0, 16
9D00FC28  00002812   MFLO A1
9D00FC2C  00005010   MFHI T2
9D00FC30  000A5400   SLL T2, T2, 16
9D00FC34  014C5025   OR T2, T2, T4
9D00FC38  71051802   MUL V1, T0, A1
9D00FC3C  0143602B   SLTU T4, T2, V1
9D00FC40  1180000A   BEQ T4, ZERO, 0x9D00FC6C
9D00FC44  00A06825   OR T5, A1, ZERO
9D00FC48  01475021   ADDU T2, T2, A3
9D00FC4C  0147602B   SLTU T4, T2, A3
9D00FC50  15800006   BNE T4, ZERO, 0x9D00FC6C
9D00FC54  24ADFFFF   ADDIU T5, A1, -1
9D00FC58  0143602B   SLTU T4, T2, V1
9D00FC5C  51800004   BEQL T4, ZERO, 0x9D00FC70
9D00FC60  01435023   SUBU T2, T2, V1
9D00FC64  24ADFFFE   ADDIU T5, A1, -2
9D00FC68  01475021   ADDU T2, T2, A3
9D00FC6C  01435023   SUBU T2, T2, V1
9D00FC70  0149001B   DIVU T2, T1
9D00FC74  012001F4   TEQ T1, ZERO
9D00FC78  00004812   MFLO T1
9D00FC7C  00005010   MFHI T2
9D00FC80  000A5400   SLL T2, T2, 16
9D00FC84  71092802   MUL A1, T0, T1
9D00FC88  3048FFFF   ANDI T0, V0, -1
9D00FC8C  01484025   OR T0, T2, T0
9D00FC90  0105102B   SLTU V0, T0, A1
9D00FC94  1040000A   BEQ V0, ZERO, 0x9D00FCC0
9D00FC98  01205025   OR T2, T1, ZERO
9D00FC9C  01074021   ADDU T0, T0, A3
9D00FCA0  0107102B   SLTU V0, T0, A3
9D00FCA4  14400006   BNE V0, ZERO, 0x9D00FCC0
9D00FCA8  252AFFFF   ADDIU T2, T1, -1
9D00FCAC  0105102B   SLTU V0, T0, A1
9D00FCB0  10400004   BEQ V0, ZERO, 0x9D00FCC4
9D00FCB4  000D6400   SLL T4, T5, 16
9D00FCB8  252AFFFE   ADDIU T2, T1, -2
9D00FCBC  01074021   ADDU T0, T0, A3
9D00FCC0  000D6400   SLL T4, T5, 16
9D00FCC4  01C61004   SLLV V0, A2, T6
9D00FCC8  018A6025   OR T4, T4, T2
9D00FCCC  01820019   MULTU 0, T4, V0
9D00FCD0  01054023   SUBU T0, T0, A1
9D00FCD4  01C41804   SLLV V1, A0, T6
9D00FCD8  00006810   MFHI T5
9D00FCDC  010D202B   SLTU A0, T0, T5
9D00FCE0  01A02825   OR A1, T5, ZERO
9D00FCE4  00006012   MFLO T4
9D00FCE8  14800005   BNE A0, ZERO, 0x9D00FD00
9D00FCEC  00003012   MFLO A2
9D00FCF0  150D0007   BNE T0, T5, 0x9D00FD10
9D00FCF4  006C202B   SLTU A0, V1, T4
9D00FCF8  10800006   BEQ A0, ZERO, 0x9D00FD14
9D00FCFC  00663023   SUBU A2, V1, A2
9D00FD00  01823023   SUBU A2, T4, V0
9D00FD04  01A73823   SUBU A3, T5, A3
9D00FD08  0186602B   SLTU T4, T4, A2
9D00FD0C  00EC2823   SUBU A1, A3, T4
9D00FD10  00663023   SUBU A2, V1, A2
9D00FD14  0066182B   SLTU V1, V1, A2
9D00FD18  01054023   SUBU T0, T0, A1
9D00FD1C  01031823   SUBU V1, T0, V1
9D00FD20  01631004   SLLV V0, V1, T3
9D00FD24  01C63006   SRLV A2, A2, T6
9D00FD28  00461025   OR V0, V0, A2
9D00FD2C  01C31806   SRLV V1, V1, T6
9D00FD30  03E00008   JR RA
9D00FD34  00000000   NOP
9D017848  27BDFFE0   ADDIU SP, SP, -32
9D01784C  AFB20018   SW S2, 24(SP)
9D017850  00809025   OR S2, A0, ZERO
9D017854  00A02025   OR A0, A1, ZERO
9D017858  AFBF001C   SW RA, 28(SP)
9D01785C  AFB10014   SW S1, 20(SP)
9D017860  0F405DF4   JAL __floatsidf
9D017864  AFB00010   SW S0, 16(SP)
9D017868  3C049D01   LUI A0, -25343
9D01786C  8C86B4D8   LW A2, -19240(A0)
9D017870  8C87B4DC   LW A3, -19236(A0)
9D017874  00602825   OR A1, V1, ZERO
9D017878  0F404121   JAL dpmul
9D01787C  00402025   OR A0, V0, ZERO
9D017880  02402025   OR A0, S2, ZERO
9D017884  00408025   OR S0, V0, ZERO
9D017888  0F406165   JAL __floatunsidf
9D01788C  00608825   OR S1, V1, ZERO
9D017890  00402025   OR A0, V0, ZERO
9D017894  02003025   OR A2, S0, ZERO
9D017898  02203825   OR A3, S1, ZERO
9D01789C  0F403C67   JAL __adddf3
9D0178A0  00602825   OR A1, V1, ZERO
9D0178A4  8FBF001C   LW RA, 28(SP)
9D0178A8  8FB20018   LW S2, 24(SP)
9D0178AC  8FB10014   LW S1, 20(SP)
9D0178B0  8FB00010   LW S0, 16(SP)
9D0178B4  03E00008   JR RA
9D0178B8  27BD0020   ADDIU SP, SP, 32
9D018688  10C00008   BEQ A2, ZERO, 0x9D0186AC
9D01868C  00801025   OR V0, A0, ZERO
9D018690  24030020   ADDIU V1, ZERO, 32
9D018694  00661823   SUBU V1, V1, A2
9D018698  1C600006   BGTZ V1, 0x9D0186B4
9D01869C  00C52006   SRLV A0, A1, A2
9D0186A0  00002025   OR A0, ZERO, ZERO
9D0186A4  00C51006   SRLV V0, A1, A2
9D0186A8  00802825   OR A1, A0, ZERO
9D0186AC  03E00008   JR RA
9D0186B0  00A01825   OR V1, A1, ZERO
9D0186B4  00C21006   SRLV V0, V0, A2
9D0186B8  00652804   SLLV A1, A1, V1
9D0186BC  1000FFFA   BEQ ZERO, ZERO, 0x9D0186A8
9D0186C0  00451025   OR V0, V0, A1
9D0186C4  10C00008   BEQ A2, ZERO, 0x9D0186E8
9D0186C8  00801025   OR V0, A0, ZERO
9D0186CC  24040020   ADDIU A0, ZERO, 32
9D0186D0  00862023   SUBU A0, A0, A2
9D0186D4  5C800006   BGTZL A0, 0x9D0186F0
9D0186D8  00C21804   SLLV V1, V0, A2
9D0186DC  00001825   OR V1, ZERO, ZERO
9D0186E0  00C22804   SLLV A1, V0, A2
9D0186E4  00601025   OR V0, V1, ZERO
9D0186E8  03E00008   JR RA
9D0186EC  00A01825   OR V1, A1, ZERO
9D0186F0  00C52804   SLLV A1, A1, A2
9D0186F4  00821006   SRLV V0, V0, A0
9D0186F8  1000FFFA   BEQ ZERO, ZERO, 0x9D0186E4
9D0186FC  00A22825   OR A1, A1, V0
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-gcc/gcc/libgcc/floatunsisf.c  ---
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D018334  27BDFFE8   ADDIU SP, SP, -24
9D018338  0481000C   BGEZ A0, 0x9D01836C
9D01833C  AFBF0014   SW RA, 20(SP)
9D018340  00801025   OR V0, A0, ZERO
9D018344  00021042   SRL V0, V0, 1
9D018348  30840001   ANDI A0, A0, 1
9D01834C  0F405EFF   JAL sitofp
9D018350  00822025   OR A0, A0, V0
9D018354  00402825   OR A1, V0, ZERO
9D018358  0F4043EF   JAL fpadd
9D01835C  00402025   OR A0, V0, ZERO
9D018360  8FBF0014   LW RA, 20(SP)
9D018364  03E00008   JR RA
9D018368  27BD0018   ADDIU SP, SP, 24
9D01836C  0F405EFF   JAL sitofp
9D018370  00000000   NOP
9D018374  1000FFFB   BEQ ZERO, ZERO, 0x9D018364
9D018378  8FBF0014   LW RA, 20(SP)
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/src/xc32-gcc/gcc/libgcc/floatunsidf.c  ---
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D018594  27BDFFE8   ADDIU SP, SP, -24
9D018598  AFB00010   SW S0, 16(SP)
9D01859C  AFBF0014   SW RA, 20(SP)
9D0185A0  0F405DF4   JAL __floatsidf
9D0185A4  00808025   OR S0, A0, ZERO
9D0185A8  06010006   BGEZ S0, 0x9D0185C4
9D0185AC  00602825   OR A1, V1, ZERO
9D0185B0  3C049D01   LUI A0, -25343
9D0185B4  8C86B4B0   LW A2, -19280(A0)
9D0185B8  8C87B4B4   LW A3, -19276(A0)
9D0185BC  0F403C67   JAL __adddf3
9D0185C0  00402025   OR A0, V0, ZERO
9D0185C4  8FBF0014   LW RA, 20(SP)
9D0185C8  8FB00010   LW S0, 16(SP)
9D0185CC  03E00008   JR RA
9D0185D0  27BD0018   ADDIU SP, SP, 24
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/build-Linux/pic32m-libs/libpic32/stubs/default-on-reset.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00B4B8  03E00008   JR RA
9D00B4BC  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/build-Linux/pic32m-libs/libpic32/stubs/default-on-bootstrap.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00B4C8  03E00008   JR RA
9D00B4CC  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/build-Linux/pic32m-libs/libpic32/startup/software-debug-break.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D00B174  7000003F   SDBBP 0
9D00B178  03E00008   JR RA
9D00B17C  00000000   NOP
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-WOZ10-JOB1/build-Linux/pic32m-libs/libpic32/default_vector_dispatch/defaultinterrupt.c
-----*  Optimizer-Generated Procedural Abstractions  *----------------------------------------------
9D01837C  3C020000   LUI V0, 0
9D018380  24420000   ADDIU V0, V0, 0
9D018384  10400007   BEQ V0, ZERO, 0x9D0183A4
9D018388  3C029D01   LUI V0, -25343
9D01838C  2442B174   ADDIU V0, V0, -20108
9D018390  50400005   BEQL V0, ZERO, 0x9D0183A8
9D018394  3C029D02   LUI V0, -25342
9D018398  7000003F   SDBBP 0
9D01839C  03E00008   JR RA
9D0183A0  00000000   NOP
9D0183A4  3C029D02   LUI V0, -25342
9D0183A8  24428490   ADDIU V0, V0, -31600
9D0183AC  10400003   BEQ V0, ZERO, 0x9D0183BC
9D0183B0  00000000   NOP
9D0183B4  0040F809   JALR V0
9D0183B8  00000000   NOP
9D0183BC  03E00008   JR RA
9D0183C0  00000000   NOP
